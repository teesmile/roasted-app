module.exports = [
"[project]/node_modules/.pnpm/@neynar+react@1.2.22_@farcaster+miniapp-sdk@0.2.1_bufferutil@4.0.9_typescript@5.9.3_utf_07cdf20033d096ce405ed6a3efc8ecc2/node_modules/@neynar/react/dist/bundle.es.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CastCard",
    ()=>oa,
    "MiniAppProvider",
    ()=>uL,
    "NeynarAuthButton",
    ()=>pS,
    "NeynarAutoCompleteUser",
    ()=>EL,
    "NeynarCastCard",
    ()=>LA,
    "NeynarContextProvider",
    ()=>hL,
    "NeynarConversationList",
    ()=>pL,
    "NeynarFeedList",
    ()=>mL,
    "NeynarFrameCard",
    ()=>aI,
    "NeynarProfileCard",
    ()=>yL,
    "NeynarUserDropdown",
    ()=>vL,
    "SIWN_variant",
    ()=>gs,
    "Theme",
    ()=>yg,
    "useLocalStorage",
    ()=>du,
    "useMiniApp",
    ()=>dL,
    "useNeynarContext",
    ()=>ts
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@pigment-css+react@0.0.30_@types+react@19.2.6_react@19.2.0_typescript@5.9.3/node_modules/@pigment-css/react/build/chunk-AFZBAV6Q.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/next@16.0.3_@babel+core@7.28.5_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)");
var ym = Object.defineProperty;
var vm = (s, e, t)=>e in s ? ym(s, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : s[e] = t;
var Cr = (s, e, t)=>vm(s, typeof e != "symbol" ? e + "" : e, t);
;
;
const Gr = {
    vars: {
        colors: {
            primary: "var(--colors-primary)"
        },
        typography: {
            fonts: {
                base: "var(--typography-fonts-base)"
            },
            fontWeights: {
                regular: "var(--typography-fontWeights-regular)",
                bold: "var(--typography-fontWeights-bold)"
            },
            fontSizes: {
                large: "var(--typography-fontSizes-large)",
                medium: "var(--typography-fontSizes-medium)",
                small: "var(--typography-fontSizes-small)"
            }
        },
        palette: {
            background: "var(--palette-background)",
            border: "var(--palette-border)",
            text: "var(--palette-text)",
            textMuted: "var(--palette-textMuted)"
        }
    }
};
function Fc(s) {
    return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, "default") ? s.default : s;
}
function Nc(s) {
    if (Object.prototype.hasOwnProperty.call(s, "__esModule")) return s;
    var e = s.default;
    if (typeof e == "function") {
        var t = function r() {
            return this instanceof r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
        };
        t.prototype = e.prototype;
    } else t = {};
    return Object.defineProperty(t, "__esModule", {
        value: !0
    }), Object.keys(s).forEach(function(r) {
        var n1 = Object.getOwnPropertyDescriptor(s, r);
        Object.defineProperty(t, r, n1.get ? n1 : {
            enumerable: !0,
            get: function() {
                return s[r];
            }
        });
    }), t;
}
var Ua = {
    exports: {}
}, Kn = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Wu;
function Sm() {
    if (Wu) return Kn;
    Wu = 1;
    var s = Symbol.for("react.transitional.element"), e = Symbol.for("react.fragment");
    function t(r, n1, i) {
        var o = null;
        if (i !== void 0 && (o = "" + i), n1.key !== void 0 && (o = "" + n1.key), "key" in n1) {
            i = {};
            for(var a in n1)a !== "key" && (i[a] = n1[a]);
        } else i = n1;
        return n1 = i.ref, {
            $$typeof: s,
            type: r,
            key: o,
            ref: n1 !== void 0 ? n1 : null,
            props: i
        };
    }
    return Kn.Fragment = e, Kn.jsx = t, Kn.jsxs = t, Kn;
}
var zu;
function bm() {
    return zu || (zu = 1, Ua.exports = Sm()), Ua.exports;
}
var q = bm();
let Fn = class extends Error {
    constructor(t, r = {}){
        super(t, r.cause ? {
            cause: r.cause
        } : void 0);
        Cr(this, "name", "BaseError");
        Cr(this, "cause");
        this.cause = r.cause;
    }
};
class Tm extends Fn {
    constructor(){
        super("Invalid domain manifest");
        Cr(this, "name", "AddMiniApp.InvalidDomainManifest");
    }
}
let wm = class extends Fn {
    constructor(){
        super("Add miniapp rejected by user");
        Cr(this, "name", "AddMiniApp.RejectedByUser");
    }
}, Of = class extends Fn {
    constructor(){
        super("Sign in rejected by user");
        Cr(this, "name", "SignIn.RejectedByUser");
    }
};
class Am extends Fn {
    constructor(){
        super("Sign manifest rejected by user");
        Cr(this, "name", "SignManifest.RejectedByUser");
    }
}
class Im extends Fn {
    constructor(){
        super("Invalid domain provided");
        Cr(this, "name", "SignManifest.InvalidDomain");
    }
}
class _m extends Fn {
    constructor(t = "Manifest signing failed"){
        super(t);
        Cr(this, "name", "SignManifest.GenericError");
    }
}
var Ze;
(function(s) {
    s.assertEqual = (n1)=>{};
    function e(n1) {}
    s.assertIs = e;
    function t(n1) {
        throw new Error();
    }
    s.assertNever = t, s.arrayToEnum = (n1)=>{
        const i = {};
        for (const o of n1)i[o] = o;
        return i;
    }, s.getValidEnumValues = (n1)=>{
        const i = s.objectKeys(n1).filter((a)=>typeof n1[n1[a]] != "number"), o = {};
        for (const a of i)o[a] = n1[a];
        return s.objectValues(o);
    }, s.objectValues = (n1)=>s.objectKeys(n1).map(function(i) {
            return n1[i];
        }), s.objectKeys = typeof Object.keys == "function" ? (n1)=>Object.keys(n1) : (n1)=>{
        const i = [];
        for(const o in n1)Object.prototype.hasOwnProperty.call(n1, o) && i.push(o);
        return i;
    }, s.find = (n1, i)=>{
        for (const o of n1)if (i(o)) return o;
    }, s.isInteger = typeof Number.isInteger == "function" ? (n1)=>Number.isInteger(n1) : (n1)=>typeof n1 == "number" && Number.isFinite(n1) && Math.floor(n1) === n1;
    function r(n1, i = " | ") {
        return n1.map((o)=>typeof o == "string" ? `'${o}'` : o).join(i);
    }
    s.joinValues = r, s.jsonStringifyReplacer = (n1, i)=>typeof i == "bigint" ? i.toString() : i;
})(Ze || (Ze = {}));
var Yu;
(function(s) {
    s.mergeShapes = (e, t)=>({
            ...e,
            ...t
        });
})(Yu || (Yu = {}));
const me = Ze.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
]), ws = (s)=>{
    switch(typeof s){
        case "undefined":
            return me.undefined;
        case "string":
            return me.string;
        case "number":
            return Number.isNaN(s) ? me.nan : me.number;
        case "boolean":
            return me.boolean;
        case "function":
            return me.function;
        case "bigint":
            return me.bigint;
        case "symbol":
            return me.symbol;
        case "object":
            return Array.isArray(s) ? me.array : s === null ? me.null : s.then && typeof s.then == "function" && s.catch && typeof s.catch == "function" ? me.promise : typeof Map < "u" && s instanceof Map ? me.map : typeof Set < "u" && s instanceof Set ? me.set : typeof Date < "u" && s instanceof Date ? me.date : me.object;
        default:
            return me.unknown;
    }
}, ae = Ze.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
]);
class ps extends Error {
    get errors() {
        return this.issues;
    }
    constructor(e){
        super(), this.issues = [], this.addIssue = (r)=>{
            this.issues = [
                ...this.issues,
                r
            ];
        }, this.addIssues = (r = [])=>{
            this.issues = [
                ...this.issues,
                ...r
            ];
        };
        const t = new.target.prototype;
        Object.setPrototypeOf ? Object.setPrototypeOf(this, t) : this.__proto__ = t, this.name = "ZodError", this.issues = e;
    }
    format(e) {
        const t = e || function(i) {
            return i.message;
        }, r = {
            _errors: []
        }, n1 = (i)=>{
            for (const o of i.issues)if (o.code === "invalid_union") o.unionErrors.map(n1);
            else if (o.code === "invalid_return_type") n1(o.returnTypeError);
            else if (o.code === "invalid_arguments") n1(o.argumentsError);
            else if (o.path.length === 0) r._errors.push(t(o));
            else {
                let a = r, l = 0;
                for(; l < o.path.length;){
                    const c = o.path[l];
                    l === o.path.length - 1 ? (a[c] = a[c] || {
                        _errors: []
                    }, a[c]._errors.push(t(o))) : a[c] = a[c] || {
                        _errors: []
                    }, a = a[c], l++;
                }
            }
        };
        return n1(this), r;
    }
    static assert(e) {
        if (!(e instanceof ps)) throw new Error(`Not a ZodError: ${e}`);
    }
    toString() {
        return this.message;
    }
    get message() {
        return JSON.stringify(this.issues, Ze.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
        return this.issues.length === 0;
    }
    flatten(e = (t)=>t.message) {
        const t = {}, r = [];
        for (const n1 of this.issues)if (n1.path.length > 0) {
            const i = n1.path[0];
            t[i] = t[i] || [], t[i].push(e(n1));
        } else r.push(e(n1));
        return {
            formErrors: r,
            fieldErrors: t
        };
    }
    get formErrors() {
        return this.flatten();
    }
}
ps.create = (s)=>new ps(s);
const Kl = (s, e)=>{
    let t;
    switch(s.code){
        case ae.invalid_type:
            s.received === me.undefined ? t = "Required" : t = `Expected ${s.expected}, received ${s.received}`;
            break;
        case ae.invalid_literal:
            t = `Invalid literal value, expected ${JSON.stringify(s.expected, Ze.jsonStringifyReplacer)}`;
            break;
        case ae.unrecognized_keys:
            t = `Unrecognized key(s) in object: ${Ze.joinValues(s.keys, ", ")}`;
            break;
        case ae.invalid_union:
            t = "Invalid input";
            break;
        case ae.invalid_union_discriminator:
            t = `Invalid discriminator value. Expected ${Ze.joinValues(s.options)}`;
            break;
        case ae.invalid_enum_value:
            t = `Invalid enum value. Expected ${Ze.joinValues(s.options)}, received '${s.received}'`;
            break;
        case ae.invalid_arguments:
            t = "Invalid function arguments";
            break;
        case ae.invalid_return_type:
            t = "Invalid function return type";
            break;
        case ae.invalid_date:
            t = "Invalid date";
            break;
        case ae.invalid_string:
            typeof s.validation == "object" ? "includes" in s.validation ? (t = `Invalid input: must include "${s.validation.includes}"`, typeof s.validation.position == "number" && (t = `${t} at one or more positions greater than or equal to ${s.validation.position}`)) : "startsWith" in s.validation ? t = `Invalid input: must start with "${s.validation.startsWith}"` : "endsWith" in s.validation ? t = `Invalid input: must end with "${s.validation.endsWith}"` : Ze.assertNever(s.validation) : s.validation !== "regex" ? t = `Invalid ${s.validation}` : t = "Invalid";
            break;
        case ae.too_small:
            s.type === "array" ? t = `Array must contain ${s.exact ? "exactly" : s.inclusive ? "at least" : "more than"} ${s.minimum} element(s)` : s.type === "string" ? t = `String must contain ${s.exact ? "exactly" : s.inclusive ? "at least" : "over"} ${s.minimum} character(s)` : s.type === "number" ? t = `Number must be ${s.exact ? "exactly equal to " : s.inclusive ? "greater than or equal to " : "greater than "}${s.minimum}` : s.type === "bigint" ? t = `Number must be ${s.exact ? "exactly equal to " : s.inclusive ? "greater than or equal to " : "greater than "}${s.minimum}` : s.type === "date" ? t = `Date must be ${s.exact ? "exactly equal to " : s.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(s.minimum))}` : t = "Invalid input";
            break;
        case ae.too_big:
            s.type === "array" ? t = `Array must contain ${s.exact ? "exactly" : s.inclusive ? "at most" : "less than"} ${s.maximum} element(s)` : s.type === "string" ? t = `String must contain ${s.exact ? "exactly" : s.inclusive ? "at most" : "under"} ${s.maximum} character(s)` : s.type === "number" ? t = `Number must be ${s.exact ? "exactly" : s.inclusive ? "less than or equal to" : "less than"} ${s.maximum}` : s.type === "bigint" ? t = `BigInt must be ${s.exact ? "exactly" : s.inclusive ? "less than or equal to" : "less than"} ${s.maximum}` : s.type === "date" ? t = `Date must be ${s.exact ? "exactly" : s.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(s.maximum))}` : t = "Invalid input";
            break;
        case ae.custom:
            t = "Invalid input";
            break;
        case ae.invalid_intersection_types:
            t = "Intersection results could not be merged";
            break;
        case ae.not_multiple_of:
            t = `Number must be a multiple of ${s.multipleOf}`;
            break;
        case ae.not_finite:
            t = "Number must be finite";
            break;
        default:
            t = e.defaultError, Ze.assertNever(s);
    }
    return {
        message: t
    };
};
let Lm = Kl;
function Rm() {
    return Lm;
}
const Cm = (s)=>{
    const { data: e, path: t, errorMaps: r, issueData: n1 } = s, i = [
        ...t,
        ...n1.path || []
    ], o = {
        ...n1,
        path: i
    };
    if (n1.message !== void 0) return {
        ...n1,
        path: i,
        message: n1.message
    };
    let a = "";
    const l = r.filter((c)=>!!c).slice().reverse();
    for (const c of l)a = c(o, {
        data: e,
        defaultError: a
    }).message;
    return {
        ...n1,
        path: i,
        message: a
    };
};
function he(s, e) {
    const t = Rm(), r = Cm({
        issueData: e,
        data: s.data,
        path: s.path,
        errorMaps: [
            s.common.contextualErrorMap,
            // contextual error map is first priority
            s.schemaErrorMap,
            // then schema-bound map if available
            t,
            // then global override map
            t === Kl ? void 0 : Kl
        ].filter((n1)=>!!n1)
    });
    s.common.issues.push(r);
}
class wr {
    constructor(){
        this.value = "valid";
    }
    dirty() {
        this.value === "valid" && (this.value = "dirty");
    }
    abort() {
        this.value !== "aborted" && (this.value = "aborted");
    }
    static mergeArray(e, t) {
        const r = [];
        for (const n1 of t){
            if (n1.status === "aborted") return Le;
            n1.status === "dirty" && e.dirty(), r.push(n1.value);
        }
        return {
            status: e.value,
            value: r
        };
    }
    static async mergeObjectAsync(e, t) {
        const r = [];
        for (const n1 of t){
            const i = await n1.key, o = await n1.value;
            r.push({
                key: i,
                value: o
            });
        }
        return wr.mergeObjectSync(e, r);
    }
    static mergeObjectSync(e, t) {
        const r = {};
        for (const n1 of t){
            const { key: i, value: o } = n1;
            if (i.status === "aborted" || o.status === "aborted") return Le;
            i.status === "dirty" && e.dirty(), o.status === "dirty" && e.dirty(), i.value !== "__proto__" && (typeof o.value < "u" || n1.alwaysSet) && (r[i.value] = o.value);
        }
        return {
            status: e.value,
            value: r
        };
    }
}
const Le = Object.freeze({
    status: "aborted"
}), Wn = (s)=>({
        status: "dirty",
        value: s
    }), Lr = (s)=>({
        status: "valid",
        value: s
    }), Zu = (s)=>s.status === "aborted", Xu = (s)=>s.status === "dirty", _n = (s)=>s.status === "valid", bo = (s)=>typeof Promise < "u" && s instanceof Promise;
var Ee;
(function(s) {
    s.errToObj = (e)=>typeof e == "string" ? {
            message: e
        } : e || {}, s.toString = (e)=>typeof e == "string" ? e : e == null ? void 0 : e.message;
})(Ee || (Ee = {}));
class Ds {
    constructor(e, t, r, n1){
        this._cachedPath = [], this.parent = e, this.data = t, this._path = r, this._key = n1;
    }
    get path() {
        return this._cachedPath.length || (Array.isArray(this._key) ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
    }
}
const Ju = (s, e)=>{
    if (_n(e)) return {
        success: !0,
        data: e.value
    };
    if (!s.common.issues.length) throw new Error("Validation failed but no issues detected.");
    return {
        success: !1,
        get error () {
            if (this._error) return this._error;
            const t = new ps(s.common.issues);
            return this._error = t, this._error;
        }
    };
};
function Ve(s) {
    if (!s) return {};
    const { errorMap: e, invalid_type_error: t, required_error: r, description: n1 } = s;
    if (e && (t || r)) throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    return e ? {
        errorMap: e,
        description: n1
    } : {
        errorMap: (o, a)=>{
            const { message: l } = s;
            return o.code === "invalid_enum_value" ? {
                message: l ?? a.defaultError
            } : typeof a.data > "u" ? {
                message: l ?? r ?? a.defaultError
            } : o.code !== "invalid_type" ? {
                message: a.defaultError
            } : {
                message: l ?? t ?? a.defaultError
            };
        },
        description: n1
    };
}
class Ye {
    get description() {
        return this._def.description;
    }
    _getType(e) {
        return ws(e.data);
    }
    _getOrReturnCtx(e, t) {
        return t || {
            common: e.parent.common,
            data: e.data,
            parsedType: ws(e.data),
            schemaErrorMap: this._def.errorMap,
            path: e.path,
            parent: e.parent
        };
    }
    _processInputParams(e) {
        return {
            status: new wr(),
            ctx: {
                common: e.parent.common,
                data: e.data,
                parsedType: ws(e.data),
                schemaErrorMap: this._def.errorMap,
                path: e.path,
                parent: e.parent
            }
        };
    }
    _parseSync(e) {
        const t = this._parse(e);
        if (bo(t)) throw new Error("Synchronous parse encountered promise.");
        return t;
    }
    _parseAsync(e) {
        const t = this._parse(e);
        return Promise.resolve(t);
    }
    parse(e, t) {
        const r = this.safeParse(e, t);
        if (r.success) return r.data;
        throw r.error;
    }
    safeParse(e, t) {
        const r = {
            common: {
                issues: [],
                async: (t == null ? void 0 : t.async) ?? !1,
                contextualErrorMap: t == null ? void 0 : t.errorMap
            },
            path: (t == null ? void 0 : t.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data: e,
            parsedType: ws(e)
        }, n1 = this._parseSync({
            data: e,
            path: r.path,
            parent: r
        });
        return Ju(r, n1);
    }
    "~validate"(e) {
        var r, n1;
        const t = {
            common: {
                issues: [],
                async: !!this["~standard"].async
            },
            path: [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data: e,
            parsedType: ws(e)
        };
        if (!this["~standard"].async) try {
            const i = this._parseSync({
                data: e,
                path: [],
                parent: t
            });
            return _n(i) ? {
                value: i.value
            } : {
                issues: t.common.issues
            };
        } catch (i) {
            (n1 = (r = i == null ? void 0 : i.message) == null ? void 0 : r.toLowerCase()) != null && n1.includes("encountered") && (this["~standard"].async = !0), t.common = {
                issues: [],
                async: !0
            };
        }
        return this._parseAsync({
            data: e,
            path: [],
            parent: t
        }).then((i)=>_n(i) ? {
                value: i.value
            } : {
                issues: t.common.issues
            });
    }
    async parseAsync(e, t) {
        const r = await this.safeParseAsync(e, t);
        if (r.success) return r.data;
        throw r.error;
    }
    async safeParseAsync(e, t) {
        const r = {
            common: {
                issues: [],
                contextualErrorMap: t == null ? void 0 : t.errorMap,
                async: !0
            },
            path: (t == null ? void 0 : t.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data: e,
            parsedType: ws(e)
        }, n1 = this._parse({
            data: e,
            path: r.path,
            parent: r
        }), i = await (bo(n1) ? n1 : Promise.resolve(n1));
        return Ju(r, i);
    }
    refine(e, t) {
        const r = (n1)=>typeof t == "string" || typeof t > "u" ? {
                message: t
            } : typeof t == "function" ? t(n1) : t;
        return this._refinement((n1, i)=>{
            const o = e(n1), a = ()=>i.addIssue({
                    code: ae.custom,
                    ...r(n1)
                });
            return typeof Promise < "u" && o instanceof Promise ? o.then((l)=>l ? !0 : (a(), !1)) : o ? !0 : (a(), !1);
        });
    }
    refinement(e, t) {
        return this._refinement((r, n1)=>e(r) ? !0 : (n1.addIssue(typeof t == "function" ? t(r, n1) : t), !1));
    }
    _refinement(e) {
        return new Ys({
            schema: this,
            typeName: ke.ZodEffects,
            effect: {
                type: "refinement",
                refinement: e
            }
        });
    }
    superRefine(e) {
        return this._refinement(e);
    }
    constructor(e){
        this.spa = this.safeParseAsync, this._def = e, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = {
            version: 1,
            vendor: "zod",
            validate: (t)=>this["~validate"](t)
        };
    }
    optional() {
        return fs.create(this, this._def);
    }
    nullable() {
        return Zs.create(this, this._def);
    }
    nullish() {
        return this.nullable().optional();
    }
    array() {
        return Yr.create(this);
    }
    promise() {
        return _o.create(this, this._def);
    }
    or(e) {
        return wo.create([
            this,
            e
        ], this._def);
    }
    and(e) {
        return Ao.create(this, e, this._def);
    }
    transform(e) {
        return new Ys({
            ...Ve(this._def),
            schema: this,
            typeName: ke.ZodEffects,
            effect: {
                type: "transform",
                transform: e
            }
        });
    }
    default(e) {
        const t = typeof e == "function" ? e : ()=>e;
        return new Lo({
            ...Ve(this._def),
            innerType: this,
            defaultValue: t,
            typeName: ke.ZodDefault
        });
    }
    brand() {
        return new Uf({
            typeName: ke.ZodBranded,
            type: this,
            ...Ve(this._def)
        });
    }
    catch(e) {
        const t = typeof e == "function" ? e : ()=>e;
        return new Ro({
            ...Ve(this._def),
            innerType: this,
            catchValue: t,
            typeName: ke.ZodCatch
        });
    }
    describe(e) {
        const t = this.constructor;
        return new t({
            ...this._def,
            description: e
        });
    }
    pipe(e) {
        return $c.create(this, e);
    }
    readonly() {
        return Co.create(this);
    }
    isOptional() {
        return this.safeParse(void 0).success;
    }
    isNullable() {
        return this.safeParse(null).success;
    }
}
const km = /^c[^\s-]{8,}$/i, Dm = /^[0-9a-z]+$/, Pm = /^[0-9A-HJKMNP-TV-Z]{26}$/i, Mm = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, Om = /^[a-z0-9_-]{21}$/i, Bm = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/, Fm = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, Nm = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, Um = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let $a;
const $m = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, Gm = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/, Vm = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/, jm = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, Km = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, Hm = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/, Bf = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", qm = new RegExp(`^${Bf}$`);
function Ff(s) {
    let e = "[0-5]\\d";
    s.precision ? e = `${e}\\.\\d{${s.precision}}` : s.precision == null && (e = `${e}(\\.\\d+)?`);
    const t = s.precision ? "+" : "?";
    return `([01]\\d|2[0-3]):[0-5]\\d(:${e})${t}`;
}
function Wm(s) {
    return new RegExp(`^${Ff(s)}$`);
}
function zm(s) {
    let e = `${Bf}T${Ff(s)}`;
    const t = [];
    return t.push(s.local ? "Z?" : "Z"), s.offset && t.push("([+-]\\d{2}:?\\d{2})"), e = `${e}(${t.join("|")})`, new RegExp(`^${e}$`);
}
function Ym(s, e) {
    return !!((e === "v4" || !e) && $m.test(s) || (e === "v6" || !e) && Vm.test(s));
}
function Zm(s, e) {
    if (!Bm.test(s)) return !1;
    try {
        const [t] = s.split(".");
        if (!t) return !1;
        const r = t.replace(/-/g, "+").replace(/_/g, "/").padEnd(t.length + (4 - t.length % 4) % 4, "="), n1 = JSON.parse(atob(r));
        return !(typeof n1 != "object" || n1 === null || "typ" in n1 && (n1 == null ? void 0 : n1.typ) !== "JWT" || !n1.alg || e && n1.alg !== e);
    } catch  {
        return !1;
    }
}
function Xm(s, e) {
    return !!((e === "v4" || !e) && Gm.test(s) || (e === "v6" || !e) && jm.test(s));
}
class Ls extends Ye {
    _parse(e) {
        if (this._def.coerce && (e.data = String(e.data)), this._getType(e) !== me.string) {
            const i = this._getOrReturnCtx(e);
            return he(i, {
                code: ae.invalid_type,
                expected: me.string,
                received: i.parsedType
            }), Le;
        }
        const r = new wr();
        let n1;
        for (const i of this._def.checks)if (i.kind === "min") e.data.length < i.value && (n1 = this._getOrReturnCtx(e, n1), he(n1, {
            code: ae.too_small,
            minimum: i.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: i.message
        }), r.dirty());
        else if (i.kind === "max") e.data.length > i.value && (n1 = this._getOrReturnCtx(e, n1), he(n1, {
            code: ae.too_big,
            maximum: i.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: i.message
        }), r.dirty());
        else if (i.kind === "length") {
            const o = e.data.length > i.value, a = e.data.length < i.value;
            (o || a) && (n1 = this._getOrReturnCtx(e, n1), o ? he(n1, {
                code: ae.too_big,
                maximum: i.value,
                type: "string",
                inclusive: !0,
                exact: !0,
                message: i.message
            }) : a && he(n1, {
                code: ae.too_small,
                minimum: i.value,
                type: "string",
                inclusive: !0,
                exact: !0,
                message: i.message
            }), r.dirty());
        } else if (i.kind === "email") Nm.test(e.data) || (n1 = this._getOrReturnCtx(e, n1), he(n1, {
            validation: "email",
            code: ae.invalid_string,
            message: i.message
        }), r.dirty());
        else if (i.kind === "emoji") $a || ($a = new RegExp(Um, "u")), $a.test(e.data) || (n1 = this._getOrReturnCtx(e, n1), he(n1, {
            validation: "emoji",
            code: ae.invalid_string,
            message: i.message
        }), r.dirty());
        else if (i.kind === "uuid") Mm.test(e.data) || (n1 = this._getOrReturnCtx(e, n1), he(n1, {
            validation: "uuid",
            code: ae.invalid_string,
            message: i.message
        }), r.dirty());
        else if (i.kind === "nanoid") Om.test(e.data) || (n1 = this._getOrReturnCtx(e, n1), he(n1, {
            validation: "nanoid",
            code: ae.invalid_string,
            message: i.message
        }), r.dirty());
        else if (i.kind === "cuid") km.test(e.data) || (n1 = this._getOrReturnCtx(e, n1), he(n1, {
            validation: "cuid",
            code: ae.invalid_string,
            message: i.message
        }), r.dirty());
        else if (i.kind === "cuid2") Dm.test(e.data) || (n1 = this._getOrReturnCtx(e, n1), he(n1, {
            validation: "cuid2",
            code: ae.invalid_string,
            message: i.message
        }), r.dirty());
        else if (i.kind === "ulid") Pm.test(e.data) || (n1 = this._getOrReturnCtx(e, n1), he(n1, {
            validation: "ulid",
            code: ae.invalid_string,
            message: i.message
        }), r.dirty());
        else if (i.kind === "url") try {
            new URL(e.data);
        } catch  {
            n1 = this._getOrReturnCtx(e, n1), he(n1, {
                validation: "url",
                code: ae.invalid_string,
                message: i.message
            }), r.dirty();
        }
        else i.kind === "regex" ? (i.regex.lastIndex = 0, i.regex.test(e.data) || (n1 = this._getOrReturnCtx(e, n1), he(n1, {
            validation: "regex",
            code: ae.invalid_string,
            message: i.message
        }), r.dirty())) : i.kind === "trim" ? e.data = e.data.trim() : i.kind === "includes" ? e.data.includes(i.value, i.position) || (n1 = this._getOrReturnCtx(e, n1), he(n1, {
            code: ae.invalid_string,
            validation: {
                includes: i.value,
                position: i.position
            },
            message: i.message
        }), r.dirty()) : i.kind === "toLowerCase" ? e.data = e.data.toLowerCase() : i.kind === "toUpperCase" ? e.data = e.data.toUpperCase() : i.kind === "startsWith" ? e.data.startsWith(i.value) || (n1 = this._getOrReturnCtx(e, n1), he(n1, {
            code: ae.invalid_string,
            validation: {
                startsWith: i.value
            },
            message: i.message
        }), r.dirty()) : i.kind === "endsWith" ? e.data.endsWith(i.value) || (n1 = this._getOrReturnCtx(e, n1), he(n1, {
            code: ae.invalid_string,
            validation: {
                endsWith: i.value
            },
            message: i.message
        }), r.dirty()) : i.kind === "datetime" ? zm(i).test(e.data) || (n1 = this._getOrReturnCtx(e, n1), he(n1, {
            code: ae.invalid_string,
            validation: "datetime",
            message: i.message
        }), r.dirty()) : i.kind === "date" ? qm.test(e.data) || (n1 = this._getOrReturnCtx(e, n1), he(n1, {
            code: ae.invalid_string,
            validation: "date",
            message: i.message
        }), r.dirty()) : i.kind === "time" ? Wm(i).test(e.data) || (n1 = this._getOrReturnCtx(e, n1), he(n1, {
            code: ae.invalid_string,
            validation: "time",
            message: i.message
        }), r.dirty()) : i.kind === "duration" ? Fm.test(e.data) || (n1 = this._getOrReturnCtx(e, n1), he(n1, {
            validation: "duration",
            code: ae.invalid_string,
            message: i.message
        }), r.dirty()) : i.kind === "ip" ? Ym(e.data, i.version) || (n1 = this._getOrReturnCtx(e, n1), he(n1, {
            validation: "ip",
            code: ae.invalid_string,
            message: i.message
        }), r.dirty()) : i.kind === "jwt" ? Zm(e.data, i.alg) || (n1 = this._getOrReturnCtx(e, n1), he(n1, {
            validation: "jwt",
            code: ae.invalid_string,
            message: i.message
        }), r.dirty()) : i.kind === "cidr" ? Xm(e.data, i.version) || (n1 = this._getOrReturnCtx(e, n1), he(n1, {
            validation: "cidr",
            code: ae.invalid_string,
            message: i.message
        }), r.dirty()) : i.kind === "base64" ? Km.test(e.data) || (n1 = this._getOrReturnCtx(e, n1), he(n1, {
            validation: "base64",
            code: ae.invalid_string,
            message: i.message
        }), r.dirty()) : i.kind === "base64url" ? Hm.test(e.data) || (n1 = this._getOrReturnCtx(e, n1), he(n1, {
            validation: "base64url",
            code: ae.invalid_string,
            message: i.message
        }), r.dirty()) : Ze.assertNever(i);
        return {
            status: r.value,
            value: e.data
        };
    }
    _regex(e, t, r) {
        return this.refinement((n1)=>e.test(n1), {
            validation: t,
            code: ae.invalid_string,
            ...Ee.errToObj(r)
        });
    }
    _addCheck(e) {
        return new Ls({
            ...this._def,
            checks: [
                ...this._def.checks,
                e
            ]
        });
    }
    email(e) {
        return this._addCheck({
            kind: "email",
            ...Ee.errToObj(e)
        });
    }
    url(e) {
        return this._addCheck({
            kind: "url",
            ...Ee.errToObj(e)
        });
    }
    emoji(e) {
        return this._addCheck({
            kind: "emoji",
            ...Ee.errToObj(e)
        });
    }
    uuid(e) {
        return this._addCheck({
            kind: "uuid",
            ...Ee.errToObj(e)
        });
    }
    nanoid(e) {
        return this._addCheck({
            kind: "nanoid",
            ...Ee.errToObj(e)
        });
    }
    cuid(e) {
        return this._addCheck({
            kind: "cuid",
            ...Ee.errToObj(e)
        });
    }
    cuid2(e) {
        return this._addCheck({
            kind: "cuid2",
            ...Ee.errToObj(e)
        });
    }
    ulid(e) {
        return this._addCheck({
            kind: "ulid",
            ...Ee.errToObj(e)
        });
    }
    base64(e) {
        return this._addCheck({
            kind: "base64",
            ...Ee.errToObj(e)
        });
    }
    base64url(e) {
        return this._addCheck({
            kind: "base64url",
            ...Ee.errToObj(e)
        });
    }
    jwt(e) {
        return this._addCheck({
            kind: "jwt",
            ...Ee.errToObj(e)
        });
    }
    ip(e) {
        return this._addCheck({
            kind: "ip",
            ...Ee.errToObj(e)
        });
    }
    cidr(e) {
        return this._addCheck({
            kind: "cidr",
            ...Ee.errToObj(e)
        });
    }
    datetime(e) {
        return typeof e == "string" ? this._addCheck({
            kind: "datetime",
            precision: null,
            offset: !1,
            local: !1,
            message: e
        }) : this._addCheck({
            kind: "datetime",
            precision: typeof (e == null ? void 0 : e.precision) > "u" ? null : e == null ? void 0 : e.precision,
            offset: (e == null ? void 0 : e.offset) ?? !1,
            local: (e == null ? void 0 : e.local) ?? !1,
            ...Ee.errToObj(e == null ? void 0 : e.message)
        });
    }
    date(e) {
        return this._addCheck({
            kind: "date",
            message: e
        });
    }
    time(e) {
        return typeof e == "string" ? this._addCheck({
            kind: "time",
            precision: null,
            message: e
        }) : this._addCheck({
            kind: "time",
            precision: typeof (e == null ? void 0 : e.precision) > "u" ? null : e == null ? void 0 : e.precision,
            ...Ee.errToObj(e == null ? void 0 : e.message)
        });
    }
    duration(e) {
        return this._addCheck({
            kind: "duration",
            ...Ee.errToObj(e)
        });
    }
    regex(e, t) {
        return this._addCheck({
            kind: "regex",
            regex: e,
            ...Ee.errToObj(t)
        });
    }
    includes(e, t) {
        return this._addCheck({
            kind: "includes",
            value: e,
            position: t == null ? void 0 : t.position,
            ...Ee.errToObj(t == null ? void 0 : t.message)
        });
    }
    startsWith(e, t) {
        return this._addCheck({
            kind: "startsWith",
            value: e,
            ...Ee.errToObj(t)
        });
    }
    endsWith(e, t) {
        return this._addCheck({
            kind: "endsWith",
            value: e,
            ...Ee.errToObj(t)
        });
    }
    min(e, t) {
        return this._addCheck({
            kind: "min",
            value: e,
            ...Ee.errToObj(t)
        });
    }
    max(e, t) {
        return this._addCheck({
            kind: "max",
            value: e,
            ...Ee.errToObj(t)
        });
    }
    length(e, t) {
        return this._addCheck({
            kind: "length",
            value: e,
            ...Ee.errToObj(t)
        });
    }
    /**
   * Equivalent to `.min(1)`
   */ nonempty(e) {
        return this.min(1, Ee.errToObj(e));
    }
    trim() {
        return new Ls({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind: "trim"
                }
            ]
        });
    }
    toLowerCase() {
        return new Ls({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind: "toLowerCase"
                }
            ]
        });
    }
    toUpperCase() {
        return new Ls({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind: "toUpperCase"
                }
            ]
        });
    }
    get isDatetime() {
        return !!this._def.checks.find((e)=>e.kind === "datetime");
    }
    get isDate() {
        return !!this._def.checks.find((e)=>e.kind === "date");
    }
    get isTime() {
        return !!this._def.checks.find((e)=>e.kind === "time");
    }
    get isDuration() {
        return !!this._def.checks.find((e)=>e.kind === "duration");
    }
    get isEmail() {
        return !!this._def.checks.find((e)=>e.kind === "email");
    }
    get isURL() {
        return !!this._def.checks.find((e)=>e.kind === "url");
    }
    get isEmoji() {
        return !!this._def.checks.find((e)=>e.kind === "emoji");
    }
    get isUUID() {
        return !!this._def.checks.find((e)=>e.kind === "uuid");
    }
    get isNANOID() {
        return !!this._def.checks.find((e)=>e.kind === "nanoid");
    }
    get isCUID() {
        return !!this._def.checks.find((e)=>e.kind === "cuid");
    }
    get isCUID2() {
        return !!this._def.checks.find((e)=>e.kind === "cuid2");
    }
    get isULID() {
        return !!this._def.checks.find((e)=>e.kind === "ulid");
    }
    get isIP() {
        return !!this._def.checks.find((e)=>e.kind === "ip");
    }
    get isCIDR() {
        return !!this._def.checks.find((e)=>e.kind === "cidr");
    }
    get isBase64() {
        return !!this._def.checks.find((e)=>e.kind === "base64");
    }
    get isBase64url() {
        return !!this._def.checks.find((e)=>e.kind === "base64url");
    }
    get minLength() {
        let e = null;
        for (const t of this._def.checks)t.kind === "min" && (e === null || t.value > e) && (e = t.value);
        return e;
    }
    get maxLength() {
        let e = null;
        for (const t of this._def.checks)t.kind === "max" && (e === null || t.value < e) && (e = t.value);
        return e;
    }
}
Ls.create = (s)=>new Ls({
        checks: [],
        typeName: ke.ZodString,
        coerce: (s == null ? void 0 : s.coerce) ?? !1,
        ...Ve(s)
    });
function Jm(s, e) {
    const t = (s.toString().split(".")[1] || "").length, r = (e.toString().split(".")[1] || "").length, n1 = t > r ? t : r, i = Number.parseInt(s.toFixed(n1).replace(".", "")), o = Number.parseInt(e.toFixed(n1).replace(".", ""));
    return i % o / 10 ** n1;
}
class Ln extends Ye {
    constructor(){
        super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
    }
    _parse(e) {
        if (this._def.coerce && (e.data = Number(e.data)), this._getType(e) !== me.number) {
            const i = this._getOrReturnCtx(e);
            return he(i, {
                code: ae.invalid_type,
                expected: me.number,
                received: i.parsedType
            }), Le;
        }
        let r;
        const n1 = new wr();
        for (const i of this._def.checks)i.kind === "int" ? Ze.isInteger(e.data) || (r = this._getOrReturnCtx(e, r), he(r, {
            code: ae.invalid_type,
            expected: "integer",
            received: "float",
            message: i.message
        }), n1.dirty()) : i.kind === "min" ? (i.inclusive ? e.data < i.value : e.data <= i.value) && (r = this._getOrReturnCtx(e, r), he(r, {
            code: ae.too_small,
            minimum: i.value,
            type: "number",
            inclusive: i.inclusive,
            exact: !1,
            message: i.message
        }), n1.dirty()) : i.kind === "max" ? (i.inclusive ? e.data > i.value : e.data >= i.value) && (r = this._getOrReturnCtx(e, r), he(r, {
            code: ae.too_big,
            maximum: i.value,
            type: "number",
            inclusive: i.inclusive,
            exact: !1,
            message: i.message
        }), n1.dirty()) : i.kind === "multipleOf" ? Jm(e.data, i.value) !== 0 && (r = this._getOrReturnCtx(e, r), he(r, {
            code: ae.not_multiple_of,
            multipleOf: i.value,
            message: i.message
        }), n1.dirty()) : i.kind === "finite" ? Number.isFinite(e.data) || (r = this._getOrReturnCtx(e, r), he(r, {
            code: ae.not_finite,
            message: i.message
        }), n1.dirty()) : Ze.assertNever(i);
        return {
            status: n1.value,
            value: e.data
        };
    }
    gte(e, t) {
        return this.setLimit("min", e, !0, Ee.toString(t));
    }
    gt(e, t) {
        return this.setLimit("min", e, !1, Ee.toString(t));
    }
    lte(e, t) {
        return this.setLimit("max", e, !0, Ee.toString(t));
    }
    lt(e, t) {
        return this.setLimit("max", e, !1, Ee.toString(t));
    }
    setLimit(e, t, r, n1) {
        return new Ln({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind: e,
                    value: t,
                    inclusive: r,
                    message: Ee.toString(n1)
                }
            ]
        });
    }
    _addCheck(e) {
        return new Ln({
            ...this._def,
            checks: [
                ...this._def.checks,
                e
            ]
        });
    }
    int(e) {
        return this._addCheck({
            kind: "int",
            message: Ee.toString(e)
        });
    }
    positive(e) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !1,
            message: Ee.toString(e)
        });
    }
    negative(e) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !1,
            message: Ee.toString(e)
        });
    }
    nonpositive(e) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !0,
            message: Ee.toString(e)
        });
    }
    nonnegative(e) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !0,
            message: Ee.toString(e)
        });
    }
    multipleOf(e, t) {
        return this._addCheck({
            kind: "multipleOf",
            value: e,
            message: Ee.toString(t)
        });
    }
    finite(e) {
        return this._addCheck({
            kind: "finite",
            message: Ee.toString(e)
        });
    }
    safe(e) {
        return this._addCheck({
            kind: "min",
            inclusive: !0,
            value: Number.MIN_SAFE_INTEGER,
            message: Ee.toString(e)
        })._addCheck({
            kind: "max",
            inclusive: !0,
            value: Number.MAX_SAFE_INTEGER,
            message: Ee.toString(e)
        });
    }
    get minValue() {
        let e = null;
        for (const t of this._def.checks)t.kind === "min" && (e === null || t.value > e) && (e = t.value);
        return e;
    }
    get maxValue() {
        let e = null;
        for (const t of this._def.checks)t.kind === "max" && (e === null || t.value < e) && (e = t.value);
        return e;
    }
    get isInt() {
        return !!this._def.checks.find((e)=>e.kind === "int" || e.kind === "multipleOf" && Ze.isInteger(e.value));
    }
    get isFinite() {
        let e = null, t = null;
        for (const r of this._def.checks){
            if (r.kind === "finite" || r.kind === "int" || r.kind === "multipleOf") return !0;
            r.kind === "min" ? (t === null || r.value > t) && (t = r.value) : r.kind === "max" && (e === null || r.value < e) && (e = r.value);
        }
        return Number.isFinite(t) && Number.isFinite(e);
    }
}
Ln.create = (s)=>new Ln({
        checks: [],
        typeName: ke.ZodNumber,
        coerce: (s == null ? void 0 : s.coerce) || !1,
        ...Ve(s)
    });
class Jn extends Ye {
    constructor(){
        super(...arguments), this.min = this.gte, this.max = this.lte;
    }
    _parse(e) {
        if (this._def.coerce) try {
            e.data = BigInt(e.data);
        } catch  {
            return this._getInvalidInput(e);
        }
        if (this._getType(e) !== me.bigint) return this._getInvalidInput(e);
        let r;
        const n1 = new wr();
        for (const i of this._def.checks)i.kind === "min" ? (i.inclusive ? e.data < i.value : e.data <= i.value) && (r = this._getOrReturnCtx(e, r), he(r, {
            code: ae.too_small,
            type: "bigint",
            minimum: i.value,
            inclusive: i.inclusive,
            message: i.message
        }), n1.dirty()) : i.kind === "max" ? (i.inclusive ? e.data > i.value : e.data >= i.value) && (r = this._getOrReturnCtx(e, r), he(r, {
            code: ae.too_big,
            type: "bigint",
            maximum: i.value,
            inclusive: i.inclusive,
            message: i.message
        }), n1.dirty()) : i.kind === "multipleOf" ? e.data % i.value !== BigInt(0) && (r = this._getOrReturnCtx(e, r), he(r, {
            code: ae.not_multiple_of,
            multipleOf: i.value,
            message: i.message
        }), n1.dirty()) : Ze.assertNever(i);
        return {
            status: n1.value,
            value: e.data
        };
    }
    _getInvalidInput(e) {
        const t = this._getOrReturnCtx(e);
        return he(t, {
            code: ae.invalid_type,
            expected: me.bigint,
            received: t.parsedType
        }), Le;
    }
    gte(e, t) {
        return this.setLimit("min", e, !0, Ee.toString(t));
    }
    gt(e, t) {
        return this.setLimit("min", e, !1, Ee.toString(t));
    }
    lte(e, t) {
        return this.setLimit("max", e, !0, Ee.toString(t));
    }
    lt(e, t) {
        return this.setLimit("max", e, !1, Ee.toString(t));
    }
    setLimit(e, t, r, n1) {
        return new Jn({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind: e,
                    value: t,
                    inclusive: r,
                    message: Ee.toString(n1)
                }
            ]
        });
    }
    _addCheck(e) {
        return new Jn({
            ...this._def,
            checks: [
                ...this._def.checks,
                e
            ]
        });
    }
    positive(e) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !1,
            message: Ee.toString(e)
        });
    }
    negative(e) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !1,
            message: Ee.toString(e)
        });
    }
    nonpositive(e) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !0,
            message: Ee.toString(e)
        });
    }
    nonnegative(e) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !0,
            message: Ee.toString(e)
        });
    }
    multipleOf(e, t) {
        return this._addCheck({
            kind: "multipleOf",
            value: e,
            message: Ee.toString(t)
        });
    }
    get minValue() {
        let e = null;
        for (const t of this._def.checks)t.kind === "min" && (e === null || t.value > e) && (e = t.value);
        return e;
    }
    get maxValue() {
        let e = null;
        for (const t of this._def.checks)t.kind === "max" && (e === null || t.value < e) && (e = t.value);
        return e;
    }
}
Jn.create = (s)=>new Jn({
        checks: [],
        typeName: ke.ZodBigInt,
        coerce: (s == null ? void 0 : s.coerce) ?? !1,
        ...Ve(s)
    });
class Hl extends Ye {
    _parse(e) {
        if (this._def.coerce && (e.data = !!e.data), this._getType(e) !== me.boolean) {
            const r = this._getOrReturnCtx(e);
            return he(r, {
                code: ae.invalid_type,
                expected: me.boolean,
                received: r.parsedType
            }), Le;
        }
        return Lr(e.data);
    }
}
Hl.create = (s)=>new Hl({
        typeName: ke.ZodBoolean,
        coerce: (s == null ? void 0 : s.coerce) || !1,
        ...Ve(s)
    });
class To extends Ye {
    _parse(e) {
        if (this._def.coerce && (e.data = new Date(e.data)), this._getType(e) !== me.date) {
            const i = this._getOrReturnCtx(e);
            return he(i, {
                code: ae.invalid_type,
                expected: me.date,
                received: i.parsedType
            }), Le;
        }
        if (Number.isNaN(e.data.getTime())) {
            const i = this._getOrReturnCtx(e);
            return he(i, {
                code: ae.invalid_date
            }), Le;
        }
        const r = new wr();
        let n1;
        for (const i of this._def.checks)i.kind === "min" ? e.data.getTime() < i.value && (n1 = this._getOrReturnCtx(e, n1), he(n1, {
            code: ae.too_small,
            message: i.message,
            inclusive: !0,
            exact: !1,
            minimum: i.value,
            type: "date"
        }), r.dirty()) : i.kind === "max" ? e.data.getTime() > i.value && (n1 = this._getOrReturnCtx(e, n1), he(n1, {
            code: ae.too_big,
            message: i.message,
            inclusive: !0,
            exact: !1,
            maximum: i.value,
            type: "date"
        }), r.dirty()) : Ze.assertNever(i);
        return {
            status: r.value,
            value: new Date(e.data.getTime())
        };
    }
    _addCheck(e) {
        return new To({
            ...this._def,
            checks: [
                ...this._def.checks,
                e
            ]
        });
    }
    min(e, t) {
        return this._addCheck({
            kind: "min",
            value: e.getTime(),
            message: Ee.toString(t)
        });
    }
    max(e, t) {
        return this._addCheck({
            kind: "max",
            value: e.getTime(),
            message: Ee.toString(t)
        });
    }
    get minDate() {
        let e = null;
        for (const t of this._def.checks)t.kind === "min" && (e === null || t.value > e) && (e = t.value);
        return e != null ? new Date(e) : null;
    }
    get maxDate() {
        let e = null;
        for (const t of this._def.checks)t.kind === "max" && (e === null || t.value < e) && (e = t.value);
        return e != null ? new Date(e) : null;
    }
}
To.create = (s)=>new To({
        checks: [],
        coerce: (s == null ? void 0 : s.coerce) || !1,
        typeName: ke.ZodDate,
        ...Ve(s)
    });
class Qu extends Ye {
    _parse(e) {
        if (this._getType(e) !== me.symbol) {
            const r = this._getOrReturnCtx(e);
            return he(r, {
                code: ae.invalid_type,
                expected: me.symbol,
                received: r.parsedType
            }), Le;
        }
        return Lr(e.data);
    }
}
Qu.create = (s)=>new Qu({
        typeName: ke.ZodSymbol,
        ...Ve(s)
    });
class ql extends Ye {
    _parse(e) {
        if (this._getType(e) !== me.undefined) {
            const r = this._getOrReturnCtx(e);
            return he(r, {
                code: ae.invalid_type,
                expected: me.undefined,
                received: r.parsedType
            }), Le;
        }
        return Lr(e.data);
    }
}
ql.create = (s)=>new ql({
        typeName: ke.ZodUndefined,
        ...Ve(s)
    });
class Wl extends Ye {
    _parse(e) {
        if (this._getType(e) !== me.null) {
            const r = this._getOrReturnCtx(e);
            return he(r, {
                code: ae.invalid_type,
                expected: me.null,
                received: r.parsedType
            }), Le;
        }
        return Lr(e.data);
    }
}
Wl.create = (s)=>new Wl({
        typeName: ke.ZodNull,
        ...Ve(s)
    });
class ed extends Ye {
    constructor(){
        super(...arguments), this._any = !0;
    }
    _parse(e) {
        return Lr(e.data);
    }
}
ed.create = (s)=>new ed({
        typeName: ke.ZodAny,
        ...Ve(s)
    });
class td extends Ye {
    constructor(){
        super(...arguments), this._unknown = !0;
    }
    _parse(e) {
        return Lr(e.data);
    }
}
td.create = (s)=>new td({
        typeName: ke.ZodUnknown,
        ...Ve(s)
    });
class Ps extends Ye {
    _parse(e) {
        const t = this._getOrReturnCtx(e);
        return he(t, {
            code: ae.invalid_type,
            expected: me.never,
            received: t.parsedType
        }), Le;
    }
}
Ps.create = (s)=>new Ps({
        typeName: ke.ZodNever,
        ...Ve(s)
    });
class rd extends Ye {
    _parse(e) {
        if (this._getType(e) !== me.undefined) {
            const r = this._getOrReturnCtx(e);
            return he(r, {
                code: ae.invalid_type,
                expected: me.void,
                received: r.parsedType
            }), Le;
        }
        return Lr(e.data);
    }
}
rd.create = (s)=>new rd({
        typeName: ke.ZodVoid,
        ...Ve(s)
    });
class Yr extends Ye {
    _parse(e) {
        const { ctx: t, status: r } = this._processInputParams(e), n1 = this._def;
        if (t.parsedType !== me.array) return he(t, {
            code: ae.invalid_type,
            expected: me.array,
            received: t.parsedType
        }), Le;
        if (n1.exactLength !== null) {
            const o = t.data.length > n1.exactLength.value, a = t.data.length < n1.exactLength.value;
            (o || a) && (he(t, {
                code: o ? ae.too_big : ae.too_small,
                minimum: a ? n1.exactLength.value : void 0,
                maximum: o ? n1.exactLength.value : void 0,
                type: "array",
                inclusive: !0,
                exact: !0,
                message: n1.exactLength.message
            }), r.dirty());
        }
        if (n1.minLength !== null && t.data.length < n1.minLength.value && (he(t, {
            code: ae.too_small,
            minimum: n1.minLength.value,
            type: "array",
            inclusive: !0,
            exact: !1,
            message: n1.minLength.message
        }), r.dirty()), n1.maxLength !== null && t.data.length > n1.maxLength.value && (he(t, {
            code: ae.too_big,
            maximum: n1.maxLength.value,
            type: "array",
            inclusive: !0,
            exact: !1,
            message: n1.maxLength.message
        }), r.dirty()), t.common.async) return Promise.all([
            ...t.data
        ].map((o, a)=>n1.type._parseAsync(new Ds(t, o, t.path, a)))).then((o)=>wr.mergeArray(r, o));
        const i = [
            ...t.data
        ].map((o, a)=>n1.type._parseSync(new Ds(t, o, t.path, a)));
        return wr.mergeArray(r, i);
    }
    get element() {
        return this._def.type;
    }
    min(e, t) {
        return new Yr({
            ...this._def,
            minLength: {
                value: e,
                message: Ee.toString(t)
            }
        });
    }
    max(e, t) {
        return new Yr({
            ...this._def,
            maxLength: {
                value: e,
                message: Ee.toString(t)
            }
        });
    }
    length(e, t) {
        return new Yr({
            ...this._def,
            exactLength: {
                value: e,
                message: Ee.toString(t)
            }
        });
    }
    nonempty(e) {
        return this.min(1, e);
    }
}
Yr.create = (s, e)=>new Yr({
        type: s,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ke.ZodArray,
        ...Ve(e)
    });
function gn(s) {
    if (s instanceof $t) {
        const e = {};
        for(const t in s.shape){
            const r = s.shape[t];
            e[t] = fs.create(gn(r));
        }
        return new $t({
            ...s._def,
            shape: ()=>e
        });
    } else return s instanceof Yr ? new Yr({
        ...s._def,
        type: gn(s.element)
    }) : s instanceof fs ? fs.create(gn(s.unwrap())) : s instanceof Zs ? Zs.create(gn(s.unwrap())) : s instanceof Ws ? Ws.create(s.items.map((e)=>gn(e))) : s;
}
class $t extends Ye {
    constructor(){
        super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
    }
    _getCached() {
        if (this._cached !== null) return this._cached;
        const e = this._def.shape(), t = Ze.objectKeys(e);
        return this._cached = {
            shape: e,
            keys: t
        }, this._cached;
    }
    _parse(e) {
        if (this._getType(e) !== me.object) {
            const c = this._getOrReturnCtx(e);
            return he(c, {
                code: ae.invalid_type,
                expected: me.object,
                received: c.parsedType
            }), Le;
        }
        const { status: r, ctx: n1 } = this._processInputParams(e), { shape: i, keys: o } = this._getCached(), a = [];
        if (!(this._def.catchall instanceof Ps && this._def.unknownKeys === "strip")) for(const c in n1.data)o.includes(c) || a.push(c);
        const l = [];
        for (const c of o){
            const u = i[c], d1 = n1.data[c];
            l.push({
                key: {
                    status: "valid",
                    value: c
                },
                value: u._parse(new Ds(n1, d1, n1.path, c)),
                alwaysSet: c in n1.data
            });
        }
        if (this._def.catchall instanceof Ps) {
            const c = this._def.unknownKeys;
            if (c === "passthrough") for (const u of a)l.push({
                key: {
                    status: "valid",
                    value: u
                },
                value: {
                    status: "valid",
                    value: n1.data[u]
                }
            });
            else if (c === "strict") a.length > 0 && (he(n1, {
                code: ae.unrecognized_keys,
                keys: a
            }), r.dirty());
            else if (c !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.");
        } else {
            const c = this._def.catchall;
            for (const u of a){
                const d1 = n1.data[u];
                l.push({
                    key: {
                        status: "valid",
                        value: u
                    },
                    value: c._parse(new Ds(n1, d1, n1.path, u)),
                    alwaysSet: u in n1.data
                });
            }
        }
        return n1.common.async ? Promise.resolve().then(async ()=>{
            const c = [];
            for (const u of l){
                const d1 = await u.key, h = await u.value;
                c.push({
                    key: d1,
                    value: h,
                    alwaysSet: u.alwaysSet
                });
            }
            return c;
        }).then((c)=>wr.mergeObjectSync(r, c)) : wr.mergeObjectSync(r, l);
    }
    get shape() {
        return this._def.shape();
    }
    strict(e) {
        return Ee.errToObj, new $t({
            ...this._def,
            unknownKeys: "strict",
            ...e !== void 0 ? {
                errorMap: (t, r)=>{
                    var i, o;
                    const n1 = ((o = (i = this._def).errorMap) == null ? void 0 : o.call(i, t, r).message) ?? r.defaultError;
                    return t.code === "unrecognized_keys" ? {
                        message: Ee.errToObj(e).message ?? n1
                    } : {
                        message: n1
                    };
                }
            } : {}
        });
    }
    strip() {
        return new $t({
            ...this._def,
            unknownKeys: "strip"
        });
    }
    passthrough() {
        return new $t({
            ...this._def,
            unknownKeys: "passthrough"
        });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(e) {
        return new $t({
            ...this._def,
            shape: ()=>({
                    ...this._def.shape(),
                    ...e
                })
        });
    }
    /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */ merge(e) {
        return new $t({
            unknownKeys: e._def.unknownKeys,
            catchall: e._def.catchall,
            shape: ()=>({
                    ...this._def.shape(),
                    ...e._def.shape()
                }),
            typeName: ke.ZodObject
        });
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(e, t) {
        return this.augment({
            [e]: t
        });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(e) {
        return new $t({
            ...this._def,
            catchall: e
        });
    }
    pick(e) {
        const t = {};
        for (const r of Ze.objectKeys(e))e[r] && this.shape[r] && (t[r] = this.shape[r]);
        return new $t({
            ...this._def,
            shape: ()=>t
        });
    }
    omit(e) {
        const t = {};
        for (const r of Ze.objectKeys(this.shape))e[r] || (t[r] = this.shape[r]);
        return new $t({
            ...this._def,
            shape: ()=>t
        });
    }
    /**
   * @deprecated
   */ deepPartial() {
        return gn(this);
    }
    partial(e) {
        const t = {};
        for (const r of Ze.objectKeys(this.shape)){
            const n1 = this.shape[r];
            e && !e[r] ? t[r] = n1 : t[r] = n1.optional();
        }
        return new $t({
            ...this._def,
            shape: ()=>t
        });
    }
    required(e) {
        const t = {};
        for (const r of Ze.objectKeys(this.shape))if (e && !e[r]) t[r] = this.shape[r];
        else {
            let i = this.shape[r];
            for(; i instanceof fs;)i = i._def.innerType;
            t[r] = i;
        }
        return new $t({
            ...this._def,
            shape: ()=>t
        });
    }
    keyof() {
        return Nf(Ze.objectKeys(this.shape));
    }
}
$t.create = (s, e)=>new $t({
        shape: ()=>s,
        unknownKeys: "strip",
        catchall: Ps.create(),
        typeName: ke.ZodObject,
        ...Ve(e)
    });
$t.strictCreate = (s, e)=>new $t({
        shape: ()=>s,
        unknownKeys: "strict",
        catchall: Ps.create(),
        typeName: ke.ZodObject,
        ...Ve(e)
    });
$t.lazycreate = (s, e)=>new $t({
        shape: s,
        unknownKeys: "strip",
        catchall: Ps.create(),
        typeName: ke.ZodObject,
        ...Ve(e)
    });
class wo extends Ye {
    _parse(e) {
        const { ctx: t } = this._processInputParams(e), r = this._def.options;
        function n1(i) {
            for (const a of i)if (a.result.status === "valid") return a.result;
            for (const a of i)if (a.result.status === "dirty") return t.common.issues.push(...a.ctx.common.issues), a.result;
            const o = i.map((a)=>new ps(a.ctx.common.issues));
            return he(t, {
                code: ae.invalid_union,
                unionErrors: o
            }), Le;
        }
        if (t.common.async) return Promise.all(r.map(async (i)=>{
            const o = {
                ...t,
                common: {
                    ...t.common,
                    issues: []
                },
                parent: null
            };
            return {
                result: await i._parseAsync({
                    data: t.data,
                    path: t.path,
                    parent: o
                }),
                ctx: o
            };
        })).then(n1);
        {
            let i;
            const o = [];
            for (const l of r){
                const c = {
                    ...t,
                    common: {
                        ...t.common,
                        issues: []
                    },
                    parent: null
                }, u = l._parseSync({
                    data: t.data,
                    path: t.path,
                    parent: c
                });
                if (u.status === "valid") return u;
                u.status === "dirty" && !i && (i = {
                    result: u,
                    ctx: c
                }), c.common.issues.length && o.push(c.common.issues);
            }
            if (i) return t.common.issues.push(...i.ctx.common.issues), i.result;
            const a = o.map((l)=>new ps(l));
            return he(t, {
                code: ae.invalid_union,
                unionErrors: a
            }), Le;
        }
    }
    get options() {
        return this._def.options;
    }
}
wo.create = (s, e)=>new wo({
        options: s,
        typeName: ke.ZodUnion,
        ...Ve(e)
    });
const os = (s)=>s instanceof Yl ? os(s.schema) : s instanceof Ys ? os(s.innerType()) : s instanceof Io ? [
        s.value
    ] : s instanceof zs ? s.options : s instanceof Zl ? Ze.objectValues(s.enum) : s instanceof Lo ? os(s._def.innerType) : s instanceof ql ? [
        void 0
    ] : s instanceof Wl ? [
        null
    ] : s instanceof fs ? [
        void 0,
        ...os(s.unwrap())
    ] : s instanceof Zs ? [
        null,
        ...os(s.unwrap())
    ] : s instanceof Uf || s instanceof Co ? os(s.unwrap()) : s instanceof Ro ? os(s._def.innerType) : [];
class Uc extends Ye {
    _parse(e) {
        const { ctx: t } = this._processInputParams(e);
        if (t.parsedType !== me.object) return he(t, {
            code: ae.invalid_type,
            expected: me.object,
            received: t.parsedType
        }), Le;
        const r = this.discriminator, n1 = t.data[r], i = this.optionsMap.get(n1);
        return i ? t.common.async ? i._parseAsync({
            data: t.data,
            path: t.path,
            parent: t
        }) : i._parseSync({
            data: t.data,
            path: t.path,
            parent: t
        }) : (he(t, {
            code: ae.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [
                r
            ]
        }), Le);
    }
    get discriminator() {
        return this._def.discriminator;
    }
    get options() {
        return this._def.options;
    }
    get optionsMap() {
        return this._def.optionsMap;
    }
    /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */ static create(e, t, r) {
        const n1 = /* @__PURE__ */ new Map();
        for (const i of t){
            const o = os(i.shape[e]);
            if (!o.length) throw new Error(`A discriminator value for key \`${e}\` could not be extracted from all schema options`);
            for (const a of o){
                if (n1.has(a)) throw new Error(`Discriminator property ${String(e)} has duplicate value ${String(a)}`);
                n1.set(a, i);
            }
        }
        return new Uc({
            typeName: ke.ZodDiscriminatedUnion,
            discriminator: e,
            options: t,
            optionsMap: n1,
            ...Ve(r)
        });
    }
}
function zl(s, e) {
    const t = ws(s), r = ws(e);
    if (s === e) return {
        valid: !0,
        data: s
    };
    if (t === me.object && r === me.object) {
        const n1 = Ze.objectKeys(e), i = Ze.objectKeys(s).filter((a)=>n1.indexOf(a) !== -1), o = {
            ...s,
            ...e
        };
        for (const a of i){
            const l = zl(s[a], e[a]);
            if (!l.valid) return {
                valid: !1
            };
            o[a] = l.data;
        }
        return {
            valid: !0,
            data: o
        };
    } else if (t === me.array && r === me.array) {
        if (s.length !== e.length) return {
            valid: !1
        };
        const n1 = [];
        for(let i = 0; i < s.length; i++){
            const o = s[i], a = e[i], l = zl(o, a);
            if (!l.valid) return {
                valid: !1
            };
            n1.push(l.data);
        }
        return {
            valid: !0,
            data: n1
        };
    } else return t === me.date && r === me.date && +s == +e ? {
        valid: !0,
        data: s
    } : {
        valid: !1
    };
}
class Ao extends Ye {
    _parse(e) {
        const { status: t, ctx: r } = this._processInputParams(e), n1 = (i, o)=>{
            if (Zu(i) || Zu(o)) return Le;
            const a = zl(i.value, o.value);
            return a.valid ? ((Xu(i) || Xu(o)) && t.dirty(), {
                status: t.value,
                value: a.data
            }) : (he(r, {
                code: ae.invalid_intersection_types
            }), Le);
        };
        return r.common.async ? Promise.all([
            this._def.left._parseAsync({
                data: r.data,
                path: r.path,
                parent: r
            }),
            this._def.right._parseAsync({
                data: r.data,
                path: r.path,
                parent: r
            })
        ]).then(([i, o])=>n1(i, o)) : n1(this._def.left._parseSync({
            data: r.data,
            path: r.path,
            parent: r
        }), this._def.right._parseSync({
            data: r.data,
            path: r.path,
            parent: r
        }));
    }
}
Ao.create = (s, e, t)=>new Ao({
        left: s,
        right: e,
        typeName: ke.ZodIntersection,
        ...Ve(t)
    });
class Ws extends Ye {
    _parse(e) {
        const { status: t, ctx: r } = this._processInputParams(e);
        if (r.parsedType !== me.array) return he(r, {
            code: ae.invalid_type,
            expected: me.array,
            received: r.parsedType
        }), Le;
        if (r.data.length < this._def.items.length) return he(r, {
            code: ae.too_small,
            minimum: this._def.items.length,
            inclusive: !0,
            exact: !1,
            type: "array"
        }), Le;
        !this._def.rest && r.data.length > this._def.items.length && (he(r, {
            code: ae.too_big,
            maximum: this._def.items.length,
            inclusive: !0,
            exact: !1,
            type: "array"
        }), t.dirty());
        const i = [
            ...r.data
        ].map((o, a)=>{
            const l = this._def.items[a] || this._def.rest;
            return l ? l._parse(new Ds(r, o, r.path, a)) : null;
        }).filter((o)=>!!o);
        return r.common.async ? Promise.all(i).then((o)=>wr.mergeArray(t, o)) : wr.mergeArray(t, i);
    }
    get items() {
        return this._def.items;
    }
    rest(e) {
        return new Ws({
            ...this._def,
            rest: e
        });
    }
}
Ws.create = (s, e)=>{
    if (!Array.isArray(s)) throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    return new Ws({
        items: s,
        typeName: ke.ZodTuple,
        rest: null,
        ...Ve(e)
    });
};
class sd extends Ye {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(e) {
        const { status: t, ctx: r } = this._processInputParams(e);
        if (r.parsedType !== me.map) return he(r, {
            code: ae.invalid_type,
            expected: me.map,
            received: r.parsedType
        }), Le;
        const n1 = this._def.keyType, i = this._def.valueType, o = [
            ...r.data.entries()
        ].map(([a, l], c)=>({
                key: n1._parse(new Ds(r, a, r.path, [
                    c,
                    "key"
                ])),
                value: i._parse(new Ds(r, l, r.path, [
                    c,
                    "value"
                ]))
            }));
        if (r.common.async) {
            const a = /* @__PURE__ */ new Map();
            return Promise.resolve().then(async ()=>{
                for (const l of o){
                    const c = await l.key, u = await l.value;
                    if (c.status === "aborted" || u.status === "aborted") return Le;
                    (c.status === "dirty" || u.status === "dirty") && t.dirty(), a.set(c.value, u.value);
                }
                return {
                    status: t.value,
                    value: a
                };
            });
        } else {
            const a = /* @__PURE__ */ new Map();
            for (const l of o){
                const c = l.key, u = l.value;
                if (c.status === "aborted" || u.status === "aborted") return Le;
                (c.status === "dirty" || u.status === "dirty") && t.dirty(), a.set(c.value, u.value);
            }
            return {
                status: t.value,
                value: a
            };
        }
    }
}
sd.create = (s, e, t)=>new sd({
        valueType: e,
        keyType: s,
        typeName: ke.ZodMap,
        ...Ve(t)
    });
class Qn extends Ye {
    _parse(e) {
        const { status: t, ctx: r } = this._processInputParams(e);
        if (r.parsedType !== me.set) return he(r, {
            code: ae.invalid_type,
            expected: me.set,
            received: r.parsedType
        }), Le;
        const n1 = this._def;
        n1.minSize !== null && r.data.size < n1.minSize.value && (he(r, {
            code: ae.too_small,
            minimum: n1.minSize.value,
            type: "set",
            inclusive: !0,
            exact: !1,
            message: n1.minSize.message
        }), t.dirty()), n1.maxSize !== null && r.data.size > n1.maxSize.value && (he(r, {
            code: ae.too_big,
            maximum: n1.maxSize.value,
            type: "set",
            inclusive: !0,
            exact: !1,
            message: n1.maxSize.message
        }), t.dirty());
        const i = this._def.valueType;
        function o(l) {
            const c = /* @__PURE__ */ new Set();
            for (const u of l){
                if (u.status === "aborted") return Le;
                u.status === "dirty" && t.dirty(), c.add(u.value);
            }
            return {
                status: t.value,
                value: c
            };
        }
        const a = [
            ...r.data.values()
        ].map((l, c)=>i._parse(new Ds(r, l, r.path, c)));
        return r.common.async ? Promise.all(a).then((l)=>o(l)) : o(a);
    }
    min(e, t) {
        return new Qn({
            ...this._def,
            minSize: {
                value: e,
                message: Ee.toString(t)
            }
        });
    }
    max(e, t) {
        return new Qn({
            ...this._def,
            maxSize: {
                value: e,
                message: Ee.toString(t)
            }
        });
    }
    size(e, t) {
        return this.min(e, t).max(e, t);
    }
    nonempty(e) {
        return this.min(1, e);
    }
}
Qn.create = (s, e)=>new Qn({
        valueType: s,
        minSize: null,
        maxSize: null,
        typeName: ke.ZodSet,
        ...Ve(e)
    });
class Yl extends Ye {
    get schema() {
        return this._def.getter();
    }
    _parse(e) {
        const { ctx: t } = this._processInputParams(e);
        return this._def.getter()._parse({
            data: t.data,
            path: t.path,
            parent: t
        });
    }
}
Yl.create = (s, e)=>new Yl({
        getter: s,
        typeName: ke.ZodLazy,
        ...Ve(e)
    });
class Io extends Ye {
    _parse(e) {
        if (e.data !== this._def.value) {
            const t = this._getOrReturnCtx(e);
            return he(t, {
                received: t.data,
                code: ae.invalid_literal,
                expected: this._def.value
            }), Le;
        }
        return {
            status: "valid",
            value: e.data
        };
    }
    get value() {
        return this._def.value;
    }
}
Io.create = (s, e)=>new Io({
        value: s,
        typeName: ke.ZodLiteral,
        ...Ve(e)
    });
function Nf(s, e) {
    return new zs({
        values: s,
        typeName: ke.ZodEnum,
        ...Ve(e)
    });
}
class zs extends Ye {
    _parse(e) {
        if (typeof e.data != "string") {
            const t = this._getOrReturnCtx(e), r = this._def.values;
            return he(t, {
                expected: Ze.joinValues(r),
                received: t.parsedType,
                code: ae.invalid_type
            }), Le;
        }
        if (this._cache || (this._cache = new Set(this._def.values)), !this._cache.has(e.data)) {
            const t = this._getOrReturnCtx(e), r = this._def.values;
            return he(t, {
                received: t.data,
                code: ae.invalid_enum_value,
                options: r
            }), Le;
        }
        return Lr(e.data);
    }
    get options() {
        return this._def.values;
    }
    get enum() {
        const e = {};
        for (const t of this._def.values)e[t] = t;
        return e;
    }
    get Values() {
        const e = {};
        for (const t of this._def.values)e[t] = t;
        return e;
    }
    get Enum() {
        const e = {};
        for (const t of this._def.values)e[t] = t;
        return e;
    }
    extract(e, t = this._def) {
        return zs.create(e, {
            ...this._def,
            ...t
        });
    }
    exclude(e, t = this._def) {
        return zs.create(this.options.filter((r)=>!e.includes(r)), {
            ...this._def,
            ...t
        });
    }
}
zs.create = Nf;
class Zl extends Ye {
    _parse(e) {
        const t = Ze.getValidEnumValues(this._def.values), r = this._getOrReturnCtx(e);
        if (r.parsedType !== me.string && r.parsedType !== me.number) {
            const n1 = Ze.objectValues(t);
            return he(r, {
                expected: Ze.joinValues(n1),
                received: r.parsedType,
                code: ae.invalid_type
            }), Le;
        }
        if (this._cache || (this._cache = new Set(Ze.getValidEnumValues(this._def.values))), !this._cache.has(e.data)) {
            const n1 = Ze.objectValues(t);
            return he(r, {
                received: r.data,
                code: ae.invalid_enum_value,
                options: n1
            }), Le;
        }
        return Lr(e.data);
    }
    get enum() {
        return this._def.values;
    }
}
Zl.create = (s, e)=>new Zl({
        values: s,
        typeName: ke.ZodNativeEnum,
        ...Ve(e)
    });
class _o extends Ye {
    unwrap() {
        return this._def.type;
    }
    _parse(e) {
        const { ctx: t } = this._processInputParams(e);
        if (t.parsedType !== me.promise && t.common.async === !1) return he(t, {
            code: ae.invalid_type,
            expected: me.promise,
            received: t.parsedType
        }), Le;
        const r = t.parsedType === me.promise ? t.data : Promise.resolve(t.data);
        return Lr(r.then((n1)=>this._def.type.parseAsync(n1, {
                path: t.path,
                errorMap: t.common.contextualErrorMap
            })));
    }
}
_o.create = (s, e)=>new _o({
        type: s,
        typeName: ke.ZodPromise,
        ...Ve(e)
    });
class Ys extends Ye {
    innerType() {
        return this._def.schema;
    }
    sourceType() {
        return this._def.schema._def.typeName === ke.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(e) {
        const { status: t, ctx: r } = this._processInputParams(e), n1 = this._def.effect || null, i = {
            addIssue: (o)=>{
                he(r, o), o.fatal ? t.abort() : t.dirty();
            },
            get path () {
                return r.path;
            }
        };
        if (i.addIssue = i.addIssue.bind(i), n1.type === "preprocess") {
            const o = n1.transform(r.data, i);
            if (r.common.async) return Promise.resolve(o).then(async (a)=>{
                if (t.value === "aborted") return Le;
                const l = await this._def.schema._parseAsync({
                    data: a,
                    path: r.path,
                    parent: r
                });
                return l.status === "aborted" ? Le : l.status === "dirty" || t.value === "dirty" ? Wn(l.value) : l;
            });
            {
                if (t.value === "aborted") return Le;
                const a = this._def.schema._parseSync({
                    data: o,
                    path: r.path,
                    parent: r
                });
                return a.status === "aborted" ? Le : a.status === "dirty" || t.value === "dirty" ? Wn(a.value) : a;
            }
        }
        if (n1.type === "refinement") {
            const o = (a)=>{
                const l = n1.refinement(a, i);
                if (r.common.async) return Promise.resolve(l);
                if (l instanceof Promise) throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                return a;
            };
            if (r.common.async === !1) {
                const a = this._def.schema._parseSync({
                    data: r.data,
                    path: r.path,
                    parent: r
                });
                return a.status === "aborted" ? Le : (a.status === "dirty" && t.dirty(), o(a.value), {
                    status: t.value,
                    value: a.value
                });
            } else return this._def.schema._parseAsync({
                data: r.data,
                path: r.path,
                parent: r
            }).then((a)=>a.status === "aborted" ? Le : (a.status === "dirty" && t.dirty(), o(a.value).then(()=>({
                        status: t.value,
                        value: a.value
                    }))));
        }
        if (n1.type === "transform") if (r.common.async === !1) {
            const o = this._def.schema._parseSync({
                data: r.data,
                path: r.path,
                parent: r
            });
            if (!_n(o)) return Le;
            const a = n1.transform(o.value, i);
            if (a instanceof Promise) throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
            return {
                status: t.value,
                value: a
            };
        } else return this._def.schema._parseAsync({
            data: r.data,
            path: r.path,
            parent: r
        }).then((o)=>_n(o) ? Promise.resolve(n1.transform(o.value, i)).then((a)=>({
                    status: t.value,
                    value: a
                })) : Le);
        Ze.assertNever(n1);
    }
}
Ys.create = (s, e, t)=>new Ys({
        schema: s,
        typeName: ke.ZodEffects,
        effect: e,
        ...Ve(t)
    });
Ys.createWithPreprocess = (s, e, t)=>new Ys({
        schema: e,
        effect: {
            type: "preprocess",
            transform: s
        },
        typeName: ke.ZodEffects,
        ...Ve(t)
    });
class fs extends Ye {
    _parse(e) {
        return this._getType(e) === me.undefined ? Lr(void 0) : this._def.innerType._parse(e);
    }
    unwrap() {
        return this._def.innerType;
    }
}
fs.create = (s, e)=>new fs({
        innerType: s,
        typeName: ke.ZodOptional,
        ...Ve(e)
    });
class Zs extends Ye {
    _parse(e) {
        return this._getType(e) === me.null ? Lr(null) : this._def.innerType._parse(e);
    }
    unwrap() {
        return this._def.innerType;
    }
}
Zs.create = (s, e)=>new Zs({
        innerType: s,
        typeName: ke.ZodNullable,
        ...Ve(e)
    });
class Lo extends Ye {
    _parse(e) {
        const { ctx: t } = this._processInputParams(e);
        let r = t.data;
        return t.parsedType === me.undefined && (r = this._def.defaultValue()), this._def.innerType._parse({
            data: r,
            path: t.path,
            parent: t
        });
    }
    removeDefault() {
        return this._def.innerType;
    }
}
Lo.create = (s, e)=>new Lo({
        innerType: s,
        typeName: ke.ZodDefault,
        defaultValue: typeof e.default == "function" ? e.default : ()=>e.default,
        ...Ve(e)
    });
class Ro extends Ye {
    _parse(e) {
        const { ctx: t } = this._processInputParams(e), r = {
            ...t,
            common: {
                ...t.common,
                issues: []
            }
        }, n1 = this._def.innerType._parse({
            data: r.data,
            path: r.path,
            parent: {
                ...r
            }
        });
        return bo(n1) ? n1.then((i)=>({
                status: "valid",
                value: i.status === "valid" ? i.value : this._def.catchValue({
                    get error () {
                        return new ps(r.common.issues);
                    },
                    input: r.data
                })
            })) : {
            status: "valid",
            value: n1.status === "valid" ? n1.value : this._def.catchValue({
                get error () {
                    return new ps(r.common.issues);
                },
                input: r.data
            })
        };
    }
    removeCatch() {
        return this._def.innerType;
    }
}
Ro.create = (s, e)=>new Ro({
        innerType: s,
        typeName: ke.ZodCatch,
        catchValue: typeof e.catch == "function" ? e.catch : ()=>e.catch,
        ...Ve(e)
    });
class nd extends Ye {
    _parse(e) {
        if (this._getType(e) !== me.nan) {
            const r = this._getOrReturnCtx(e);
            return he(r, {
                code: ae.invalid_type,
                expected: me.nan,
                received: r.parsedType
            }), Le;
        }
        return {
            status: "valid",
            value: e.data
        };
    }
}
nd.create = (s)=>new nd({
        typeName: ke.ZodNaN,
        ...Ve(s)
    });
class Uf extends Ye {
    _parse(e) {
        const { ctx: t } = this._processInputParams(e), r = t.data;
        return this._def.type._parse({
            data: r,
            path: t.path,
            parent: t
        });
    }
    unwrap() {
        return this._def.type;
    }
}
class $c extends Ye {
    _parse(e) {
        const { status: t, ctx: r } = this._processInputParams(e);
        if (r.common.async) return (async ()=>{
            const i = await this._def.in._parseAsync({
                data: r.data,
                path: r.path,
                parent: r
            });
            return i.status === "aborted" ? Le : i.status === "dirty" ? (t.dirty(), Wn(i.value)) : this._def.out._parseAsync({
                data: i.value,
                path: r.path,
                parent: r
            });
        })();
        {
            const n1 = this._def.in._parseSync({
                data: r.data,
                path: r.path,
                parent: r
            });
            return n1.status === "aborted" ? Le : n1.status === "dirty" ? (t.dirty(), {
                status: "dirty",
                value: n1.value
            }) : this._def.out._parseSync({
                data: n1.value,
                path: r.path,
                parent: r
            });
        }
    }
    static create(e, t) {
        return new $c({
            in: e,
            out: t,
            typeName: ke.ZodPipeline
        });
    }
}
class Co extends Ye {
    _parse(e) {
        const t = this._def.innerType._parse(e), r = (n1)=>(_n(n1) && (n1.value = Object.freeze(n1.value)), n1);
        return bo(t) ? t.then((n1)=>r(n1)) : r(t);
    }
    unwrap() {
        return this._def.innerType;
    }
}
Co.create = (s, e)=>new Co({
        innerType: s,
        typeName: ke.ZodReadonly,
        ...Ve(e)
    });
var ke;
(function(s) {
    s.ZodString = "ZodString", s.ZodNumber = "ZodNumber", s.ZodNaN = "ZodNaN", s.ZodBigInt = "ZodBigInt", s.ZodBoolean = "ZodBoolean", s.ZodDate = "ZodDate", s.ZodSymbol = "ZodSymbol", s.ZodUndefined = "ZodUndefined", s.ZodNull = "ZodNull", s.ZodAny = "ZodAny", s.ZodUnknown = "ZodUnknown", s.ZodNever = "ZodNever", s.ZodVoid = "ZodVoid", s.ZodArray = "ZodArray", s.ZodObject = "ZodObject", s.ZodUnion = "ZodUnion", s.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", s.ZodIntersection = "ZodIntersection", s.ZodTuple = "ZodTuple", s.ZodRecord = "ZodRecord", s.ZodMap = "ZodMap", s.ZodSet = "ZodSet", s.ZodFunction = "ZodFunction", s.ZodLazy = "ZodLazy", s.ZodLiteral = "ZodLiteral", s.ZodEnum = "ZodEnum", s.ZodEffects = "ZodEffects", s.ZodNativeEnum = "ZodNativeEnum", s.ZodOptional = "ZodOptional", s.ZodNullable = "ZodNullable", s.ZodDefault = "ZodDefault", s.ZodCatch = "ZodCatch", s.ZodPromise = "ZodPromise", s.ZodBranded = "ZodBranded", s.ZodPipeline = "ZodPipeline", s.ZodReadonly = "ZodReadonly";
})(ke || (ke = {}));
const xt = Ls.create, $f = Ln.create, Qm = Hl.create;
Ps.create;
const Ks = Yr.create, Jt = $t.create, ko = wo.create, Gf = Uc.create;
Ao.create;
Ws.create;
const ir = Io.create, Gc = zs.create;
_o.create;
fs.create;
Zs.create;
const e1 = /[@#$%^&*+=/\\|~]/, t1 = /(!{2,}|\?{2,}|-{2,})/, r1 = /[\u{1F300}-\u{1F9FF}]|[\u{2702}-\u{27B0}]|[\u{2600}-\u{26FF}]|[\u{2B00}-\u{2BFF}]/u, Nn = ({ max: s, noSpaces: e } = {})=>(e ? xt().max(s ?? Number.POSITIVE_INFINITY).regex(/^\S*$/, "Spaces are not allowed") : xt().max(s ?? Number.POSITIVE_INFINITY)).refine((r)=>!r1.test(r), {
        message: "Emojis and symbols are not allowed"
    }).refine((r)=>!e1.test(r), {
        message: "Special characters (@, #, $, %, ^, &, *, +, =, /, \\, |, ~, , ) are not allowed"
    }).refine((r)=>!t1.test(r), {
        message: "Repeated punctuations (!!, ??, --) are not allowed"
    }), or = xt().url().startsWith("https://", {
    message: "Must be an https url"
}).max(1024).refine((s)=>!s.includes(" "), {
    message: "URL must not contain spaces"
}).refine((s)=>{
    try {
        const e = new URL(s).hostname;
        return !(e === "localhost" || e.endsWith(".localhost") || /^(\d{1,3}\.){3}\d{1,3}$/.test(e) || e.startsWith("[") && e.endsWith("]"));
    } catch  {
        return !1;
    }
}, {
    message: "URL must not use IP addresses or localhost"
}), Vc = xt().max(32), Vf = xt().max(32), s1 = /^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}\/(?:[-a-z0-9]{3,8}:[-.%a-zA-Z0-9]{1,128}(?:\/[-.%a-zA-Z0-9]{1,78})?|native)$/, n1 = xt().regex(s1, {
    message: "Invalid CAIP-19 asset ID"
}), jc = xt().regex(/^#([0-9A-F]{3}|[0-9A-F]{6})$/i, {
    message: "Invalid hex color code. It should be in the format #RRGGBB or #RGB."
}), i1 = /^(?!.*\.\.)([a-zA-Z0-9]([a-zA-Z0-9-]*[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/, o1 = xt().max(1024).regex(i1, {
    message: "Must be a valid domain name (e.g., example.com, sub.example.com)"
}).refine((s)=>!s.includes("://"), {
    message: "Domain must not include protocol (http://, https://, etc.)"
}).refine((s)=>!s.includes("/"), {
    message: "Domain must not include path separators"
}).refine((s)=>!s.includes("@"), {
    message: "Domain must not include @ symbol"
}).refine((s)=>!s.includes(":"), {
    message: "Domain must not include port numbers"
}), a1 = ko([
    ir("1:1"),
    ir("3:2")
]), l1 = Jt({
    header: xt(),
    payload: xt(),
    signature: xt()
});
Jt({
    fid: $f(),
    type: ir("app_key"),
    key: xt().startsWith("0x")
});
const c1 = Jt({
    type: ir("launch_frame"),
    name: Vc,
    url: or.optional(),
    splashImageUrl: or.optional(),
    splashBackgroundColor: jc.optional()
}), u1 = Jt({
    type: ir("launch_miniapp"),
    name: Vc,
    url: or.optional(),
    splashImageUrl: or.optional(),
    splashBackgroundColor: jc.optional()
}), d1 = Jt({
    type: ir("view_token"),
    token: n1
}), h1 = Gf("type", [
    u1,
    d1,
    // Remove after compatibility period
    c1
]), f1 = Jt({
    title: Vf,
    action: h1
});
Jt({
    version: ko([
        xt(),
        $f()
    ]).transform((s)=>String(s)).pipe(ko([
        ir("next"),
        ir("1")
    ])),
    imageUrl: or,
    aspectRatio: a1.optional(),
    button: f1
});
const jf = Jt({
    url: xt(),
    token: xt()
});
Jt({
    notificationId: xt().max(128),
    title: xt().max(32),
    body: xt().max(128),
    targetUrl: or,
    tokens: xt().array().max(100)
});
Jt({
    result: Jt({
        successfulTokens: Ks(xt()),
        invalidTokens: Ks(xt()),
        rateLimitedTokens: Ks(xt())
    })
});
const g1 = Jt({
    event: ir("miniapp_added"),
    notificationDetails: jf.optional()
}), p1 = Jt({
    event: ir("miniapp_removed")
}), m1 = Jt({
    event: ir("notifications_enabled"),
    notificationDetails: jf.required()
}), y1 = Jt({
    event: ir("notifications_disabled")
});
Gf("event", [
    g1,
    p1,
    m1,
    y1
]);
const v1 = [
    "wallet.getEthereumProvider",
    "wallet.getSolanaProvider",
    "actions.ready",
    "actions.openUrl",
    "actions.close",
    "actions.setPrimaryButton",
    "actions.addMiniApp",
    "actions.signIn",
    "actions.viewCast",
    "actions.viewProfile",
    "actions.composeCast",
    "actions.viewToken",
    "actions.sendToken",
    "actions.swapToken",
    "actions.openMiniApp",
    "actions.requestCameraAndMicrophoneAccess",
    "experimental.signManifest",
    "haptics.impactOccurred",
    "haptics.notificationOccurred",
    "haptics.selectionChanged",
    "back"
], E1 = [
    "games",
    "social",
    "finance",
    "utility",
    "productivity",
    "health-fitness",
    "news-media",
    "music",
    "shopping",
    "education",
    "developer-tools",
    "entertainment",
    "art-creativity"
], x1 = Gc(E1), S1 = ko([
    ir("0.0.0"),
    ir("0.0.1"),
    ir("1"),
    ir("next")
]), b1 = Nn({
    max: 30
}), T1 = Nn({
    max: 170
}), w1 = Ks(or).max(3), A1 = Ks(Nn({
    max: 20,
    noSpaces: !0
})).max(5), I1 = Nn({
    max: 30
}), _1 = Nn({
    max: 30
}), L1 = Nn({
    max: 100
}), R1 = Qm(), C1 = [
    "eip155:1",
    // Ethereum mainnet
    "eip155:8453",
    // Base mainnet
    "eip155:42161",
    // Arbitrum One
    "eip155:421614",
    // Arbitrum Sepolia
    "eip155:84532",
    // Base Sepolia
    "eip155:666666666",
    // Degen
    "eip155:100",
    // Gnosis
    "eip155:10",
    // Optimism
    "eip155:11155420",
    // Optimism Sepolia
    "eip155:137",
    // Polygon
    "eip155:11155111",
    // Ethereum Sepolia
    "eip155:7777777",
    // Zora
    "eip155:130",
    // Unichain
    "eip155:10143",
    // Monad testnet
    "eip155:42220",
    // Celo
    "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp"
];
function Kf(s) {
    const e = new Set(s);
    return Array.from(e);
}
const k1 = Ks(Gc(C1)).transform(Kf), D1 = Ks(Gc(v1)).transform(Kf), id = Jt({
    // 0.0.0 and 0.0.1 are not technically part of the spec but kept for
    // backwards compatibility. next should always resolve to the most recent
    // schema version.
    version: S1,
    name: Vc,
    iconUrl: or,
    homeUrl: or,
    /** deprecated, set ogImageUrl instead */ imageUrl: or.optional(),
    /** deprecated, will rely on fc:frame/fc:miniapp meta tag */ buttonTitle: Vf.optional(),
    splashImageUrl: or.optional(),
    splashBackgroundColor: jc.optional(),
    webhookUrl: or.optional(),
    /** see: https://github.com/farcasterxyz/miniapps/discussions/191 */ subtitle: b1.optional(),
    description: T1.optional(),
    screenshotUrls: w1.optional(),
    primaryCategory: x1.optional(),
    tags: A1.optional(),
    heroImageUrl: or.optional(),
    tagline: I1.optional(),
    ogTitle: _1.optional(),
    ogDescription: L1.optional(),
    ogImageUrl: or.optional(),
    /** see: https://github.com/farcasterxyz/miniapps/discussions/204 */ noindex: R1.optional(),
    /** see https://github.com/farcasterxyz/miniapps/discussions/256 */ requiredChains: k1.optional(),
    requiredCapabilities: D1.optional(),
    /** see https://github.com/farcasterxyz/miniapps/discussions/158 */ /** Documentation will be added once this feature is finalized. */ castShareUrl: or.optional(),
    /** Canonical domain for the miniapp application */ canonicalDomain: o1.optional()
}).refine((s)=>{
    if (s.castShareUrl === void 0) return !0;
    try {
        const e = new URL(s.homeUrl).hostname, t = new URL(s.castShareUrl).hostname;
        return e === t;
    } catch  {
        return !1;
    }
}, {
    message: "castShareUrl must have the same domain as homeUrl",
    path: [
        "castShareUrl"
    ]
});
Jt({
    accountAssociation: l1,
    miniapp: id.optional(),
    // Support both 'frame' and 'miniapp' during transition period
    frame: id.optional()
}).refine((s)=>s.frame && s.miniapp ? JSON.stringify(s.frame) === JSON.stringify(s.miniapp) : !0, {
    message: 'If both "frame" and "miniapp" are provided, they must be identical',
    path: [
        "frame",
        "miniapp"
    ]
}).transform((s)=>({
        ...s,
        frame: s.frame ?? s.miniapp
    }));
var Ga = {}, Hn = {}, od;
function P1() {
    if (od) return Hn;
    od = 1, Hn.byteLength = a, Hn.toByteArray = c, Hn.fromByteArray = h;
    for(var s = [], e = [], t = typeof Uint8Array < "u" ? Uint8Array : Array, r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", n1 = 0, i = r.length; n1 < i; ++n1)s[n1] = r[n1], e[r.charCodeAt(n1)] = n1;
    e[45] = 62, e[95] = 63;
    function o(f) {
        var p = f.length;
        if (p % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
        var y = f.indexOf("=");
        y === -1 && (y = p);
        var E = y === p ? 0 : 4 - y % 4;
        return [
            y,
            E
        ];
    }
    function a(f) {
        var p = o(f), y = p[0], E = p[1];
        return (y + E) * 3 / 4 - E;
    }
    function l(f, p, y) {
        return (p + y) * 3 / 4 - y;
    }
    function c(f) {
        var p, y = o(f), E = y[0], b = y[1], L = new t(l(f, E, b)), A = 0, F = b > 0 ? E - 4 : E, M;
        for(M = 0; M < F; M += 4)p = e[f.charCodeAt(M)] << 18 | e[f.charCodeAt(M + 1)] << 12 | e[f.charCodeAt(M + 2)] << 6 | e[f.charCodeAt(M + 3)], L[A++] = p >> 16 & 255, L[A++] = p >> 8 & 255, L[A++] = p & 255;
        return b === 2 && (p = e[f.charCodeAt(M)] << 2 | e[f.charCodeAt(M + 1)] >> 4, L[A++] = p & 255), b === 1 && (p = e[f.charCodeAt(M)] << 10 | e[f.charCodeAt(M + 1)] << 4 | e[f.charCodeAt(M + 2)] >> 2, L[A++] = p >> 8 & 255, L[A++] = p & 255), L;
    }
    function u(f) {
        return s[f >> 18 & 63] + s[f >> 12 & 63] + s[f >> 6 & 63] + s[f & 63];
    }
    function d1(f, p, y) {
        for(var E, b = [], L = p; L < y; L += 3)E = (f[L] << 16 & 16711680) + (f[L + 1] << 8 & 65280) + (f[L + 2] & 255), b.push(u(E));
        return b.join("");
    }
    function h(f) {
        for(var p, y = f.length, E = y % 3, b = [], L = 16383, A = 0, F = y - E; A < F; A += L)b.push(d1(f, A, A + L > F ? F : A + L));
        return E === 1 ? (p = f[y - 1], b.push(s[p >> 2] + s[p << 4 & 63] + "==")) : E === 2 && (p = (f[y - 2] << 8) + f[y - 1], b.push(s[p >> 10] + s[p >> 4 & 63] + s[p << 2 & 63] + "=")), b.join("");
    }
    return Hn;
}
var Mi = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ var ad;
function M1() {
    return ad || (ad = 1, Mi.read = function(s, e, t, r, n1) {
        var i, o, a = n1 * 8 - r - 1, l = (1 << a) - 1, c = l >> 1, u = -7, d1 = t ? n1 - 1 : 0, h = t ? -1 : 1, f = s[e + d1];
        for(d1 += h, i = f & (1 << -u) - 1, f >>= -u, u += a; u > 0; i = i * 256 + s[e + d1], d1 += h, u -= 8);
        for(o = i & (1 << -u) - 1, i >>= -u, u += r; u > 0; o = o * 256 + s[e + d1], d1 += h, u -= 8);
        if (i === 0) i = 1 - c;
        else {
            if (i === l) return o ? NaN : (f ? -1 : 1) * (1 / 0);
            o = o + Math.pow(2, r), i = i - c;
        }
        return (f ? -1 : 1) * o * Math.pow(2, i - r);
    }, Mi.write = function(s, e, t, r, n1, i) {
        var o, a, l, c = i * 8 - n1 - 1, u = (1 << c) - 1, d1 = u >> 1, h = n1 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f = r ? 0 : i - 1, p = r ? 1 : -1, y = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
        for(e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (a = isNaN(e) ? 1 : 0, o = u) : (o = Math.floor(Math.log(e) / Math.LN2), e * (l = Math.pow(2, -o)) < 1 && (o--, l *= 2), o + d1 >= 1 ? e += h / l : e += h * Math.pow(2, 1 - d1), e * l >= 2 && (o++, l /= 2), o + d1 >= u ? (a = 0, o = u) : o + d1 >= 1 ? (a = (e * l - 1) * Math.pow(2, n1), o = o + d1) : (a = e * Math.pow(2, d1 - 1) * Math.pow(2, n1), o = 0)); n1 >= 8; s[t + f] = a & 255, f += p, a /= 256, n1 -= 8);
        for(o = o << n1 | a, c += n1; c > 0; s[t + f] = o & 255, f += p, o /= 256, c -= 8);
        s[t + f - p] |= y * 128;
    }), Mi;
}
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ var ld;
function Kc() {
    return ld || (ld = 1, function(s) {
        const e = P1(), t = M1(), r = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
        s.Buffer = a, s.SlowBuffer = L, s.INSPECT_MAX_BYTES = 50;
        const n1 = 2147483647;
        s.kMaxLength = n1, a.TYPED_ARRAY_SUPPORT = i(), !a.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
        function i() {
            try {
                const B = new Uint8Array(1), S = {
                    foo: function() {
                        return 42;
                    }
                };
                return Object.setPrototypeOf(S, Uint8Array.prototype), Object.setPrototypeOf(B, S), B.foo() === 42;
            } catch  {
                return !1;
            }
        }
        Object.defineProperty(a.prototype, "parent", {
            enumerable: !0,
            get: function() {
                if (a.isBuffer(this)) return this.buffer;
            }
        }), Object.defineProperty(a.prototype, "offset", {
            enumerable: !0,
            get: function() {
                if (a.isBuffer(this)) return this.byteOffset;
            }
        });
        function o(B) {
            if (B > n1) throw new RangeError('The value "' + B + '" is invalid for option "size"');
            const S = new Uint8Array(B);
            return Object.setPrototypeOf(S, a.prototype), S;
        }
        function a(B, S, T) {
            if (typeof B == "number") {
                if (typeof S == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
                return d1(B);
            }
            return l(B, S, T);
        }
        a.poolSize = 8192;
        function l(B, S, T) {
            if (typeof B == "string") return h(B, S);
            if (ArrayBuffer.isView(B)) return p(B);
            if (B == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof B);
            if (dt(B, ArrayBuffer) || B && dt(B.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (dt(B, SharedArrayBuffer) || B && dt(B.buffer, SharedArrayBuffer))) return y(B, S, T);
            if (typeof B == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
            const G = B.valueOf && B.valueOf();
            if (G != null && G !== B) return a.from(G, S, T);
            const Z = E(B);
            if (Z) return Z;
            if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof B[Symbol.toPrimitive] == "function") return a.from(B[Symbol.toPrimitive]("string"), S, T);
            throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof B);
        }
        a.from = function(B, S, T) {
            return l(B, S, T);
        }, Object.setPrototypeOf(a.prototype, Uint8Array.prototype), Object.setPrototypeOf(a, Uint8Array);
        function c(B) {
            if (typeof B != "number") throw new TypeError('"size" argument must be of type number');
            if (B < 0) throw new RangeError('The value "' + B + '" is invalid for option "size"');
        }
        function u(B, S, T) {
            return c(B), B <= 0 ? o(B) : S !== void 0 ? typeof T == "string" ? o(B).fill(S, T) : o(B).fill(S) : o(B);
        }
        a.alloc = function(B, S, T) {
            return u(B, S, T);
        };
        function d1(B) {
            return c(B), o(B < 0 ? 0 : b(B) | 0);
        }
        a.allocUnsafe = function(B) {
            return d1(B);
        }, a.allocUnsafeSlow = function(B) {
            return d1(B);
        };
        function h(B, S) {
            if ((typeof S != "string" || S === "") && (S = "utf8"), !a.isEncoding(S)) throw new TypeError("Unknown encoding: " + S);
            const T = A(B, S) | 0;
            let G = o(T);
            const Z = G.write(B, S);
            return Z !== T && (G = G.slice(0, Z)), G;
        }
        function f(B) {
            const S = B.length < 0 ? 0 : b(B.length) | 0, T = o(S);
            for(let G = 0; G < S; G += 1)T[G] = B[G] & 255;
            return T;
        }
        function p(B) {
            if (dt(B, Uint8Array)) {
                const S = new Uint8Array(B);
                return y(S.buffer, S.byteOffset, S.byteLength);
            }
            return f(B);
        }
        function y(B, S, T) {
            if (S < 0 || B.byteLength < S) throw new RangeError('"offset" is outside of buffer bounds');
            if (B.byteLength < S + (T || 0)) throw new RangeError('"length" is outside of buffer bounds');
            let G;
            return S === void 0 && T === void 0 ? G = new Uint8Array(B) : T === void 0 ? G = new Uint8Array(B, S) : G = new Uint8Array(B, S, T), Object.setPrototypeOf(G, a.prototype), G;
        }
        function E(B) {
            if (a.isBuffer(B)) {
                const S = b(B.length) | 0, T = o(S);
                return T.length === 0 || B.copy(T, 0, 0, S), T;
            }
            if (B.length !== void 0) return typeof B.length != "number" || Je(B.length) ? o(0) : f(B);
            if (B.type === "Buffer" && Array.isArray(B.data)) return f(B.data);
        }
        function b(B) {
            if (B >= n1) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + n1.toString(16) + " bytes");
            return B | 0;
        }
        function L(B) {
            return +B != B && (B = 0), a.alloc(+B);
        }
        a.isBuffer = function(S) {
            return S != null && S._isBuffer === !0 && S !== a.prototype;
        }, a.compare = function(S, T) {
            if (dt(S, Uint8Array) && (S = a.from(S, S.offset, S.byteLength)), dt(T, Uint8Array) && (T = a.from(T, T.offset, T.byteLength)), !a.isBuffer(S) || !a.isBuffer(T)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
            if (S === T) return 0;
            let G = S.length, Z = T.length;
            for(let Q = 0, se = Math.min(G, Z); Q < se; ++Q)if (S[Q] !== T[Q]) {
                G = S[Q], Z = T[Q];
                break;
            }
            return G < Z ? -1 : Z < G ? 1 : 0;
        }, a.isEncoding = function(S) {
            switch(String(S).toLowerCase()){
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "latin1":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return !0;
                default:
                    return !1;
            }
        }, a.concat = function(S, T) {
            if (!Array.isArray(S)) throw new TypeError('"list" argument must be an Array of Buffers');
            if (S.length === 0) return a.alloc(0);
            let G;
            if (T === void 0) for(T = 0, G = 0; G < S.length; ++G)T += S[G].length;
            const Z = a.allocUnsafe(T);
            let Q = 0;
            for(G = 0; G < S.length; ++G){
                let se = S[G];
                if (dt(se, Uint8Array)) Q + se.length > Z.length ? (a.isBuffer(se) || (se = a.from(se)), se.copy(Z, Q)) : Uint8Array.prototype.set.call(Z, se, Q);
                else if (a.isBuffer(se)) se.copy(Z, Q);
                else throw new TypeError('"list" argument must be an Array of Buffers');
                Q += se.length;
            }
            return Z;
        };
        function A(B, S) {
            if (a.isBuffer(B)) return B.length;
            if (ArrayBuffer.isView(B) || dt(B, ArrayBuffer)) return B.byteLength;
            if (typeof B != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof B);
            const T = B.length, G = arguments.length > 2 && arguments[2] === !0;
            if (!G && T === 0) return 0;
            let Z = !1;
            for(;;)switch(S){
                case "ascii":
                case "latin1":
                case "binary":
                    return T;
                case "utf8":
                case "utf-8":
                    return be(B).length;
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return T * 2;
                case "hex":
                    return T >>> 1;
                case "base64":
                    return we(B).length;
                default:
                    if (Z) return G ? -1 : be(B).length;
                    S = ("" + S).toLowerCase(), Z = !0;
            }
        }
        a.byteLength = A;
        function F(B, S, T) {
            let G = !1;
            if ((S === void 0 || S < 0) && (S = 0), S > this.length || ((T === void 0 || T > this.length) && (T = this.length), T <= 0) || (T >>>= 0, S >>>= 0, T <= S)) return "";
            for(B || (B = "utf8");;)switch(B){
                case "hex":
                    return U(this, S, T);
                case "utf8":
                case "utf-8":
                    return g(this, S, T);
                case "ascii":
                    return D(this, S, T);
                case "latin1":
                case "binary":
                    return O(this, S, T);
                case "base64":
                    return _(this, S, T);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return V(this, S, T);
                default:
                    if (G) throw new TypeError("Unknown encoding: " + B);
                    B = (B + "").toLowerCase(), G = !0;
            }
        }
        a.prototype._isBuffer = !0;
        function M(B, S, T) {
            const G = B[S];
            B[S] = B[T], B[T] = G;
        }
        a.prototype.swap16 = function() {
            const S = this.length;
            if (S % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
            for(let T = 0; T < S; T += 2)M(this, T, T + 1);
            return this;
        }, a.prototype.swap32 = function() {
            const S = this.length;
            if (S % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
            for(let T = 0; T < S; T += 4)M(this, T, T + 3), M(this, T + 1, T + 2);
            return this;
        }, a.prototype.swap64 = function() {
            const S = this.length;
            if (S % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
            for(let T = 0; T < S; T += 8)M(this, T, T + 7), M(this, T + 1, T + 6), M(this, T + 2, T + 5), M(this, T + 3, T + 4);
            return this;
        }, a.prototype.toString = function() {
            const S = this.length;
            return S === 0 ? "" : arguments.length === 0 ? g(this, 0, S) : F.apply(this, arguments);
        }, a.prototype.toLocaleString = a.prototype.toString, a.prototype.equals = function(S) {
            if (!a.isBuffer(S)) throw new TypeError("Argument must be a Buffer");
            return this === S ? !0 : a.compare(this, S) === 0;
        }, a.prototype.inspect = function() {
            let S = "";
            const T = s.INSPECT_MAX_BYTES;
            return S = this.toString("hex", 0, T).replace(/(.{2})/g, "$1 ").trim(), this.length > T && (S += " ... "), "<Buffer " + S + ">";
        }, r && (a.prototype[r] = a.prototype.inspect), a.prototype.compare = function(S, T, G, Z, Q) {
            if (dt(S, Uint8Array) && (S = a.from(S, S.offset, S.byteLength)), !a.isBuffer(S)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof S);
            if (T === void 0 && (T = 0), G === void 0 && (G = S ? S.length : 0), Z === void 0 && (Z = 0), Q === void 0 && (Q = this.length), T < 0 || G > S.length || Z < 0 || Q > this.length) throw new RangeError("out of range index");
            if (Z >= Q && T >= G) return 0;
            if (Z >= Q) return -1;
            if (T >= G) return 1;
            if (T >>>= 0, G >>>= 0, Z >>>= 0, Q >>>= 0, this === S) return 0;
            let se = Q - Z, Ue = G - T;
            const Pe = Math.min(se, Ue), Re = this.slice(Z, Q), ct = S.slice(T, G);
            for(let Ae = 0; Ae < Pe; ++Ae)if (Re[Ae] !== ct[Ae]) {
                se = Re[Ae], Ue = ct[Ae];
                break;
            }
            return se < Ue ? -1 : Ue < se ? 1 : 0;
        };
        function H(B, S, T, G, Z) {
            if (B.length === 0) return -1;
            if (typeof T == "string" ? (G = T, T = 0) : T > 2147483647 ? T = 2147483647 : T < -2147483648 && (T = -2147483648), T = +T, Je(T) && (T = Z ? 0 : B.length - 1), T < 0 && (T = B.length + T), T >= B.length) {
                if (Z) return -1;
                T = B.length - 1;
            } else if (T < 0) if (Z) T = 0;
            else return -1;
            if (typeof S == "string" && (S = a.from(S, G)), a.isBuffer(S)) return S.length === 0 ? -1 : K(B, S, T, G, Z);
            if (typeof S == "number") return S = S & 255, typeof Uint8Array.prototype.indexOf == "function" ? Z ? Uint8Array.prototype.indexOf.call(B, S, T) : Uint8Array.prototype.lastIndexOf.call(B, S, T) : K(B, [
                S
            ], T, G, Z);
            throw new TypeError("val must be string, number or Buffer");
        }
        function K(B, S, T, G, Z) {
            let Q = 1, se = B.length, Ue = S.length;
            if (G !== void 0 && (G = String(G).toLowerCase(), G === "ucs2" || G === "ucs-2" || G === "utf16le" || G === "utf-16le")) {
                if (B.length < 2 || S.length < 2) return -1;
                Q = 2, se /= 2, Ue /= 2, T /= 2;
            }
            function Pe(ct, Ae) {
                return Q === 1 ? ct[Ae] : ct.readUInt16BE(Ae * Q);
            }
            let Re;
            if (Z) {
                let ct = -1;
                for(Re = T; Re < se; Re++)if (Pe(B, Re) === Pe(S, ct === -1 ? 0 : Re - ct)) {
                    if (ct === -1 && (ct = Re), Re - ct + 1 === Ue) return ct * Q;
                } else ct !== -1 && (Re -= Re - ct), ct = -1;
            } else for(T + Ue > se && (T = se - Ue), Re = T; Re >= 0; Re--){
                let ct = !0;
                for(let Ae = 0; Ae < Ue; Ae++)if (Pe(B, Re + Ae) !== Pe(S, Ae)) {
                    ct = !1;
                    break;
                }
                if (ct) return Re;
            }
            return -1;
        }
        a.prototype.includes = function(S, T, G) {
            return this.indexOf(S, T, G) !== -1;
        }, a.prototype.indexOf = function(S, T, G) {
            return H(this, S, T, G, !0);
        }, a.prototype.lastIndexOf = function(S, T, G) {
            return H(this, S, T, G, !1);
        };
        function j(B, S, T, G) {
            T = Number(T) || 0;
            const Z = B.length - T;
            G ? (G = Number(G), G > Z && (G = Z)) : G = Z;
            const Q = S.length;
            G > Q / 2 && (G = Q / 2);
            let se;
            for(se = 0; se < G; ++se){
                const Ue = parseInt(S.substr(se * 2, 2), 16);
                if (Je(Ue)) return se;
                B[T + se] = Ue;
            }
            return se;
        }
        function C(B, S, T, G) {
            return Ne(be(S, B.length - T), B, T, G);
        }
        function k(B, S, T, G) {
            return Ne(Fe(S), B, T, G);
        }
        function $(B, S, T, G) {
            return Ne(we(S), B, T, G);
        }
        function W(B, S, T, G) {
            return Ne(Xe(S, B.length - T), B, T, G);
        }
        a.prototype.write = function(S, T, G, Z) {
            if (T === void 0) Z = "utf8", G = this.length, T = 0;
            else if (G === void 0 && typeof T == "string") Z = T, G = this.length, T = 0;
            else if (isFinite(T)) T = T >>> 0, isFinite(G) ? (G = G >>> 0, Z === void 0 && (Z = "utf8")) : (Z = G, G = void 0);
            else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
            const Q = this.length - T;
            if ((G === void 0 || G > Q) && (G = Q), S.length > 0 && (G < 0 || T < 0) || T > this.length) throw new RangeError("Attempt to write outside buffer bounds");
            Z || (Z = "utf8");
            let se = !1;
            for(;;)switch(Z){
                case "hex":
                    return j(this, S, T, G);
                case "utf8":
                case "utf-8":
                    return C(this, S, T, G);
                case "ascii":
                case "latin1":
                case "binary":
                    return k(this, S, T, G);
                case "base64":
                    return $(this, S, T, G);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return W(this, S, T, G);
                default:
                    if (se) throw new TypeError("Unknown encoding: " + Z);
                    Z = ("" + Z).toLowerCase(), se = !0;
            }
        }, a.prototype.toJSON = function() {
            return {
                type: "Buffer",
                data: Array.prototype.slice.call(this._arr || this, 0)
            };
        };
        function _(B, S, T) {
            return S === 0 && T === B.length ? e.fromByteArray(B) : e.fromByteArray(B.slice(S, T));
        }
        function g(B, S, T) {
            T = Math.min(B.length, T);
            const G = [];
            let Z = S;
            for(; Z < T;){
                const Q = B[Z];
                let se = null, Ue = Q > 239 ? 4 : Q > 223 ? 3 : Q > 191 ? 2 : 1;
                if (Z + Ue <= T) {
                    let Pe, Re, ct, Ae;
                    switch(Ue){
                        case 1:
                            Q < 128 && (se = Q);
                            break;
                        case 2:
                            Pe = B[Z + 1], (Pe & 192) === 128 && (Ae = (Q & 31) << 6 | Pe & 63, Ae > 127 && (se = Ae));
                            break;
                        case 3:
                            Pe = B[Z + 1], Re = B[Z + 2], (Pe & 192) === 128 && (Re & 192) === 128 && (Ae = (Q & 15) << 12 | (Pe & 63) << 6 | Re & 63, Ae > 2047 && (Ae < 55296 || Ae > 57343) && (se = Ae));
                            break;
                        case 4:
                            Pe = B[Z + 1], Re = B[Z + 2], ct = B[Z + 3], (Pe & 192) === 128 && (Re & 192) === 128 && (ct & 192) === 128 && (Ae = (Q & 15) << 18 | (Pe & 63) << 12 | (Re & 63) << 6 | ct & 63, Ae > 65535 && Ae < 1114112 && (se = Ae));
                    }
                }
                se === null ? (se = 65533, Ue = 1) : se > 65535 && (se -= 65536, G.push(se >>> 10 & 1023 | 55296), se = 56320 | se & 1023), G.push(se), Z += Ue;
            }
            return w(G);
        }
        const x = 4096;
        function w(B) {
            const S = B.length;
            if (S <= x) return String.fromCharCode.apply(String, B);
            let T = "", G = 0;
            for(; G < S;)T += String.fromCharCode.apply(String, B.slice(G, G += x));
            return T;
        }
        function D(B, S, T) {
            let G = "";
            T = Math.min(B.length, T);
            for(let Z = S; Z < T; ++Z)G += String.fromCharCode(B[Z] & 127);
            return G;
        }
        function O(B, S, T) {
            let G = "";
            T = Math.min(B.length, T);
            for(let Z = S; Z < T; ++Z)G += String.fromCharCode(B[Z]);
            return G;
        }
        function U(B, S, T) {
            const G = B.length;
            (!S || S < 0) && (S = 0), (!T || T < 0 || T > G) && (T = G);
            let Z = "";
            for(let Q = S; Q < T; ++Q)Z += Qe[B[Q]];
            return Z;
        }
        function V(B, S, T) {
            const G = B.slice(S, T);
            let Z = "";
            for(let Q = 0; Q < G.length - 1; Q += 2)Z += String.fromCharCode(G[Q] + G[Q + 1] * 256);
            return Z;
        }
        a.prototype.slice = function(S, T) {
            const G = this.length;
            S = ~~S, T = T === void 0 ? G : ~~T, S < 0 ? (S += G, S < 0 && (S = 0)) : S > G && (S = G), T < 0 ? (T += G, T < 0 && (T = 0)) : T > G && (T = G), T < S && (T = S);
            const Z = this.subarray(S, T);
            return Object.setPrototypeOf(Z, a.prototype), Z;
        };
        function R(B, S, T) {
            if (B % 1 !== 0 || B < 0) throw new RangeError("offset is not uint");
            if (B + S > T) throw new RangeError("Trying to access beyond buffer length");
        }
        a.prototype.readUintLE = a.prototype.readUIntLE = function(S, T, G) {
            S = S >>> 0, T = T >>> 0, G || R(S, T, this.length);
            let Z = this[S], Q = 1, se = 0;
            for(; ++se < T && (Q *= 256);)Z += this[S + se] * Q;
            return Z;
        }, a.prototype.readUintBE = a.prototype.readUIntBE = function(S, T, G) {
            S = S >>> 0, T = T >>> 0, G || R(S, T, this.length);
            let Z = this[S + --T], Q = 1;
            for(; T > 0 && (Q *= 256);)Z += this[S + --T] * Q;
            return Z;
        }, a.prototype.readUint8 = a.prototype.readUInt8 = function(S, T) {
            return S = S >>> 0, T || R(S, 1, this.length), this[S];
        }, a.prototype.readUint16LE = a.prototype.readUInt16LE = function(S, T) {
            return S = S >>> 0, T || R(S, 2, this.length), this[S] | this[S + 1] << 8;
        }, a.prototype.readUint16BE = a.prototype.readUInt16BE = function(S, T) {
            return S = S >>> 0, T || R(S, 2, this.length), this[S] << 8 | this[S + 1];
        }, a.prototype.readUint32LE = a.prototype.readUInt32LE = function(S, T) {
            return S = S >>> 0, T || R(S, 4, this.length), (this[S] | this[S + 1] << 8 | this[S + 2] << 16) + this[S + 3] * 16777216;
        }, a.prototype.readUint32BE = a.prototype.readUInt32BE = function(S, T) {
            return S = S >>> 0, T || R(S, 4, this.length), this[S] * 16777216 + (this[S + 1] << 16 | this[S + 2] << 8 | this[S + 3]);
        }, a.prototype.readBigUInt64LE = it(function(S) {
            S = S >>> 0, _e(S, "offset");
            const T = this[S], G = this[S + 7];
            (T === void 0 || G === void 0) && xe(S, this.length - 8);
            const Z = T + this[++S] * 2 ** 8 + this[++S] * 2 ** 16 + this[++S] * 2 ** 24, Q = this[++S] + this[++S] * 2 ** 8 + this[++S] * 2 ** 16 + G * 2 ** 24;
            return BigInt(Z) + (BigInt(Q) << BigInt(32));
        }), a.prototype.readBigUInt64BE = it(function(S) {
            S = S >>> 0, _e(S, "offset");
            const T = this[S], G = this[S + 7];
            (T === void 0 || G === void 0) && xe(S, this.length - 8);
            const Z = T * 2 ** 24 + this[++S] * 2 ** 16 + this[++S] * 2 ** 8 + this[++S], Q = this[++S] * 2 ** 24 + this[++S] * 2 ** 16 + this[++S] * 2 ** 8 + G;
            return (BigInt(Z) << BigInt(32)) + BigInt(Q);
        }), a.prototype.readIntLE = function(S, T, G) {
            S = S >>> 0, T = T >>> 0, G || R(S, T, this.length);
            let Z = this[S], Q = 1, se = 0;
            for(; ++se < T && (Q *= 256);)Z += this[S + se] * Q;
            return Q *= 128, Z >= Q && (Z -= Math.pow(2, 8 * T)), Z;
        }, a.prototype.readIntBE = function(S, T, G) {
            S = S >>> 0, T = T >>> 0, G || R(S, T, this.length);
            let Z = T, Q = 1, se = this[S + --Z];
            for(; Z > 0 && (Q *= 256);)se += this[S + --Z] * Q;
            return Q *= 128, se >= Q && (se -= Math.pow(2, 8 * T)), se;
        }, a.prototype.readInt8 = function(S, T) {
            return S = S >>> 0, T || R(S, 1, this.length), this[S] & 128 ? (255 - this[S] + 1) * -1 : this[S];
        }, a.prototype.readInt16LE = function(S, T) {
            S = S >>> 0, T || R(S, 2, this.length);
            const G = this[S] | this[S + 1] << 8;
            return G & 32768 ? G | 4294901760 : G;
        }, a.prototype.readInt16BE = function(S, T) {
            S = S >>> 0, T || R(S, 2, this.length);
            const G = this[S + 1] | this[S] << 8;
            return G & 32768 ? G | 4294901760 : G;
        }, a.prototype.readInt32LE = function(S, T) {
            return S = S >>> 0, T || R(S, 4, this.length), this[S] | this[S + 1] << 8 | this[S + 2] << 16 | this[S + 3] << 24;
        }, a.prototype.readInt32BE = function(S, T) {
            return S = S >>> 0, T || R(S, 4, this.length), this[S] << 24 | this[S + 1] << 16 | this[S + 2] << 8 | this[S + 3];
        }, a.prototype.readBigInt64LE = it(function(S) {
            S = S >>> 0, _e(S, "offset");
            const T = this[S], G = this[S + 7];
            (T === void 0 || G === void 0) && xe(S, this.length - 8);
            const Z = this[S + 4] + this[S + 5] * 2 ** 8 + this[S + 6] * 2 ** 16 + (G << 24);
            return (BigInt(Z) << BigInt(32)) + BigInt(T + this[++S] * 2 ** 8 + this[++S] * 2 ** 16 + this[++S] * 2 ** 24);
        }), a.prototype.readBigInt64BE = it(function(S) {
            S = S >>> 0, _e(S, "offset");
            const T = this[S], G = this[S + 7];
            (T === void 0 || G === void 0) && xe(S, this.length - 8);
            const Z = (T << 24) + // Overflow
            this[++S] * 2 ** 16 + this[++S] * 2 ** 8 + this[++S];
            return (BigInt(Z) << BigInt(32)) + BigInt(this[++S] * 2 ** 24 + this[++S] * 2 ** 16 + this[++S] * 2 ** 8 + G);
        }), a.prototype.readFloatLE = function(S, T) {
            return S = S >>> 0, T || R(S, 4, this.length), t.read(this, S, !0, 23, 4);
        }, a.prototype.readFloatBE = function(S, T) {
            return S = S >>> 0, T || R(S, 4, this.length), t.read(this, S, !1, 23, 4);
        }, a.prototype.readDoubleLE = function(S, T) {
            return S = S >>> 0, T || R(S, 8, this.length), t.read(this, S, !0, 52, 8);
        }, a.prototype.readDoubleBE = function(S, T) {
            return S = S >>> 0, T || R(S, 8, this.length), t.read(this, S, !1, 52, 8);
        };
        function m(B, S, T, G, Z, Q) {
            if (!a.isBuffer(B)) throw new TypeError('"buffer" argument must be a Buffer instance');
            if (S > Z || S < Q) throw new RangeError('"value" argument is out of bounds');
            if (T + G > B.length) throw new RangeError("Index out of range");
        }
        a.prototype.writeUintLE = a.prototype.writeUIntLE = function(S, T, G, Z) {
            if (S = +S, T = T >>> 0, G = G >>> 0, !Z) {
                const Ue = Math.pow(2, 8 * G) - 1;
                m(this, S, T, G, Ue, 0);
            }
            let Q = 1, se = 0;
            for(this[T] = S & 255; ++se < G && (Q *= 256);)this[T + se] = S / Q & 255;
            return T + G;
        }, a.prototype.writeUintBE = a.prototype.writeUIntBE = function(S, T, G, Z) {
            if (S = +S, T = T >>> 0, G = G >>> 0, !Z) {
                const Ue = Math.pow(2, 8 * G) - 1;
                m(this, S, T, G, Ue, 0);
            }
            let Q = G - 1, se = 1;
            for(this[T + Q] = S & 255; --Q >= 0 && (se *= 256);)this[T + Q] = S / se & 255;
            return T + G;
        }, a.prototype.writeUint8 = a.prototype.writeUInt8 = function(S, T, G) {
            return S = +S, T = T >>> 0, G || m(this, S, T, 1, 255, 0), this[T] = S & 255, T + 1;
        }, a.prototype.writeUint16LE = a.prototype.writeUInt16LE = function(S, T, G) {
            return S = +S, T = T >>> 0, G || m(this, S, T, 2, 65535, 0), this[T] = S & 255, this[T + 1] = S >>> 8, T + 2;
        }, a.prototype.writeUint16BE = a.prototype.writeUInt16BE = function(S, T, G) {
            return S = +S, T = T >>> 0, G || m(this, S, T, 2, 65535, 0), this[T] = S >>> 8, this[T + 1] = S & 255, T + 2;
        }, a.prototype.writeUint32LE = a.prototype.writeUInt32LE = function(S, T, G) {
            return S = +S, T = T >>> 0, G || m(this, S, T, 4, 4294967295, 0), this[T + 3] = S >>> 24, this[T + 2] = S >>> 16, this[T + 1] = S >>> 8, this[T] = S & 255, T + 4;
        }, a.prototype.writeUint32BE = a.prototype.writeUInt32BE = function(S, T, G) {
            return S = +S, T = T >>> 0, G || m(this, S, T, 4, 4294967295, 0), this[T] = S >>> 24, this[T + 1] = S >>> 16, this[T + 2] = S >>> 8, this[T + 3] = S & 255, T + 4;
        };
        function v(B, S, T, G, Z) {
            ze(S, G, Z, B, T, 7);
            let Q = Number(S & BigInt(4294967295));
            B[T++] = Q, Q = Q >> 8, B[T++] = Q, Q = Q >> 8, B[T++] = Q, Q = Q >> 8, B[T++] = Q;
            let se = Number(S >> BigInt(32) & BigInt(4294967295));
            return B[T++] = se, se = se >> 8, B[T++] = se, se = se >> 8, B[T++] = se, se = se >> 8, B[T++] = se, T;
        }
        function P(B, S, T, G, Z) {
            ze(S, G, Z, B, T, 7);
            let Q = Number(S & BigInt(4294967295));
            B[T + 7] = Q, Q = Q >> 8, B[T + 6] = Q, Q = Q >> 8, B[T + 5] = Q, Q = Q >> 8, B[T + 4] = Q;
            let se = Number(S >> BigInt(32) & BigInt(4294967295));
            return B[T + 3] = se, se = se >> 8, B[T + 2] = se, se = se >> 8, B[T + 1] = se, se = se >> 8, B[T] = se, T + 8;
        }
        a.prototype.writeBigUInt64LE = it(function(S, T = 0) {
            return v(this, S, T, BigInt(0), BigInt("0xffffffffffffffff"));
        }), a.prototype.writeBigUInt64BE = it(function(S, T = 0) {
            return P(this, S, T, BigInt(0), BigInt("0xffffffffffffffff"));
        }), a.prototype.writeIntLE = function(S, T, G, Z) {
            if (S = +S, T = T >>> 0, !Z) {
                const Pe = Math.pow(2, 8 * G - 1);
                m(this, S, T, G, Pe - 1, -Pe);
            }
            let Q = 0, se = 1, Ue = 0;
            for(this[T] = S & 255; ++Q < G && (se *= 256);)S < 0 && Ue === 0 && this[T + Q - 1] !== 0 && (Ue = 1), this[T + Q] = (S / se >> 0) - Ue & 255;
            return T + G;
        }, a.prototype.writeIntBE = function(S, T, G, Z) {
            if (S = +S, T = T >>> 0, !Z) {
                const Pe = Math.pow(2, 8 * G - 1);
                m(this, S, T, G, Pe - 1, -Pe);
            }
            let Q = G - 1, se = 1, Ue = 0;
            for(this[T + Q] = S & 255; --Q >= 0 && (se *= 256);)S < 0 && Ue === 0 && this[T + Q + 1] !== 0 && (Ue = 1), this[T + Q] = (S / se >> 0) - Ue & 255;
            return T + G;
        }, a.prototype.writeInt8 = function(S, T, G) {
            return S = +S, T = T >>> 0, G || m(this, S, T, 1, 127, -128), S < 0 && (S = 255 + S + 1), this[T] = S & 255, T + 1;
        }, a.prototype.writeInt16LE = function(S, T, G) {
            return S = +S, T = T >>> 0, G || m(this, S, T, 2, 32767, -32768), this[T] = S & 255, this[T + 1] = S >>> 8, T + 2;
        }, a.prototype.writeInt16BE = function(S, T, G) {
            return S = +S, T = T >>> 0, G || m(this, S, T, 2, 32767, -32768), this[T] = S >>> 8, this[T + 1] = S & 255, T + 2;
        }, a.prototype.writeInt32LE = function(S, T, G) {
            return S = +S, T = T >>> 0, G || m(this, S, T, 4, 2147483647, -2147483648), this[T] = S & 255, this[T + 1] = S >>> 8, this[T + 2] = S >>> 16, this[T + 3] = S >>> 24, T + 4;
        }, a.prototype.writeInt32BE = function(S, T, G) {
            return S = +S, T = T >>> 0, G || m(this, S, T, 4, 2147483647, -2147483648), S < 0 && (S = 4294967295 + S + 1), this[T] = S >>> 24, this[T + 1] = S >>> 16, this[T + 2] = S >>> 8, this[T + 3] = S & 255, T + 4;
        }, a.prototype.writeBigInt64LE = it(function(S, T = 0) {
            return v(this, S, T, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
        }), a.prototype.writeBigInt64BE = it(function(S, T = 0) {
            return P(this, S, T, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
        });
        function N(B, S, T, G, Z, Q) {
            if (T + G > B.length) throw new RangeError("Index out of range");
            if (T < 0) throw new RangeError("Index out of range");
        }
        function Y(B, S, T, G, Z) {
            return S = +S, T = T >>> 0, Z || N(B, S, T, 4), t.write(B, S, T, G, 23, 4), T + 4;
        }
        a.prototype.writeFloatLE = function(S, T, G) {
            return Y(this, S, T, !0, G);
        }, a.prototype.writeFloatBE = function(S, T, G) {
            return Y(this, S, T, !1, G);
        };
        function ee(B, S, T, G, Z) {
            return S = +S, T = T >>> 0, Z || N(B, S, T, 8), t.write(B, S, T, G, 52, 8), T + 8;
        }
        a.prototype.writeDoubleLE = function(S, T, G) {
            return ee(this, S, T, !0, G);
        }, a.prototype.writeDoubleBE = function(S, T, G) {
            return ee(this, S, T, !1, G);
        }, a.prototype.copy = function(S, T, G, Z) {
            if (!a.isBuffer(S)) throw new TypeError("argument should be a Buffer");
            if (G || (G = 0), !Z && Z !== 0 && (Z = this.length), T >= S.length && (T = S.length), T || (T = 0), Z > 0 && Z < G && (Z = G), Z === G || S.length === 0 || this.length === 0) return 0;
            if (T < 0) throw new RangeError("targetStart out of bounds");
            if (G < 0 || G >= this.length) throw new RangeError("Index out of range");
            if (Z < 0) throw new RangeError("sourceEnd out of bounds");
            Z > this.length && (Z = this.length), S.length - T < Z - G && (Z = S.length - T + G);
            const Q = Z - G;
            return this === S && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(T, G, Z) : Uint8Array.prototype.set.call(S, this.subarray(G, Z), T), Q;
        }, a.prototype.fill = function(S, T, G, Z) {
            if (typeof S == "string") {
                if (typeof T == "string" ? (Z = T, T = 0, G = this.length) : typeof G == "string" && (Z = G, G = this.length), Z !== void 0 && typeof Z != "string") throw new TypeError("encoding must be a string");
                if (typeof Z == "string" && !a.isEncoding(Z)) throw new TypeError("Unknown encoding: " + Z);
                if (S.length === 1) {
                    const se = S.charCodeAt(0);
                    (Z === "utf8" && se < 128 || Z === "latin1") && (S = se);
                }
            } else typeof S == "number" ? S = S & 255 : typeof S == "boolean" && (S = Number(S));
            if (T < 0 || this.length < T || this.length < G) throw new RangeError("Out of range index");
            if (G <= T) return this;
            T = T >>> 0, G = G === void 0 ? this.length : G >>> 0, S || (S = 0);
            let Q;
            if (typeof S == "number") for(Q = T; Q < G; ++Q)this[Q] = S;
            else {
                const se = a.isBuffer(S) ? S : a.from(S, Z), Ue = se.length;
                if (Ue === 0) throw new TypeError('The value "' + S + '" is invalid for argument "value"');
                for(Q = 0; Q < G - T; ++Q)this[Q + T] = se[Q % Ue];
            }
            return this;
        };
        const ie = {};
        function le(B, S, T) {
            ie[B] = class extends T {
                constructor(){
                    super(), Object.defineProperty(this, "message", {
                        value: S.apply(this, arguments),
                        writable: !0,
                        configurable: !0
                    }), this.name = `${this.name} [${B}]`, this.stack, delete this.name;
                }
                get code() {
                    return B;
                }
                set code(Z) {
                    Object.defineProperty(this, "code", {
                        configurable: !0,
                        enumerable: !0,
                        value: Z,
                        writable: !0
                    });
                }
                toString() {
                    return `${this.name} [${B}]: ${this.message}`;
                }
            };
        }
        le("ERR_BUFFER_OUT_OF_BOUNDS", function(B) {
            return B ? `${B} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
        }, RangeError), le("ERR_INVALID_ARG_TYPE", function(B, S) {
            return `The "${B}" argument must be of type number. Received type ${typeof S}`;
        }, TypeError), le("ERR_OUT_OF_RANGE", function(B, S, T) {
            let G = `The value of "${B}" is out of range.`, Z = T;
            return Number.isInteger(T) && Math.abs(T) > 2 ** 32 ? Z = Te(String(T)) : typeof T == "bigint" && (Z = String(T), (T > BigInt(2) ** BigInt(32) || T < -(BigInt(2) ** BigInt(32))) && (Z = Te(Z)), Z += "n"), G += ` It must be ${S}. Received ${Z}`, G;
        }, RangeError);
        function Te(B) {
            let S = "", T = B.length;
            const G = B[0] === "-" ? 1 : 0;
            for(; T >= G + 4; T -= 3)S = `_${B.slice(T - 3, T)}${S}`;
            return `${B.slice(0, T)}${S}`;
        }
        function De(B, S, T) {
            _e(S, "offset"), (B[S] === void 0 || B[S + T] === void 0) && xe(S, B.length - (T + 1));
        }
        function ze(B, S, T, G, Z, Q) {
            if (B > T || B < S) {
                const se = typeof S == "bigint" ? "n" : "";
                let Ue;
                throw S === 0 || S === BigInt(0) ? Ue = `>= 0${se} and < 2${se} ** ${(Q + 1) * 8}${se}` : Ue = `>= -(2${se} ** ${(Q + 1) * 8 - 1}${se}) and < 2 ** ${(Q + 1) * 8 - 1}${se}`, new ie.ERR_OUT_OF_RANGE("value", Ue, B);
            }
            De(G, Z, Q);
        }
        function _e(B, S) {
            if (typeof B != "number") throw new ie.ERR_INVALID_ARG_TYPE(S, "number", B);
        }
        function xe(B, S, T) {
            throw Math.floor(B) !== B ? (_e(B, T), new ie.ERR_OUT_OF_RANGE("offset", "an integer", B)) : S < 0 ? new ie.ERR_BUFFER_OUT_OF_BOUNDS() : new ie.ERR_OUT_OF_RANGE("offset", `>= 0 and <= ${S}`, B);
        }
        const Be = /[^+/0-9A-Za-z-_]/g;
        function ye(B) {
            if (B = B.split("=")[0], B = B.trim().replace(Be, ""), B.length < 2) return "";
            for(; B.length % 4 !== 0;)B = B + "=";
            return B;
        }
        function be(B, S) {
            S = S || 1 / 0;
            let T;
            const G = B.length;
            let Z = null;
            const Q = [];
            for(let se = 0; se < G; ++se){
                if (T = B.charCodeAt(se), T > 55295 && T < 57344) {
                    if (!Z) {
                        if (T > 56319) {
                            (S -= 3) > -1 && Q.push(239, 191, 189);
                            continue;
                        } else if (se + 1 === G) {
                            (S -= 3) > -1 && Q.push(239, 191, 189);
                            continue;
                        }
                        Z = T;
                        continue;
                    }
                    if (T < 56320) {
                        (S -= 3) > -1 && Q.push(239, 191, 189), Z = T;
                        continue;
                    }
                    T = (Z - 55296 << 10 | T - 56320) + 65536;
                } else Z && (S -= 3) > -1 && Q.push(239, 191, 189);
                if (Z = null, T < 128) {
                    if ((S -= 1) < 0) break;
                    Q.push(T);
                } else if (T < 2048) {
                    if ((S -= 2) < 0) break;
                    Q.push(T >> 6 | 192, T & 63 | 128);
                } else if (T < 65536) {
                    if ((S -= 3) < 0) break;
                    Q.push(T >> 12 | 224, T >> 6 & 63 | 128, T & 63 | 128);
                } else if (T < 1114112) {
                    if ((S -= 4) < 0) break;
                    Q.push(T >> 18 | 240, T >> 12 & 63 | 128, T >> 6 & 63 | 128, T & 63 | 128);
                } else throw new Error("Invalid code point");
            }
            return Q;
        }
        function Fe(B) {
            const S = [];
            for(let T = 0; T < B.length; ++T)S.push(B.charCodeAt(T) & 255);
            return S;
        }
        function Xe(B, S) {
            let T, G, Z;
            const Q = [];
            for(let se = 0; se < B.length && !((S -= 2) < 0); ++se)T = B.charCodeAt(se), G = T >> 8, Z = T % 256, Q.push(Z), Q.push(G);
            return Q;
        }
        function we(B) {
            return e.toByteArray(ye(B));
        }
        function Ne(B, S, T, G) {
            let Z;
            for(Z = 0; Z < G && !(Z + T >= S.length || Z >= B.length); ++Z)S[Z + T] = B[Z];
            return Z;
        }
        function dt(B, S) {
            return B instanceof S || B != null && B.constructor != null && B.constructor.name != null && B.constructor.name === S.name;
        }
        function Je(B) {
            return B !== B;
        }
        const Qe = function() {
            const B = "0123456789abcdef", S = new Array(256);
            for(let T = 0; T < 16; ++T){
                const G = T * 16;
                for(let Z = 0; Z < 16; ++Z)S[G + Z] = B[T] + B[Z];
            }
            return S;
        }();
        function it(B) {
            return typeof BigInt > "u" ? je : B;
        }
        function je() {
            throw new Error("BigInt not supported");
        }
    }(Ga)), Ga;
}
var He = Kc();
const on = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function Ii(s) {
    return s instanceof Uint8Array || ArrayBuffer.isView(s) && s.constructor.name === "Uint8Array";
}
function Xl(s) {
    if (!Number.isSafeInteger(s) || s < 0) throw new Error("positive integer expected, got " + s);
}
function Qs(s, ...e) {
    if (!Ii(s)) throw new Error("Uint8Array expected");
    if (e.length > 0 && !e.includes(s.length)) throw new Error("Uint8Array expected of length " + e + ", got length=" + s.length);
}
function Hf(s) {
    if (typeof s != "function" || typeof s.create != "function") throw new Error("Hash should be wrapped by utils.createHasher");
    Xl(s.outputLen), Xl(s.blockLen);
}
function Do(s, e = !0) {
    if (s.destroyed) throw new Error("Hash instance has been destroyed");
    if (e && s.finished) throw new Error("Hash#digest() has already been called");
}
function O1(s, e) {
    Qs(s);
    const t = e.outputLen;
    if (s.length < t) throw new Error("digestInto() expects output buffer of length at least " + t);
}
function Rn(...s) {
    for(let e = 0; e < s.length; e++)s[e].fill(0);
}
function Va(s) {
    return new DataView(s.buffer, s.byteOffset, s.byteLength);
}
function Nr(s, e) {
    return s << 32 - e | s >>> e;
}
const qf = /* @ts-ignore */ typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function", B1 = /* @__PURE__ */ Array.from({
    length: 256
}, (s, e)=>e.toString(16).padStart(2, "0"));
function Hs(s) {
    if (Qs(s), qf) return s.toHex();
    let e = "";
    for(let t = 0; t < s.length; t++)e += B1[s[t]];
    return e;
}
const rs = {
    _0: 48,
    _9: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
};
function cd(s) {
    if (s >= rs._0 && s <= rs._9) return s - rs._0;
    if (s >= rs.A && s <= rs.F) return s - (rs.A - 10);
    if (s >= rs.a && s <= rs.f) return s - (rs.a - 10);
}
function Po(s) {
    if (typeof s != "string") throw new Error("hex string expected, got " + typeof s);
    if (qf) return Uint8Array.fromHex(s);
    const e = s.length, t = e / 2;
    if (e % 2) throw new Error("hex string expected, got unpadded hex of length " + e);
    const r = new Uint8Array(t);
    for(let n1 = 0, i = 0; n1 < t; n1++, i += 2){
        const o = cd(s.charCodeAt(i)), a = cd(s.charCodeAt(i + 1));
        if (o === void 0 || a === void 0) {
            const l = s[i] + s[i + 1];
            throw new Error('hex string expected, got non-hex character "' + l + '" at index ' + i);
        }
        r[n1] = o * 16 + a;
    }
    return r;
}
function F1(s) {
    if (typeof s != "string") throw new Error("string expected");
    return new Uint8Array(new TextEncoder().encode(s));
}
function Hc(s) {
    return typeof s == "string" && (s = F1(s)), Qs(s), s;
}
function Kr(...s) {
    let e = 0;
    for(let r = 0; r < s.length; r++){
        const n1 = s[r];
        Qs(n1), e += n1.length;
    }
    const t = new Uint8Array(e);
    for(let r = 0, n1 = 0; r < s.length; r++){
        const i = s[r];
        t.set(i, n1), n1 += i.length;
    }
    return t;
}
class Wf {
}
function zf(s) {
    const e = (r)=>s().update(Hc(r)).digest(), t = s();
    return e.outputLen = t.outputLen, e.blockLen = t.blockLen, e.create = ()=>s(), e;
}
function qc(s = 32) {
    if (on && typeof on.getRandomValues == "function") return on.getRandomValues(new Uint8Array(s));
    if (on && typeof on.randomBytes == "function") return Uint8Array.from(on.randomBytes(s));
    throw new Error("crypto.getRandomValues must be defined");
}
function N1(s, e, t, r) {
    if (typeof s.setBigUint64 == "function") return s.setBigUint64(e, t, r);
    const n1 = BigInt(32), i = BigInt(4294967295), o = Number(t >> n1 & i), a = Number(t & i), l = r ? 4 : 0, c = r ? 0 : 4;
    s.setUint32(e + l, o, r), s.setUint32(e + c, a, r);
}
function U1(s, e, t) {
    return s & e ^ ~s & t;
}
function $1(s, e, t) {
    return s & e ^ s & t ^ e & t;
}
class Yf extends Wf {
    constructor(e, t, r, n1){
        super(), this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.blockLen = e, this.outputLen = t, this.padOffset = r, this.isLE = n1, this.buffer = new Uint8Array(e), this.view = Va(this.buffer);
    }
    update(e) {
        Do(this), e = Hc(e), Qs(e);
        const { view: t, buffer: r, blockLen: n1 } = this, i = e.length;
        for(let o = 0; o < i;){
            const a = Math.min(n1 - this.pos, i - o);
            if (a === n1) {
                const l = Va(e);
                for(; n1 <= i - o; o += n1)this.process(l, o);
                continue;
            }
            r.set(e.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === n1 && (this.process(t, 0), this.pos = 0);
        }
        return this.length += e.length, this.roundClean(), this;
    }
    digestInto(e) {
        Do(this), O1(e, this), this.finished = !0;
        const { buffer: t, view: r, blockLen: n1, isLE: i } = this;
        let { pos: o } = this;
        t[o++] = 128, Rn(this.buffer.subarray(o)), this.padOffset > n1 - o && (this.process(r, 0), o = 0);
        for(let d1 = o; d1 < n1; d1++)t[d1] = 0;
        N1(r, n1 - 8, BigInt(this.length * 8), i), this.process(r, 0);
        const a = Va(e), l = this.outputLen;
        if (l % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
        const c = l / 4, u = this.get();
        if (c > u.length) throw new Error("_sha2: outputLen bigger than state");
        for(let d1 = 0; d1 < c; d1++)a.setUint32(4 * d1, u[d1], i);
    }
    digest() {
        const { buffer: e, outputLen: t } = this;
        this.digestInto(e);
        const r = e.slice(0, t);
        return this.destroy(), r;
    }
    _cloneInto(e) {
        e || (e = new this.constructor()), e.set(...this.get());
        const { blockLen: t, buffer: r, length: n1, finished: i, destroyed: o, pos: a } = this;
        return e.destroyed = o, e.finished = i, e.length = n1, e.pos = a, n1 % t && e.buffer.set(r), e;
    }
    clone() {
        return this._cloneInto();
    }
}
const ms = /* @__PURE__ */ Uint32Array.from([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
]), Qt = /* @__PURE__ */ Uint32Array.from([
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
]), Oi = /* @__PURE__ */ BigInt(2 ** 32 - 1), ud = /* @__PURE__ */ BigInt(32);
function G1(s, e = !1) {
    return e ? {
        h: Number(s & Oi),
        l: Number(s >> ud & Oi)
    } : {
        h: Number(s >> ud & Oi) | 0,
        l: Number(s & Oi) | 0
    };
}
function V1(s, e = !1) {
    const t = s.length;
    let r = new Uint32Array(t), n1 = new Uint32Array(t);
    for(let i = 0; i < t; i++){
        const { h: o, l: a } = G1(s[i], e);
        [r[i], n1[i]] = [
            o,
            a
        ];
    }
    return [
        r,
        n1
    ];
}
const dd = (s, e, t)=>s >>> t, hd = (s, e, t)=>s << 32 - t | e >>> t, an = (s, e, t)=>s >>> t | e << 32 - t, ln = (s, e, t)=>s << 32 - t | e >>> t, Bi = (s, e, t)=>s << 64 - t | e >>> t - 32, Fi = (s, e, t)=>s >>> t - 32 | e << 64 - t;
function ss(s, e, t, r) {
    const n1 = (e >>> 0) + (r >>> 0);
    return {
        h: s + t + (n1 / 2 ** 32 | 0) | 0,
        l: n1 | 0
    };
}
const j1 = (s, e, t)=>(s >>> 0) + (e >>> 0) + (t >>> 0), K1 = (s, e, t, r)=>e + t + r + (s / 2 ** 32 | 0) | 0, H1 = (s, e, t, r)=>(s >>> 0) + (e >>> 0) + (t >>> 0) + (r >>> 0), q1 = (s, e, t, r, n1)=>e + t + r + n1 + (s / 2 ** 32 | 0) | 0, W1 = (s, e, t, r, n1)=>(s >>> 0) + (e >>> 0) + (t >>> 0) + (r >>> 0) + (n1 >>> 0), z1 = (s, e, t, r, n1, i)=>e + t + r + n1 + i + (s / 2 ** 32 | 0) | 0, Y1 = /* @__PURE__ */ Uint32Array.from([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
]), ys = /* @__PURE__ */ new Uint32Array(64);
class Z1 extends Yf {
    constructor(e = 32){
        super(64, e, 8, !1), this.A = ms[0] | 0, this.B = ms[1] | 0, this.C = ms[2] | 0, this.D = ms[3] | 0, this.E = ms[4] | 0, this.F = ms[5] | 0, this.G = ms[6] | 0, this.H = ms[7] | 0;
    }
    get() {
        const { A: e, B: t, C: r, D: n1, E: i, F: o, G: a, H: l } = this;
        return [
            e,
            t,
            r,
            n1,
            i,
            o,
            a,
            l
        ];
    }
    // prettier-ignore
    set(e, t, r, n1, i, o, a, l) {
        this.A = e | 0, this.B = t | 0, this.C = r | 0, this.D = n1 | 0, this.E = i | 0, this.F = o | 0, this.G = a | 0, this.H = l | 0;
    }
    process(e, t) {
        for(let d1 = 0; d1 < 16; d1++, t += 4)ys[d1] = e.getUint32(t, !1);
        for(let d1 = 16; d1 < 64; d1++){
            const h = ys[d1 - 15], f = ys[d1 - 2], p = Nr(h, 7) ^ Nr(h, 18) ^ h >>> 3, y = Nr(f, 17) ^ Nr(f, 19) ^ f >>> 10;
            ys[d1] = y + ys[d1 - 7] + p + ys[d1 - 16] | 0;
        }
        let { A: r, B: n1, C: i, D: o, E: a, F: l, G: c, H: u } = this;
        for(let d1 = 0; d1 < 64; d1++){
            const h = Nr(a, 6) ^ Nr(a, 11) ^ Nr(a, 25), f = u + h + U1(a, l, c) + Y1[d1] + ys[d1] | 0, y = (Nr(r, 2) ^ Nr(r, 13) ^ Nr(r, 22)) + $1(r, n1, i) | 0;
            u = c, c = l, l = a, a = o + f | 0, o = i, i = n1, n1 = r, r = f + y | 0;
        }
        r = r + this.A | 0, n1 = n1 + this.B | 0, i = i + this.C | 0, o = o + this.D | 0, a = a + this.E | 0, l = l + this.F | 0, c = c + this.G | 0, u = u + this.H | 0, this.set(r, n1, i, o, a, l, c, u);
    }
    roundClean() {
        Rn(ys);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0), Rn(this.buffer);
    }
}
const Zf = V1([
    "0x428a2f98d728ae22",
    "0x7137449123ef65cd",
    "0xb5c0fbcfec4d3b2f",
    "0xe9b5dba58189dbbc",
    "0x3956c25bf348b538",
    "0x59f111f1b605d019",
    "0x923f82a4af194f9b",
    "0xab1c5ed5da6d8118",
    "0xd807aa98a3030242",
    "0x12835b0145706fbe",
    "0x243185be4ee4b28c",
    "0x550c7dc3d5ffb4e2",
    "0x72be5d74f27b896f",
    "0x80deb1fe3b1696b1",
    "0x9bdc06a725c71235",
    "0xc19bf174cf692694",
    "0xe49b69c19ef14ad2",
    "0xefbe4786384f25e3",
    "0x0fc19dc68b8cd5b5",
    "0x240ca1cc77ac9c65",
    "0x2de92c6f592b0275",
    "0x4a7484aa6ea6e483",
    "0x5cb0a9dcbd41fbd4",
    "0x76f988da831153b5",
    "0x983e5152ee66dfab",
    "0xa831c66d2db43210",
    "0xb00327c898fb213f",
    "0xbf597fc7beef0ee4",
    "0xc6e00bf33da88fc2",
    "0xd5a79147930aa725",
    "0x06ca6351e003826f",
    "0x142929670a0e6e70",
    "0x27b70a8546d22ffc",
    "0x2e1b21385c26c926",
    "0x4d2c6dfc5ac42aed",
    "0x53380d139d95b3df",
    "0x650a73548baf63de",
    "0x766a0abb3c77b2a8",
    "0x81c2c92e47edaee6",
    "0x92722c851482353b",
    "0xa2bfe8a14cf10364",
    "0xa81a664bbc423001",
    "0xc24b8b70d0f89791",
    "0xc76c51a30654be30",
    "0xd192e819d6ef5218",
    "0xd69906245565a910",
    "0xf40e35855771202a",
    "0x106aa07032bbd1b8",
    "0x19a4c116b8d2d0c8",
    "0x1e376c085141ab53",
    "0x2748774cdf8eeb99",
    "0x34b0bcb5e19b48a8",
    "0x391c0cb3c5c95a63",
    "0x4ed8aa4ae3418acb",
    "0x5b9cca4f7763e373",
    "0x682e6ff3d6b2b8a3",
    "0x748f82ee5defb2fc",
    "0x78a5636f43172f60",
    "0x84c87814a1f0ab72",
    "0x8cc702081a6439ec",
    "0x90befffa23631e28",
    "0xa4506cebde82bde9",
    "0xbef9a3f7b2c67915",
    "0xc67178f2e372532b",
    "0xca273eceea26619c",
    "0xd186b8c721c0c207",
    "0xeada7dd6cde0eb1e",
    "0xf57d4f7fee6ed178",
    "0x06f067aa72176fba",
    "0x0a637dc5a2c898a6",
    "0x113f9804bef90dae",
    "0x1b710b35131c471b",
    "0x28db77f523047d84",
    "0x32caab7b40c72493",
    "0x3c9ebe0a15c9bebc",
    "0x431d67c49c100d4c",
    "0x4cc5d4becb3e42b6",
    "0x597f299cfc657e2a",
    "0x5fcb6fab3ad6faec",
    "0x6c44198c4a475817"
].map((s)=>BigInt(s))), X1 = Zf[0], J1 = Zf[1], vs = /* @__PURE__ */ new Uint32Array(80), Es = /* @__PURE__ */ new Uint32Array(80);
class Q1 extends Yf {
    constructor(e = 64){
        super(128, e, 16, !1), this.Ah = Qt[0] | 0, this.Al = Qt[1] | 0, this.Bh = Qt[2] | 0, this.Bl = Qt[3] | 0, this.Ch = Qt[4] | 0, this.Cl = Qt[5] | 0, this.Dh = Qt[6] | 0, this.Dl = Qt[7] | 0, this.Eh = Qt[8] | 0, this.El = Qt[9] | 0, this.Fh = Qt[10] | 0, this.Fl = Qt[11] | 0, this.Gh = Qt[12] | 0, this.Gl = Qt[13] | 0, this.Hh = Qt[14] | 0, this.Hl = Qt[15] | 0;
    }
    // prettier-ignore
    get() {
        const { Ah: e, Al: t, Bh: r, Bl: n1, Ch: i, Cl: o, Dh: a, Dl: l, Eh: c, El: u, Fh: d1, Fl: h, Gh: f, Gl: p, Hh: y, Hl: E } = this;
        return [
            e,
            t,
            r,
            n1,
            i,
            o,
            a,
            l,
            c,
            u,
            d1,
            h,
            f,
            p,
            y,
            E
        ];
    }
    // prettier-ignore
    set(e, t, r, n1, i, o, a, l, c, u, d1, h, f, p, y, E) {
        this.Ah = e | 0, this.Al = t | 0, this.Bh = r | 0, this.Bl = n1 | 0, this.Ch = i | 0, this.Cl = o | 0, this.Dh = a | 0, this.Dl = l | 0, this.Eh = c | 0, this.El = u | 0, this.Fh = d1 | 0, this.Fl = h | 0, this.Gh = f | 0, this.Gl = p | 0, this.Hh = y | 0, this.Hl = E | 0;
    }
    process(e, t) {
        for(let A = 0; A < 16; A++, t += 4)vs[A] = e.getUint32(t), Es[A] = e.getUint32(t += 4);
        for(let A = 16; A < 80; A++){
            const F = vs[A - 15] | 0, M = Es[A - 15] | 0, H = an(F, M, 1) ^ an(F, M, 8) ^ dd(F, M, 7), K = ln(F, M, 1) ^ ln(F, M, 8) ^ hd(F, M, 7), j = vs[A - 2] | 0, C = Es[A - 2] | 0, k = an(j, C, 19) ^ Bi(j, C, 61) ^ dd(j, C, 6), $ = ln(j, C, 19) ^ Fi(j, C, 61) ^ hd(j, C, 6), W = H1(K, $, Es[A - 7], Es[A - 16]), _ = q1(W, H, k, vs[A - 7], vs[A - 16]);
            vs[A] = _ | 0, Es[A] = W | 0;
        }
        let { Ah: r, Al: n1, Bh: i, Bl: o, Ch: a, Cl: l, Dh: c, Dl: u, Eh: d1, El: h, Fh: f, Fl: p, Gh: y, Gl: E, Hh: b, Hl: L } = this;
        for(let A = 0; A < 80; A++){
            const F = an(d1, h, 14) ^ an(d1, h, 18) ^ Bi(d1, h, 41), M = ln(d1, h, 14) ^ ln(d1, h, 18) ^ Fi(d1, h, 41), H = d1 & f ^ ~d1 & y, K = h & p ^ ~h & E, j = W1(L, M, K, J1[A], Es[A]), C = z1(j, b, F, H, X1[A], vs[A]), k = j | 0, $ = an(r, n1, 28) ^ Bi(r, n1, 34) ^ Bi(r, n1, 39), W = ln(r, n1, 28) ^ Fi(r, n1, 34) ^ Fi(r, n1, 39), _ = r & i ^ r & a ^ i & a, g = n1 & o ^ n1 & l ^ o & l;
            b = y | 0, L = E | 0, y = f | 0, E = p | 0, f = d1 | 0, p = h | 0, ({ h: d1, l: h } = ss(c | 0, u | 0, C | 0, k | 0)), c = a | 0, u = l | 0, a = i | 0, l = o | 0, i = r | 0, o = n1 | 0;
            const x = j1(k, W, g);
            r = K1(x, C, $, _), n1 = x | 0;
        }
        ({ h: r, l: n1 } = ss(this.Ah | 0, this.Al | 0, r | 0, n1 | 0)), ({ h: i, l: o } = ss(this.Bh | 0, this.Bl | 0, i | 0, o | 0)), ({ h: a, l } = ss(this.Ch | 0, this.Cl | 0, a | 0, l | 0)), ({ h: c, l: u } = ss(this.Dh | 0, this.Dl | 0, c | 0, u | 0)), ({ h: d1, l: h } = ss(this.Eh | 0, this.El | 0, d1 | 0, h | 0)), ({ h: f, l: p } = ss(this.Fh | 0, this.Fl | 0, f | 0, p | 0)), ({ h: y, l: E } = ss(this.Gh | 0, this.Gl | 0, y | 0, E | 0)), ({ h: b, l: L } = ss(this.Hh | 0, this.Hl | 0, b | 0, L | 0)), this.set(r, n1, i, o, a, l, c, u, d1, h, f, p, y, E, b, L);
    }
    roundClean() {
        Rn(vs, Es);
    }
    destroy() {
        Rn(this.buffer), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
}
const Xf = /* @__PURE__ */ zf(()=>new Z1()), ey = /* @__PURE__ */ zf(()=>new Q1());
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const Wc = /* @__PURE__ */ BigInt(0), Jl = /* @__PURE__ */ BigInt(1);
function Xs(s, e = "") {
    if (typeof s != "boolean") {
        const t = e && `"${e}"`;
        throw new Error(t + "expected boolean, got type=" + typeof s);
    }
    return s;
}
function Or(s, e, t = "") {
    const r = Ii(s), n1 = s == null ? void 0 : s.length, i = e !== void 0;
    if (!r || i && n1 !== e) {
        const o = t && `"${t}" `, a = i ? ` of length ${e}` : "", l = r ? `length=${n1}` : `type=${typeof s}`;
        throw new Error(o + "expected Uint8Array" + a + ", got " + l);
    }
    return s;
}
function Ni(s) {
    const e = s.toString(16);
    return e.length & 1 ? "0" + e : e;
}
function Jf(s) {
    if (typeof s != "string") throw new Error("hex string expected, got " + typeof s);
    return s === "" ? Wc : BigInt("0x" + s);
}
function la(s) {
    return Jf(Hs(s));
}
function ei(s) {
    return Qs(s), Jf(Hs(Uint8Array.from(s).reverse()));
}
function zc(s, e) {
    return Po(s.toString(16).padStart(e * 2, "0"));
}
function Qf(s, e) {
    return zc(s, e).reverse();
}
function Et(s, e, t) {
    let r;
    if (typeof e == "string") try {
        r = Po(e);
    } catch (i) {
        throw new Error(s + " must be hex string or Uint8Array, cause: " + i);
    }
    else if (Ii(e)) r = Uint8Array.from(e);
    else throw new Error(s + " must be hex string or Uint8Array");
    const n1 = r.length;
    if (typeof t == "number" && n1 !== t) throw new Error(s + " of length " + t + " expected, got " + n1);
    return r;
}
function fd(s) {
    return Uint8Array.from(s);
}
const ja = (s)=>typeof s == "bigint" && Wc <= s;
function ty(s, e, t) {
    return ja(s) && ja(e) && ja(t) && e <= s && s < t;
}
function Ql(s, e, t, r) {
    if (!ty(e, t, r)) throw new Error("expected valid " + s + ": " + t + " <= n < " + r + ", got " + e);
}
function e0(s) {
    let e;
    for(e = 0; s > Wc; s >>= Jl, e += 1);
    return e;
}
const _i = (s)=>(Jl << BigInt(s)) - Jl;
function ry(s, e, t) {
    if (typeof s != "number" || s < 2) throw new Error("hashLen must be a number");
    if (typeof e != "number" || e < 2) throw new Error("qByteLen must be a number");
    if (typeof t != "function") throw new Error("hmacFn must be a function");
    const r = (f)=>new Uint8Array(f), n1 = (f)=>Uint8Array.of(f);
    let i = r(s), o = r(s), a = 0;
    const l = ()=>{
        i.fill(1), o.fill(0), a = 0;
    }, c = (...f)=>t(o, i, ...f), u = (f = r(0))=>{
        o = c(n1(0), f), i = c(), f.length !== 0 && (o = c(n1(1), f), i = c());
    }, d1 = ()=>{
        if (a++ >= 1e3) throw new Error("drbg: tried 1000 values");
        let f = 0;
        const p = [];
        for(; f < e;){
            i = c();
            const y = i.slice();
            p.push(y), f += i.length;
        }
        return Kr(...p);
    };
    return (f, p)=>{
        l(), u(f);
        let y;
        for(; !(y = p(d1()));)u();
        return l(), y;
    };
}
function Li(s, e, t = {}) {
    if (!s || typeof s != "object") throw new Error("expected valid options object");
    function r(n1, i, o) {
        const a = s[n1];
        if (o && a === void 0) return;
        const l = typeof a;
        if (l !== i || a === null) throw new Error(`param "${n1}" is invalid: expected ${i}, got ${l}`);
    }
    Object.entries(e).forEach(([n1, i])=>r(n1, i, !1)), Object.entries(t).forEach(([n1, i])=>r(n1, i, !0));
}
function Mo(s) {
    const e = /* @__PURE__ */ new WeakMap();
    return (t, ...r)=>{
        const n1 = e.get(t);
        if (n1 !== void 0) return n1;
        const i = s(t, ...r);
        return e.set(t, i), i;
    };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const gr = BigInt(0), Xt = BigInt(1), Gs = /* @__PURE__ */ BigInt(2), t0 = /* @__PURE__ */ BigInt(3), r0 = /* @__PURE__ */ BigInt(4), s0 = /* @__PURE__ */ BigInt(5), sy = /* @__PURE__ */ BigInt(7), n0 = /* @__PURE__ */ BigInt(8), ny = /* @__PURE__ */ BigInt(9), i0 = /* @__PURE__ */ BigInt(16);
function Gt(s, e) {
    const t = s % e;
    return t >= gr ? t : e + t;
}
function vt(s, e, t) {
    let r = s;
    for(; e-- > gr;)r *= r, r %= t;
    return r;
}
function gd(s, e) {
    if (s === gr) throw new Error("invert: expected non-zero number");
    if (e <= gr) throw new Error("invert: expected positive modulus, got " + e);
    let t = Gt(s, e), r = e, n1 = gr, i = Xt;
    for(; t !== gr;){
        const a = r / t, l = r % t, c = n1 - i * a;
        r = t, t = l, n1 = i, i = c;
    }
    if (r !== Xt) throw new Error("invert: does not exist");
    return Gt(n1, e);
}
function Yc(s, e, t) {
    if (!s.eql(s.sqr(e), t)) throw new Error("Cannot find square root");
}
function o0(s, e) {
    const t = (s.ORDER + Xt) / r0, r = s.pow(e, t);
    return Yc(s, r, e), r;
}
function iy(s, e) {
    const t = (s.ORDER - s0) / n0, r = s.mul(e, Gs), n1 = s.pow(r, t), i = s.mul(e, n1), o = s.mul(s.mul(i, Gs), n1), a = s.mul(i, s.sub(o, s.ONE));
    return Yc(s, a, e), a;
}
function oy(s) {
    const e = en(s), t = a0(s), r = t(e, e.neg(e.ONE)), n1 = t(e, r), i = t(e, e.neg(r)), o = (s + sy) / i0;
    return (a, l)=>{
        let c = a.pow(l, o), u = a.mul(c, r);
        const d1 = a.mul(c, n1), h = a.mul(c, i), f = a.eql(a.sqr(u), l), p = a.eql(a.sqr(d1), l);
        c = a.cmov(c, u, f), u = a.cmov(h, d1, p);
        const y = a.eql(a.sqr(u), l), E = a.cmov(c, u, y);
        return Yc(a, E, l), E;
    };
}
function a0(s) {
    if (s < t0) throw new Error("sqrt is not defined for small field");
    let e = s - Xt, t = 0;
    for(; e % Gs === gr;)e /= Gs, t++;
    let r = Gs;
    const n1 = en(s);
    for(; pd(n1, r) === 1;)if (r++ > 1e3) throw new Error("Cannot find square root: probably non-prime P");
    if (t === 1) return o0;
    let i = n1.pow(r, e);
    const o = (e + Xt) / Gs;
    return function(l, c) {
        if (l.is0(c)) return c;
        if (pd(l, c) !== 1) throw new Error("Cannot find square root");
        let u = t, d1 = l.mul(l.ONE, i), h = l.pow(c, e), f = l.pow(c, o);
        for(; !l.eql(h, l.ONE);){
            if (l.is0(h)) return l.ZERO;
            let p = 1, y = l.sqr(h);
            for(; !l.eql(y, l.ONE);)if (p++, y = l.sqr(y), p === u) throw new Error("Cannot find square root");
            const E = Xt << BigInt(u - p - 1), b = l.pow(d1, E);
            u = p, d1 = l.sqr(b), h = l.mul(h, d1), f = l.mul(f, b);
        }
        return f;
    };
}
function ay(s) {
    return s % r0 === t0 ? o0 : s % n0 === s0 ? iy : s % i0 === ny ? oy(s) : a0(s);
}
const ly = (s, e)=>(Gt(s, e) & Xt) === Xt, cy = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN"
];
function uy(s) {
    const e = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "number",
        BITS: "number"
    }, t = cy.reduce((r, n1)=>(r[n1] = "function", r), e);
    return Li(s, t), s;
}
function dy(s, e, t) {
    if (t < gr) throw new Error("invalid exponent, negatives unsupported");
    if (t === gr) return s.ONE;
    if (t === Xt) return e;
    let r = s.ONE, n1 = e;
    for(; t > gr;)t & Xt && (r = s.mul(r, n1)), n1 = s.sqr(n1), t >>= Xt;
    return r;
}
function l0(s, e, t = !1) {
    const r = new Array(e.length).fill(t ? s.ZERO : void 0), n1 = e.reduce((o, a, l)=>s.is0(a) ? o : (r[l] = o, s.mul(o, a)), s.ONE), i = s.inv(n1);
    return e.reduceRight((o, a, l)=>s.is0(a) ? o : (r[l] = s.mul(o, r[l]), s.mul(o, a)), i), r;
}
function pd(s, e) {
    const t = (s.ORDER - Xt) / Gs, r = s.pow(e, t), n1 = s.eql(r, s.ONE), i = s.eql(r, s.ZERO), o = s.eql(r, s.neg(s.ONE));
    if (!n1 && !i && !o) throw new Error("invalid Legendre symbol result");
    return n1 ? 1 : i ? 0 : -1;
}
function c0(s, e) {
    e !== void 0 && Xl(e);
    const t = e !== void 0 ? e : s.toString(2).length, r = Math.ceil(t / 8);
    return {
        nBitLength: t,
        nByteLength: r
    };
}
function en(s, e, t = !1, r = {}) {
    if (s <= gr) throw new Error("invalid field: expected ORDER > 0, got " + s);
    let n1, i, o = !1, a;
    if (typeof e == "object" && e != null) {
        if (r.sqrt || t) throw new Error("cannot specify opts in two arguments");
        const h = e;
        h.BITS && (n1 = h.BITS), h.sqrt && (i = h.sqrt), typeof h.isLE == "boolean" && (t = h.isLE), typeof h.modFromBytes == "boolean" && (o = h.modFromBytes), a = h.allowedLengths;
    } else typeof e == "number" && (n1 = e), r.sqrt && (i = r.sqrt);
    const { nBitLength: l, nByteLength: c } = c0(s, n1);
    if (c > 2048) throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    let u;
    const d1 = Object.freeze({
        ORDER: s,
        isLE: t,
        BITS: l,
        BYTES: c,
        MASK: _i(l),
        ZERO: gr,
        ONE: Xt,
        allowedLengths: a,
        create: (h)=>Gt(h, s),
        isValid: (h)=>{
            if (typeof h != "bigint") throw new Error("invalid field element: expected bigint, got " + typeof h);
            return gr <= h && h < s;
        },
        is0: (h)=>h === gr,
        // is valid and invertible
        isValidNot0: (h)=>!d1.is0(h) && d1.isValid(h),
        isOdd: (h)=>(h & Xt) === Xt,
        neg: (h)=>Gt(-h, s),
        eql: (h, f)=>h === f,
        sqr: (h)=>Gt(h * h, s),
        add: (h, f)=>Gt(h + f, s),
        sub: (h, f)=>Gt(h - f, s),
        mul: (h, f)=>Gt(h * f, s),
        pow: (h, f)=>dy(d1, h, f),
        div: (h, f)=>Gt(h * gd(f, s), s),
        // Same as above, but doesn't normalize
        sqrN: (h)=>h * h,
        addN: (h, f)=>h + f,
        subN: (h, f)=>h - f,
        mulN: (h, f)=>h * f,
        inv: (h)=>gd(h, s),
        sqrt: i || ((h)=>(u || (u = ay(s)), u(d1, h))),
        toBytes: (h)=>t ? Qf(h, c) : zc(h, c),
        fromBytes: (h, f = !0)=>{
            if (a) {
                if (!a.includes(h.length) || h.length > c) throw new Error("Field.fromBytes: expected " + a + " bytes, got " + h.length);
                const y = new Uint8Array(c);
                y.set(h, t ? 0 : y.length - h.length), h = y;
            }
            if (h.length !== c) throw new Error("Field.fromBytes: expected " + c + " bytes, got " + h.length);
            let p = t ? ei(h) : la(h);
            if (o && (p = Gt(p, s)), !f && !d1.isValid(p)) throw new Error("invalid field element: outside of range 0..ORDER");
            return p;
        },
        // TODO: we don't need it here, move out to separate fn
        invertBatch: (h)=>l0(d1, h),
        // We can't move this out because Fp6, Fp12 implement it
        // and it's unclear what to return in there.
        cmov: (h, f, p)=>p ? f : h
    });
    return Object.freeze(d1);
}
function u0(s) {
    if (typeof s != "bigint") throw new Error("field order must be bigint");
    const e = s.toString(2).length;
    return Math.ceil(e / 8);
}
function d0(s) {
    const e = u0(s);
    return e + Math.ceil(e / 2);
}
function hy(s, e, t = !1) {
    const r = s.length, n1 = u0(e), i = d0(e);
    if (r < 16 || r < i || r > 1024) throw new Error("expected " + i + "-1024 bytes of input, got " + r);
    const o = t ? ei(s) : la(s), a = Gt(o, e - Xt) + Xt;
    return t ? Qf(a, n1) : zc(a, n1);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const Cn = BigInt(0), Vs = BigInt(1);
function Oo(s, e) {
    const t = e.negate();
    return s ? t : e;
}
function js(s, e) {
    const t = l0(s.Fp, e.map((r)=>r.Z));
    return e.map((r, n1)=>s.fromAffine(r.toAffine(t[n1])));
}
function h0(s, e) {
    if (!Number.isSafeInteger(s) || s <= 0 || s > e) throw new Error("invalid window size, expected [1.." + e + "], got W=" + s);
}
function Ka(s, e) {
    h0(s, e);
    const t = Math.ceil(e / s) + 1, r = 2 ** (s - 1), n1 = 2 ** s, i = _i(s), o = BigInt(s);
    return {
        windows: t,
        windowSize: r,
        mask: i,
        maxNumber: n1,
        shiftBy: o
    };
}
function md(s, e, t) {
    const { windowSize: r, mask: n1, maxNumber: i, shiftBy: o } = t;
    let a = Number(s & n1), l = s >> o;
    a > r && (a -= i, l += Vs);
    const c = e * r, u = c + Math.abs(a) - 1, d1 = a === 0, h = a < 0, f = e % 2 !== 0;
    return {
        nextN: l,
        offset: u,
        isZero: d1,
        isNeg: h,
        isNegF: f,
        offsetF: c
    };
}
function fy(s, e) {
    if (!Array.isArray(s)) throw new Error("array expected");
    s.forEach((t, r)=>{
        if (!(t instanceof e)) throw new Error("invalid point at index " + r);
    });
}
function gy(s, e) {
    if (!Array.isArray(s)) throw new Error("array of scalars expected");
    s.forEach((t, r)=>{
        if (!e.isValid(t)) throw new Error("invalid scalar at index " + r);
    });
}
const Ha = /* @__PURE__ */ new WeakMap(), f0 = /* @__PURE__ */ new WeakMap();
function qa(s) {
    return f0.get(s) || 1;
}
function yd(s) {
    if (s !== Cn) throw new Error("invalid wNAF");
}
class g0 {
    // Parametrized with a given Point class (not individual point)
    constructor(e, t){
        this.BASE = e.BASE, this.ZERO = e.ZERO, this.Fn = e.Fn, this.bits = t;
    }
    // non-const time multiplication ladder
    _unsafeLadder(e, t, r = this.ZERO) {
        let n1 = e;
        for(; t > Cn;)t & Vs && (r = r.add(n1)), n1 = n1.double(), t >>= Vs;
        return r;
    }
    /**
   * Creates a wNAF precomputation window. Used for caching.
   * Default window size is set by `utils.precompute()` and is equal to 8.
   * Number of precomputed points depends on the curve size:
   * 2^(1) * (Math.ceil( / ) + 1), where:
   * -  is the window size
   * -  is the bitlength of the curve order.
   * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
   * @param point Point instance
   * @param W window size
   * @returns precomputed point tables flattened to a single array
   */ precomputeWindow(e, t) {
        const { windows: r, windowSize: n1 } = Ka(t, this.bits), i = [];
        let o = e, a = o;
        for(let l = 0; l < r; l++){
            a = o, i.push(a);
            for(let c = 1; c < n1; c++)a = a.add(o), i.push(a);
            o = a.double();
        }
        return i;
    }
    /**
   * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
   * More compact implementation:
   * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
   * @returns real and fake (for const-time) points
   */ wNAF(e, t, r) {
        if (!this.Fn.isValid(r)) throw new Error("invalid scalar");
        let n1 = this.ZERO, i = this.BASE;
        const o = Ka(e, this.bits);
        for(let a = 0; a < o.windows; a++){
            const { nextN: l, offset: c, isZero: u, isNeg: d1, isNegF: h, offsetF: f } = md(r, a, o);
            r = l, u ? i = i.add(Oo(h, t[f])) : n1 = n1.add(Oo(d1, t[c]));
        }
        return yd(r), {
            p: n1,
            f: i
        };
    }
    /**
   * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
   * @param acc accumulator point to add result of multiplication
   * @returns point
   */ wNAFUnsafe(e, t, r, n1 = this.ZERO) {
        const i = Ka(e, this.bits);
        for(let o = 0; o < i.windows && r !== Cn; o++){
            const { nextN: a, offset: l, isZero: c, isNeg: u } = md(r, o, i);
            if (r = a, !c) {
                const d1 = t[l];
                n1 = n1.add(u ? d1.negate() : d1);
            }
        }
        return yd(r), n1;
    }
    getPrecomputes(e, t, r) {
        let n1 = Ha.get(t);
        return n1 || (n1 = this.precomputeWindow(t, e), e !== 1 && (typeof r == "function" && (n1 = r(n1)), Ha.set(t, n1))), n1;
    }
    cached(e, t, r) {
        const n1 = qa(e);
        return this.wNAF(n1, this.getPrecomputes(n1, e, r), t);
    }
    unsafe(e, t, r, n1) {
        const i = qa(e);
        return i === 1 ? this._unsafeLadder(e, t, n1) : this.wNAFUnsafe(i, this.getPrecomputes(i, e, r), t, n1);
    }
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    createCache(e, t) {
        h0(t, this.bits), f0.set(e, t), Ha.delete(e);
    }
    hasCache(e) {
        return qa(e) !== 1;
    }
}
function py(s, e, t, r) {
    let n1 = e, i = s.ZERO, o = s.ZERO;
    for(; t > Cn || r > Cn;)t & Vs && (i = i.add(n1)), r & Vs && (o = o.add(n1)), n1 = n1.double(), t >>= Vs, r >>= Vs;
    return {
        p1: i,
        p2: o
    };
}
function p0(s, e, t, r) {
    fy(t, s), gy(r, e);
    const n1 = t.length, i = r.length;
    if (n1 !== i) throw new Error("arrays of points and scalars must have equal length");
    const o = s.ZERO, a = e0(BigInt(n1));
    let l = 1;
    a > 12 ? l = a - 3 : a > 4 ? l = a - 2 : a > 0 && (l = 2);
    const c = _i(l), u = new Array(Number(c) + 1).fill(o), d1 = Math.floor((e.BITS - 1) / l) * l;
    let h = o;
    for(let f = d1; f >= 0; f -= l){
        u.fill(o);
        for(let y = 0; y < i; y++){
            const E = r[y], b = Number(E >> BigInt(f) & c);
            u[b] = u[b].add(t[y]);
        }
        let p = o;
        for(let y = u.length - 1, E = o; y > 0; y--)E = E.add(u[y]), p = p.add(E);
        if (h = h.add(p), f !== 0) for(let y = 0; y < l; y++)h = h.double();
    }
    return h;
}
function vd(s, e, t) {
    if (e) {
        if (e.ORDER !== s) throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
        return uy(e), e;
    } else return en(s, {
        isLE: t
    });
}
function m0(s, e, t = {}, r) {
    if (r === void 0 && (r = s === "edwards"), !e || typeof e != "object") throw new Error(`expected valid ${s} CURVE object`);
    for (const l of [
        "p",
        "n",
        "h"
    ]){
        const c = e[l];
        if (!(typeof c == "bigint" && c > Cn)) throw new Error(`CURVE.${l} must be positive bigint`);
    }
    const n1 = vd(e.p, t.Fp, r), i = vd(e.n, t.Fn, r), a = [
        "Gx",
        "Gy",
        "a",
        s === "weierstrass" ? "b" : "d"
    ];
    for (const l of a)if (!n1.isValid(e[l])) throw new Error(`CURVE.${l} must be valid field element of CURVE.Fp`);
    return e = Object.freeze(Object.assign({}, e)), {
        CURVE: e,
        Fp: n1,
        Fn: i
    };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const xs = BigInt(0), zt = BigInt(1), Wa = BigInt(2), my = BigInt(8);
function yy(s, e, t, r) {
    const n1 = s.sqr(t), i = s.sqr(r), o = s.add(s.mul(e.a, n1), i), a = s.add(s.ONE, s.mul(e.d, s.mul(n1, i)));
    return s.eql(o, a);
}
function vy(s, e = {}) {
    const t = m0("edwards", s, e, e.FpFnLE), { Fp: r, Fn: n1 } = t;
    let i = t.CURVE;
    const { h: o } = i;
    Li(e, {}, {
        uvRatio: "function"
    });
    const a = Wa << BigInt(n1.BYTES * 8) - zt, l = (E)=>r.create(E), c = e.uvRatio || ((E, b)=>{
        try {
            return {
                isValid: !0,
                value: r.sqrt(r.div(E, b))
            };
        } catch  {
            return {
                isValid: !1,
                value: xs
            };
        }
    });
    if (!yy(r, i, i.Gx, i.Gy)) throw new Error("bad curve params: generator point");
    function u(E, b, L = !1) {
        const A = L ? zt : xs;
        return Ql("coordinate " + E, b, A, a), b;
    }
    function d1(E) {
        if (!(E instanceof p)) throw new Error("ExtendedPoint expected");
    }
    const h = Mo((E, b)=>{
        const { X: L, Y: A, Z: F } = E, M = E.is0();
        b == null && (b = M ? my : r.inv(F));
        const H = l(L * b), K = l(A * b), j = r.mul(F, b);
        if (M) return {
            x: xs,
            y: zt
        };
        if (j !== zt) throw new Error("invZ was invalid");
        return {
            x: H,
            y: K
        };
    }), f = Mo((E)=>{
        const { a: b, d: L } = i;
        if (E.is0()) throw new Error("bad point: ZERO");
        const { X: A, Y: F, Z: M, T: H } = E, K = l(A * A), j = l(F * F), C = l(M * M), k = l(C * C), $ = l(K * b), W = l(C * l($ + j)), _ = l(k + l(L * l(K * j)));
        if (W !== _) throw new Error("bad point: equation left != right (1)");
        const g = l(A * F), x = l(M * H);
        if (g !== x) throw new Error("bad point: equation left != right (2)");
        return !0;
    });
    class p {
        constructor(b, L, A, F){
            this.X = u("x", b), this.Y = u("y", L), this.Z = u("z", A, !0), this.T = u("t", F), Object.freeze(this);
        }
        static CURVE() {
            return i;
        }
        static fromAffine(b) {
            if (b instanceof p) throw new Error("extended point not allowed");
            const { x: L, y: A } = b || {};
            return u("x", L), u("y", A), new p(L, A, zt, l(L * A));
        }
        // Uses algo from RFC8032 5.1.3.
        static fromBytes(b, L = !1) {
            const A = r.BYTES, { a: F, d: M } = i;
            b = fd(Or(b, A, "point")), Xs(L, "zip215");
            const H = fd(b), K = b[A - 1];
            H[A - 1] = K & -129;
            const j = ei(H), C = L ? a : r.ORDER;
            Ql("point.y", j, xs, C);
            const k = l(j * j), $ = l(k - zt), W = l(M * k - F);
            let { isValid: _, value: g } = c($, W);
            if (!_) throw new Error("bad point: invalid y coordinate");
            const x = (g & zt) === zt, w = (K & 128) !== 0;
            if (!L && g === xs && w) throw new Error("bad point: x=0 and x_0=1");
            return w !== x && (g = l(-g)), p.fromAffine({
                x: g,
                y: j
            });
        }
        static fromHex(b, L = !1) {
            return p.fromBytes(Et("point", b), L);
        }
        get x() {
            return this.toAffine().x;
        }
        get y() {
            return this.toAffine().y;
        }
        precompute(b = 8, L = !0) {
            return y.createCache(this, b), L || this.multiply(Wa), this;
        }
        // Useful in fromAffine() - not for fromBytes(), which always created valid points.
        assertValidity() {
            f(this);
        }
        // Compare one point to another.
        equals(b) {
            d1(b);
            const { X: L, Y: A, Z: F } = this, { X: M, Y: H, Z: K } = b, j = l(L * K), C = l(M * F), k = l(A * K), $ = l(H * F);
            return j === C && k === $;
        }
        is0() {
            return this.equals(p.ZERO);
        }
        negate() {
            return new p(l(-this.X), this.Y, this.Z, l(-this.T));
        }
        // Fast algo for doubling Extended Point.
        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
        // Cost: 4M + 4S + 1*a + 6add + 1*2.
        double() {
            const { a: b } = i, { X: L, Y: A, Z: F } = this, M = l(L * L), H = l(A * A), K = l(Wa * l(F * F)), j = l(b * M), C = L + A, k = l(l(C * C) - M - H), $ = j + H, W = $ - K, _ = j - H, g = l(k * W), x = l($ * _), w = l(k * _), D = l(W * $);
            return new p(g, x, D, w);
        }
        // Fast algo for adding 2 Extended Points.
        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
        // Cost: 9M + 1*a + 1*d + 7add.
        add(b) {
            d1(b);
            const { a: L, d: A } = i, { X: F, Y: M, Z: H, T: K } = this, { X: j, Y: C, Z: k, T: $ } = b, W = l(F * j), _ = l(M * C), g = l(K * A * $), x = l(H * k), w = l((F + M) * (j + C) - W - _), D = x - g, O = x + g, U = l(_ - L * W), V = l(w * D), R = l(O * U), m = l(w * U), v = l(D * O);
            return new p(V, R, v, m);
        }
        subtract(b) {
            return this.add(b.negate());
        }
        // Constant-time multiplication.
        multiply(b) {
            if (!n1.isValidNot0(b)) throw new Error("invalid scalar: expected 1 <= sc < curve.n");
            const { p: L, f: A } = y.cached(this, b, (F)=>js(p, F));
            return js(p, [
                L,
                A
            ])[0];
        }
        // Non-constant-time multiplication. Uses double-and-add algorithm.
        // It's faster, but should only be used when you don't care about
        // an exposed private key e.g. sig verification.
        // Does NOT allow scalars higher than CURVE.n.
        // Accepts optional accumulator to merge with multiply (important for sparse scalars)
        multiplyUnsafe(b, L = p.ZERO) {
            if (!n1.isValid(b)) throw new Error("invalid scalar: expected 0 <= sc < curve.n");
            return b === xs ? p.ZERO : this.is0() || b === zt ? this : y.unsafe(this, b, (A)=>js(p, A), L);
        }
        // Checks if point is of small order.
        // If you add something to small order point, you will have "dirty"
        // point with torsion component.
        // Multiplies point by cofactor and checks if the result is 0.
        isSmallOrder() {
            return this.multiplyUnsafe(o).is0();
        }
        // Multiplies point by curve order and checks if the result is 0.
        // Returns `false` is the point is dirty.
        isTorsionFree() {
            return y.unsafe(this, i.n).is0();
        }
        // Converts Extended point to default (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        toAffine(b) {
            return h(this, b);
        }
        clearCofactor() {
            return o === zt ? this : this.multiplyUnsafe(o);
        }
        toBytes() {
            const { x: b, y: L } = this.toAffine(), A = r.toBytes(L);
            return A[A.length - 1] |= b & zt ? 128 : 0, A;
        }
        toHex() {
            return Hs(this.toBytes());
        }
        toString() {
            return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
        }
        // TODO: remove
        get ex() {
            return this.X;
        }
        get ey() {
            return this.Y;
        }
        get ez() {
            return this.Z;
        }
        get et() {
            return this.T;
        }
        static normalizeZ(b) {
            return js(p, b);
        }
        static msm(b, L) {
            return p0(p, n1, b, L);
        }
        _setWindowSize(b) {
            this.precompute(b);
        }
        toRawBytes() {
            return this.toBytes();
        }
    }
    p.BASE = new p(i.Gx, i.Gy, zt, l(i.Gx * i.Gy)), p.ZERO = new p(xs, zt, zt, xs), p.Fp = r, p.Fn = n1;
    const y = new g0(p, n1.BITS);
    return p.BASE.precompute(8), p;
}
function Ey(s, e, t = {}) {
    if (typeof e != "function") throw new Error('"hash" function param is required');
    Li(t, {}, {
        adjustScalarBytes: "function",
        randomBytes: "function",
        domain: "function",
        prehash: "function",
        mapToCurve: "function"
    });
    const { prehash: r } = t, { BASE: n1, Fp: i, Fn: o } = s, a = t.randomBytes || qc, l = t.adjustScalarBytes || ((C)=>C), c = t.domain || ((C, k, $)=>{
        if (Xs($, "phflag"), k.length || $) throw new Error("Contexts/pre-hash are not supported");
        return C;
    });
    function u(C) {
        return o.create(ei(C));
    }
    function d1(C) {
        const k = A.secretKey;
        C = Et("private key", C, k);
        const $ = Et("hashed private key", e(C), 2 * k), W = l($.slice(0, k)), _ = $.slice(k, 2 * k), g = u(W);
        return {
            head: W,
            prefix: _,
            scalar: g
        };
    }
    function h(C) {
        const { head: k, prefix: $, scalar: W } = d1(C), _ = n1.multiply(W), g = _.toBytes();
        return {
            head: k,
            prefix: $,
            scalar: W,
            point: _,
            pointBytes: g
        };
    }
    function f(C) {
        return h(C).pointBytes;
    }
    function p(C = Uint8Array.of(), ...k) {
        const $ = Kr(...k);
        return u(e(c($, Et("context", C), !!r)));
    }
    function y(C, k, $ = {}) {
        C = Et("message", C), r && (C = r(C));
        const { prefix: W, scalar: _, pointBytes: g } = h(k), x = p($.context, W, C), w = n1.multiply(x).toBytes(), D = p($.context, w, g, C), O = o.create(x + D * _);
        if (!o.isValid(O)) throw new Error("sign failed: invalid s");
        const U = Kr(w, o.toBytes(O));
        return Or(U, A.signature, "result");
    }
    const E = {
        zip215: !0
    };
    function b(C, k, $, W = E) {
        const { context: _, zip215: g } = W, x = A.signature;
        C = Et("signature", C, x), k = Et("message", k), $ = Et("publicKey", $, A.publicKey), g !== void 0 && Xs(g, "zip215"), r && (k = r(k));
        const w = x / 2, D = C.subarray(0, w), O = ei(C.subarray(w, x));
        let U, V, R;
        try {
            U = s.fromBytes($, g), V = s.fromBytes(D, g), R = n1.multiplyUnsafe(O);
        } catch  {
            return !1;
        }
        if (!g && U.isSmallOrder()) return !1;
        const m = p(_, V.toBytes(), U.toBytes(), k);
        return V.add(U.multiplyUnsafe(m)).subtract(R).clearCofactor().is0();
    }
    const L = i.BYTES, A = {
        secretKey: L,
        publicKey: L,
        signature: 2 * L,
        seed: L
    };
    function F(C = a(A.seed)) {
        return Or(C, A.seed, "seed");
    }
    function M(C) {
        const k = j.randomSecretKey(C);
        return {
            secretKey: k,
            publicKey: f(k)
        };
    }
    function H(C) {
        return Ii(C) && C.length === o.BYTES;
    }
    function K(C, k) {
        try {
            return !!s.fromBytes(C, k);
        } catch  {
            return !1;
        }
    }
    const j = {
        getExtendedPublicKey: h,
        randomSecretKey: F,
        isValidSecretKey: H,
        isValidPublicKey: K,
        /**
     * Converts ed public key to x public key. Uses formula:
     * - ed25519:
     *   - `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`
     *   - `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`
     * - ed448:
     *   - `(u, v) = ((y-1)/(y+1), sqrt(156324)*u/x)`
     *   - `(x, y) = (sqrt(156324)*u/v, (1+u)/(1-u))`
     */ toMontgomery (C) {
            const { y: k } = s.fromBytes(C), $ = A.publicKey, W = $ === 32;
            if (!W && $ !== 57) throw new Error("only defined for 25519 and 448");
            const _ = W ? i.div(zt + k, zt - k) : i.div(k - zt, k + zt);
            return i.toBytes(_);
        },
        toMontgomerySecret (C) {
            const k = A.secretKey;
            Or(C, k);
            const $ = e(C.subarray(0, k));
            return l($).subarray(0, k);
        },
        /** @deprecated */ randomPrivateKey: F,
        /** @deprecated */ precompute (C = 8, k = s.BASE) {
            return k.precompute(C, !1);
        }
    };
    return Object.freeze({
        keygen: M,
        getPublicKey: f,
        sign: y,
        verify: b,
        utils: j,
        Point: s,
        lengths: A
    });
}
function xy(s) {
    const e = {
        a: s.a,
        d: s.d,
        p: s.Fp.ORDER,
        n: s.n,
        h: s.h,
        Gx: s.Gx,
        Gy: s.Gy
    }, t = s.Fp, r = en(e.n, s.nBitLength, !0), n1 = {
        Fp: t,
        Fn: r,
        uvRatio: s.uvRatio
    }, i = {
        randomBytes: s.randomBytes,
        adjustScalarBytes: s.adjustScalarBytes,
        domain: s.domain,
        prehash: s.prehash,
        mapToCurve: s.mapToCurve
    };
    return {
        CURVE: e,
        curveOpts: n1,
        hash: s.hash,
        eddsaOpts: i
    };
}
function Sy(s, e) {
    const t = e.Point;
    return Object.assign({}, e, {
        ExtendedPoint: t,
        CURVE: s,
        nBitLength: t.Fn.BITS,
        nByteLength: t.Fn.BYTES
    });
}
function by(s) {
    const { CURVE: e, curveOpts: t, hash: r, eddsaOpts: n1 } = xy(s), i = vy(e, t), o = Ey(i, r, n1);
    return Sy(s, o);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const Ty = BigInt(1), Ed = BigInt(2);
BigInt(3);
const wy = BigInt(5), Ay = BigInt(8), Zc = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"), y0 = {
    p: Zc,
    n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),
    h: Ay,
    a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),
    d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),
    Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),
    Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")
};
function Iy(s) {
    const e = BigInt(10), t = BigInt(20), r = BigInt(40), n1 = BigInt(80), i = Zc, a = s * s % i * s % i, l = vt(a, Ed, i) * a % i, c = vt(l, Ty, i) * s % i, u = vt(c, wy, i) * c % i, d1 = vt(u, e, i) * u % i, h = vt(d1, t, i) * d1 % i, f = vt(h, r, i) * h % i, p = vt(f, n1, i) * f % i, y = vt(p, n1, i) * f % i, E = vt(y, e, i) * u % i;
    return {
        pow_p_5_8: vt(E, Ed, i) * s % i,
        b2: a
    };
}
function _y(s) {
    return s[0] &= 248, s[31] &= 127, s[31] |= 64, s;
}
const xd = /* @__PURE__ */ BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
function Ly(s, e) {
    const t = Zc, r = Gt(e * e * e, t), n1 = Gt(r * r * e, t), i = Iy(s * n1).pow_p_5_8;
    let o = Gt(s * r * i, t);
    const a = Gt(e * o * o, t), l = o, c = Gt(o * xd, t), u = a === s, d1 = a === Gt(-s, t), h = a === Gt(-s * xd, t);
    return u && (o = l), (d1 || h) && (o = c), ly(o, t) && (o = Gt(-o, t)), {
        isValid: u || d1,
        value: o
    };
}
const Ry = en(y0.p, {
    isLE: !0
}), Cy = {
    ...y0,
    Fp: Ry,
    hash: ey,
    adjustScalarBytes: _y,
    // dom2
    // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
    // Constant-time, u/v
    uvRatio: Ly
}, Ri = by(Cy);
var co = {
    exports: {}
};
const ky = {}, Dy = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: ky
}, Symbol.toStringTag, {
    value: "Module"
})), Py = /* @__PURE__ */ Nc(Dy);
var My = co.exports, Sd;
function v0() {
    return Sd || (Sd = 1, function(s) {
        (function(e, t) {
            function r(_, g) {
                if (!_) throw new Error(g || "Assertion failed");
            }
            function n1(_, g) {
                _.super_ = g;
                var x = function() {};
                x.prototype = g.prototype, _.prototype = new x(), _.prototype.constructor = _;
            }
            function i(_, g, x) {
                if (i.isBN(_)) return _;
                this.negative = 0, this.words = null, this.length = 0, this.red = null, _ !== null && ((g === "le" || g === "be") && (x = g, g = 10), this._init(_ || 0, g || 10, x || "be"));
            }
            typeof e == "object" ? e.exports = i : t.BN = i, i.BN = i, i.wordSize = 26;
            var o;
            try {
                ("TURBOPACK compile-time value", "undefined") < "u" && typeof window.Buffer < "u" ? o = window.Buffer : o = Py.Buffer;
            } catch  {}
            i.isBN = function(g) {
                return g instanceof i ? !0 : g !== null && typeof g == "object" && g.constructor.wordSize === i.wordSize && Array.isArray(g.words);
            }, i.max = function(g, x) {
                return g.cmp(x) > 0 ? g : x;
            }, i.min = function(g, x) {
                return g.cmp(x) < 0 ? g : x;
            }, i.prototype._init = function(g, x, w) {
                if (typeof g == "number") return this._initNumber(g, x, w);
                if (typeof g == "object") return this._initArray(g, x, w);
                x === "hex" && (x = 16), r(x === (x | 0) && x >= 2 && x <= 36), g = g.toString().replace(/\s+/g, "");
                var D = 0;
                g[0] === "-" && (D++, this.negative = 1), D < g.length && (x === 16 ? this._parseHex(g, D, w) : (this._parseBase(g, x, D), w === "le" && this._initArray(this.toArray(), x, w)));
            }, i.prototype._initNumber = function(g, x, w) {
                g < 0 && (this.negative = 1, g = -g), g < 67108864 ? (this.words = [
                    g & 67108863
                ], this.length = 1) : g < 4503599627370496 ? (this.words = [
                    g & 67108863,
                    g / 67108864 & 67108863
                ], this.length = 2) : (r(g < 9007199254740992), this.words = [
                    g & 67108863,
                    g / 67108864 & 67108863,
                    1
                ], this.length = 3), w === "le" && this._initArray(this.toArray(), x, w);
            }, i.prototype._initArray = function(g, x, w) {
                if (r(typeof g.length == "number"), g.length <= 0) return this.words = [
                    0
                ], this.length = 1, this;
                this.length = Math.ceil(g.length / 3), this.words = new Array(this.length);
                for(var D = 0; D < this.length; D++)this.words[D] = 0;
                var O, U, V = 0;
                if (w === "be") for(D = g.length - 1, O = 0; D >= 0; D -= 3)U = g[D] | g[D - 1] << 8 | g[D - 2] << 16, this.words[O] |= U << V & 67108863, this.words[O + 1] = U >>> 26 - V & 67108863, V += 24, V >= 26 && (V -= 26, O++);
                else if (w === "le") for(D = 0, O = 0; D < g.length; D += 3)U = g[D] | g[D + 1] << 8 | g[D + 2] << 16, this.words[O] |= U << V & 67108863, this.words[O + 1] = U >>> 26 - V & 67108863, V += 24, V >= 26 && (V -= 26, O++);
                return this._strip();
            };
            function a(_, g) {
                var x = _.charCodeAt(g);
                if (x >= 48 && x <= 57) return x - 48;
                if (x >= 65 && x <= 70) return x - 55;
                if (x >= 97 && x <= 102) return x - 87;
                r(!1, "Invalid character in " + _);
            }
            function l(_, g, x) {
                var w = a(_, x);
                return x - 1 >= g && (w |= a(_, x - 1) << 4), w;
            }
            i.prototype._parseHex = function(g, x, w) {
                this.length = Math.ceil((g.length - x) / 6), this.words = new Array(this.length);
                for(var D = 0; D < this.length; D++)this.words[D] = 0;
                var O = 0, U = 0, V;
                if (w === "be") for(D = g.length - 1; D >= x; D -= 2)V = l(g, x, D) << O, this.words[U] |= V & 67108863, O >= 18 ? (O -= 18, U += 1, this.words[U] |= V >>> 26) : O += 8;
                else {
                    var R = g.length - x;
                    for(D = R % 2 === 0 ? x + 1 : x; D < g.length; D += 2)V = l(g, x, D) << O, this.words[U] |= V & 67108863, O >= 18 ? (O -= 18, U += 1, this.words[U] |= V >>> 26) : O += 8;
                }
                this._strip();
            };
            function c(_, g, x, w) {
                for(var D = 0, O = 0, U = Math.min(_.length, x), V = g; V < U; V++){
                    var R = _.charCodeAt(V) - 48;
                    D *= w, R >= 49 ? O = R - 49 + 10 : R >= 17 ? O = R - 17 + 10 : O = R, r(R >= 0 && O < w, "Invalid character"), D += O;
                }
                return D;
            }
            i.prototype._parseBase = function(g, x, w) {
                this.words = [
                    0
                ], this.length = 1;
                for(var D = 0, O = 1; O <= 67108863; O *= x)D++;
                D--, O = O / x | 0;
                for(var U = g.length - w, V = U % D, R = Math.min(U, U - V) + w, m = 0, v = w; v < R; v += D)m = c(g, v, v + D, x), this.imuln(O), this.words[0] + m < 67108864 ? this.words[0] += m : this._iaddn(m);
                if (V !== 0) {
                    var P = 1;
                    for(m = c(g, v, g.length, x), v = 0; v < V; v++)P *= x;
                    this.imuln(P), this.words[0] + m < 67108864 ? this.words[0] += m : this._iaddn(m);
                }
                this._strip();
            }, i.prototype.copy = function(g) {
                g.words = new Array(this.length);
                for(var x = 0; x < this.length; x++)g.words[x] = this.words[x];
                g.length = this.length, g.negative = this.negative, g.red = this.red;
            };
            function u(_, g) {
                _.words = g.words, _.length = g.length, _.negative = g.negative, _.red = g.red;
            }
            if (i.prototype._move = function(g) {
                u(g, this);
            }, i.prototype.clone = function() {
                var g = new i(null);
                return this.copy(g), g;
            }, i.prototype._expand = function(g) {
                for(; this.length < g;)this.words[this.length++] = 0;
                return this;
            }, i.prototype._strip = function() {
                for(; this.length > 1 && this.words[this.length - 1] === 0;)this.length--;
                return this._normSign();
            }, i.prototype._normSign = function() {
                return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
            }, typeof Symbol < "u" && typeof Symbol.for == "function") try {
                i.prototype[Symbol.for("nodejs.util.inspect.custom")] = d1;
            } catch  {
                i.prototype.inspect = d1;
            }
            else i.prototype.inspect = d1;
            function d1() {
                return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
            }
            var h = [
                "",
                "0",
                "00",
                "000",
                "0000",
                "00000",
                "000000",
                "0000000",
                "00000000",
                "000000000",
                "0000000000",
                "00000000000",
                "000000000000",
                "0000000000000",
                "00000000000000",
                "000000000000000",
                "0000000000000000",
                "00000000000000000",
                "000000000000000000",
                "0000000000000000000",
                "00000000000000000000",
                "000000000000000000000",
                "0000000000000000000000",
                "00000000000000000000000",
                "000000000000000000000000",
                "0000000000000000000000000"
            ], f = [
                0,
                0,
                25,
                16,
                12,
                11,
                10,
                9,
                8,
                8,
                7,
                7,
                7,
                7,
                6,
                6,
                6,
                6,
                6,
                6,
                6,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5
            ], p = [
                0,
                0,
                33554432,
                43046721,
                16777216,
                48828125,
                60466176,
                40353607,
                16777216,
                43046721,
                1e7,
                19487171,
                35831808,
                62748517,
                7529536,
                11390625,
                16777216,
                24137569,
                34012224,
                47045881,
                64e6,
                4084101,
                5153632,
                6436343,
                7962624,
                9765625,
                11881376,
                14348907,
                17210368,
                20511149,
                243e5,
                28629151,
                33554432,
                39135393,
                45435424,
                52521875,
                60466176
            ];
            i.prototype.toString = function(g, x) {
                g = g || 10, x = x | 0 || 1;
                var w;
                if (g === 16 || g === "hex") {
                    w = "";
                    for(var D = 0, O = 0, U = 0; U < this.length; U++){
                        var V = this.words[U], R = ((V << D | O) & 16777215).toString(16);
                        O = V >>> 24 - D & 16777215, D += 2, D >= 26 && (D -= 26, U--), O !== 0 || U !== this.length - 1 ? w = h[6 - R.length] + R + w : w = R + w;
                    }
                    for(O !== 0 && (w = O.toString(16) + w); w.length % x !== 0;)w = "0" + w;
                    return this.negative !== 0 && (w = "-" + w), w;
                }
                if (g === (g | 0) && g >= 2 && g <= 36) {
                    var m = f[g], v = p[g];
                    w = "";
                    var P = this.clone();
                    for(P.negative = 0; !P.isZero();){
                        var N = P.modrn(v).toString(g);
                        P = P.idivn(v), P.isZero() ? w = N + w : w = h[m - N.length] + N + w;
                    }
                    for(this.isZero() && (w = "0" + w); w.length % x !== 0;)w = "0" + w;
                    return this.negative !== 0 && (w = "-" + w), w;
                }
                r(!1, "Base should be between 2 and 36");
            }, i.prototype.toNumber = function() {
                var g = this.words[0];
                return this.length === 2 ? g += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? g += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -g : g;
            }, i.prototype.toJSON = function() {
                return this.toString(16, 2);
            }, o && (i.prototype.toBuffer = function(g, x) {
                return this.toArrayLike(o, g, x);
            }), i.prototype.toArray = function(g, x) {
                return this.toArrayLike(Array, g, x);
            };
            var y = function(g, x) {
                return g.allocUnsafe ? g.allocUnsafe(x) : new g(x);
            };
            i.prototype.toArrayLike = function(g, x, w) {
                this._strip();
                var D = this.byteLength(), O = w || Math.max(1, D);
                r(D <= O, "byte array longer than desired length"), r(O > 0, "Requested array length <= 0");
                var U = y(g, O), V = x === "le" ? "LE" : "BE";
                return this["_toArrayLike" + V](U, D), U;
            }, i.prototype._toArrayLikeLE = function(g, x) {
                for(var w = 0, D = 0, O = 0, U = 0; O < this.length; O++){
                    var V = this.words[O] << U | D;
                    g[w++] = V & 255, w < g.length && (g[w++] = V >> 8 & 255), w < g.length && (g[w++] = V >> 16 & 255), U === 6 ? (w < g.length && (g[w++] = V >> 24 & 255), D = 0, U = 0) : (D = V >>> 24, U += 2);
                }
                if (w < g.length) for(g[w++] = D; w < g.length;)g[w++] = 0;
            }, i.prototype._toArrayLikeBE = function(g, x) {
                for(var w = g.length - 1, D = 0, O = 0, U = 0; O < this.length; O++){
                    var V = this.words[O] << U | D;
                    g[w--] = V & 255, w >= 0 && (g[w--] = V >> 8 & 255), w >= 0 && (g[w--] = V >> 16 & 255), U === 6 ? (w >= 0 && (g[w--] = V >> 24 & 255), D = 0, U = 0) : (D = V >>> 24, U += 2);
                }
                if (w >= 0) for(g[w--] = D; w >= 0;)g[w--] = 0;
            }, Math.clz32 ? i.prototype._countBits = function(g) {
                return 32 - Math.clz32(g);
            } : i.prototype._countBits = function(g) {
                var x = g, w = 0;
                return x >= 4096 && (w += 13, x >>>= 13), x >= 64 && (w += 7, x >>>= 7), x >= 8 && (w += 4, x >>>= 4), x >= 2 && (w += 2, x >>>= 2), w + x;
            }, i.prototype._zeroBits = function(g) {
                if (g === 0) return 26;
                var x = g, w = 0;
                return (x & 8191) === 0 && (w += 13, x >>>= 13), (x & 127) === 0 && (w += 7, x >>>= 7), (x & 15) === 0 && (w += 4, x >>>= 4), (x & 3) === 0 && (w += 2, x >>>= 2), (x & 1) === 0 && w++, w;
            }, i.prototype.bitLength = function() {
                var g = this.words[this.length - 1], x = this._countBits(g);
                return (this.length - 1) * 26 + x;
            };
            function E(_) {
                for(var g = new Array(_.bitLength()), x = 0; x < g.length; x++){
                    var w = x / 26 | 0, D = x % 26;
                    g[x] = _.words[w] >>> D & 1;
                }
                return g;
            }
            i.prototype.zeroBits = function() {
                if (this.isZero()) return 0;
                for(var g = 0, x = 0; x < this.length; x++){
                    var w = this._zeroBits(this.words[x]);
                    if (g += w, w !== 26) break;
                }
                return g;
            }, i.prototype.byteLength = function() {
                return Math.ceil(this.bitLength() / 8);
            }, i.prototype.toTwos = function(g) {
                return this.negative !== 0 ? this.abs().inotn(g).iaddn(1) : this.clone();
            }, i.prototype.fromTwos = function(g) {
                return this.testn(g - 1) ? this.notn(g).iaddn(1).ineg() : this.clone();
            }, i.prototype.isNeg = function() {
                return this.negative !== 0;
            }, i.prototype.neg = function() {
                return this.clone().ineg();
            }, i.prototype.ineg = function() {
                return this.isZero() || (this.negative ^= 1), this;
            }, i.prototype.iuor = function(g) {
                for(; this.length < g.length;)this.words[this.length++] = 0;
                for(var x = 0; x < g.length; x++)this.words[x] = this.words[x] | g.words[x];
                return this._strip();
            }, i.prototype.ior = function(g) {
                return r((this.negative | g.negative) === 0), this.iuor(g);
            }, i.prototype.or = function(g) {
                return this.length > g.length ? this.clone().ior(g) : g.clone().ior(this);
            }, i.prototype.uor = function(g) {
                return this.length > g.length ? this.clone().iuor(g) : g.clone().iuor(this);
            }, i.prototype.iuand = function(g) {
                var x;
                this.length > g.length ? x = g : x = this;
                for(var w = 0; w < x.length; w++)this.words[w] = this.words[w] & g.words[w];
                return this.length = x.length, this._strip();
            }, i.prototype.iand = function(g) {
                return r((this.negative | g.negative) === 0), this.iuand(g);
            }, i.prototype.and = function(g) {
                return this.length > g.length ? this.clone().iand(g) : g.clone().iand(this);
            }, i.prototype.uand = function(g) {
                return this.length > g.length ? this.clone().iuand(g) : g.clone().iuand(this);
            }, i.prototype.iuxor = function(g) {
                var x, w;
                this.length > g.length ? (x = this, w = g) : (x = g, w = this);
                for(var D = 0; D < w.length; D++)this.words[D] = x.words[D] ^ w.words[D];
                if (this !== x) for(; D < x.length; D++)this.words[D] = x.words[D];
                return this.length = x.length, this._strip();
            }, i.prototype.ixor = function(g) {
                return r((this.negative | g.negative) === 0), this.iuxor(g);
            }, i.prototype.xor = function(g) {
                return this.length > g.length ? this.clone().ixor(g) : g.clone().ixor(this);
            }, i.prototype.uxor = function(g) {
                return this.length > g.length ? this.clone().iuxor(g) : g.clone().iuxor(this);
            }, i.prototype.inotn = function(g) {
                r(typeof g == "number" && g >= 0);
                var x = Math.ceil(g / 26) | 0, w = g % 26;
                this._expand(x), w > 0 && x--;
                for(var D = 0; D < x; D++)this.words[D] = ~this.words[D] & 67108863;
                return w > 0 && (this.words[D] = ~this.words[D] & 67108863 >> 26 - w), this._strip();
            }, i.prototype.notn = function(g) {
                return this.clone().inotn(g);
            }, i.prototype.setn = function(g, x) {
                r(typeof g == "number" && g >= 0);
                var w = g / 26 | 0, D = g % 26;
                return this._expand(w + 1), x ? this.words[w] = this.words[w] | 1 << D : this.words[w] = this.words[w] & ~(1 << D), this._strip();
            }, i.prototype.iadd = function(g) {
                var x;
                if (this.negative !== 0 && g.negative === 0) return this.negative = 0, x = this.isub(g), this.negative ^= 1, this._normSign();
                if (this.negative === 0 && g.negative !== 0) return g.negative = 0, x = this.isub(g), g.negative = 1, x._normSign();
                var w, D;
                this.length > g.length ? (w = this, D = g) : (w = g, D = this);
                for(var O = 0, U = 0; U < D.length; U++)x = (w.words[U] | 0) + (D.words[U] | 0) + O, this.words[U] = x & 67108863, O = x >>> 26;
                for(; O !== 0 && U < w.length; U++)x = (w.words[U] | 0) + O, this.words[U] = x & 67108863, O = x >>> 26;
                if (this.length = w.length, O !== 0) this.words[this.length] = O, this.length++;
                else if (w !== this) for(; U < w.length; U++)this.words[U] = w.words[U];
                return this;
            }, i.prototype.add = function(g) {
                var x;
                return g.negative !== 0 && this.negative === 0 ? (g.negative = 0, x = this.sub(g), g.negative ^= 1, x) : g.negative === 0 && this.negative !== 0 ? (this.negative = 0, x = g.sub(this), this.negative = 1, x) : this.length > g.length ? this.clone().iadd(g) : g.clone().iadd(this);
            }, i.prototype.isub = function(g) {
                if (g.negative !== 0) {
                    g.negative = 0;
                    var x = this.iadd(g);
                    return g.negative = 1, x._normSign();
                } else if (this.negative !== 0) return this.negative = 0, this.iadd(g), this.negative = 1, this._normSign();
                var w = this.cmp(g);
                if (w === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
                var D, O;
                w > 0 ? (D = this, O = g) : (D = g, O = this);
                for(var U = 0, V = 0; V < O.length; V++)x = (D.words[V] | 0) - (O.words[V] | 0) + U, U = x >> 26, this.words[V] = x & 67108863;
                for(; U !== 0 && V < D.length; V++)x = (D.words[V] | 0) + U, U = x >> 26, this.words[V] = x & 67108863;
                if (U === 0 && V < D.length && D !== this) for(; V < D.length; V++)this.words[V] = D.words[V];
                return this.length = Math.max(this.length, V), D !== this && (this.negative = 1), this._strip();
            }, i.prototype.sub = function(g) {
                return this.clone().isub(g);
            };
            function b(_, g, x) {
                x.negative = g.negative ^ _.negative;
                var w = _.length + g.length | 0;
                x.length = w, w = w - 1 | 0;
                var D = _.words[0] | 0, O = g.words[0] | 0, U = D * O, V = U & 67108863, R = U / 67108864 | 0;
                x.words[0] = V;
                for(var m = 1; m < w; m++){
                    for(var v = R >>> 26, P = R & 67108863, N = Math.min(m, g.length - 1), Y = Math.max(0, m - _.length + 1); Y <= N; Y++){
                        var ee = m - Y | 0;
                        D = _.words[ee] | 0, O = g.words[Y] | 0, U = D * O + P, v += U / 67108864 | 0, P = U & 67108863;
                    }
                    x.words[m] = P | 0, R = v | 0;
                }
                return R !== 0 ? x.words[m] = R | 0 : x.length--, x._strip();
            }
            var L = function(g, x, w) {
                var D = g.words, O = x.words, U = w.words, V = 0, R, m, v, P = D[0] | 0, N = P & 8191, Y = P >>> 13, ee = D[1] | 0, ie = ee & 8191, le = ee >>> 13, Te = D[2] | 0, De = Te & 8191, ze = Te >>> 13, _e = D[3] | 0, xe = _e & 8191, Be = _e >>> 13, ye = D[4] | 0, be = ye & 8191, Fe = ye >>> 13, Xe = D[5] | 0, we = Xe & 8191, Ne = Xe >>> 13, dt = D[6] | 0, Je = dt & 8191, Qe = dt >>> 13, it = D[7] | 0, je = it & 8191, B = it >>> 13, S = D[8] | 0, T = S & 8191, G = S >>> 13, Z = D[9] | 0, Q = Z & 8191, se = Z >>> 13, Ue = O[0] | 0, Pe = Ue & 8191, Re = Ue >>> 13, ct = O[1] | 0, Ae = ct & 8191, Tt = ct >>> 13, Uu = O[2] | 0, wt = Uu & 8191, At = Uu >>> 13, $u = O[3] | 0, It = $u & 8191, _t = $u >>> 13, Gu = O[4] | 0, Lt = Gu & 8191, Rt = Gu >>> 13, Vu = O[5] | 0, Ct = Vu & 8191, kt = Vu >>> 13, ju = O[6] | 0, Dt = ju & 8191, Pt = ju >>> 13, Ku = O[7] | 0, Mt = Ku & 8191, Ot = Ku >>> 13, Hu = O[8] | 0, Bt = Hu & 8191, Ft = Hu >>> 13, qu = O[9] | 0, Nt = qu & 8191, Ut = qu >>> 13;
                w.negative = g.negative ^ x.negative, w.length = 19, R = Math.imul(N, Pe), m = Math.imul(N, Re), m = m + Math.imul(Y, Pe) | 0, v = Math.imul(Y, Re);
                var xa = (V + R | 0) + ((m & 8191) << 13) | 0;
                V = (v + (m >>> 13) | 0) + (xa >>> 26) | 0, xa &= 67108863, R = Math.imul(ie, Pe), m = Math.imul(ie, Re), m = m + Math.imul(le, Pe) | 0, v = Math.imul(le, Re), R = R + Math.imul(N, Ae) | 0, m = m + Math.imul(N, Tt) | 0, m = m + Math.imul(Y, Ae) | 0, v = v + Math.imul(Y, Tt) | 0;
                var Sa = (V + R | 0) + ((m & 8191) << 13) | 0;
                V = (v + (m >>> 13) | 0) + (Sa >>> 26) | 0, Sa &= 67108863, R = Math.imul(De, Pe), m = Math.imul(De, Re), m = m + Math.imul(ze, Pe) | 0, v = Math.imul(ze, Re), R = R + Math.imul(ie, Ae) | 0, m = m + Math.imul(ie, Tt) | 0, m = m + Math.imul(le, Ae) | 0, v = v + Math.imul(le, Tt) | 0, R = R + Math.imul(N, wt) | 0, m = m + Math.imul(N, At) | 0, m = m + Math.imul(Y, wt) | 0, v = v + Math.imul(Y, At) | 0;
                var ba = (V + R | 0) + ((m & 8191) << 13) | 0;
                V = (v + (m >>> 13) | 0) + (ba >>> 26) | 0, ba &= 67108863, R = Math.imul(xe, Pe), m = Math.imul(xe, Re), m = m + Math.imul(Be, Pe) | 0, v = Math.imul(Be, Re), R = R + Math.imul(De, Ae) | 0, m = m + Math.imul(De, Tt) | 0, m = m + Math.imul(ze, Ae) | 0, v = v + Math.imul(ze, Tt) | 0, R = R + Math.imul(ie, wt) | 0, m = m + Math.imul(ie, At) | 0, m = m + Math.imul(le, wt) | 0, v = v + Math.imul(le, At) | 0, R = R + Math.imul(N, It) | 0, m = m + Math.imul(N, _t) | 0, m = m + Math.imul(Y, It) | 0, v = v + Math.imul(Y, _t) | 0;
                var Ta = (V + R | 0) + ((m & 8191) << 13) | 0;
                V = (v + (m >>> 13) | 0) + (Ta >>> 26) | 0, Ta &= 67108863, R = Math.imul(be, Pe), m = Math.imul(be, Re), m = m + Math.imul(Fe, Pe) | 0, v = Math.imul(Fe, Re), R = R + Math.imul(xe, Ae) | 0, m = m + Math.imul(xe, Tt) | 0, m = m + Math.imul(Be, Ae) | 0, v = v + Math.imul(Be, Tt) | 0, R = R + Math.imul(De, wt) | 0, m = m + Math.imul(De, At) | 0, m = m + Math.imul(ze, wt) | 0, v = v + Math.imul(ze, At) | 0, R = R + Math.imul(ie, It) | 0, m = m + Math.imul(ie, _t) | 0, m = m + Math.imul(le, It) | 0, v = v + Math.imul(le, _t) | 0, R = R + Math.imul(N, Lt) | 0, m = m + Math.imul(N, Rt) | 0, m = m + Math.imul(Y, Lt) | 0, v = v + Math.imul(Y, Rt) | 0;
                var wa = (V + R | 0) + ((m & 8191) << 13) | 0;
                V = (v + (m >>> 13) | 0) + (wa >>> 26) | 0, wa &= 67108863, R = Math.imul(we, Pe), m = Math.imul(we, Re), m = m + Math.imul(Ne, Pe) | 0, v = Math.imul(Ne, Re), R = R + Math.imul(be, Ae) | 0, m = m + Math.imul(be, Tt) | 0, m = m + Math.imul(Fe, Ae) | 0, v = v + Math.imul(Fe, Tt) | 0, R = R + Math.imul(xe, wt) | 0, m = m + Math.imul(xe, At) | 0, m = m + Math.imul(Be, wt) | 0, v = v + Math.imul(Be, At) | 0, R = R + Math.imul(De, It) | 0, m = m + Math.imul(De, _t) | 0, m = m + Math.imul(ze, It) | 0, v = v + Math.imul(ze, _t) | 0, R = R + Math.imul(ie, Lt) | 0, m = m + Math.imul(ie, Rt) | 0, m = m + Math.imul(le, Lt) | 0, v = v + Math.imul(le, Rt) | 0, R = R + Math.imul(N, Ct) | 0, m = m + Math.imul(N, kt) | 0, m = m + Math.imul(Y, Ct) | 0, v = v + Math.imul(Y, kt) | 0;
                var Aa = (V + R | 0) + ((m & 8191) << 13) | 0;
                V = (v + (m >>> 13) | 0) + (Aa >>> 26) | 0, Aa &= 67108863, R = Math.imul(Je, Pe), m = Math.imul(Je, Re), m = m + Math.imul(Qe, Pe) | 0, v = Math.imul(Qe, Re), R = R + Math.imul(we, Ae) | 0, m = m + Math.imul(we, Tt) | 0, m = m + Math.imul(Ne, Ae) | 0, v = v + Math.imul(Ne, Tt) | 0, R = R + Math.imul(be, wt) | 0, m = m + Math.imul(be, At) | 0, m = m + Math.imul(Fe, wt) | 0, v = v + Math.imul(Fe, At) | 0, R = R + Math.imul(xe, It) | 0, m = m + Math.imul(xe, _t) | 0, m = m + Math.imul(Be, It) | 0, v = v + Math.imul(Be, _t) | 0, R = R + Math.imul(De, Lt) | 0, m = m + Math.imul(De, Rt) | 0, m = m + Math.imul(ze, Lt) | 0, v = v + Math.imul(ze, Rt) | 0, R = R + Math.imul(ie, Ct) | 0, m = m + Math.imul(ie, kt) | 0, m = m + Math.imul(le, Ct) | 0, v = v + Math.imul(le, kt) | 0, R = R + Math.imul(N, Dt) | 0, m = m + Math.imul(N, Pt) | 0, m = m + Math.imul(Y, Dt) | 0, v = v + Math.imul(Y, Pt) | 0;
                var Ia = (V + R | 0) + ((m & 8191) << 13) | 0;
                V = (v + (m >>> 13) | 0) + (Ia >>> 26) | 0, Ia &= 67108863, R = Math.imul(je, Pe), m = Math.imul(je, Re), m = m + Math.imul(B, Pe) | 0, v = Math.imul(B, Re), R = R + Math.imul(Je, Ae) | 0, m = m + Math.imul(Je, Tt) | 0, m = m + Math.imul(Qe, Ae) | 0, v = v + Math.imul(Qe, Tt) | 0, R = R + Math.imul(we, wt) | 0, m = m + Math.imul(we, At) | 0, m = m + Math.imul(Ne, wt) | 0, v = v + Math.imul(Ne, At) | 0, R = R + Math.imul(be, It) | 0, m = m + Math.imul(be, _t) | 0, m = m + Math.imul(Fe, It) | 0, v = v + Math.imul(Fe, _t) | 0, R = R + Math.imul(xe, Lt) | 0, m = m + Math.imul(xe, Rt) | 0, m = m + Math.imul(Be, Lt) | 0, v = v + Math.imul(Be, Rt) | 0, R = R + Math.imul(De, Ct) | 0, m = m + Math.imul(De, kt) | 0, m = m + Math.imul(ze, Ct) | 0, v = v + Math.imul(ze, kt) | 0, R = R + Math.imul(ie, Dt) | 0, m = m + Math.imul(ie, Pt) | 0, m = m + Math.imul(le, Dt) | 0, v = v + Math.imul(le, Pt) | 0, R = R + Math.imul(N, Mt) | 0, m = m + Math.imul(N, Ot) | 0, m = m + Math.imul(Y, Mt) | 0, v = v + Math.imul(Y, Ot) | 0;
                var _a = (V + R | 0) + ((m & 8191) << 13) | 0;
                V = (v + (m >>> 13) | 0) + (_a >>> 26) | 0, _a &= 67108863, R = Math.imul(T, Pe), m = Math.imul(T, Re), m = m + Math.imul(G, Pe) | 0, v = Math.imul(G, Re), R = R + Math.imul(je, Ae) | 0, m = m + Math.imul(je, Tt) | 0, m = m + Math.imul(B, Ae) | 0, v = v + Math.imul(B, Tt) | 0, R = R + Math.imul(Je, wt) | 0, m = m + Math.imul(Je, At) | 0, m = m + Math.imul(Qe, wt) | 0, v = v + Math.imul(Qe, At) | 0, R = R + Math.imul(we, It) | 0, m = m + Math.imul(we, _t) | 0, m = m + Math.imul(Ne, It) | 0, v = v + Math.imul(Ne, _t) | 0, R = R + Math.imul(be, Lt) | 0, m = m + Math.imul(be, Rt) | 0, m = m + Math.imul(Fe, Lt) | 0, v = v + Math.imul(Fe, Rt) | 0, R = R + Math.imul(xe, Ct) | 0, m = m + Math.imul(xe, kt) | 0, m = m + Math.imul(Be, Ct) | 0, v = v + Math.imul(Be, kt) | 0, R = R + Math.imul(De, Dt) | 0, m = m + Math.imul(De, Pt) | 0, m = m + Math.imul(ze, Dt) | 0, v = v + Math.imul(ze, Pt) | 0, R = R + Math.imul(ie, Mt) | 0, m = m + Math.imul(ie, Ot) | 0, m = m + Math.imul(le, Mt) | 0, v = v + Math.imul(le, Ot) | 0, R = R + Math.imul(N, Bt) | 0, m = m + Math.imul(N, Ft) | 0, m = m + Math.imul(Y, Bt) | 0, v = v + Math.imul(Y, Ft) | 0;
                var La = (V + R | 0) + ((m & 8191) << 13) | 0;
                V = (v + (m >>> 13) | 0) + (La >>> 26) | 0, La &= 67108863, R = Math.imul(Q, Pe), m = Math.imul(Q, Re), m = m + Math.imul(se, Pe) | 0, v = Math.imul(se, Re), R = R + Math.imul(T, Ae) | 0, m = m + Math.imul(T, Tt) | 0, m = m + Math.imul(G, Ae) | 0, v = v + Math.imul(G, Tt) | 0, R = R + Math.imul(je, wt) | 0, m = m + Math.imul(je, At) | 0, m = m + Math.imul(B, wt) | 0, v = v + Math.imul(B, At) | 0, R = R + Math.imul(Je, It) | 0, m = m + Math.imul(Je, _t) | 0, m = m + Math.imul(Qe, It) | 0, v = v + Math.imul(Qe, _t) | 0, R = R + Math.imul(we, Lt) | 0, m = m + Math.imul(we, Rt) | 0, m = m + Math.imul(Ne, Lt) | 0, v = v + Math.imul(Ne, Rt) | 0, R = R + Math.imul(be, Ct) | 0, m = m + Math.imul(be, kt) | 0, m = m + Math.imul(Fe, Ct) | 0, v = v + Math.imul(Fe, kt) | 0, R = R + Math.imul(xe, Dt) | 0, m = m + Math.imul(xe, Pt) | 0, m = m + Math.imul(Be, Dt) | 0, v = v + Math.imul(Be, Pt) | 0, R = R + Math.imul(De, Mt) | 0, m = m + Math.imul(De, Ot) | 0, m = m + Math.imul(ze, Mt) | 0, v = v + Math.imul(ze, Ot) | 0, R = R + Math.imul(ie, Bt) | 0, m = m + Math.imul(ie, Ft) | 0, m = m + Math.imul(le, Bt) | 0, v = v + Math.imul(le, Ft) | 0, R = R + Math.imul(N, Nt) | 0, m = m + Math.imul(N, Ut) | 0, m = m + Math.imul(Y, Nt) | 0, v = v + Math.imul(Y, Ut) | 0;
                var Ra = (V + R | 0) + ((m & 8191) << 13) | 0;
                V = (v + (m >>> 13) | 0) + (Ra >>> 26) | 0, Ra &= 67108863, R = Math.imul(Q, Ae), m = Math.imul(Q, Tt), m = m + Math.imul(se, Ae) | 0, v = Math.imul(se, Tt), R = R + Math.imul(T, wt) | 0, m = m + Math.imul(T, At) | 0, m = m + Math.imul(G, wt) | 0, v = v + Math.imul(G, At) | 0, R = R + Math.imul(je, It) | 0, m = m + Math.imul(je, _t) | 0, m = m + Math.imul(B, It) | 0, v = v + Math.imul(B, _t) | 0, R = R + Math.imul(Je, Lt) | 0, m = m + Math.imul(Je, Rt) | 0, m = m + Math.imul(Qe, Lt) | 0, v = v + Math.imul(Qe, Rt) | 0, R = R + Math.imul(we, Ct) | 0, m = m + Math.imul(we, kt) | 0, m = m + Math.imul(Ne, Ct) | 0, v = v + Math.imul(Ne, kt) | 0, R = R + Math.imul(be, Dt) | 0, m = m + Math.imul(be, Pt) | 0, m = m + Math.imul(Fe, Dt) | 0, v = v + Math.imul(Fe, Pt) | 0, R = R + Math.imul(xe, Mt) | 0, m = m + Math.imul(xe, Ot) | 0, m = m + Math.imul(Be, Mt) | 0, v = v + Math.imul(Be, Ot) | 0, R = R + Math.imul(De, Bt) | 0, m = m + Math.imul(De, Ft) | 0, m = m + Math.imul(ze, Bt) | 0, v = v + Math.imul(ze, Ft) | 0, R = R + Math.imul(ie, Nt) | 0, m = m + Math.imul(ie, Ut) | 0, m = m + Math.imul(le, Nt) | 0, v = v + Math.imul(le, Ut) | 0;
                var Ca = (V + R | 0) + ((m & 8191) << 13) | 0;
                V = (v + (m >>> 13) | 0) + (Ca >>> 26) | 0, Ca &= 67108863, R = Math.imul(Q, wt), m = Math.imul(Q, At), m = m + Math.imul(se, wt) | 0, v = Math.imul(se, At), R = R + Math.imul(T, It) | 0, m = m + Math.imul(T, _t) | 0, m = m + Math.imul(G, It) | 0, v = v + Math.imul(G, _t) | 0, R = R + Math.imul(je, Lt) | 0, m = m + Math.imul(je, Rt) | 0, m = m + Math.imul(B, Lt) | 0, v = v + Math.imul(B, Rt) | 0, R = R + Math.imul(Je, Ct) | 0, m = m + Math.imul(Je, kt) | 0, m = m + Math.imul(Qe, Ct) | 0, v = v + Math.imul(Qe, kt) | 0, R = R + Math.imul(we, Dt) | 0, m = m + Math.imul(we, Pt) | 0, m = m + Math.imul(Ne, Dt) | 0, v = v + Math.imul(Ne, Pt) | 0, R = R + Math.imul(be, Mt) | 0, m = m + Math.imul(be, Ot) | 0, m = m + Math.imul(Fe, Mt) | 0, v = v + Math.imul(Fe, Ot) | 0, R = R + Math.imul(xe, Bt) | 0, m = m + Math.imul(xe, Ft) | 0, m = m + Math.imul(Be, Bt) | 0, v = v + Math.imul(Be, Ft) | 0, R = R + Math.imul(De, Nt) | 0, m = m + Math.imul(De, Ut) | 0, m = m + Math.imul(ze, Nt) | 0, v = v + Math.imul(ze, Ut) | 0;
                var ka = (V + R | 0) + ((m & 8191) << 13) | 0;
                V = (v + (m >>> 13) | 0) + (ka >>> 26) | 0, ka &= 67108863, R = Math.imul(Q, It), m = Math.imul(Q, _t), m = m + Math.imul(se, It) | 0, v = Math.imul(se, _t), R = R + Math.imul(T, Lt) | 0, m = m + Math.imul(T, Rt) | 0, m = m + Math.imul(G, Lt) | 0, v = v + Math.imul(G, Rt) | 0, R = R + Math.imul(je, Ct) | 0, m = m + Math.imul(je, kt) | 0, m = m + Math.imul(B, Ct) | 0, v = v + Math.imul(B, kt) | 0, R = R + Math.imul(Je, Dt) | 0, m = m + Math.imul(Je, Pt) | 0, m = m + Math.imul(Qe, Dt) | 0, v = v + Math.imul(Qe, Pt) | 0, R = R + Math.imul(we, Mt) | 0, m = m + Math.imul(we, Ot) | 0, m = m + Math.imul(Ne, Mt) | 0, v = v + Math.imul(Ne, Ot) | 0, R = R + Math.imul(be, Bt) | 0, m = m + Math.imul(be, Ft) | 0, m = m + Math.imul(Fe, Bt) | 0, v = v + Math.imul(Fe, Ft) | 0, R = R + Math.imul(xe, Nt) | 0, m = m + Math.imul(xe, Ut) | 0, m = m + Math.imul(Be, Nt) | 0, v = v + Math.imul(Be, Ut) | 0;
                var Da = (V + R | 0) + ((m & 8191) << 13) | 0;
                V = (v + (m >>> 13) | 0) + (Da >>> 26) | 0, Da &= 67108863, R = Math.imul(Q, Lt), m = Math.imul(Q, Rt), m = m + Math.imul(se, Lt) | 0, v = Math.imul(se, Rt), R = R + Math.imul(T, Ct) | 0, m = m + Math.imul(T, kt) | 0, m = m + Math.imul(G, Ct) | 0, v = v + Math.imul(G, kt) | 0, R = R + Math.imul(je, Dt) | 0, m = m + Math.imul(je, Pt) | 0, m = m + Math.imul(B, Dt) | 0, v = v + Math.imul(B, Pt) | 0, R = R + Math.imul(Je, Mt) | 0, m = m + Math.imul(Je, Ot) | 0, m = m + Math.imul(Qe, Mt) | 0, v = v + Math.imul(Qe, Ot) | 0, R = R + Math.imul(we, Bt) | 0, m = m + Math.imul(we, Ft) | 0, m = m + Math.imul(Ne, Bt) | 0, v = v + Math.imul(Ne, Ft) | 0, R = R + Math.imul(be, Nt) | 0, m = m + Math.imul(be, Ut) | 0, m = m + Math.imul(Fe, Nt) | 0, v = v + Math.imul(Fe, Ut) | 0;
                var Pa = (V + R | 0) + ((m & 8191) << 13) | 0;
                V = (v + (m >>> 13) | 0) + (Pa >>> 26) | 0, Pa &= 67108863, R = Math.imul(Q, Ct), m = Math.imul(Q, kt), m = m + Math.imul(se, Ct) | 0, v = Math.imul(se, kt), R = R + Math.imul(T, Dt) | 0, m = m + Math.imul(T, Pt) | 0, m = m + Math.imul(G, Dt) | 0, v = v + Math.imul(G, Pt) | 0, R = R + Math.imul(je, Mt) | 0, m = m + Math.imul(je, Ot) | 0, m = m + Math.imul(B, Mt) | 0, v = v + Math.imul(B, Ot) | 0, R = R + Math.imul(Je, Bt) | 0, m = m + Math.imul(Je, Ft) | 0, m = m + Math.imul(Qe, Bt) | 0, v = v + Math.imul(Qe, Ft) | 0, R = R + Math.imul(we, Nt) | 0, m = m + Math.imul(we, Ut) | 0, m = m + Math.imul(Ne, Nt) | 0, v = v + Math.imul(Ne, Ut) | 0;
                var Ma = (V + R | 0) + ((m & 8191) << 13) | 0;
                V = (v + (m >>> 13) | 0) + (Ma >>> 26) | 0, Ma &= 67108863, R = Math.imul(Q, Dt), m = Math.imul(Q, Pt), m = m + Math.imul(se, Dt) | 0, v = Math.imul(se, Pt), R = R + Math.imul(T, Mt) | 0, m = m + Math.imul(T, Ot) | 0, m = m + Math.imul(G, Mt) | 0, v = v + Math.imul(G, Ot) | 0, R = R + Math.imul(je, Bt) | 0, m = m + Math.imul(je, Ft) | 0, m = m + Math.imul(B, Bt) | 0, v = v + Math.imul(B, Ft) | 0, R = R + Math.imul(Je, Nt) | 0, m = m + Math.imul(Je, Ut) | 0, m = m + Math.imul(Qe, Nt) | 0, v = v + Math.imul(Qe, Ut) | 0;
                var Oa = (V + R | 0) + ((m & 8191) << 13) | 0;
                V = (v + (m >>> 13) | 0) + (Oa >>> 26) | 0, Oa &= 67108863, R = Math.imul(Q, Mt), m = Math.imul(Q, Ot), m = m + Math.imul(se, Mt) | 0, v = Math.imul(se, Ot), R = R + Math.imul(T, Bt) | 0, m = m + Math.imul(T, Ft) | 0, m = m + Math.imul(G, Bt) | 0, v = v + Math.imul(G, Ft) | 0, R = R + Math.imul(je, Nt) | 0, m = m + Math.imul(je, Ut) | 0, m = m + Math.imul(B, Nt) | 0, v = v + Math.imul(B, Ut) | 0;
                var Ba = (V + R | 0) + ((m & 8191) << 13) | 0;
                V = (v + (m >>> 13) | 0) + (Ba >>> 26) | 0, Ba &= 67108863, R = Math.imul(Q, Bt), m = Math.imul(Q, Ft), m = m + Math.imul(se, Bt) | 0, v = Math.imul(se, Ft), R = R + Math.imul(T, Nt) | 0, m = m + Math.imul(T, Ut) | 0, m = m + Math.imul(G, Nt) | 0, v = v + Math.imul(G, Ut) | 0;
                var Fa = (V + R | 0) + ((m & 8191) << 13) | 0;
                V = (v + (m >>> 13) | 0) + (Fa >>> 26) | 0, Fa &= 67108863, R = Math.imul(Q, Nt), m = Math.imul(Q, Ut), m = m + Math.imul(se, Nt) | 0, v = Math.imul(se, Ut);
                var Na = (V + R | 0) + ((m & 8191) << 13) | 0;
                return V = (v + (m >>> 13) | 0) + (Na >>> 26) | 0, Na &= 67108863, U[0] = xa, U[1] = Sa, U[2] = ba, U[3] = Ta, U[4] = wa, U[5] = Aa, U[6] = Ia, U[7] = _a, U[8] = La, U[9] = Ra, U[10] = Ca, U[11] = ka, U[12] = Da, U[13] = Pa, U[14] = Ma, U[15] = Oa, U[16] = Ba, U[17] = Fa, U[18] = Na, V !== 0 && (U[19] = V, w.length++), w;
            };
            Math.imul || (L = b);
            function A(_, g, x) {
                x.negative = g.negative ^ _.negative, x.length = _.length + g.length;
                for(var w = 0, D = 0, O = 0; O < x.length - 1; O++){
                    var U = D;
                    D = 0;
                    for(var V = w & 67108863, R = Math.min(O, g.length - 1), m = Math.max(0, O - _.length + 1); m <= R; m++){
                        var v = O - m, P = _.words[v] | 0, N = g.words[m] | 0, Y = P * N, ee = Y & 67108863;
                        U = U + (Y / 67108864 | 0) | 0, ee = ee + V | 0, V = ee & 67108863, U = U + (ee >>> 26) | 0, D += U >>> 26, U &= 67108863;
                    }
                    x.words[O] = V, w = U, U = D;
                }
                return w !== 0 ? x.words[O] = w : x.length--, x._strip();
            }
            function F(_, g, x) {
                return A(_, g, x);
            }
            i.prototype.mulTo = function(g, x) {
                var w, D = this.length + g.length;
                return this.length === 10 && g.length === 10 ? w = L(this, g, x) : D < 63 ? w = b(this, g, x) : D < 1024 ? w = A(this, g, x) : w = F(this, g, x), w;
            }, i.prototype.mul = function(g) {
                var x = new i(null);
                return x.words = new Array(this.length + g.length), this.mulTo(g, x);
            }, i.prototype.mulf = function(g) {
                var x = new i(null);
                return x.words = new Array(this.length + g.length), F(this, g, x);
            }, i.prototype.imul = function(g) {
                return this.clone().mulTo(g, this);
            }, i.prototype.imuln = function(g) {
                var x = g < 0;
                x && (g = -g), r(typeof g == "number"), r(g < 67108864);
                for(var w = 0, D = 0; D < this.length; D++){
                    var O = (this.words[D] | 0) * g, U = (O & 67108863) + (w & 67108863);
                    w >>= 26, w += O / 67108864 | 0, w += U >>> 26, this.words[D] = U & 67108863;
                }
                return w !== 0 && (this.words[D] = w, this.length++), this.length = g === 0 ? 1 : this.length, x ? this.ineg() : this;
            }, i.prototype.muln = function(g) {
                return this.clone().imuln(g);
            }, i.prototype.sqr = function() {
                return this.mul(this);
            }, i.prototype.isqr = function() {
                return this.imul(this.clone());
            }, i.prototype.pow = function(g) {
                var x = E(g);
                if (x.length === 0) return new i(1);
                for(var w = this, D = 0; D < x.length && x[D] === 0; D++, w = w.sqr());
                if (++D < x.length) for(var O = w.sqr(); D < x.length; D++, O = O.sqr())x[D] !== 0 && (w = w.mul(O));
                return w;
            }, i.prototype.iushln = function(g) {
                r(typeof g == "number" && g >= 0);
                var x = g % 26, w = (g - x) / 26, D = 67108863 >>> 26 - x << 26 - x, O;
                if (x !== 0) {
                    var U = 0;
                    for(O = 0; O < this.length; O++){
                        var V = this.words[O] & D, R = (this.words[O] | 0) - V << x;
                        this.words[O] = R | U, U = V >>> 26 - x;
                    }
                    U && (this.words[O] = U, this.length++);
                }
                if (w !== 0) {
                    for(O = this.length - 1; O >= 0; O--)this.words[O + w] = this.words[O];
                    for(O = 0; O < w; O++)this.words[O] = 0;
                    this.length += w;
                }
                return this._strip();
            }, i.prototype.ishln = function(g) {
                return r(this.negative === 0), this.iushln(g);
            }, i.prototype.iushrn = function(g, x, w) {
                r(typeof g == "number" && g >= 0);
                var D;
                x ? D = (x - x % 26) / 26 : D = 0;
                var O = g % 26, U = Math.min((g - O) / 26, this.length), V = 67108863 ^ 67108863 >>> O << O, R = w;
                if (D -= U, D = Math.max(0, D), R) {
                    for(var m = 0; m < U; m++)R.words[m] = this.words[m];
                    R.length = U;
                }
                if (U !== 0) if (this.length > U) for(this.length -= U, m = 0; m < this.length; m++)this.words[m] = this.words[m + U];
                else this.words[0] = 0, this.length = 1;
                var v = 0;
                for(m = this.length - 1; m >= 0 && (v !== 0 || m >= D); m--){
                    var P = this.words[m] | 0;
                    this.words[m] = v << 26 - O | P >>> O, v = P & V;
                }
                return R && v !== 0 && (R.words[R.length++] = v), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
            }, i.prototype.ishrn = function(g, x, w) {
                return r(this.negative === 0), this.iushrn(g, x, w);
            }, i.prototype.shln = function(g) {
                return this.clone().ishln(g);
            }, i.prototype.ushln = function(g) {
                return this.clone().iushln(g);
            }, i.prototype.shrn = function(g) {
                return this.clone().ishrn(g);
            }, i.prototype.ushrn = function(g) {
                return this.clone().iushrn(g);
            }, i.prototype.testn = function(g) {
                r(typeof g == "number" && g >= 0);
                var x = g % 26, w = (g - x) / 26, D = 1 << x;
                if (this.length <= w) return !1;
                var O = this.words[w];
                return !!(O & D);
            }, i.prototype.imaskn = function(g) {
                r(typeof g == "number" && g >= 0);
                var x = g % 26, w = (g - x) / 26;
                if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= w) return this;
                if (x !== 0 && w++, this.length = Math.min(w, this.length), x !== 0) {
                    var D = 67108863 ^ 67108863 >>> x << x;
                    this.words[this.length - 1] &= D;
                }
                return this._strip();
            }, i.prototype.maskn = function(g) {
                return this.clone().imaskn(g);
            }, i.prototype.iaddn = function(g) {
                return r(typeof g == "number"), r(g < 67108864), g < 0 ? this.isubn(-g) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= g ? (this.words[0] = g - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(g), this.negative = 1, this) : this._iaddn(g);
            }, i.prototype._iaddn = function(g) {
                this.words[0] += g;
                for(var x = 0; x < this.length && this.words[x] >= 67108864; x++)this.words[x] -= 67108864, x === this.length - 1 ? this.words[x + 1] = 1 : this.words[x + 1]++;
                return this.length = Math.max(this.length, x + 1), this;
            }, i.prototype.isubn = function(g) {
                if (r(typeof g == "number"), r(g < 67108864), g < 0) return this.iaddn(-g);
                if (this.negative !== 0) return this.negative = 0, this.iaddn(g), this.negative = 1, this;
                if (this.words[0] -= g, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
                else for(var x = 0; x < this.length && this.words[x] < 0; x++)this.words[x] += 67108864, this.words[x + 1] -= 1;
                return this._strip();
            }, i.prototype.addn = function(g) {
                return this.clone().iaddn(g);
            }, i.prototype.subn = function(g) {
                return this.clone().isubn(g);
            }, i.prototype.iabs = function() {
                return this.negative = 0, this;
            }, i.prototype.abs = function() {
                return this.clone().iabs();
            }, i.prototype._ishlnsubmul = function(g, x, w) {
                var D = g.length + w, O;
                this._expand(D);
                var U, V = 0;
                for(O = 0; O < g.length; O++){
                    U = (this.words[O + w] | 0) + V;
                    var R = (g.words[O] | 0) * x;
                    U -= R & 67108863, V = (U >> 26) - (R / 67108864 | 0), this.words[O + w] = U & 67108863;
                }
                for(; O < this.length - w; O++)U = (this.words[O + w] | 0) + V, V = U >> 26, this.words[O + w] = U & 67108863;
                if (V === 0) return this._strip();
                for(r(V === -1), V = 0, O = 0; O < this.length; O++)U = -(this.words[O] | 0) + V, V = U >> 26, this.words[O] = U & 67108863;
                return this.negative = 1, this._strip();
            }, i.prototype._wordDiv = function(g, x) {
                var w = this.length - g.length, D = this.clone(), O = g, U = O.words[O.length - 1] | 0, V = this._countBits(U);
                w = 26 - V, w !== 0 && (O = O.ushln(w), D.iushln(w), U = O.words[O.length - 1] | 0);
                var R = D.length - O.length, m;
                if (x !== "mod") {
                    m = new i(null), m.length = R + 1, m.words = new Array(m.length);
                    for(var v = 0; v < m.length; v++)m.words[v] = 0;
                }
                var P = D.clone()._ishlnsubmul(O, 1, R);
                P.negative === 0 && (D = P, m && (m.words[R] = 1));
                for(var N = R - 1; N >= 0; N--){
                    var Y = (D.words[O.length + N] | 0) * 67108864 + (D.words[O.length + N - 1] | 0);
                    for(Y = Math.min(Y / U | 0, 67108863), D._ishlnsubmul(O, Y, N); D.negative !== 0;)Y--, D.negative = 0, D._ishlnsubmul(O, 1, N), D.isZero() || (D.negative ^= 1);
                    m && (m.words[N] = Y);
                }
                return m && m._strip(), D._strip(), x !== "div" && w !== 0 && D.iushrn(w), {
                    div: m || null,
                    mod: D
                };
            }, i.prototype.divmod = function(g, x, w) {
                if (r(!g.isZero()), this.isZero()) return {
                    div: new i(0),
                    mod: new i(0)
                };
                var D, O, U;
                return this.negative !== 0 && g.negative === 0 ? (U = this.neg().divmod(g, x), x !== "mod" && (D = U.div.neg()), x !== "div" && (O = U.mod.neg(), w && O.negative !== 0 && O.iadd(g)), {
                    div: D,
                    mod: O
                }) : this.negative === 0 && g.negative !== 0 ? (U = this.divmod(g.neg(), x), x !== "mod" && (D = U.div.neg()), {
                    div: D,
                    mod: U.mod
                }) : (this.negative & g.negative) !== 0 ? (U = this.neg().divmod(g.neg(), x), x !== "div" && (O = U.mod.neg(), w && O.negative !== 0 && O.isub(g)), {
                    div: U.div,
                    mod: O
                }) : g.length > this.length || this.cmp(g) < 0 ? {
                    div: new i(0),
                    mod: this
                } : g.length === 1 ? x === "div" ? {
                    div: this.divn(g.words[0]),
                    mod: null
                } : x === "mod" ? {
                    div: null,
                    mod: new i(this.modrn(g.words[0]))
                } : {
                    div: this.divn(g.words[0]),
                    mod: new i(this.modrn(g.words[0]))
                } : this._wordDiv(g, x);
            }, i.prototype.div = function(g) {
                return this.divmod(g, "div", !1).div;
            }, i.prototype.mod = function(g) {
                return this.divmod(g, "mod", !1).mod;
            }, i.prototype.umod = function(g) {
                return this.divmod(g, "mod", !0).mod;
            }, i.prototype.divRound = function(g) {
                var x = this.divmod(g);
                if (x.mod.isZero()) return x.div;
                var w = x.div.negative !== 0 ? x.mod.isub(g) : x.mod, D = g.ushrn(1), O = g.andln(1), U = w.cmp(D);
                return U < 0 || O === 1 && U === 0 ? x.div : x.div.negative !== 0 ? x.div.isubn(1) : x.div.iaddn(1);
            }, i.prototype.modrn = function(g) {
                var x = g < 0;
                x && (g = -g), r(g <= 67108863);
                for(var w = (1 << 26) % g, D = 0, O = this.length - 1; O >= 0; O--)D = (w * D + (this.words[O] | 0)) % g;
                return x ? -D : D;
            }, i.prototype.modn = function(g) {
                return this.modrn(g);
            }, i.prototype.idivn = function(g) {
                var x = g < 0;
                x && (g = -g), r(g <= 67108863);
                for(var w = 0, D = this.length - 1; D >= 0; D--){
                    var O = (this.words[D] | 0) + w * 67108864;
                    this.words[D] = O / g | 0, w = O % g;
                }
                return this._strip(), x ? this.ineg() : this;
            }, i.prototype.divn = function(g) {
                return this.clone().idivn(g);
            }, i.prototype.egcd = function(g) {
                r(g.negative === 0), r(!g.isZero());
                var x = this, w = g.clone();
                x.negative !== 0 ? x = x.umod(g) : x = x.clone();
                for(var D = new i(1), O = new i(0), U = new i(0), V = new i(1), R = 0; x.isEven() && w.isEven();)x.iushrn(1), w.iushrn(1), ++R;
                for(var m = w.clone(), v = x.clone(); !x.isZero();){
                    for(var P = 0, N = 1; (x.words[0] & N) === 0 && P < 26; ++P, N <<= 1);
                    if (P > 0) for(x.iushrn(P); P-- > 0;)(D.isOdd() || O.isOdd()) && (D.iadd(m), O.isub(v)), D.iushrn(1), O.iushrn(1);
                    for(var Y = 0, ee = 1; (w.words[0] & ee) === 0 && Y < 26; ++Y, ee <<= 1);
                    if (Y > 0) for(w.iushrn(Y); Y-- > 0;)(U.isOdd() || V.isOdd()) && (U.iadd(m), V.isub(v)), U.iushrn(1), V.iushrn(1);
                    x.cmp(w) >= 0 ? (x.isub(w), D.isub(U), O.isub(V)) : (w.isub(x), U.isub(D), V.isub(O));
                }
                return {
                    a: U,
                    b: V,
                    gcd: w.iushln(R)
                };
            }, i.prototype._invmp = function(g) {
                r(g.negative === 0), r(!g.isZero());
                var x = this, w = g.clone();
                x.negative !== 0 ? x = x.umod(g) : x = x.clone();
                for(var D = new i(1), O = new i(0), U = w.clone(); x.cmpn(1) > 0 && w.cmpn(1) > 0;){
                    for(var V = 0, R = 1; (x.words[0] & R) === 0 && V < 26; ++V, R <<= 1);
                    if (V > 0) for(x.iushrn(V); V-- > 0;)D.isOdd() && D.iadd(U), D.iushrn(1);
                    for(var m = 0, v = 1; (w.words[0] & v) === 0 && m < 26; ++m, v <<= 1);
                    if (m > 0) for(w.iushrn(m); m-- > 0;)O.isOdd() && O.iadd(U), O.iushrn(1);
                    x.cmp(w) >= 0 ? (x.isub(w), D.isub(O)) : (w.isub(x), O.isub(D));
                }
                var P;
                return x.cmpn(1) === 0 ? P = D : P = O, P.cmpn(0) < 0 && P.iadd(g), P;
            }, i.prototype.gcd = function(g) {
                if (this.isZero()) return g.abs();
                if (g.isZero()) return this.abs();
                var x = this.clone(), w = g.clone();
                x.negative = 0, w.negative = 0;
                for(var D = 0; x.isEven() && w.isEven(); D++)x.iushrn(1), w.iushrn(1);
                do {
                    for(; x.isEven();)x.iushrn(1);
                    for(; w.isEven();)w.iushrn(1);
                    var O = x.cmp(w);
                    if (O < 0) {
                        var U = x;
                        x = w, w = U;
                    } else if (O === 0 || w.cmpn(1) === 0) break;
                    x.isub(w);
                }while (!0)
                return w.iushln(D);
            }, i.prototype.invm = function(g) {
                return this.egcd(g).a.umod(g);
            }, i.prototype.isEven = function() {
                return (this.words[0] & 1) === 0;
            }, i.prototype.isOdd = function() {
                return (this.words[0] & 1) === 1;
            }, i.prototype.andln = function(g) {
                return this.words[0] & g;
            }, i.prototype.bincn = function(g) {
                r(typeof g == "number");
                var x = g % 26, w = (g - x) / 26, D = 1 << x;
                if (this.length <= w) return this._expand(w + 1), this.words[w] |= D, this;
                for(var O = D, U = w; O !== 0 && U < this.length; U++){
                    var V = this.words[U] | 0;
                    V += O, O = V >>> 26, V &= 67108863, this.words[U] = V;
                }
                return O !== 0 && (this.words[U] = O, this.length++), this;
            }, i.prototype.isZero = function() {
                return this.length === 1 && this.words[0] === 0;
            }, i.prototype.cmpn = function(g) {
                var x = g < 0;
                if (this.negative !== 0 && !x) return -1;
                if (this.negative === 0 && x) return 1;
                this._strip();
                var w;
                if (this.length > 1) w = 1;
                else {
                    x && (g = -g), r(g <= 67108863, "Number is too big");
                    var D = this.words[0] | 0;
                    w = D === g ? 0 : D < g ? -1 : 1;
                }
                return this.negative !== 0 ? -w | 0 : w;
            }, i.prototype.cmp = function(g) {
                if (this.negative !== 0 && g.negative === 0) return -1;
                if (this.negative === 0 && g.negative !== 0) return 1;
                var x = this.ucmp(g);
                return this.negative !== 0 ? -x | 0 : x;
            }, i.prototype.ucmp = function(g) {
                if (this.length > g.length) return 1;
                if (this.length < g.length) return -1;
                for(var x = 0, w = this.length - 1; w >= 0; w--){
                    var D = this.words[w] | 0, O = g.words[w] | 0;
                    if (D !== O) {
                        D < O ? x = -1 : D > O && (x = 1);
                        break;
                    }
                }
                return x;
            }, i.prototype.gtn = function(g) {
                return this.cmpn(g) === 1;
            }, i.prototype.gt = function(g) {
                return this.cmp(g) === 1;
            }, i.prototype.gten = function(g) {
                return this.cmpn(g) >= 0;
            }, i.prototype.gte = function(g) {
                return this.cmp(g) >= 0;
            }, i.prototype.ltn = function(g) {
                return this.cmpn(g) === -1;
            }, i.prototype.lt = function(g) {
                return this.cmp(g) === -1;
            }, i.prototype.lten = function(g) {
                return this.cmpn(g) <= 0;
            }, i.prototype.lte = function(g) {
                return this.cmp(g) <= 0;
            }, i.prototype.eqn = function(g) {
                return this.cmpn(g) === 0;
            }, i.prototype.eq = function(g) {
                return this.cmp(g) === 0;
            }, i.red = function(g) {
                return new $(g);
            }, i.prototype.toRed = function(g) {
                return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), g.convertTo(this)._forceRed(g);
            }, i.prototype.fromRed = function() {
                return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
            }, i.prototype._forceRed = function(g) {
                return this.red = g, this;
            }, i.prototype.forceRed = function(g) {
                return r(!this.red, "Already a number in reduction context"), this._forceRed(g);
            }, i.prototype.redAdd = function(g) {
                return r(this.red, "redAdd works only with red numbers"), this.red.add(this, g);
            }, i.prototype.redIAdd = function(g) {
                return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, g);
            }, i.prototype.redSub = function(g) {
                return r(this.red, "redSub works only with red numbers"), this.red.sub(this, g);
            }, i.prototype.redISub = function(g) {
                return r(this.red, "redISub works only with red numbers"), this.red.isub(this, g);
            }, i.prototype.redShl = function(g) {
                return r(this.red, "redShl works only with red numbers"), this.red.shl(this, g);
            }, i.prototype.redMul = function(g) {
                return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, g), this.red.mul(this, g);
            }, i.prototype.redIMul = function(g) {
                return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, g), this.red.imul(this, g);
            }, i.prototype.redSqr = function() {
                return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
            }, i.prototype.redISqr = function() {
                return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
            }, i.prototype.redSqrt = function() {
                return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
            }, i.prototype.redInvm = function() {
                return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
            }, i.prototype.redNeg = function() {
                return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
            }, i.prototype.redPow = function(g) {
                return r(this.red && !g.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, g);
            };
            var M = {
                k256: null,
                p224: null,
                p192: null,
                p25519: null
            };
            function H(_, g) {
                this.name = _, this.p = new i(g, 16), this.n = this.p.bitLength(), this.k = new i(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
            }
            H.prototype._tmp = function() {
                var g = new i(null);
                return g.words = new Array(Math.ceil(this.n / 13)), g;
            }, H.prototype.ireduce = function(g) {
                var x = g, w;
                do this.split(x, this.tmp), x = this.imulK(x), x = x.iadd(this.tmp), w = x.bitLength();
                while (w > this.n)
                var D = w < this.n ? -1 : x.ucmp(this.p);
                return D === 0 ? (x.words[0] = 0, x.length = 1) : D > 0 ? x.isub(this.p) : x.strip !== void 0 ? x.strip() : x._strip(), x;
            }, H.prototype.split = function(g, x) {
                g.iushrn(this.n, 0, x);
            }, H.prototype.imulK = function(g) {
                return g.imul(this.k);
            };
            function K() {
                H.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
            }
            n1(K, H), K.prototype.split = function(g, x) {
                for(var w = 4194303, D = Math.min(g.length, 9), O = 0; O < D; O++)x.words[O] = g.words[O];
                if (x.length = D, g.length <= 9) {
                    g.words[0] = 0, g.length = 1;
                    return;
                }
                var U = g.words[9];
                for(x.words[x.length++] = U & w, O = 10; O < g.length; O++){
                    var V = g.words[O] | 0;
                    g.words[O - 10] = (V & w) << 4 | U >>> 22, U = V;
                }
                U >>>= 22, g.words[O - 10] = U, U === 0 && g.length > 10 ? g.length -= 10 : g.length -= 9;
            }, K.prototype.imulK = function(g) {
                g.words[g.length] = 0, g.words[g.length + 1] = 0, g.length += 2;
                for(var x = 0, w = 0; w < g.length; w++){
                    var D = g.words[w] | 0;
                    x += D * 977, g.words[w] = x & 67108863, x = D * 64 + (x / 67108864 | 0);
                }
                return g.words[g.length - 1] === 0 && (g.length--, g.words[g.length - 1] === 0 && g.length--), g;
            };
            function j() {
                H.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
            }
            n1(j, H);
            function C() {
                H.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
            }
            n1(C, H);
            function k() {
                H.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
            }
            n1(k, H), k.prototype.imulK = function(g) {
                for(var x = 0, w = 0; w < g.length; w++){
                    var D = (g.words[w] | 0) * 19 + x, O = D & 67108863;
                    D >>>= 26, g.words[w] = O, x = D;
                }
                return x !== 0 && (g.words[g.length++] = x), g;
            }, i._prime = function(g) {
                if (M[g]) return M[g];
                var x;
                if (g === "k256") x = new K();
                else if (g === "p224") x = new j();
                else if (g === "p192") x = new C();
                else if (g === "p25519") x = new k();
                else throw new Error("Unknown prime " + g);
                return M[g] = x, x;
            };
            function $(_) {
                if (typeof _ == "string") {
                    var g = i._prime(_);
                    this.m = g.p, this.prime = g;
                } else r(_.gtn(1), "modulus must be greater than 1"), this.m = _, this.prime = null;
            }
            $.prototype._verify1 = function(g) {
                r(g.negative === 0, "red works only with positives"), r(g.red, "red works only with red numbers");
            }, $.prototype._verify2 = function(g, x) {
                r((g.negative | x.negative) === 0, "red works only with positives"), r(g.red && g.red === x.red, "red works only with red numbers");
            }, $.prototype.imod = function(g) {
                return this.prime ? this.prime.ireduce(g)._forceRed(this) : (u(g, g.umod(this.m)._forceRed(this)), g);
            }, $.prototype.neg = function(g) {
                return g.isZero() ? g.clone() : this.m.sub(g)._forceRed(this);
            }, $.prototype.add = function(g, x) {
                this._verify2(g, x);
                var w = g.add(x);
                return w.cmp(this.m) >= 0 && w.isub(this.m), w._forceRed(this);
            }, $.prototype.iadd = function(g, x) {
                this._verify2(g, x);
                var w = g.iadd(x);
                return w.cmp(this.m) >= 0 && w.isub(this.m), w;
            }, $.prototype.sub = function(g, x) {
                this._verify2(g, x);
                var w = g.sub(x);
                return w.cmpn(0) < 0 && w.iadd(this.m), w._forceRed(this);
            }, $.prototype.isub = function(g, x) {
                this._verify2(g, x);
                var w = g.isub(x);
                return w.cmpn(0) < 0 && w.iadd(this.m), w;
            }, $.prototype.shl = function(g, x) {
                return this._verify1(g), this.imod(g.ushln(x));
            }, $.prototype.imul = function(g, x) {
                return this._verify2(g, x), this.imod(g.imul(x));
            }, $.prototype.mul = function(g, x) {
                return this._verify2(g, x), this.imod(g.mul(x));
            }, $.prototype.isqr = function(g) {
                return this.imul(g, g.clone());
            }, $.prototype.sqr = function(g) {
                return this.mul(g, g);
            }, $.prototype.sqrt = function(g) {
                if (g.isZero()) return g.clone();
                var x = this.m.andln(3);
                if (r(x % 2 === 1), x === 3) {
                    var w = this.m.add(new i(1)).iushrn(2);
                    return this.pow(g, w);
                }
                for(var D = this.m.subn(1), O = 0; !D.isZero() && D.andln(1) === 0;)O++, D.iushrn(1);
                r(!D.isZero());
                var U = new i(1).toRed(this), V = U.redNeg(), R = this.m.subn(1).iushrn(1), m = this.m.bitLength();
                for(m = new i(2 * m * m).toRed(this); this.pow(m, R).cmp(V) !== 0;)m.redIAdd(V);
                for(var v = this.pow(m, D), P = this.pow(g, D.addn(1).iushrn(1)), N = this.pow(g, D), Y = O; N.cmp(U) !== 0;){
                    for(var ee = N, ie = 0; ee.cmp(U) !== 0; ie++)ee = ee.redSqr();
                    r(ie < Y);
                    var le = this.pow(v, new i(1).iushln(Y - ie - 1));
                    P = P.redMul(le), v = le.redSqr(), N = N.redMul(v), Y = ie;
                }
                return P;
            }, $.prototype.invm = function(g) {
                var x = g._invmp(this.m);
                return x.negative !== 0 ? (x.negative = 0, this.imod(x).redNeg()) : this.imod(x);
            }, $.prototype.pow = function(g, x) {
                if (x.isZero()) return new i(1).toRed(this);
                if (x.cmpn(1) === 0) return g.clone();
                var w = 4, D = new Array(1 << w);
                D[0] = new i(1).toRed(this), D[1] = g;
                for(var O = 2; O < D.length; O++)D[O] = this.mul(D[O - 1], g);
                var U = D[0], V = 0, R = 0, m = x.bitLength() % 26;
                for(m === 0 && (m = 26), O = x.length - 1; O >= 0; O--){
                    for(var v = x.words[O], P = m - 1; P >= 0; P--){
                        var N = v >> P & 1;
                        if (U !== D[0] && (U = this.sqr(U)), N === 0 && V === 0) {
                            R = 0;
                            continue;
                        }
                        V <<= 1, V |= N, R++, !(R !== w && (O !== 0 || P !== 0)) && (U = this.mul(U, D[V]), R = 0, V = 0);
                    }
                    m = 26;
                }
                return U;
            }, $.prototype.convertTo = function(g) {
                var x = g.umod(this.m);
                return x === g ? x.clone() : x;
            }, $.prototype.convertFrom = function(g) {
                var x = g.clone();
                return x.red = null, x;
            }, i.mont = function(g) {
                return new W(g);
            };
            function W(_) {
                $.call(this, _), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new i(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
            }
            n1(W, $), W.prototype.convertTo = function(g) {
                return this.imod(g.ushln(this.shift));
            }, W.prototype.convertFrom = function(g) {
                var x = this.imod(g.mul(this.rinv));
                return x.red = null, x;
            }, W.prototype.imul = function(g, x) {
                if (g.isZero() || x.isZero()) return g.words[0] = 0, g.length = 1, g;
                var w = g.imul(x), D = w.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), O = w.isub(D).iushrn(this.shift), U = O;
                return O.cmp(this.m) >= 0 ? U = O.isub(this.m) : O.cmpn(0) < 0 && (U = O.iadd(this.m)), U._forceRed(this);
            }, W.prototype.mul = function(g, x) {
                if (g.isZero() || x.isZero()) return new i(0)._forceRed(this);
                var w = g.mul(x), D = w.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), O = w.isub(D).iushrn(this.shift), U = O;
                return O.cmp(this.m) >= 0 ? U = O.isub(this.m) : O.cmpn(0) < 0 && (U = O.iadd(this.m)), U._forceRed(this);
            }, W.prototype.invm = function(g) {
                var x = this.imod(g._invmp(this.m).mul(this.r2));
                return x._forceRed(this);
            };
        })(s, My);
    }(co)), co.exports;
}
var Oy = v0();
const bd = /* @__PURE__ */ Fc(Oy);
var Ui = {
    exports: {}
};
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ var Td;
function By() {
    return Td || (Td = 1, function(s, e) {
        var t = Kc(), r = t.Buffer;
        function n1(o, a) {
            for(var l in o)a[l] = o[l];
        }
        r.from && r.alloc && r.allocUnsafe && r.allocUnsafeSlow ? s.exports = t : (n1(t, e), e.Buffer = i);
        function i(o, a, l) {
            return r(o, a, l);
        }
        i.prototype = Object.create(r.prototype), n1(r, i), i.from = function(o, a, l) {
            if (typeof o == "number") throw new TypeError("Argument must not be a number");
            return r(o, a, l);
        }, i.alloc = function(o, a, l) {
            if (typeof o != "number") throw new TypeError("Argument must be a number");
            var c = r(o);
            return a !== void 0 ? typeof l == "string" ? c.fill(a, l) : c.fill(a) : c.fill(0), c;
        }, i.allocUnsafe = function(o) {
            if (typeof o != "number") throw new TypeError("Argument must be a number");
            return r(o);
        }, i.allocUnsafeSlow = function(o) {
            if (typeof o != "number") throw new TypeError("Argument must be a number");
            return t.SlowBuffer(o);
        };
    }(Ui, Ui.exports)), Ui.exports;
}
var za, wd;
function E0() {
    if (wd) return za;
    wd = 1;
    var s = By().Buffer;
    function e(t) {
        if (t.length >= 255) throw new TypeError("Alphabet too long");
        for(var r = new Uint8Array(256), n1 = 0; n1 < r.length; n1++)r[n1] = 255;
        for(var i = 0; i < t.length; i++){
            var o = t.charAt(i), a = o.charCodeAt(0);
            if (r[a] !== 255) throw new TypeError(o + " is ambiguous");
            r[a] = i;
        }
        var l = t.length, c = t.charAt(0), u = Math.log(l) / Math.log(256), d1 = Math.log(256) / Math.log(l);
        function h(y) {
            if ((Array.isArray(y) || y instanceof Uint8Array) && (y = s.from(y)), !s.isBuffer(y)) throw new TypeError("Expected Buffer");
            if (y.length === 0) return "";
            for(var E = 0, b = 0, L = 0, A = y.length; L !== A && y[L] === 0;)L++, E++;
            for(var F = (A - L) * d1 + 1 >>> 0, M = new Uint8Array(F); L !== A;){
                for(var H = y[L], K = 0, j = F - 1; (H !== 0 || K < b) && j !== -1; j--, K++)H += 256 * M[j] >>> 0, M[j] = H % l >>> 0, H = H / l >>> 0;
                if (H !== 0) throw new Error("Non-zero carry");
                b = K, L++;
            }
            for(var C = F - b; C !== F && M[C] === 0;)C++;
            for(var k = c.repeat(E); C < F; ++C)k += t.charAt(M[C]);
            return k;
        }
        function f(y) {
            if (typeof y != "string") throw new TypeError("Expected String");
            if (y.length === 0) return s.alloc(0);
            for(var E = 0, b = 0, L = 0; y[E] === c;)b++, E++;
            for(var A = (y.length - E) * u + 1 >>> 0, F = new Uint8Array(A); E < y.length;){
                var M = y.charCodeAt(E);
                if (M > 255) return;
                var H = r[M];
                if (H === 255) return;
                for(var K = 0, j = A - 1; (H !== 0 || K < L) && j !== -1; j--, K++)H += l * F[j] >>> 0, F[j] = H % 256 >>> 0, H = H / 256 >>> 0;
                if (H !== 0) throw new Error("Non-zero carry");
                L = K, E++;
            }
            for(var C = A - L; C !== A && F[C] === 0;)C++;
            var k = s.allocUnsafe(b + (A - C));
            k.fill(0, 0, b);
            for(var $ = b; C !== A;)k[$++] = F[C++];
            return k;
        }
        function p(y) {
            var E = f(y);
            if (E) return E;
            throw new Error("Non-base" + l + " character");
        }
        return {
            encode: h,
            decodeUnsafe: f,
            decode: p
        };
    }
    return za = e, za;
}
var Ya, Ad;
function Fy() {
    if (Ad) return Ya;
    Ad = 1;
    var s = E0(), e = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    return Ya = s(e), Ya;
}
var Ny = Fy();
const ar = /* @__PURE__ */ Fc(Ny), Id = Xf;
var et = {}, Za, _d;
function Uy() {
    if (_d) return Za;
    _d = 1;
    var s = E0(), e = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    return Za = s(e), Za;
}
function us(s, e, t) {
    return e <= s && s <= t;
}
function ca(s) {
    if (s === void 0) return {};
    if (s === Object(s)) return s;
    throw TypeError("Could not convert argument to dictionary");
}
function $y(s) {
    for(var e = String(s), t = e.length, r = 0, n1 = []; r < t;){
        var i = e.charCodeAt(r);
        if (i < 55296 || i > 57343) n1.push(i);
        else if (56320 <= i && i <= 57343) n1.push(65533);
        else if (55296 <= i && i <= 56319) if (r === t - 1) n1.push(65533);
        else {
            var o = s.charCodeAt(r + 1);
            if (56320 <= o && o <= 57343) {
                var a = i & 1023, l = o & 1023;
                n1.push(65536 + (a << 10) + l), r += 1;
            } else n1.push(65533);
        }
        r += 1;
    }
    return n1;
}
function Gy(s) {
    for(var e = "", t = 0; t < s.length; ++t){
        var r = s[t];
        r <= 65535 ? e += String.fromCharCode(r) : (r -= 65536, e += String.fromCharCode((r >> 10) + 55296, (r & 1023) + 56320));
    }
    return e;
}
var Bo = -1;
function Xc(s) {
    this.tokens = [].slice.call(s);
}
Xc.prototype = {
    /**
   * @return {boolean} True if end-of-stream has been hit.
   */ endOfStream: function() {
        return !this.tokens.length;
    },
    /**
   * When a token is read from a stream, the first token in the
   * stream must be returned and subsequently removed, and
   * end-of-stream must be returned otherwise.
   *
   * @return {number} Get the next token from the stream, or
   * end_of_stream.
   */ read: function() {
        return this.tokens.length ? this.tokens.shift() : Bo;
    },
    /**
   * When one or more tokens are prepended to a stream, those tokens
   * must be inserted, in given order, before the first token in the
   * stream.
   *
   * @param {(number|!Array.<number>)} token The token(s) to prepend to the stream.
   */ prepend: function(s) {
        if (Array.isArray(s)) for(var e = /**@type {!Array.<number>}*/ s; e.length;)this.tokens.unshift(e.pop());
        else this.tokens.unshift(s);
    },
    /**
   * When one or more tokens are pushed to a stream, those tokens
   * must be inserted, in given order, after the last token in the
   * stream.
   *
   * @param {(number|!Array.<number>)} token The tokens(s) to prepend to the stream.
   */ push: function(s) {
        if (Array.isArray(s)) for(var e = /**@type {!Array.<number>}*/ s; e.length;)this.tokens.push(e.shift());
        else this.tokens.push(s);
    }
};
var kn = -1;
function Xa(s, e) {
    if (s) throw TypeError("Decoder error");
    return e || 65533;
}
var Fo = "utf-8";
function No(s, e) {
    if (!(this instanceof No)) return new No(s, e);
    if (s = s !== void 0 ? String(s).toLowerCase() : Fo, s !== Fo) throw new Error("Encoding not supported. Only utf-8 is supported");
    e = ca(e), this._streaming = !1, this._BOMseen = !1, this._decoder = null, this._fatal = !!e.fatal, this._ignoreBOM = !!e.ignoreBOM, Object.defineProperty(this, "encoding", {
        value: "utf-8"
    }), Object.defineProperty(this, "fatal", {
        value: this._fatal
    }), Object.defineProperty(this, "ignoreBOM", {
        value: this._ignoreBOM
    });
}
No.prototype = {
    /**
   * @param {ArrayBufferView=} input The buffer of bytes to decode.
   * @param {Object=} options
   * @return {string} The decoded string.
   */ decode: function(e, t) {
        var r;
        typeof e == "object" && e instanceof ArrayBuffer ? r = new Uint8Array(e) : typeof e == "object" && "buffer" in e && e.buffer instanceof ArrayBuffer ? r = new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : r = new Uint8Array(0), t = ca(t), this._streaming || (this._decoder = new Vy({
            fatal: this._fatal
        }), this._BOMseen = !1), this._streaming = !!t.stream;
        for(var n1 = new Xc(r), i = [], o; !n1.endOfStream() && (o = this._decoder.handler(n1, n1.read()), o !== kn);)o !== null && (Array.isArray(o) ? i.push.apply(i, /**@type {!Array.<number>}*/ o) : i.push(o));
        if (!this._streaming) {
            do {
                if (o = this._decoder.handler(n1, n1.read()), o === kn) break;
                o !== null && (Array.isArray(o) ? i.push.apply(i, /**@type {!Array.<number>}*/ o) : i.push(o));
            }while (!n1.endOfStream())
            this._decoder = null;
        }
        return i.length && [
            "utf-8"
        ].indexOf(this.encoding) !== -1 && !this._ignoreBOM && !this._BOMseen && (i[0] === 65279 ? (this._BOMseen = !0, i.shift()) : this._BOMseen = !0), Gy(i);
    }
};
function Uo(s, e) {
    if (!(this instanceof Uo)) return new Uo(s, e);
    if (s = s !== void 0 ? String(s).toLowerCase() : Fo, s !== Fo) throw new Error("Encoding not supported. Only utf-8 is supported");
    e = ca(e), this._streaming = !1, this._encoder = null, this._options = {
        fatal: !!e.fatal
    }, Object.defineProperty(this, "encoding", {
        value: "utf-8"
    });
}
Uo.prototype = {
    /**
   * @param {string=} opt_string The string to encode.
   * @param {Object=} options
   * @return {Uint8Array} Encoded bytes, as a Uint8Array.
   */ encode: function(e, t) {
        e = e ? String(e) : "", t = ca(t), this._streaming || (this._encoder = new jy(this._options)), this._streaming = !!t.stream;
        for(var r = [], n1 = new Xc($y(e)), i; !n1.endOfStream() && (i = this._encoder.handler(n1, n1.read()), i !== kn);)Array.isArray(i) ? r.push.apply(r, /**@type {!Array.<number>}*/ i) : r.push(i);
        if (!this._streaming) {
            for(; i = this._encoder.handler(n1, n1.read()), i !== kn;)Array.isArray(i) ? r.push.apply(r, /**@type {!Array.<number>}*/ i) : r.push(i);
            this._encoder = null;
        }
        return new Uint8Array(r);
    }
};
function Vy(s) {
    var e = s.fatal, t = 0, r = 0, n1 = 0, i = 128, o = 191;
    this.handler = function(a, l) {
        if (l === Bo && n1 !== 0) return n1 = 0, Xa(e);
        if (l === Bo) return kn;
        if (n1 === 0) {
            if (us(l, 0, 127)) return l;
            if (us(l, 194, 223)) n1 = 1, t = l - 192;
            else if (us(l, 224, 239)) l === 224 && (i = 160), l === 237 && (o = 159), n1 = 2, t = l - 224;
            else if (us(l, 240, 244)) l === 240 && (i = 144), l === 244 && (o = 143), n1 = 3, t = l - 240;
            else return Xa(e);
            return t = t << 6 * n1, null;
        }
        if (!us(l, i, o)) return t = n1 = r = 0, i = 128, o = 191, a.prepend(l), Xa(e);
        if (i = 128, o = 191, r += 1, t += l - 128 << 6 * (n1 - r), r !== n1) return null;
        var c = t;
        return t = n1 = r = 0, c;
    };
}
function jy(s) {
    s.fatal, this.handler = function(e, t) {
        if (t === Bo) return kn;
        if (us(t, 0, 127)) return t;
        var r, n1;
        us(t, 128, 2047) ? (r = 1, n1 = 192) : us(t, 2048, 65535) ? (r = 2, n1 = 224) : us(t, 65536, 1114111) && (r = 3, n1 = 240);
        for(var i = [
            (t >> 6 * r) + n1
        ]; r > 0;){
            var o = t >> 6 * (r - 1);
            i.push(128 | o & 63), r -= 1;
        }
        return i;
    };
}
const Ky = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    TextDecoder: No,
    TextEncoder: Uo
}, Symbol.toStringTag, {
    value: "Module"
})), Hy = /* @__PURE__ */ Nc(Ky);
var Ld;
function qy() {
    if (Ld) return et;
    Ld = 1;
    var s = et && et.__createBinding || (Object.create ? function(C, k, $, W) {
        W === void 0 && (W = $), Object.defineProperty(C, W, {
            enumerable: !0,
            get: function() {
                return k[$];
            }
        });
    } : function(C, k, $, W) {
        W === void 0 && (W = $), C[W] = k[$];
    }), e = et && et.__setModuleDefault || (Object.create ? function(C, k) {
        Object.defineProperty(C, "default", {
            enumerable: !0,
            value: k
        });
    } : function(C, k) {
        C.default = k;
    }), t = et && et.__decorate || function(C, k, $, W) {
        var _ = arguments.length, g = _ < 3 ? k : W === null ? W = Object.getOwnPropertyDescriptor(k, $) : W, x;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") g = Reflect.decorate(C, k, $, W);
        else for(var w = C.length - 1; w >= 0; w--)(x = C[w]) && (g = (_ < 3 ? x(g) : _ > 3 ? x(k, $, g) : x(k, $)) || g);
        return _ > 3 && g && Object.defineProperty(k, $, g), g;
    }, r = et && et.__importStar || function(C) {
        if (C && C.__esModule) return C;
        var k = {};
        if (C != null) for(var $ in C)$ !== "default" && Object.hasOwnProperty.call(C, $) && s(k, C, $);
        return e(k, C), k;
    }, n1 = et && et.__importDefault || function(C) {
        return C && C.__esModule ? C : {
            default: C
        };
    };
    Object.defineProperty(et, "__esModule", {
        value: !0
    }), et.deserializeUnchecked = et.deserialize = et.serialize = et.BinaryReader = et.BinaryWriter = et.BorshError = et.baseDecode = et.baseEncode = void 0;
    const i = n1(v0()), o = n1(Uy()), a = r(Hy), l = typeof TextDecoder != "function" ? a.TextDecoder : TextDecoder, c = new l("utf-8", {
        fatal: !0
    });
    function u(C) {
        return typeof C == "string" && (C = Buffer.from(C, "utf8")), o.default.encode(Buffer.from(C));
    }
    et.baseEncode = u;
    function d1(C) {
        return Buffer.from(o.default.decode(C));
    }
    et.baseDecode = d1;
    const h = 1024;
    class f extends Error {
        constructor(k){
            super(k), this.fieldPath = [], this.originalMessage = k;
        }
        addToFieldPath(k) {
            this.fieldPath.splice(0, 0, k), this.message = this.originalMessage + ": " + this.fieldPath.join(".");
        }
    }
    et.BorshError = f;
    class p {
        constructor(){
            this.buf = Buffer.alloc(h), this.length = 0;
        }
        maybeResize() {
            this.buf.length < 16 + this.length && (this.buf = Buffer.concat([
                this.buf,
                Buffer.alloc(h)
            ]));
        }
        writeU8(k) {
            this.maybeResize(), this.buf.writeUInt8(k, this.length), this.length += 1;
        }
        writeU16(k) {
            this.maybeResize(), this.buf.writeUInt16LE(k, this.length), this.length += 2;
        }
        writeU32(k) {
            this.maybeResize(), this.buf.writeUInt32LE(k, this.length), this.length += 4;
        }
        writeU64(k) {
            this.maybeResize(), this.writeBuffer(Buffer.from(new i.default(k).toArray("le", 8)));
        }
        writeU128(k) {
            this.maybeResize(), this.writeBuffer(Buffer.from(new i.default(k).toArray("le", 16)));
        }
        writeU256(k) {
            this.maybeResize(), this.writeBuffer(Buffer.from(new i.default(k).toArray("le", 32)));
        }
        writeU512(k) {
            this.maybeResize(), this.writeBuffer(Buffer.from(new i.default(k).toArray("le", 64)));
        }
        writeBuffer(k) {
            this.buf = Buffer.concat([
                Buffer.from(this.buf.subarray(0, this.length)),
                k,
                Buffer.alloc(h)
            ]), this.length += k.length;
        }
        writeString(k) {
            this.maybeResize();
            const $ = Buffer.from(k, "utf8");
            this.writeU32($.length), this.writeBuffer($);
        }
        writeFixedArray(k) {
            this.writeBuffer(Buffer.from(k));
        }
        writeArray(k, $) {
            this.maybeResize(), this.writeU32(k.length);
            for (const W of k)this.maybeResize(), $(W);
        }
        toArray() {
            return this.buf.subarray(0, this.length);
        }
    }
    et.BinaryWriter = p;
    function y(C, k, $) {
        const W = $.value;
        $.value = function(..._) {
            try {
                return W.apply(this, _);
            } catch (g) {
                if (g instanceof RangeError) {
                    const x = g.code;
                    if ([
                        "ERR_BUFFER_OUT_OF_BOUNDS",
                        "ERR_OUT_OF_RANGE"
                    ].indexOf(x) >= 0) throw new f("Reached the end of buffer when deserializing");
                }
                throw g;
            }
        };
    }
    class E {
        constructor(k){
            this.buf = k, this.offset = 0;
        }
        readU8() {
            const k = this.buf.readUInt8(this.offset);
            return this.offset += 1, k;
        }
        readU16() {
            const k = this.buf.readUInt16LE(this.offset);
            return this.offset += 2, k;
        }
        readU32() {
            const k = this.buf.readUInt32LE(this.offset);
            return this.offset += 4, k;
        }
        readU64() {
            const k = this.readBuffer(8);
            return new i.default(k, "le");
        }
        readU128() {
            const k = this.readBuffer(16);
            return new i.default(k, "le");
        }
        readU256() {
            const k = this.readBuffer(32);
            return new i.default(k, "le");
        }
        readU512() {
            const k = this.readBuffer(64);
            return new i.default(k, "le");
        }
        readBuffer(k) {
            if (this.offset + k > this.buf.length) throw new f(`Expected buffer length ${k} isn't within bounds`);
            const $ = this.buf.slice(this.offset, this.offset + k);
            return this.offset += k, $;
        }
        readString() {
            const k = this.readU32(), $ = this.readBuffer(k);
            try {
                return c.decode($);
            } catch (W) {
                throw new f(`Error decoding UTF-8 string: ${W}`);
            }
        }
        readFixedArray(k) {
            return new Uint8Array(this.readBuffer(k));
        }
        readArray(k) {
            const $ = this.readU32(), W = Array();
            for(let _ = 0; _ < $; ++_)W.push(k());
            return W;
        }
    }
    t([
        y
    ], E.prototype, "readU8", null), t([
        y
    ], E.prototype, "readU16", null), t([
        y
    ], E.prototype, "readU32", null), t([
        y
    ], E.prototype, "readU64", null), t([
        y
    ], E.prototype, "readU128", null), t([
        y
    ], E.prototype, "readU256", null), t([
        y
    ], E.prototype, "readU512", null), t([
        y
    ], E.prototype, "readString", null), t([
        y
    ], E.prototype, "readFixedArray", null), t([
        y
    ], E.prototype, "readArray", null), et.BinaryReader = E;
    function b(C) {
        return C.charAt(0).toUpperCase() + C.slice(1);
    }
    function L(C, k, $, W, _) {
        try {
            if (typeof W == "string") _[`write${b(W)}`]($);
            else if (W instanceof Array) if (typeof W[0] == "number") {
                if ($.length !== W[0]) throw new f(`Expecting byte array of length ${W[0]}, but got ${$.length} bytes`);
                _.writeFixedArray($);
            } else if (W.length === 2 && typeof W[1] == "number") {
                if ($.length !== W[1]) throw new f(`Expecting byte array of length ${W[1]}, but got ${$.length} bytes`);
                for(let g = 0; g < W[1]; g++)L(C, null, $[g], W[0], _);
            } else _.writeArray($, (g)=>{
                L(C, k, g, W[0], _);
            });
            else if (W.kind !== void 0) switch(W.kind){
                case "option":
                    {
                        $ == null ? _.writeU8(0) : (_.writeU8(1), L(C, k, $, W.type, _));
                        break;
                    }
                case "map":
                    {
                        _.writeU32($.size), $.forEach((g, x)=>{
                            L(C, k, x, W.key, _), L(C, k, g, W.value, _);
                        });
                        break;
                    }
                default:
                    throw new f(`FieldType ${W} unrecognized`);
            }
            else A(C, $, _);
        } catch (g) {
            throw g instanceof f && g.addToFieldPath(k), g;
        }
    }
    function A(C, k, $) {
        if (typeof k.borshSerialize == "function") {
            k.borshSerialize($);
            return;
        }
        const W = C.get(k.constructor);
        if (!W) throw new f(`Class ${k.constructor.name} is missing in schema`);
        if (W.kind === "struct") W.fields.map(([_, g])=>{
            L(C, _, k[_], g, $);
        });
        else if (W.kind === "enum") {
            const _ = k[W.field];
            for(let g = 0; g < W.values.length; ++g){
                const [x, w] = W.values[g];
                if (x === _) {
                    $.writeU8(g), L(C, x, k[x], w, $);
                    break;
                }
            }
        } else throw new f(`Unexpected schema kind: ${W.kind} for ${k.constructor.name}`);
    }
    function F(C, k, $ = p) {
        const W = new $();
        return A(C, k, W), W.toArray();
    }
    et.serialize = F;
    function M(C, k, $, W) {
        try {
            if (typeof $ == "string") return W[`read${b($)}`]();
            if ($ instanceof Array) {
                if (typeof $[0] == "number") return W.readFixedArray($[0]);
                if (typeof $[1] == "number") {
                    const _ = [];
                    for(let g = 0; g < $[1]; g++)_.push(M(C, null, $[0], W));
                    return _;
                } else return W.readArray(()=>M(C, k, $[0], W));
            }
            if ($.kind === "option") return W.readU8() ? M(C, k, $.type, W) : void 0;
            if ($.kind === "map") {
                let _ = /* @__PURE__ */ new Map();
                const g = W.readU32();
                for(let x = 0; x < g; x++){
                    const w = M(C, k, $.key, W), D = M(C, k, $.value, W);
                    _.set(w, D);
                }
                return _;
            }
            return H(C, $, W);
        } catch (_) {
            throw _ instanceof f && _.addToFieldPath(k), _;
        }
    }
    function H(C, k, $) {
        if (typeof k.borshDeserialize == "function") return k.borshDeserialize($);
        const W = C.get(k);
        if (!W) throw new f(`Class ${k.name} is missing in schema`);
        if (W.kind === "struct") {
            const _ = {};
            for (const [g, x] of C.get(k).fields)_[g] = M(C, g, x, $);
            return new k(_);
        }
        if (W.kind === "enum") {
            const _ = $.readU8();
            if (_ >= W.values.length) throw new f(`Enum index: ${_} is out of range`);
            const [g, x] = W.values[_], w = M(C, g, x, $);
            return new k({
                [g]: w
            });
        }
        throw new f(`Unexpected schema kind: ${W.kind} for ${k.constructor.name}`);
    }
    function K(C, k, $, W = E) {
        const _ = new W($), g = H(C, k, _);
        if (_.offset < $.length) throw new f(`Unexpected ${$.length - _.offset} bytes after deserialized data`);
        return g;
    }
    et.deserialize = K;
    function j(C, k, $, W = E) {
        const _ = new W($);
        return H(C, k, _);
    }
    return et.deserializeUnchecked = j, et;
}
var Ja = qy(), re = {}, Rd;
function Wy() {
    if (Rd) return re;
    Rd = 1, Object.defineProperty(re, "__esModule", {
        value: !0
    }), re.s16 = re.s8 = re.nu64be = re.u48be = re.u40be = re.u32be = re.u24be = re.u16be = re.nu64 = re.u48 = re.u40 = re.u32 = re.u24 = re.u16 = re.u8 = re.offset = re.greedy = re.Constant = re.UTF8 = re.CString = re.Blob = re.Boolean = re.BitField = re.BitStructure = re.VariantLayout = re.Union = re.UnionLayoutDiscriminator = re.UnionDiscriminator = re.Structure = re.Sequence = re.DoubleBE = re.Double = re.FloatBE = re.Float = re.NearInt64BE = re.NearInt64 = re.NearUInt64BE = re.NearUInt64 = re.IntBE = re.Int = re.UIntBE = re.UInt = re.OffsetLayout = re.GreedyCount = re.ExternalLayout = re.bindConstructorLayout = re.nameWithProperty = re.Layout = re.uint8ArrayToBuffer = re.checkUint8Array = void 0, re.constant = re.utf8 = re.cstr = re.blob = re.unionLayoutDiscriminator = re.union = re.seq = re.bits = re.struct = re.f64be = re.f64 = re.f32be = re.f32 = re.ns64be = re.s48be = re.s40be = re.s32be = re.s24be = re.s16be = re.ns64 = re.s48 = re.s40 = re.s32 = re.s24 = void 0;
    const s = Kc();
    function e(m) {
        if (!(m instanceof Uint8Array)) throw new TypeError("b must be a Uint8Array");
    }
    re.checkUint8Array = e;
    function t(m) {
        return e(m), s.Buffer.from(m.buffer, m.byteOffset, m.length);
    }
    re.uint8ArrayToBuffer = t;
    let r = class {
        constructor(v, P){
            if (!Number.isInteger(v)) throw new TypeError("span must be an integer");
            this.span = v, this.property = P;
        }
        /** Function to create an Object into which decoded properties will
     * be written.
     *
     * Used only for layouts that {@link Layout#decode|decode} to Object
     * instances, which means:
     * * {@link Structure}
     * * {@link Union}
     * * {@link VariantLayout}
     * * {@link BitStructure}
     *
     * If left undefined the JavaScript representation of these layouts
     * will be Object instances.
     *
     * See {@link bindConstructorLayout}.
     */ makeDestinationObject() {
            return {};
        }
        /**
     * Calculate the span of a specific instance of a layout.
     *
     * @param {Uint8Array} b - the buffer that contains an encoded instance.
     *
     * @param {Number} [offset] - the offset at which the encoded instance
     * starts.  If absent a zero offset is inferred.
     *
     * @return {Number} - the number of bytes covered by the layout
     * instance.  If this method is not overridden in a subclass the
     * definition-time constant {@link Layout#span|span} will be
     * returned.
     *
     * @throws {RangeError} - if the length of the value cannot be
     * determined.
     */ getSpan(v, P) {
            if (0 > this.span) throw new RangeError("indeterminate span");
            return this.span;
        }
        /**
     * Replicate the layout using a new property.
     *
     * This function must be used to get a structurally-equivalent layout
     * with a different name since all {@link Layout} instances are
     * immutable.
     *
     * **NOTE** This is a shallow copy.  All fields except {@link
     * Layout#property|property} are strictly equal to the origin layout.
     *
     * @param {String} property - the value for {@link
     * Layout#property|property} in the replica.
     *
     * @returns {Layout} - the copy with {@link Layout#property|property}
     * set to `property`.
     */ replicate(v) {
            const P = Object.create(this.constructor.prototype);
            return Object.assign(P, this), P.property = v, P;
        }
        /**
     * Create an object from layout properties and an array of values.
     *
     * **NOTE** This function returns `undefined` if invoked on a layout
     * that does not return its value as an Object.  Objects are
     * returned for things that are a {@link Structure}, which includes
     * {@link VariantLayout|variant layouts} if they are structures, and
     * excludes {@link Union}s.  If you want this feature for a union
     * you must use {@link Union.getVariant|getVariant} to select the
     * desired layout.
     *
     * @param {Array} values - an array of values that correspond to the
     * default order for properties.  As with {@link Layout#decode|decode}
     * layout elements that have no property name are skipped when
     * iterating over the array values.  Only the top-level properties are
     * assigned; arguments are not assigned to properties of contained
     * layouts.  Any unused values are ignored.
     *
     * @return {(Object|undefined)}
     */ fromArray(v) {}
    };
    re.Layout = r;
    function n1(m, v) {
        return v.property ? m + "[" + v.property + "]" : m;
    }
    re.nameWithProperty = n1;
    function i(m, v) {
        if (typeof m != "function") throw new TypeError("Class must be constructor");
        if (Object.prototype.hasOwnProperty.call(m, "layout_")) throw new Error("Class is already bound to a layout");
        if (!(v && v instanceof r)) throw new TypeError("layout must be a Layout");
        if (Object.prototype.hasOwnProperty.call(v, "boundConstructor_")) throw new Error("layout is already bound to a constructor");
        m.layout_ = v, v.boundConstructor_ = m, v.makeDestinationObject = ()=>new m(), Object.defineProperty(m.prototype, "encode", {
            value (P, N) {
                return v.encode(this, P, N);
            },
            writable: !0
        }), Object.defineProperty(m, "decode", {
            value (P, N) {
                return v.decode(P, N);
            },
            writable: !0
        });
    }
    re.bindConstructorLayout = i;
    class o extends r {
        /**
     * Return `true` iff the external layout decodes to an unsigned
     * integer layout.
     *
     * In that case it can be used as the source of {@link
     * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},
     * or as {@link UnionLayoutDiscriminator#layout|external union
     * discriminators}.
     *
     * @abstract
     */ isCount() {
            throw new Error("ExternalLayout is abstract");
        }
    }
    re.ExternalLayout = o;
    class a extends o {
        constructor(v = 1, P){
            if (!Number.isInteger(v) || 0 >= v) throw new TypeError("elementSpan must be a (positive) integer");
            super(-1, P), this.elementSpan = v;
        }
        /** @override */ isCount() {
            return !0;
        }
        /** @override */ decode(v, P = 0) {
            e(v);
            const N = v.length - P;
            return Math.floor(N / this.elementSpan);
        }
        /** @override */ encode(v, P, N) {
            return 0;
        }
    }
    re.GreedyCount = a;
    class l extends o {
        constructor(v, P = 0, N){
            if (!(v instanceof r)) throw new TypeError("layout must be a Layout");
            if (!Number.isInteger(P)) throw new TypeError("offset must be integer or undefined");
            super(v.span, N || v.property), this.layout = v, this.offset = P;
        }
        /** @override */ isCount() {
            return this.layout instanceof c || this.layout instanceof u;
        }
        /** @override */ decode(v, P = 0) {
            return this.layout.decode(v, P + this.offset);
        }
        /** @override */ encode(v, P, N = 0) {
            return this.layout.encode(v, P, N + this.offset);
        }
    }
    re.OffsetLayout = l;
    class c extends r {
        constructor(v, P){
            if (super(v, P), 6 < this.span) throw new RangeError("span must not exceed 6 bytes");
        }
        /** @override */ decode(v, P = 0) {
            return t(v).readUIntLE(P, this.span);
        }
        /** @override */ encode(v, P, N = 0) {
            return t(P).writeUIntLE(v, N, this.span), this.span;
        }
    }
    re.UInt = c;
    class u extends r {
        constructor(v, P){
            if (super(v, P), 6 < this.span) throw new RangeError("span must not exceed 6 bytes");
        }
        /** @override */ decode(v, P = 0) {
            return t(v).readUIntBE(P, this.span);
        }
        /** @override */ encode(v, P, N = 0) {
            return t(P).writeUIntBE(v, N, this.span), this.span;
        }
    }
    re.UIntBE = u;
    class d1 extends r {
        constructor(v, P){
            if (super(v, P), 6 < this.span) throw new RangeError("span must not exceed 6 bytes");
        }
        /** @override */ decode(v, P = 0) {
            return t(v).readIntLE(P, this.span);
        }
        /** @override */ encode(v, P, N = 0) {
            return t(P).writeIntLE(v, N, this.span), this.span;
        }
    }
    re.Int = d1;
    class h extends r {
        constructor(v, P){
            if (super(v, P), 6 < this.span) throw new RangeError("span must not exceed 6 bytes");
        }
        /** @override */ decode(v, P = 0) {
            return t(v).readIntBE(P, this.span);
        }
        /** @override */ encode(v, P, N = 0) {
            return t(P).writeIntBE(v, N, this.span), this.span;
        }
    }
    re.IntBE = h;
    const f = Math.pow(2, 32);
    function p(m) {
        const v = Math.floor(m / f), P = m - v * f;
        return {
            hi32: v,
            lo32: P
        };
    }
    function y(m, v) {
        return m * f + v;
    }
    class E extends r {
        constructor(v){
            super(8, v);
        }
        /** @override */ decode(v, P = 0) {
            const N = t(v), Y = N.readUInt32LE(P), ee = N.readUInt32LE(P + 4);
            return y(ee, Y);
        }
        /** @override */ encode(v, P, N = 0) {
            const Y = p(v), ee = t(P);
            return ee.writeUInt32LE(Y.lo32, N), ee.writeUInt32LE(Y.hi32, N + 4), 8;
        }
    }
    re.NearUInt64 = E;
    class b extends r {
        constructor(v){
            super(8, v);
        }
        /** @override */ decode(v, P = 0) {
            const N = t(v), Y = N.readUInt32BE(P), ee = N.readUInt32BE(P + 4);
            return y(Y, ee);
        }
        /** @override */ encode(v, P, N = 0) {
            const Y = p(v), ee = t(P);
            return ee.writeUInt32BE(Y.hi32, N), ee.writeUInt32BE(Y.lo32, N + 4), 8;
        }
    }
    re.NearUInt64BE = b;
    class L extends r {
        constructor(v){
            super(8, v);
        }
        /** @override */ decode(v, P = 0) {
            const N = t(v), Y = N.readUInt32LE(P), ee = N.readInt32LE(P + 4);
            return y(ee, Y);
        }
        /** @override */ encode(v, P, N = 0) {
            const Y = p(v), ee = t(P);
            return ee.writeUInt32LE(Y.lo32, N), ee.writeInt32LE(Y.hi32, N + 4), 8;
        }
    }
    re.NearInt64 = L;
    class A extends r {
        constructor(v){
            super(8, v);
        }
        /** @override */ decode(v, P = 0) {
            const N = t(v), Y = N.readInt32BE(P), ee = N.readUInt32BE(P + 4);
            return y(Y, ee);
        }
        /** @override */ encode(v, P, N = 0) {
            const Y = p(v), ee = t(P);
            return ee.writeInt32BE(Y.hi32, N), ee.writeUInt32BE(Y.lo32, N + 4), 8;
        }
    }
    re.NearInt64BE = A;
    class F extends r {
        constructor(v){
            super(4, v);
        }
        /** @override */ decode(v, P = 0) {
            return t(v).readFloatLE(P);
        }
        /** @override */ encode(v, P, N = 0) {
            return t(P).writeFloatLE(v, N), 4;
        }
    }
    re.Float = F;
    class M extends r {
        constructor(v){
            super(4, v);
        }
        /** @override */ decode(v, P = 0) {
            return t(v).readFloatBE(P);
        }
        /** @override */ encode(v, P, N = 0) {
            return t(P).writeFloatBE(v, N), 4;
        }
    }
    re.FloatBE = M;
    class H extends r {
        constructor(v){
            super(8, v);
        }
        /** @override */ decode(v, P = 0) {
            return t(v).readDoubleLE(P);
        }
        /** @override */ encode(v, P, N = 0) {
            return t(P).writeDoubleLE(v, N), 8;
        }
    }
    re.Double = H;
    class K extends r {
        constructor(v){
            super(8, v);
        }
        /** @override */ decode(v, P = 0) {
            return t(v).readDoubleBE(P);
        }
        /** @override */ encode(v, P, N = 0) {
            return t(P).writeDoubleBE(v, N), 8;
        }
    }
    re.DoubleBE = K;
    class j extends r {
        constructor(v, P, N){
            if (!(v instanceof r)) throw new TypeError("elementLayout must be a Layout");
            if (!(P instanceof o && P.isCount() || Number.isInteger(P) && 0 <= P)) throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
            let Y = -1;
            !(P instanceof o) && 0 < v.span && (Y = P * v.span), super(Y, N), this.elementLayout = v, this.count = P;
        }
        /** @override */ getSpan(v, P = 0) {
            if (0 <= this.span) return this.span;
            let N = 0, Y = this.count;
            if (Y instanceof o && (Y = Y.decode(v, P)), 0 < this.elementLayout.span) N = Y * this.elementLayout.span;
            else {
                let ee = 0;
                for(; ee < Y;)N += this.elementLayout.getSpan(v, P + N), ++ee;
            }
            return N;
        }
        /** @override */ decode(v, P = 0) {
            const N = [];
            let Y = 0, ee = this.count;
            for(ee instanceof o && (ee = ee.decode(v, P)); Y < ee;)N.push(this.elementLayout.decode(v, P)), P += this.elementLayout.getSpan(v, P), Y += 1;
            return N;
        }
        /** Implement {@link Layout#encode|encode} for {@link Sequence}.
     *
     * **NOTE** If `src` is shorter than {@link Sequence#count|count} then
     * the unused space in the buffer is left unchanged.  If `src` is
     * longer than {@link Sequence#count|count} the unneeded elements are
     * ignored.
     *
     * **NOTE** If {@link Layout#count|count} is an instance of {@link
     * ExternalLayout} then the length of `src` will be encoded as the
     * count after `src` is encoded. */ encode(v, P, N = 0) {
            const Y = this.elementLayout, ee = v.reduce((ie, le)=>ie + Y.encode(le, P, N + ie), 0);
            return this.count instanceof o && this.count.encode(v.length, P, N), ee;
        }
    }
    re.Sequence = j;
    class C extends r {
        constructor(v, P, N){
            if (!(Array.isArray(v) && v.reduce((ee, ie)=>ee && ie instanceof r, !0))) throw new TypeError("fields must be array of Layout instances");
            typeof P == "boolean" && N === void 0 && (N = P, P = void 0);
            for (const ee of v)if (0 > ee.span && ee.property === void 0) throw new Error("fields cannot contain unnamed variable-length layout");
            let Y = -1;
            try {
                Y = v.reduce((ee, ie)=>ee + ie.getSpan(), 0);
            } catch  {}
            super(Y, P), this.fields = v, this.decodePrefixes = !!N;
        }
        /** @override */ getSpan(v, P = 0) {
            if (0 <= this.span) return this.span;
            let N = 0;
            try {
                N = this.fields.reduce((Y, ee)=>{
                    const ie = ee.getSpan(v, P);
                    return P += ie, Y + ie;
                }, 0);
            } catch  {
                throw new RangeError("indeterminate span");
            }
            return N;
        }
        /** @override */ decode(v, P = 0) {
            e(v);
            const N = this.makeDestinationObject();
            for (const Y of this.fields)if (Y.property !== void 0 && (N[Y.property] = Y.decode(v, P)), P += Y.getSpan(v, P), this.decodePrefixes && v.length === P) break;
            return N;
        }
        /** Implement {@link Layout#encode|encode} for {@link Structure}.
     *
     * If `src` is missing a property for a member with a defined {@link
     * Layout#property|property} the corresponding region of the buffer is
     * left unmodified. */ encode(v, P, N = 0) {
            const Y = N;
            let ee = 0, ie = 0;
            for (const le of this.fields){
                let Te = le.span;
                if (ie = 0 < Te ? Te : 0, le.property !== void 0) {
                    const De = v[le.property];
                    De !== void 0 && (ie = le.encode(De, P, N), 0 > Te && (Te = le.getSpan(P, N)));
                }
                ee = N, N += Te;
            }
            return ee + ie - Y;
        }
        /** @override */ fromArray(v) {
            const P = this.makeDestinationObject();
            for (const N of this.fields)N.property !== void 0 && 0 < v.length && (P[N.property] = v.shift());
            return P;
        }
        /**
     * Get access to the layout of a given property.
     *
     * @param {String} property - the structure member of interest.
     *
     * @return {Layout} - the layout associated with `property`, or
     * undefined if there is no such property.
     */ layoutFor(v) {
            if (typeof v != "string") throw new TypeError("property must be string");
            for (const P of this.fields)if (P.property === v) return P;
        }
        /**
     * Get the offset of a structure member.
     *
     * @param {String} property - the structure member of interest.
     *
     * @return {Number} - the offset in bytes to the start of `property`
     * within the structure, or undefined if `property` is not a field
     * within the structure.  If the property is a member but follows a
     * variable-length structure member a negative number will be
     * returned.
     */ offsetOf(v) {
            if (typeof v != "string") throw new TypeError("property must be string");
            let P = 0;
            for (const N of this.fields){
                if (N.property === v) return P;
                0 > N.span ? P = -1 : 0 <= P && (P += N.span);
            }
        }
    }
    re.Structure = C;
    class k {
        constructor(v){
            this.property = v;
        }
        /** Analog to {@link Layout#decode|Layout decode} for union discriminators.
     *
     * The implementation of this method need not reference the buffer if
     * variant information is available through other means. */ decode(v, P) {
            throw new Error("UnionDiscriminator is abstract");
        }
        /** Analog to {@link Layout#decode|Layout encode} for union discriminators.
     *
     * The implementation of this method need not store the value if
     * variant information is maintained through other means. */ encode(v, P, N) {
            throw new Error("UnionDiscriminator is abstract");
        }
    }
    re.UnionDiscriminator = k;
    class $ extends k {
        constructor(v, P){
            if (!(v instanceof o && v.isCount())) throw new TypeError("layout must be an unsigned integer ExternalLayout");
            super(P || v.property || "variant"), this.layout = v;
        }
        /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */ decode(v, P) {
            return this.layout.decode(v, P);
        }
        /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */ encode(v, P, N) {
            return this.layout.encode(v, P, N);
        }
    }
    re.UnionLayoutDiscriminator = $;
    class W extends r {
        constructor(v, P, N){
            let Y;
            if (v instanceof c || v instanceof u) Y = new $(new l(v));
            else if (v instanceof o && v.isCount()) Y = new $(v);
            else if (v instanceof k) Y = v;
            else throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
            if (P === void 0 && (P = null), !(P === null || P instanceof r)) throw new TypeError("defaultLayout must be null or a Layout");
            if (P !== null) {
                if (0 > P.span) throw new Error("defaultLayout must have constant span");
                P.property === void 0 && (P = P.replicate("content"));
            }
            let ee = -1;
            P && (ee = P.span, 0 <= ee && (v instanceof c || v instanceof u) && (ee += Y.layout.span)), super(ee, N), this.discriminator = Y, this.usesPrefixDiscriminator = v instanceof c || v instanceof u, this.defaultLayout = P, this.registry = {};
            let ie = this.defaultGetSourceVariant.bind(this);
            this.getSourceVariant = function(le) {
                return ie(le);
            }, this.configGetSourceVariant = function(le) {
                ie = le.bind(this);
            };
        }
        /** @override */ getSpan(v, P = 0) {
            if (0 <= this.span) return this.span;
            const N = this.getVariant(v, P);
            if (!N) throw new Error("unable to determine span for unrecognized variant");
            return N.getSpan(v, P);
        }
        /**
     * Method to infer a registered Union variant compatible with `src`.
     *
     * The first satisfied rule in the following sequence defines the
     * return value:
     * * If `src` has properties matching the Union discriminator and
     *   the default layout, `undefined` is returned regardless of the
     *   value of the discriminator property (this ensures the default
     *   layout will be used);
     * * If `src` has a property matching the Union discriminator, the
     *   value of the discriminator identifies a registered variant, and
     *   either (a) the variant has no layout, or (b) `src` has the
     *   variant's property, then the variant is returned (because the
     *   source satisfies the constraints of the variant it identifies);
     * * If `src` does not have a property matching the Union
     *   discriminator, but does have a property matching a registered
     *   variant, then the variant is returned (because the source
     *   matches a variant without an explicit conflict);
     * * An error is thrown (because we either can't identify a variant,
     *   or we were explicitly told the variant but can't satisfy it).
     *
     * @param {Object} src - an object presumed to be compatible with
     * the content of the Union.
     *
     * @return {(undefined|VariantLayout)} - as described above.
     *
     * @throws {Error} - if `src` cannot be associated with a default or
     * registered variant.
     */ defaultGetSourceVariant(v) {
            if (Object.prototype.hasOwnProperty.call(v, this.discriminator.property)) {
                if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(v, this.defaultLayout.property)) return;
                const P = this.registry[v[this.discriminator.property]];
                if (P && (!P.layout || P.property && Object.prototype.hasOwnProperty.call(v, P.property))) return P;
            } else for(const P in this.registry){
                const N = this.registry[P];
                if (N.property && Object.prototype.hasOwnProperty.call(v, N.property)) return N;
            }
            throw new Error("unable to infer src variant");
        }
        /** Implement {@link Layout#decode|decode} for {@link Union}.
     *
     * If the variant is {@link Union#addVariant|registered} the return
     * value is an instance of that variant, with no explicit
     * discriminator.  Otherwise the {@link Union#defaultLayout|default
     * layout} is used to decode the content. */ decode(v, P = 0) {
            let N;
            const Y = this.discriminator, ee = Y.decode(v, P), ie = this.registry[ee];
            if (ie === void 0) {
                const le = this.defaultLayout;
                let Te = 0;
                this.usesPrefixDiscriminator && (Te = Y.layout.span), N = this.makeDestinationObject(), N[Y.property] = ee, N[le.property] = le.decode(v, P + Te);
            } else N = ie.decode(v, P);
            return N;
        }
        /** Implement {@link Layout#encode|encode} for {@link Union}.
     *
     * This API assumes the `src` object is consistent with the union's
     * {@link Union#defaultLayout|default layout}.  To encode variants
     * use the appropriate variant-specific {@link VariantLayout#encode}
     * method. */ encode(v, P, N = 0) {
            const Y = this.getSourceVariant(v);
            if (Y === void 0) {
                const ee = this.discriminator, ie = this.defaultLayout;
                let le = 0;
                return this.usesPrefixDiscriminator && (le = ee.layout.span), ee.encode(v[ee.property], P, N), le + ie.encode(v[ie.property], P, N + le);
            }
            return Y.encode(v, P, N);
        }
        /** Register a new variant structure within a union.  The newly
     * created variant is returned.
     *
     * @param {Number} variant - initializer for {@link
     * VariantLayout#variant|variant}.
     *
     * @param {Layout} layout - initializer for {@link
     * VariantLayout#layout|layout}.
     *
     * @param {String} property - initializer for {@link
     * Layout#property|property}.
     *
     * @return {VariantLayout} */ addVariant(v, P, N) {
            const Y = new _(this, v, P, N);
            return this.registry[v] = Y, Y;
        }
        /**
     * Get the layout associated with a registered variant.
     *
     * If `vb` does not produce a registered variant the function returns
     * `undefined`.
     *
     * @param {(Number|Uint8Array)} vb - either the variant number, or a
     * buffer from which the discriminator is to be read.
     *
     * @param {Number} offset - offset into `vb` for the start of the
     * union.  Used only when `vb` is an instance of {Uint8Array}.
     *
     * @return {({VariantLayout}|undefined)}
     */ getVariant(v, P = 0) {
            let N;
            return v instanceof Uint8Array ? N = this.discriminator.decode(v, P) : N = v, this.registry[N];
        }
    }
    re.Union = W;
    class _ extends r {
        constructor(v, P, N, Y){
            if (!(v instanceof W)) throw new TypeError("union must be a Union");
            if (!Number.isInteger(P) || 0 > P) throw new TypeError("variant must be a (non-negative) integer");
            if (typeof N == "string" && Y === void 0 && (Y = N, N = null), N) {
                if (!(N instanceof r)) throw new TypeError("layout must be a Layout");
                if (v.defaultLayout !== null && 0 <= N.span && N.span > v.defaultLayout.span) throw new Error("variant span exceeds span of containing union");
                if (typeof Y != "string") throw new TypeError("variant must have a String property");
            }
            let ee = v.span;
            0 > v.span && (ee = N ? N.span : 0, 0 <= ee && v.usesPrefixDiscriminator && (ee += v.discriminator.layout.span)), super(ee, Y), this.union = v, this.variant = P, this.layout = N || null;
        }
        /** @override */ getSpan(v, P = 0) {
            if (0 <= this.span) return this.span;
            let N = 0;
            this.union.usesPrefixDiscriminator && (N = this.union.discriminator.layout.span);
            let Y = 0;
            return this.layout && (Y = this.layout.getSpan(v, P + N)), N + Y;
        }
        /** @override */ decode(v, P = 0) {
            const N = this.makeDestinationObject();
            if (this !== this.union.getVariant(v, P)) throw new Error("variant mismatch");
            let Y = 0;
            return this.union.usesPrefixDiscriminator && (Y = this.union.discriminator.layout.span), this.layout ? N[this.property] = this.layout.decode(v, P + Y) : this.property ? N[this.property] = !0 : this.union.usesPrefixDiscriminator && (N[this.union.discriminator.property] = this.variant), N;
        }
        /** @override */ encode(v, P, N = 0) {
            let Y = 0;
            if (this.union.usesPrefixDiscriminator && (Y = this.union.discriminator.layout.span), this.layout && !Object.prototype.hasOwnProperty.call(v, this.property)) throw new TypeError("variant lacks property " + this.property);
            this.union.discriminator.encode(this.variant, P, N);
            let ee = Y;
            if (this.layout && (this.layout.encode(v[this.property], P, N + Y), ee += this.layout.getSpan(P, N + Y), 0 <= this.union.span && ee > this.union.span)) throw new Error("encoded variant overruns containing union");
            return ee;
        }
        /** Delegate {@link Layout#fromArray|fromArray} to {@link
     * VariantLayout#layout|layout}. */ fromArray(v) {
            if (this.layout) return this.layout.fromArray(v);
        }
    }
    re.VariantLayout = _;
    function g(m) {
        return 0 > m && (m += 4294967296), m;
    }
    class x extends r {
        constructor(v, P, N){
            if (!(v instanceof c || v instanceof u)) throw new TypeError("word must be a UInt or UIntBE layout");
            if (typeof P == "string" && N === void 0 && (N = P, P = !1), 4 < v.span) throw new RangeError("word cannot exceed 32 bits");
            super(v.span, N), this.word = v, this.msb = !!P, this.fields = [];
            let Y = 0;
            this._packedSetValue = function(ee) {
                return Y = g(ee), this;
            }, this._packedGetValue = function() {
                return Y;
            };
        }
        /** @override */ decode(v, P = 0) {
            const N = this.makeDestinationObject(), Y = this.word.decode(v, P);
            this._packedSetValue(Y);
            for (const ee of this.fields)ee.property !== void 0 && (N[ee.property] = ee.decode(v));
            return N;
        }
        /** Implement {@link Layout#encode|encode} for {@link BitStructure}.
     *
     * If `src` is missing a property for a member with a defined {@link
     * Layout#property|property} the corresponding region of the packed
     * value is left unmodified.  Unused bits are also left unmodified. */ encode(v, P, N = 0) {
            const Y = this.word.decode(P, N);
            this._packedSetValue(Y);
            for (const ee of this.fields)if (ee.property !== void 0) {
                const ie = v[ee.property];
                ie !== void 0 && ee.encode(ie);
            }
            return this.word.encode(this._packedGetValue(), P, N);
        }
        /** Register a new bitfield with a containing bit structure.  The
     * resulting bitfield is returned.
     *
     * @param {Number} bits - initializer for {@link BitField#bits|bits}.
     *
     * @param {string} property - initializer for {@link
     * Layout#property|property}.
     *
     * @return {BitField} */ addField(v, P) {
            const N = new w(this, v, P);
            return this.fields.push(N), N;
        }
        /** As with {@link BitStructure#addField|addField} for single-bit
     * fields with `boolean` value representation.
     *
     * @param {string} property - initializer for {@link
     * Layout#property|property}.
     *
     * @return {Boolean} */ // `Boolean` conflicts with the native primitive type
        // eslint-disable-next-line @typescript-eslint/ban-types
        addBoolean(v) {
            const P = new D(this, v);
            return this.fields.push(P), P;
        }
        /**
     * Get access to the bit field for a given property.
     *
     * @param {String} property - the bit field of interest.
     *
     * @return {BitField} - the field associated with `property`, or
     * undefined if there is no such property.
     */ fieldFor(v) {
            if (typeof v != "string") throw new TypeError("property must be string");
            for (const P of this.fields)if (P.property === v) return P;
        }
    }
    re.BitStructure = x;
    class w {
        constructor(v, P, N){
            if (!(v instanceof x)) throw new TypeError("container must be a BitStructure");
            if (!Number.isInteger(P) || 0 >= P) throw new TypeError("bits must be positive integer");
            const Y = 8 * v.span, ee = v.fields.reduce((ie, le)=>ie + le.bits, 0);
            if (P + ee > Y) throw new Error("bits too long for span remainder (" + (Y - ee) + " of " + Y + " remain)");
            this.container = v, this.bits = P, this.valueMask = (1 << P) - 1, P === 32 && (this.valueMask = 4294967295), this.start = ee, this.container.msb && (this.start = Y - ee - P), this.wordMask = g(this.valueMask << this.start), this.property = N;
        }
        /** Store a value into the corresponding subsequence of the containing
     * bit field. */ decode(v, P) {
            const N = this.container._packedGetValue();
            return g(N & this.wordMask) >>> this.start;
        }
        /** Store a value into the corresponding subsequence of the containing
     * bit field.
     *
     * **NOTE** This is not a specialization of {@link
     * Layout#encode|Layout.encode} and there is no return value. */ encode(v) {
            if (typeof v != "number" || !Number.isInteger(v) || v !== g(v & this.valueMask)) throw new TypeError(n1("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
            const P = this.container._packedGetValue(), N = g(v << this.start);
            this.container._packedSetValue(g(P & ~this.wordMask) | N);
        }
    }
    re.BitField = w;
    class D extends w {
        constructor(v, P){
            super(v, 1, P);
        }
        /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.
     *
     * @returns {boolean} */ decode(v, P) {
            return !!super.decode(v, P);
        }
        /** @override */ encode(v) {
            typeof v == "boolean" && (v = +v), super.encode(v);
        }
    }
    re.Boolean = D;
    class O extends r {
        constructor(v, P){
            if (!(v instanceof o && v.isCount() || Number.isInteger(v) && 0 <= v)) throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
            let N = -1;
            v instanceof o || (N = v), super(N, P), this.length = v;
        }
        /** @override */ getSpan(v, P) {
            let N = this.span;
            return 0 > N && (N = this.length.decode(v, P)), N;
        }
        /** @override */ decode(v, P = 0) {
            let N = this.span;
            return 0 > N && (N = this.length.decode(v, P)), t(v).slice(P, P + N);
        }
        /** Implement {@link Layout#encode|encode} for {@link Blob}.
     *
     * **NOTE** If {@link Layout#count|count} is an instance of {@link
     * ExternalLayout} then the length of `src` will be encoded as the
     * count after `src` is encoded. */ encode(v, P, N) {
            let Y = this.length;
            if (this.length instanceof o && (Y = v.length), !(v instanceof Uint8Array && Y === v.length)) throw new TypeError(n1("Blob.encode", this) + " requires (length " + Y + ") Uint8Array as src");
            if (N + Y > P.length) throw new RangeError("encoding overruns Uint8Array");
            const ee = t(v);
            return t(P).write(ee.toString("hex"), N, Y, "hex"), this.length instanceof o && this.length.encode(Y, P, N), Y;
        }
    }
    re.Blob = O;
    class U extends r {
        constructor(v){
            super(-1, v);
        }
        /** @override */ getSpan(v, P = 0) {
            e(v);
            let N = P;
            for(; N < v.length && v[N] !== 0;)N += 1;
            return 1 + N - P;
        }
        /** @override */ decode(v, P = 0) {
            const N = this.getSpan(v, P);
            return t(v).slice(P, P + N - 1).toString("utf-8");
        }
        /** @override */ encode(v, P, N = 0) {
            typeof v != "string" && (v = String(v));
            const Y = s.Buffer.from(v, "utf8"), ee = Y.length;
            if (N + ee > P.length) throw new RangeError("encoding overruns Buffer");
            const ie = t(P);
            return Y.copy(ie, N), ie[N + ee] = 0, ee + 1;
        }
    }
    re.CString = U;
    class V extends r {
        constructor(v, P){
            if (typeof v == "string" && P === void 0 && (P = v, v = void 0), v === void 0) v = -1;
            else if (!Number.isInteger(v)) throw new TypeError("maxSpan must be an integer");
            super(-1, P), this.maxSpan = v;
        }
        /** @override */ getSpan(v, P = 0) {
            return e(v), v.length - P;
        }
        /** @override */ decode(v, P = 0) {
            const N = this.getSpan(v, P);
            if (0 <= this.maxSpan && this.maxSpan < N) throw new RangeError("text length exceeds maxSpan");
            return t(v).slice(P, P + N).toString("utf-8");
        }
        /** @override */ encode(v, P, N = 0) {
            typeof v != "string" && (v = String(v));
            const Y = s.Buffer.from(v, "utf8"), ee = Y.length;
            if (0 <= this.maxSpan && this.maxSpan < ee) throw new RangeError("text length exceeds maxSpan");
            if (N + ee > P.length) throw new RangeError("encoding overruns Buffer");
            return Y.copy(t(P), N), ee;
        }
    }
    re.UTF8 = V;
    class R extends r {
        constructor(v, P){
            super(0, P), this.value = v;
        }
        /** @override */ decode(v, P) {
            return this.value;
        }
        /** @override */ encode(v, P, N) {
            return 0;
        }
    }
    return re.Constant = R, re.greedy = (m, v)=>new a(m, v), re.offset = (m, v, P)=>new l(m, v, P), re.u8 = (m)=>new c(1, m), re.u16 = (m)=>new c(2, m), re.u24 = (m)=>new c(3, m), re.u32 = (m)=>new c(4, m), re.u40 = (m)=>new c(5, m), re.u48 = (m)=>new c(6, m), re.nu64 = (m)=>new E(m), re.u16be = (m)=>new u(2, m), re.u24be = (m)=>new u(3, m), re.u32be = (m)=>new u(4, m), re.u40be = (m)=>new u(5, m), re.u48be = (m)=>new u(6, m), re.nu64be = (m)=>new b(m), re.s8 = (m)=>new d1(1, m), re.s16 = (m)=>new d1(2, m), re.s24 = (m)=>new d1(3, m), re.s32 = (m)=>new d1(4, m), re.s40 = (m)=>new d1(5, m), re.s48 = (m)=>new d1(6, m), re.ns64 = (m)=>new L(m), re.s16be = (m)=>new h(2, m), re.s24be = (m)=>new h(3, m), re.s32be = (m)=>new h(4, m), re.s40be = (m)=>new h(5, m), re.s48be = (m)=>new h(6, m), re.ns64be = (m)=>new A(m), re.f32 = (m)=>new F(m), re.f32be = (m)=>new M(m), re.f64 = (m)=>new H(m), re.f64be = (m)=>new K(m), re.struct = (m, v, P)=>new C(m, v, P), re.bits = (m, v, P)=>new x(m, v, P), re.seq = (m, v, P)=>new j(m, v, P), re.union = (m, v, P)=>new W(m, v, P), re.unionLayoutDiscriminator = (m, v)=>new $(m, v), re.blob = (m, v)=>new O(m, v), re.cstr = (m)=>new U(m), re.utf8 = (m, v)=>new V(m, v), re.constant = (m, v)=>new R(m, v), re;
}
var z = Wy(), zy = 8078e3, Yy = 8078001, Zy = 8078004, Xy = 8078005, Jy = 8078006, Qy = 8078011;
function x0(s) {
    return Array.isArray(s) ? "%5B" + s.map(x0).join("%2C%20") + /* "]" */ "%5D" : typeof s == "bigint" ? `${s}n` : encodeURIComponent(String(s != null && Object.getPrototypeOf(s) === null ? // Plain objects with no prototype don't have a `toString` method.
    // Convert them before stringifying them.
    {
        ...s
    } : s));
}
function ev([s, e]) {
    return `${s}=${x0(e)}`;
}
function tv(s) {
    const e = Object.entries(s).map(ev).join("&");
    return btoa(e);
}
function rv(s, e = {}) {
    {
        let t = `Solana error #${s}; Decode this error by running \`npx @solana/errors decode -- ${s}`;
        return Object.keys(e).length && (t += ` '${tv(e)}'`), `${t}\``;
    }
}
var xn = class extends Error {
    constructor(...[e, t]){
        let r, n1;
        if (t) {
            const { cause: o, ...a } = t;
            o && (n1 = {
                cause: o
            }), Object.keys(a).length > 0 && (r = a);
        }
        const i = rv(e, r);
        super(i, n1);
        /**
     * Indicates the root cause of this {@link SolanaError}, if any.
     *
     * For example, a transaction error might have an instruction error as its root cause. In this
     * case, you will be able to access the instruction error on the transaction error as `cause`.
     */ Cr(this, "cause", this.cause);
        /**
     * Contains context that can assist in understanding or recovering from a {@link SolanaError}.
     */ Cr(this, "context");
        this.context = {
            __code: e,
            ...r
        }, this.name = "SolanaError";
    }
};
function sv(s, e) {
    return "fixedSize" in e ? e.fixedSize : e.getSizeFromValue(s);
}
function nv(s) {
    return Object.freeze({
        ...s,
        encode: (e)=>{
            const t = new Uint8Array(sv(e, s));
            return s.write(e, t, 0), t;
        }
    });
}
function iv(s) {
    return Object.freeze({
        ...s,
        decode: (e, t = 0)=>s.read(e, t)[0]
    });
}
function cn(s) {
    return "fixedSize" in s && typeof s.fixedSize == "number";
}
function ov(s, e) {
    if (cn(s) !== cn(e)) throw new xn(Zy);
    if (cn(s) && cn(e) && s.fixedSize !== e.fixedSize) throw new xn(Xy, {
        decoderFixedSize: e.fixedSize,
        encoderFixedSize: s.fixedSize
    });
    if (!cn(s) && !cn(e) && s.maxSize !== e.maxSize) throw new xn(Jy, {
        decoderMaxSize: e.maxSize,
        encoderMaxSize: s.maxSize
    });
    return {
        ...e,
        ...s,
        decode: e.decode,
        encode: s.encode,
        read: e.read,
        write: s.write
    };
}
function av(s, e, t = 0) {
    if (e.length - t <= 0) throw new xn(zy, {
        codecDescription: s
    });
}
function lv(s, e, t, r = 0) {
    const n1 = t.length - r;
    if (n1 < e) throw new xn(Yy, {
        bytesLength: n1,
        codecDescription: s,
        expected: e
    });
}
function cv(s, e, t, r) {
    if (r < e || r > t) throw new xn(Qy, {
        codecDescription: s,
        max: t,
        min: e,
        value: r
    });
}
function S0(s) {
    return (s == null ? void 0 : s.endian) !== 1;
}
function uv(s) {
    return nv({
        fixedSize: s.size,
        write (e, t, r) {
            s.range && cv(s.name, s.range[0], s.range[1], e);
            const n1 = new ArrayBuffer(s.size);
            return s.set(new DataView(n1), e, S0(s.config)), t.set(new Uint8Array(n1), r), r + s.size;
        }
    });
}
function dv(s) {
    return iv({
        fixedSize: s.size,
        read (e, t = 0) {
            av(s.name, e, t), lv(s.name, s.size, e, t);
            const r = new DataView(hv(e, t, s.size));
            return [
                s.get(r, S0(s.config)),
                t + s.size
            ];
        }
    });
}
function hv(s, e, t) {
    const r = s.byteOffset + (e ?? 0), n1 = t ?? s.byteLength;
    return s.buffer.slice(r, r + n1);
}
var fv = (s = {})=>uv({
        config: s,
        name: "u64",
        range: [
            0n,
            BigInt("0xffffffffffffffff")
        ],
        set: (e, t, r)=>e.setBigUint64(0, BigInt(t), r),
        size: 8
    }), gv = (s = {})=>dv({
        config: s,
        get: (e, t)=>e.getBigUint64(0, t),
        name: "u64",
        size: 8
    }), pv = (s = {})=>ov(fv(s), gv(s));
class mv extends TypeError {
    constructor(e, t){
        let r;
        const { message: n1, explanation: i, ...o } = e, { path: a } = e, l = a.length === 0 ? n1 : `At path: ${a.join(".")} -- ${n1}`;
        super(i ?? l), i != null && (this.cause = l), Object.assign(this, o), this.name = this.constructor.name, this.failures = ()=>r ?? (r = [
                e,
                ...t()
            ]);
    }
}
function yv(s) {
    return Ci(s) && typeof s[Symbol.iterator] == "function";
}
function Ci(s) {
    return typeof s == "object" && s != null;
}
function $o(s) {
    return Ci(s) && !Array.isArray(s);
}
function Br(s) {
    return typeof s == "symbol" ? s.toString() : typeof s == "string" ? JSON.stringify(s) : `${s}`;
}
function vv(s) {
    const { done: e, value: t } = s.next();
    return e ? void 0 : t;
}
function Ev(s, e, t, r) {
    if (s === !0) return;
    s === !1 ? s = {} : typeof s == "string" && (s = {
        message: s
    });
    const { path: n1, branch: i } = e, { type: o } = t, { refinement: a, message: l = `Expected a value of type \`${o}\`${a ? ` with refinement \`${a}\`` : ""}, but received: \`${Br(r)}\`` } = s;
    return {
        value: r,
        type: o,
        refinement: a,
        key: n1[n1.length - 1],
        path: n1,
        branch: i,
        ...s,
        message: l
    };
}
function* Cd(s, e, t, r) {
    yv(s) || (s = [
        s
    ]);
    for (const n1 of s){
        const i = Ev(n1, e, t, r);
        i && (yield i);
    }
}
function* Jc(s, e, t = {}) {
    const { path: r = [], branch: n1 = [
        s
    ], coerce: i = !1, mask: o = !1 } = t, a = {
        path: r,
        branch: n1,
        mask: o
    };
    i && (s = e.coercer(s, a));
    let l = "valid";
    for (const c of e.validator(s, a))c.explanation = t.message, l = "not_valid", yield [
        c,
        void 0
    ];
    for (let [c, u, d1] of e.entries(s, a)){
        const h = Jc(u, d1, {
            path: c === void 0 ? r : [
                ...r,
                c
            ],
            branch: c === void 0 ? n1 : [
                ...n1,
                u
            ],
            coerce: i,
            mask: o,
            message: t.message
        });
        for (const f of h)f[0] ? (l = f[0].refinement != null ? "not_refined" : "not_valid", yield [
            f[0],
            void 0
        ]) : i && (u = f[1], c === void 0 ? s = u : s instanceof Map ? s.set(c, u) : s instanceof Set ? s.add(u) : Ci(s) && (u !== void 0 || c in s) && (s[c] = u));
    }
    if (l !== "not_valid") for (const c of e.refiner(s, a))c.explanation = t.message, l = "not_refined", yield [
        c,
        void 0
    ];
    l === "valid" && (yield [
        void 0,
        s
    ]);
}
let es = class {
    constructor(e){
        const { type: t, schema: r, validator: n1, refiner: i, coercer: o = (l)=>l, entries: a = function*() {} } = e;
        this.type = t, this.schema = r, this.entries = a, this.coercer = o, n1 ? this.validator = (l, c)=>{
            const u = n1(l, c);
            return Cd(u, c, this, l);
        } : this.validator = ()=>[], i ? this.refiner = (l, c)=>{
            const u = i(l, c);
            return Cd(u, c, this, l);
        } : this.refiner = ()=>[];
    }
    /**
   * Assert that a value passes the struct's validation, throwing if it doesn't.
   */ assert(e, t) {
        return xv(e, this, t);
    }
    /**
   * Create a value with the struct's coercion logic, then validate it.
   */ create(e, t) {
        return ti(e, this, t);
    }
    /**
   * Check if a value passes the struct's validation.
   */ is(e) {
        return b0(e, this);
    }
    /**
   * Mask a value, coercing and validating it, but returning only the subset of
   * properties defined by the struct's schema. Masking applies recursively to
   * props of `object` structs only.
   */ mask(e, t) {
        return Sv(e, this, t);
    }
    /**
   * Validate a value with the struct's validation logic, returning a tuple
   * representing the result.
   *
   * You may optionally pass `true` for the `coerce` argument to coerce
   * the value before attempting to validate it. If you do, the result will
   * contain the coerced result when successful. Also, `mask` will turn on
   * masking of the unknown `object` props recursively if passed.
   */ validate(e, t = {}) {
        return ki(e, this, t);
    }
};
function xv(s, e, t) {
    const r = ki(s, e, {
        message: t
    });
    if (r[0]) throw r[0];
}
function ti(s, e, t) {
    const r = ki(s, e, {
        coerce: !0,
        message: t
    });
    if (r[0]) throw r[0];
    return r[1];
}
function Sv(s, e, t) {
    const r = ki(s, e, {
        coerce: !0,
        mask: !0,
        message: t
    });
    if (r[0]) throw r[0];
    return r[1];
}
function b0(s, e) {
    return !ki(s, e)[0];
}
function ki(s, e, t = {}) {
    const r = Jc(s, e, t), n1 = vv(r);
    return n1[0] ? [
        new mv(n1[0], function*() {
            for (const o of r)o[0] && (yield o[0]);
        }),
        void 0
    ] : [
        void 0,
        n1[1]
    ];
}
function tn(s, e) {
    return new es({
        type: s,
        schema: null,
        validator: e
    });
}
function bv() {
    return tn("any", ()=>!0);
}
function fe(s) {
    return new es({
        type: "array",
        schema: s,
        *entries (e) {
            if (s && Array.isArray(e)) for (const [t, r] of e.entries())yield [
                t,
                r,
                s
            ];
        },
        coercer (e) {
            return Array.isArray(e) ? e.slice() : e;
        },
        validator (e) {
            return Array.isArray(e) || `Expected an array value, but received: ${Br(e)}`;
        }
    });
}
function Xr() {
    return tn("boolean", (s)=>typeof s == "boolean");
}
function Qc(s) {
    return tn("instance", (e)=>e instanceof s || `Expected a \`${s.name}\` instance, but received: ${Br(e)}`);
}
function gt(s) {
    const e = Br(s), t = typeof s;
    return new es({
        type: "literal",
        schema: t === "string" || t === "number" || t === "boolean" ? s : null,
        validator (r) {
            return r === s || `Expected the literal \`${e}\`, but received: ${Br(r)}`;
        }
    });
}
function Tv() {
    return tn("never", ()=>!1);
}
function ge(s) {
    return new es({
        ...s,
        validator: (e, t)=>e === null || s.validator(e, t),
        refiner: (e, t)=>e === null || s.refiner(e, t)
    });
}
function te() {
    return tn("number", (s)=>typeof s == "number" && !isNaN(s) || `Expected a number, but received: ${Br(s)}`);
}
function Se(s) {
    return new es({
        ...s,
        validator: (e, t)=>e === void 0 || s.validator(e, t),
        refiner: (e, t)=>e === void 0 || s.refiner(e, t)
    });
}
function T0(s, e) {
    return new es({
        type: "record",
        schema: null,
        *entries (t) {
            if (Ci(t)) for(const r in t){
                const n1 = t[r];
                yield [
                    r,
                    r,
                    s
                ], yield [
                    r,
                    n1,
                    e
                ];
            }
        },
        validator (t) {
            return $o(t) || `Expected an object, but received: ${Br(t)}`;
        },
        coercer (t) {
            return $o(t) ? {
                ...t
            } : t;
        }
    });
}
function ce() {
    return tn("string", (s)=>typeof s == "string" || `Expected a string, but received: ${Br(s)}`);
}
function eu(s) {
    const e = Tv();
    return new es({
        type: "tuple",
        schema: null,
        *entries (t) {
            if (Array.isArray(t)) {
                const r = Math.max(s.length, t.length);
                for(let n1 = 0; n1 < r; n1++)yield [
                    n1,
                    t[n1],
                    s[n1] || e
                ];
            }
        },
        validator (t) {
            return Array.isArray(t) || `Expected an array, but received: ${Br(t)}`;
        },
        coercer (t) {
            return Array.isArray(t) ? t.slice() : t;
        }
    });
}
function oe(s) {
    const e = Object.keys(s);
    return new es({
        type: "type",
        schema: s,
        *entries (t) {
            if (Ci(t)) for (const r of e)yield [
                r,
                t[r],
                s[r]
            ];
        },
        validator (t) {
            return $o(t) || `Expected an object, but received: ${Br(t)}`;
        },
        coercer (t) {
            return $o(t) ? {
                ...t
            } : t;
        }
    });
}
function ur(s) {
    const e = s.map((t)=>t.type).join(" | ");
    return new es({
        type: "union",
        schema: null,
        coercer (t, r) {
            for (const n1 of s){
                const [i, o] = n1.validate(t, {
                    coerce: !0,
                    mask: r.mask
                });
                if (!i) return o;
            }
            return t;
        },
        validator (t, r) {
            const n1 = [];
            for (const i of s){
                const [...o] = Jc(t, i, r), [a] = o;
                if (a[0]) for (const [l] of o)l && n1.push(l);
                else return [];
            }
            return [
                `Expected the value to satisfy a union of \`${e}\`, but received: ${Br(t)}`,
                ...n1
            ];
        }
    });
}
function Un() {
    return tn("unknown", ()=>!0);
}
function Di(s, e, t) {
    return new es({
        ...s,
        coercer: (r, n1)=>b0(r, e) ? s.coercer(t(r, n1), n1) : s.coercer(r, n1)
    });
}
var $i, wv = new Uint8Array(16);
function w0() {
    if (!$i && ($i = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto < "u" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto), !$i)) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    return $i(wv);
}
const Av = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function ua(s) {
    return typeof s == "string" && Av.test(s);
}
var Yt = [];
for(var Qa = 0; Qa < 256; ++Qa)Yt.push((Qa + 256).toString(16).substr(1));
function da(s) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, t = (Yt[s[e + 0]] + Yt[s[e + 1]] + Yt[s[e + 2]] + Yt[s[e + 3]] + "-" + Yt[s[e + 4]] + Yt[s[e + 5]] + "-" + Yt[s[e + 6]] + Yt[s[e + 7]] + "-" + Yt[s[e + 8]] + Yt[s[e + 9]] + "-" + Yt[s[e + 10]] + Yt[s[e + 11]] + Yt[s[e + 12]] + Yt[s[e + 13]] + Yt[s[e + 14]] + Yt[s[e + 15]]).toLowerCase();
    if (!ua(t)) throw TypeError("Stringified UUID is invalid");
    return t;
}
var kd, el, tl = 0, rl = 0;
function Iv(s, e, t) {
    var r = e && t || 0, n1 = e || new Array(16);
    s = s || {};
    var i = s.node || kd, o = s.clockseq !== void 0 ? s.clockseq : el;
    if (i == null || o == null) {
        var a = s.random || (s.rng || w0)();
        i == null && (i = kd = [
            a[0] | 1,
            a[1],
            a[2],
            a[3],
            a[4],
            a[5]
        ]), o == null && (o = el = (a[6] << 8 | a[7]) & 16383);
    }
    var l = s.msecs !== void 0 ? s.msecs : Date.now(), c = s.nsecs !== void 0 ? s.nsecs : rl + 1, u = l - tl + (c - rl) / 1e4;
    if (u < 0 && s.clockseq === void 0 && (o = o + 1 & 16383), (u < 0 || l > tl) && s.nsecs === void 0 && (c = 0), c >= 1e4) throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    tl = l, rl = c, el = o, l += 122192928e5;
    var d1 = ((l & 268435455) * 1e4 + c) % 4294967296;
    n1[r++] = d1 >>> 24 & 255, n1[r++] = d1 >>> 16 & 255, n1[r++] = d1 >>> 8 & 255, n1[r++] = d1 & 255;
    var h = l / 4294967296 * 1e4 & 268435455;
    n1[r++] = h >>> 8 & 255, n1[r++] = h & 255, n1[r++] = h >>> 24 & 15 | 16, n1[r++] = h >>> 16 & 255, n1[r++] = o >>> 8 | 128, n1[r++] = o & 255;
    for(var f = 0; f < 6; ++f)n1[r + f] = i[f];
    return e || da(n1);
}
function A0(s) {
    if (!ua(s)) throw TypeError("Invalid UUID");
    var e, t = new Uint8Array(16);
    return t[0] = (e = parseInt(s.slice(0, 8), 16)) >>> 24, t[1] = e >>> 16 & 255, t[2] = e >>> 8 & 255, t[3] = e & 255, t[4] = (e = parseInt(s.slice(9, 13), 16)) >>> 8, t[5] = e & 255, t[6] = (e = parseInt(s.slice(14, 18), 16)) >>> 8, t[7] = e & 255, t[8] = (e = parseInt(s.slice(19, 23), 16)) >>> 8, t[9] = e & 255, t[10] = (e = parseInt(s.slice(24, 36), 16)) / 1099511627776 & 255, t[11] = e / 4294967296 & 255, t[12] = e >>> 24 & 255, t[13] = e >>> 16 & 255, t[14] = e >>> 8 & 255, t[15] = e & 255, t;
}
function _v(s) {
    s = unescape(encodeURIComponent(s));
    for(var e = [], t = 0; t < s.length; ++t)e.push(s.charCodeAt(t));
    return e;
}
var Lv = "6ba7b810-9dad-11d1-80b4-00c04fd430c8", Rv = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function I0(s, e, t) {
    function r(n1, i, o, a) {
        if (typeof n1 == "string" && (n1 = _v(n1)), typeof i == "string" && (i = A0(i)), i.length !== 16) throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
        var l = new Uint8Array(16 + n1.length);
        if (l.set(i), l.set(n1, i.length), l = t(l), l[6] = l[6] & 15 | e, l[8] = l[8] & 63 | 128, o) {
            a = a || 0;
            for(var c = 0; c < 16; ++c)o[a + c] = l[c];
            return o;
        }
        return da(l);
    }
    try {
        r.name = s;
    } catch  {}
    return r.DNS = Lv, r.URL = Rv, r;
}
function Cv(s) {
    if (typeof s == "string") {
        var e = unescape(encodeURIComponent(s));
        s = new Uint8Array(e.length);
        for(var t = 0; t < e.length; ++t)s[t] = e.charCodeAt(t);
    }
    return kv(Dv(Pv(s), s.length * 8));
}
function kv(s) {
    for(var e = [], t = s.length * 32, r = "0123456789abcdef", n1 = 0; n1 < t; n1 += 8){
        var i = s[n1 >> 5] >>> n1 % 32 & 255, o = parseInt(r.charAt(i >>> 4 & 15) + r.charAt(i & 15), 16);
        e.push(o);
    }
    return e;
}
function _0(s) {
    return (s + 64 >>> 9 << 4) + 14 + 1;
}
function Dv(s, e) {
    s[e >> 5] |= 128 << e % 32, s[_0(e) - 1] = e;
    for(var t = 1732584193, r = -271733879, n1 = -1732584194, i = 271733878, o = 0; o < s.length; o += 16){
        var a = t, l = r, c = n1, u = i;
        t = er(t, r, n1, i, s[o], 7, -680876936), i = er(i, t, r, n1, s[o + 1], 12, -389564586), n1 = er(n1, i, t, r, s[o + 2], 17, 606105819), r = er(r, n1, i, t, s[o + 3], 22, -1044525330), t = er(t, r, n1, i, s[o + 4], 7, -176418897), i = er(i, t, r, n1, s[o + 5], 12, 1200080426), n1 = er(n1, i, t, r, s[o + 6], 17, -1473231341), r = er(r, n1, i, t, s[o + 7], 22, -45705983), t = er(t, r, n1, i, s[o + 8], 7, 1770035416), i = er(i, t, r, n1, s[o + 9], 12, -1958414417), n1 = er(n1, i, t, r, s[o + 10], 17, -42063), r = er(r, n1, i, t, s[o + 11], 22, -1990404162), t = er(t, r, n1, i, s[o + 12], 7, 1804603682), i = er(i, t, r, n1, s[o + 13], 12, -40341101), n1 = er(n1, i, t, r, s[o + 14], 17, -1502002290), r = er(r, n1, i, t, s[o + 15], 22, 1236535329), t = tr(t, r, n1, i, s[o + 1], 5, -165796510), i = tr(i, t, r, n1, s[o + 6], 9, -1069501632), n1 = tr(n1, i, t, r, s[o + 11], 14, 643717713), r = tr(r, n1, i, t, s[o], 20, -373897302), t = tr(t, r, n1, i, s[o + 5], 5, -701558691), i = tr(i, t, r, n1, s[o + 10], 9, 38016083), n1 = tr(n1, i, t, r, s[o + 15], 14, -660478335), r = tr(r, n1, i, t, s[o + 4], 20, -405537848), t = tr(t, r, n1, i, s[o + 9], 5, 568446438), i = tr(i, t, r, n1, s[o + 14], 9, -1019803690), n1 = tr(n1, i, t, r, s[o + 3], 14, -187363961), r = tr(r, n1, i, t, s[o + 8], 20, 1163531501), t = tr(t, r, n1, i, s[o + 13], 5, -1444681467), i = tr(i, t, r, n1, s[o + 2], 9, -51403784), n1 = tr(n1, i, t, r, s[o + 7], 14, 1735328473), r = tr(r, n1, i, t, s[o + 12], 20, -1926607734), t = rr(t, r, n1, i, s[o + 5], 4, -378558), i = rr(i, t, r, n1, s[o + 8], 11, -2022574463), n1 = rr(n1, i, t, r, s[o + 11], 16, 1839030562), r = rr(r, n1, i, t, s[o + 14], 23, -35309556), t = rr(t, r, n1, i, s[o + 1], 4, -1530992060), i = rr(i, t, r, n1, s[o + 4], 11, 1272893353), n1 = rr(n1, i, t, r, s[o + 7], 16, -155497632), r = rr(r, n1, i, t, s[o + 10], 23, -1094730640), t = rr(t, r, n1, i, s[o + 13], 4, 681279174), i = rr(i, t, r, n1, s[o], 11, -358537222), n1 = rr(n1, i, t, r, s[o + 3], 16, -722521979), r = rr(r, n1, i, t, s[o + 6], 23, 76029189), t = rr(t, r, n1, i, s[o + 9], 4, -640364487), i = rr(i, t, r, n1, s[o + 12], 11, -421815835), n1 = rr(n1, i, t, r, s[o + 15], 16, 530742520), r = rr(r, n1, i, t, s[o + 2], 23, -995338651), t = sr(t, r, n1, i, s[o], 6, -198630844), i = sr(i, t, r, n1, s[o + 7], 10, 1126891415), n1 = sr(n1, i, t, r, s[o + 14], 15, -1416354905), r = sr(r, n1, i, t, s[o + 5], 21, -57434055), t = sr(t, r, n1, i, s[o + 12], 6, 1700485571), i = sr(i, t, r, n1, s[o + 3], 10, -1894986606), n1 = sr(n1, i, t, r, s[o + 10], 15, -1051523), r = sr(r, n1, i, t, s[o + 1], 21, -2054922799), t = sr(t, r, n1, i, s[o + 8], 6, 1873313359), i = sr(i, t, r, n1, s[o + 15], 10, -30611744), n1 = sr(n1, i, t, r, s[o + 6], 15, -1560198380), r = sr(r, n1, i, t, s[o + 13], 21, 1309151649), t = sr(t, r, n1, i, s[o + 4], 6, -145523070), i = sr(i, t, r, n1, s[o + 11], 10, -1120210379), n1 = sr(n1, i, t, r, s[o + 2], 15, 718787259), r = sr(r, n1, i, t, s[o + 9], 21, -343485551), t = Rs(t, a), r = Rs(r, l), n1 = Rs(n1, c), i = Rs(i, u);
    }
    return [
        t,
        r,
        n1,
        i
    ];
}
function Pv(s) {
    if (s.length === 0) return [];
    for(var e = s.length * 8, t = new Uint32Array(_0(e)), r = 0; r < e; r += 8)t[r >> 5] |= (s[r / 8] & 255) << r % 32;
    return t;
}
function Rs(s, e) {
    var t = (s & 65535) + (e & 65535), r = (s >> 16) + (e >> 16) + (t >> 16);
    return r << 16 | t & 65535;
}
function Mv(s, e) {
    return s << e | s >>> 32 - e;
}
function ha(s, e, t, r, n1, i) {
    return Rs(Mv(Rs(Rs(e, s), Rs(r, i)), n1), t);
}
function er(s, e, t, r, n1, i, o) {
    return ha(e & t | ~e & r, s, e, n1, i, o);
}
function tr(s, e, t, r, n1, i, o) {
    return ha(e & r | t & ~r, s, e, n1, i, o);
}
function rr(s, e, t, r, n1, i, o) {
    return ha(e ^ t ^ r, s, e, n1, i, o);
}
function sr(s, e, t, r, n1, i, o) {
    return ha(t ^ (e | ~r), s, e, n1, i, o);
}
var Ov = I0("v3", 48, Cv);
function Bv(s, e, t) {
    s = s || {};
    var r = s.random || (s.rng || w0)();
    if (r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, e) {
        t = t || 0;
        for(var n1 = 0; n1 < 16; ++n1)e[t + n1] = r[n1];
        return e;
    }
    return da(r);
}
function Fv(s, e, t, r) {
    switch(s){
        case 0:
            return e & t ^ ~e & r;
        case 1:
            return e ^ t ^ r;
        case 2:
            return e & t ^ e & r ^ t & r;
        case 3:
            return e ^ t ^ r;
    }
}
function sl(s, e) {
    return s << e | s >>> 32 - e;
}
function Nv(s) {
    var e = [
        1518500249,
        1859775393,
        2400959708,
        3395469782
    ], t = [
        1732584193,
        4023233417,
        2562383102,
        271733878,
        3285377520
    ];
    if (typeof s == "string") {
        var r = unescape(encodeURIComponent(s));
        s = [];
        for(var n1 = 0; n1 < r.length; ++n1)s.push(r.charCodeAt(n1));
    } else Array.isArray(s) || (s = Array.prototype.slice.call(s));
    s.push(128);
    for(var i = s.length / 4 + 2, o = Math.ceil(i / 16), a = new Array(o), l = 0; l < o; ++l){
        for(var c = new Uint32Array(16), u = 0; u < 16; ++u)c[u] = s[l * 64 + u * 4] << 24 | s[l * 64 + u * 4 + 1] << 16 | s[l * 64 + u * 4 + 2] << 8 | s[l * 64 + u * 4 + 3];
        a[l] = c;
    }
    a[o - 1][14] = (s.length - 1) * 8 / Math.pow(2, 32), a[o - 1][14] = Math.floor(a[o - 1][14]), a[o - 1][15] = (s.length - 1) * 8 & 4294967295;
    for(var d1 = 0; d1 < o; ++d1){
        for(var h = new Uint32Array(80), f = 0; f < 16; ++f)h[f] = a[d1][f];
        for(var p = 16; p < 80; ++p)h[p] = sl(h[p - 3] ^ h[p - 8] ^ h[p - 14] ^ h[p - 16], 1);
        for(var y = t[0], E = t[1], b = t[2], L = t[3], A = t[4], F = 0; F < 80; ++F){
            var M = Math.floor(F / 20), H = sl(y, 5) + Fv(M, E, b, L) + A + e[M] + h[F] >>> 0;
            A = L, L = b, b = sl(E, 30) >>> 0, E = y, y = H;
        }
        t[0] = t[0] + y >>> 0, t[1] = t[1] + E >>> 0, t[2] = t[2] + b >>> 0, t[3] = t[3] + L >>> 0, t[4] = t[4] + A >>> 0;
    }
    return [
        t[0] >> 24 & 255,
        t[0] >> 16 & 255,
        t[0] >> 8 & 255,
        t[0] & 255,
        t[1] >> 24 & 255,
        t[1] >> 16 & 255,
        t[1] >> 8 & 255,
        t[1] & 255,
        t[2] >> 24 & 255,
        t[2] >> 16 & 255,
        t[2] >> 8 & 255,
        t[2] & 255,
        t[3] >> 24 & 255,
        t[3] >> 16 & 255,
        t[3] >> 8 & 255,
        t[3] & 255,
        t[4] >> 24 & 255,
        t[4] >> 16 & 255,
        t[4] >> 8 & 255,
        t[4] & 255
    ];
}
var Uv = I0("v5", 80, Nv);
const $v = "00000000-0000-0000-0000-000000000000";
function Gv(s) {
    if (!ua(s)) throw TypeError("Invalid UUID");
    return parseInt(s.substr(14, 1), 16);
}
const Vv = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    NIL: $v,
    parse: A0,
    stringify: da,
    v1: Iv,
    v3: Ov,
    v4: Bv,
    v5: Uv,
    validate: ua,
    version: Gv
}, Symbol.toStringTag, {
    value: "Module"
})), L0 = /* @__PURE__ */ Nc(Vv);
var nl, Dd;
function jv() {
    if (Dd) return nl;
    Dd = 1;
    const s = L0.v4;
    return nl = function(t, r, n1, i) {
        if (typeof t != "string") throw new TypeError(t + " must be a string");
        i = i || {};
        const o = typeof i.version == "number" ? i.version : 2;
        if (o !== 1 && o !== 2) throw new TypeError(o + " must be 1 or 2");
        const a = {
            method: t
        };
        if (o === 2 && (a.jsonrpc = "2.0"), r) {
            if (typeof r != "object" && !Array.isArray(r)) throw new TypeError(r + " must be an object, array or omitted");
            a.params = r;
        }
        if (typeof n1 > "u") {
            const l = typeof i.generator == "function" ? i.generator : function() {
                return s();
            };
            a.id = l(a, i);
        } else o === 2 && n1 === null ? i.notificationIdNull && (a.id = null) : a.id = n1;
        return a;
    }, nl;
}
var il, Pd;
function Kv() {
    if (Pd) return il;
    Pd = 1;
    const s = L0.v4, e = jv(), t = function(r, n1) {
        if (!(this instanceof t)) return new t(r, n1);
        n1 || (n1 = {}), this.options = {
            reviver: typeof n1.reviver < "u" ? n1.reviver : null,
            replacer: typeof n1.replacer < "u" ? n1.replacer : null,
            generator: typeof n1.generator < "u" ? n1.generator : function() {
                return s();
            },
            version: typeof n1.version < "u" ? n1.version : 2,
            notificationIdNull: typeof n1.notificationIdNull == "boolean" ? n1.notificationIdNull : !1
        }, this.callServer = r;
    };
    return il = t, t.prototype.request = function(r, n1, i, o) {
        const a = this;
        let l = null;
        const c = Array.isArray(r) && typeof n1 == "function";
        if (this.options.version === 1 && c) throw new TypeError("JSON-RPC 1.0 does not support batching");
        if (c || !c && r && typeof r == "object" && typeof n1 == "function") o = n1, l = r;
        else {
            typeof i == "function" && (o = i, i = void 0);
            const h = typeof o == "function";
            try {
                l = e(r, n1, i, {
                    generator: this.options.generator,
                    version: this.options.version,
                    notificationIdNull: this.options.notificationIdNull
                });
            } catch (f) {
                if (h) return o(f);
                throw f;
            }
            if (!h) return l;
        }
        let d1;
        try {
            d1 = JSON.stringify(l, this.options.replacer);
        } catch (h) {
            return o(h);
        }
        return this.callServer(d1, function(h, f) {
            a._parseResponse(h, f, o);
        }), l;
    }, t.prototype._parseResponse = function(r, n1, i) {
        if (r) {
            i(r);
            return;
        }
        if (!n1) return i();
        let o;
        try {
            o = JSON.parse(n1, this.options.reviver);
        } catch (a) {
            return i(a);
        }
        if (i.length === 3) if (Array.isArray(o)) {
            const a = function(c) {
                return typeof c.error < "u";
            }, l = function(c) {
                return !a(c);
            };
            return i(null, o.filter(a), o.filter(l));
        } else return i(null, o.error, o.result);
        i(null, o);
    }, il;
}
Kv();
var ol = {
    exports: {}
}, Md;
function Hv() {
    return Md || (Md = 1, function(s) {
        var e = Object.prototype.hasOwnProperty, t = "~";
        function r() {}
        Object.create && (r.prototype = /* @__PURE__ */ Object.create(null), new r().__proto__ || (t = !1));
        function n1(l, c, u) {
            this.fn = l, this.context = c, this.once = u || !1;
        }
        function i(l, c, u, d1, h) {
            if (typeof u != "function") throw new TypeError("The listener must be a function");
            var f = new n1(u, d1 || l, h), p = t ? t + c : c;
            return l._events[p] ? l._events[p].fn ? l._events[p] = [
                l._events[p],
                f
            ] : l._events[p].push(f) : (l._events[p] = f, l._eventsCount++), l;
        }
        function o(l, c) {
            --l._eventsCount === 0 ? l._events = new r() : delete l._events[c];
        }
        function a() {
            this._events = new r(), this._eventsCount = 0;
        }
        a.prototype.eventNames = function() {
            var c = [], u, d1;
            if (this._eventsCount === 0) return c;
            for(d1 in u = this._events)e.call(u, d1) && c.push(t ? d1.slice(1) : d1);
            return Object.getOwnPropertySymbols ? c.concat(Object.getOwnPropertySymbols(u)) : c;
        }, a.prototype.listeners = function(c) {
            var u = t ? t + c : c, d1 = this._events[u];
            if (!d1) return [];
            if (d1.fn) return [
                d1.fn
            ];
            for(var h = 0, f = d1.length, p = new Array(f); h < f; h++)p[h] = d1[h].fn;
            return p;
        }, a.prototype.listenerCount = function(c) {
            var u = t ? t + c : c, d1 = this._events[u];
            return d1 ? d1.fn ? 1 : d1.length : 0;
        }, a.prototype.emit = function(c, u, d1, h, f, p) {
            var y = t ? t + c : c;
            if (!this._events[y]) return !1;
            var E = this._events[y], b = arguments.length, L, A;
            if (E.fn) {
                switch(E.once && this.removeListener(c, E.fn, void 0, !0), b){
                    case 1:
                        return E.fn.call(E.context), !0;
                    case 2:
                        return E.fn.call(E.context, u), !0;
                    case 3:
                        return E.fn.call(E.context, u, d1), !0;
                    case 4:
                        return E.fn.call(E.context, u, d1, h), !0;
                    case 5:
                        return E.fn.call(E.context, u, d1, h, f), !0;
                    case 6:
                        return E.fn.call(E.context, u, d1, h, f, p), !0;
                }
                for(A = 1, L = new Array(b - 1); A < b; A++)L[A - 1] = arguments[A];
                E.fn.apply(E.context, L);
            } else {
                var F = E.length, M;
                for(A = 0; A < F; A++)switch(E[A].once && this.removeListener(c, E[A].fn, void 0, !0), b){
                    case 1:
                        E[A].fn.call(E[A].context);
                        break;
                    case 2:
                        E[A].fn.call(E[A].context, u);
                        break;
                    case 3:
                        E[A].fn.call(E[A].context, u, d1);
                        break;
                    case 4:
                        E[A].fn.call(E[A].context, u, d1, h);
                        break;
                    default:
                        if (!L) for(M = 1, L = new Array(b - 1); M < b; M++)L[M - 1] = arguments[M];
                        E[A].fn.apply(E[A].context, L);
                }
            }
            return !0;
        }, a.prototype.on = function(c, u, d1) {
            return i(this, c, u, d1, !1);
        }, a.prototype.once = function(c, u, d1) {
            return i(this, c, u, d1, !0);
        }, a.prototype.removeListener = function(c, u, d1, h) {
            var f = t ? t + c : c;
            if (!this._events[f]) return this;
            if (!u) return o(this, f), this;
            var p = this._events[f];
            if (p.fn) p.fn === u && (!h || p.once) && (!d1 || p.context === d1) && o(this, f);
            else {
                for(var y = 0, E = [], b = p.length; y < b; y++)(p[y].fn !== u || h && !p[y].once || d1 && p[y].context !== d1) && E.push(p[y]);
                E.length ? this._events[f] = E.length === 1 ? E[0] : E : o(this, f);
            }
            return this;
        }, a.prototype.removeAllListeners = function(c) {
            var u;
            return c ? (u = t ? t + c : c, this._events[u] && o(this, u)) : (this._events = new r(), this._eventsCount = 0), this;
        }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = t, a.EventEmitter = a, s.exports = a;
    }(ol)), ol.exports;
}
var qv = Hv();
const R0 = /* @__PURE__ */ Fc(qv);
class C0 extends Wf {
    constructor(e, t){
        super(), this.finished = !1, this.destroyed = !1, Hf(e);
        const r = Hc(t);
        if (this.iHash = e.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
        const n1 = this.blockLen, i = new Uint8Array(n1);
        i.set(r.length > n1 ? e.create().update(r).digest() : r);
        for(let o = 0; o < i.length; o++)i[o] ^= 54;
        this.iHash.update(i), this.oHash = e.create();
        for(let o = 0; o < i.length; o++)i[o] ^= 106;
        this.oHash.update(i), Rn(i);
    }
    update(e) {
        return Do(this), this.iHash.update(e), this;
    }
    digestInto(e) {
        Do(this), Qs(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();
    }
    digest() {
        const e = new Uint8Array(this.oHash.outputLen);
        return this.digestInto(e), e;
    }
    _cloneInto(e) {
        e || (e = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash: t, iHash: r, finished: n1, destroyed: i, blockLen: o, outputLen: a } = this;
        return e = e, e.finished = n1, e.destroyed = i, e.blockLen = o, e.outputLen = a, e.oHash = t._cloneInto(e.oHash), e.iHash = r._cloneInto(e.iHash), e;
    }
    clone() {
        return this._cloneInto();
    }
    destroy() {
        this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
    }
}
const k0 = (s, e, t)=>new C0(s, e).update(t).digest();
k0.create = (s, e)=>new C0(s, e);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const Od = (s, e)=>(s + (s >= 0 ? e : -e) / D0) / e;
function Wv(s, e, t) {
    const [[r, n1], [i, o]] = e, a = Od(o * s, t), l = Od(-n1 * s, t);
    let c = s - a * r - l * i, u = -a * n1 - l * o;
    const d1 = c < hs, h = u < hs;
    d1 && (c = -c), h && (u = -u);
    const f = _i(Math.ceil(e0(t) / 2)) + Sn;
    if (c < hs || c >= f || u < hs || u >= f) throw new Error("splitScalar (endomorphism): failed, k=" + s);
    return {
        k1neg: d1,
        k1: c,
        k2neg: h,
        k2: u
    };
}
function ec(s) {
    if (![
        "compact",
        "recovered",
        "der"
    ].includes(s)) throw new Error('Signature format must be "compact", "recovered", or "der"');
    return s;
}
function al(s, e) {
    const t = {};
    for (let r of Object.keys(e))t[r] = s[r] === void 0 ? e[r] : s[r];
    return Xs(t.lowS, "lowS"), Xs(t.prehash, "prehash"), t.format !== void 0 && ec(t.format), t;
}
class zv extends Error {
    constructor(e = ""){
        super(e);
    }
}
const cs = {
    // asn.1 DER encoding utils
    Err: zv,
    // Basic building block is TLV (Tag-Length-Value)
    _tlv: {
        encode: (s, e)=>{
            const { Err: t } = cs;
            if (s < 0 || s > 256) throw new t("tlv.encode: wrong tag");
            if (e.length & 1) throw new t("tlv.encode: unpadded data");
            const r = e.length / 2, n1 = Ni(r);
            if (n1.length / 2 & 128) throw new t("tlv.encode: long form length too big");
            const i = r > 127 ? Ni(n1.length / 2 | 128) : "";
            return Ni(s) + i + n1 + e;
        },
        // v - value, l - left bytes (unparsed)
        decode (s, e) {
            const { Err: t } = cs;
            let r = 0;
            if (s < 0 || s > 256) throw new t("tlv.encode: wrong tag");
            if (e.length < 2 || e[r++] !== s) throw new t("tlv.decode: wrong tlv");
            const n1 = e[r++], i = !!(n1 & 128);
            let o = 0;
            if (!i) o = n1;
            else {
                const l = n1 & 127;
                if (!l) throw new t("tlv.decode(long): indefinite length not supported");
                if (l > 4) throw new t("tlv.decode(long): byte length is too big");
                const c = e.subarray(r, r + l);
                if (c.length !== l) throw new t("tlv.decode: length bytes not complete");
                if (c[0] === 0) throw new t("tlv.decode(long): zero leftmost byte");
                for (const u of c)o = o << 8 | u;
                if (r += l, o < 128) throw new t("tlv.decode(long): not minimal encoding");
            }
            const a = e.subarray(r, r + o);
            if (a.length !== o) throw new t("tlv.decode: wrong value length");
            return {
                v: a,
                l: e.subarray(r + o)
            };
        }
    },
    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
    // since we always use positive integers here. It must always be empty:
    // - add zero byte if exists
    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
    _int: {
        encode (s) {
            const { Err: e } = cs;
            if (s < hs) throw new e("integer: negative integers are not allowed");
            let t = Ni(s);
            if (Number.parseInt(t[0], 16) & 8 && (t = "00" + t), t.length & 1) throw new e("unexpected DER parsing assertion: unpadded hex");
            return t;
        },
        decode (s) {
            const { Err: e } = cs;
            if (s[0] & 128) throw new e("invalid signature integer: negative");
            if (s[0] === 0 && !(s[1] & 128)) throw new e("invalid signature integer: unnecessary leading zero");
            return la(s);
        }
    },
    toSig (s) {
        const { Err: e, _int: t, _tlv: r } = cs, n1 = Et("signature", s), { v: i, l: o } = r.decode(48, n1);
        if (o.length) throw new e("invalid signature: left bytes after parsing");
        const { v: a, l } = r.decode(2, i), { v: c, l: u } = r.decode(2, l);
        if (u.length) throw new e("invalid signature: left bytes after parsing");
        return {
            r: t.decode(a),
            s: t.decode(c)
        };
    },
    hexFromSig (s) {
        const { _tlv: e, _int: t } = cs, r = e.encode(2, t.encode(s.r)), n1 = e.encode(2, t.encode(s.s)), i = r + n1;
        return e.encode(48, i);
    }
}, hs = BigInt(0), Sn = BigInt(1), D0 = BigInt(2), Gi = BigInt(3), Yv = BigInt(4);
function yn(s, e) {
    const { BYTES: t } = s;
    let r;
    if (typeof e == "bigint") r = e;
    else {
        let n1 = Et("private key", e);
        try {
            r = s.fromBytes(n1);
        } catch  {
            throw new Error(`invalid private key: expected ui8a of size ${t}, got ${typeof e}`);
        }
    }
    if (!s.isValidNot0(r)) throw new Error("invalid private key: out of range [1..N-1]");
    return r;
}
function Zv(s, e = {}) {
    const t = m0("weierstrass", s, e), { Fp: r, Fn: n1 } = t;
    let i = t.CURVE;
    const { h: o, n: a } = i;
    Li(e, {}, {
        allowInfinityPoint: "boolean",
        clearCofactor: "function",
        isTorsionFree: "function",
        fromBytes: "function",
        toBytes: "function",
        endo: "object",
        wrapPrivateKey: "boolean"
    });
    const { endo: l } = e;
    if (l && (!r.is0(i.a) || typeof l.beta != "bigint" || !Array.isArray(l.basises))) throw new Error('invalid endo: expected "beta": bigint and "basises": array');
    const c = M0(r, n1);
    function u() {
        if (!r.isOdd) throw new Error("compression is not supported: Field does not have .isOdd()");
    }
    function d1(W, _, g) {
        const { x, y: w } = _.toAffine(), D = r.toBytes(x);
        if (Xs(g, "isCompressed"), g) {
            u();
            const O = !r.isOdd(w);
            return Kr(P0(O), D);
        } else return Kr(Uint8Array.of(4), D, r.toBytes(w));
    }
    function h(W) {
        Or(W, void 0, "Point");
        const { publicKey: _, publicKeyUncompressed: g } = c, x = W.length, w = W[0], D = W.subarray(1);
        if (x === _ && (w === 2 || w === 3)) {
            const O = r.fromBytes(D);
            if (!r.isValid(O)) throw new Error("bad point: is not on curve, wrong x");
            const U = y(O);
            let V;
            try {
                V = r.sqrt(U);
            } catch (v) {
                const P = v instanceof Error ? ": " + v.message : "";
                throw new Error("bad point: is not on curve, sqrt error" + P);
            }
            u();
            const R = r.isOdd(V);
            return (w & 1) === 1 !== R && (V = r.neg(V)), {
                x: O,
                y: V
            };
        } else if (x === g && w === 4) {
            const O = r.BYTES, U = r.fromBytes(D.subarray(0, O)), V = r.fromBytes(D.subarray(O, O * 2));
            if (!E(U, V)) throw new Error("bad point: is not on curve");
            return {
                x: U,
                y: V
            };
        } else throw new Error(`bad point: got length ${x}, expected compressed=${_} or uncompressed=${g}`);
    }
    const f = e.toBytes || d1, p = e.fromBytes || h;
    function y(W) {
        const _ = r.sqr(W), g = r.mul(_, W);
        return r.add(r.add(g, r.mul(W, i.a)), i.b);
    }
    function E(W, _) {
        const g = r.sqr(_), x = y(W);
        return r.eql(g, x);
    }
    if (!E(i.Gx, i.Gy)) throw new Error("bad curve params: generator point");
    const b = r.mul(r.pow(i.a, Gi), Yv), L = r.mul(r.sqr(i.b), BigInt(27));
    if (r.is0(r.add(b, L))) throw new Error("bad curve params: a or b");
    function A(W, _, g = !1) {
        if (!r.isValid(_) || g && r.is0(_)) throw new Error(`bad point coordinate ${W}`);
        return _;
    }
    function F(W) {
        if (!(W instanceof C)) throw new Error("ProjectivePoint expected");
    }
    function M(W) {
        if (!l || !l.basises) throw new Error("no endo");
        return Wv(W, l.basises, n1.ORDER);
    }
    const H = Mo((W, _)=>{
        const { X: g, Y: x, Z: w } = W;
        if (r.eql(w, r.ONE)) return {
            x: g,
            y: x
        };
        const D = W.is0();
        _ == null && (_ = D ? r.ONE : r.inv(w));
        const O = r.mul(g, _), U = r.mul(x, _), V = r.mul(w, _);
        if (D) return {
            x: r.ZERO,
            y: r.ZERO
        };
        if (!r.eql(V, r.ONE)) throw new Error("invZ was invalid");
        return {
            x: O,
            y: U
        };
    }), K = Mo((W)=>{
        if (W.is0()) {
            if (e.allowInfinityPoint && !r.is0(W.Y)) return;
            throw new Error("bad point: ZERO");
        }
        const { x: _, y: g } = W.toAffine();
        if (!r.isValid(_) || !r.isValid(g)) throw new Error("bad point: x or y not field elements");
        if (!E(_, g)) throw new Error("bad point: equation left != right");
        if (!W.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
        return !0;
    });
    function j(W, _, g, x, w) {
        return g = new C(r.mul(g.X, W), g.Y, g.Z), _ = Oo(x, _), g = Oo(w, g), _.add(g);
    }
    class C {
        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */ constructor(_, g, x){
            this.X = A("x", _), this.Y = A("y", g, !0), this.Z = A("z", x), Object.freeze(this);
        }
        static CURVE() {
            return i;
        }
        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */ static fromAffine(_) {
            const { x: g, y: x } = _ || {};
            if (!_ || !r.isValid(g) || !r.isValid(x)) throw new Error("invalid affine point");
            if (_ instanceof C) throw new Error("projective point not allowed");
            return r.is0(g) && r.is0(x) ? C.ZERO : new C(g, x, r.ONE);
        }
        static fromBytes(_) {
            const g = C.fromAffine(p(Or(_, void 0, "point")));
            return g.assertValidity(), g;
        }
        static fromHex(_) {
            return C.fromBytes(Et("pointHex", _));
        }
        get x() {
            return this.toAffine().x;
        }
        get y() {
            return this.toAffine().y;
        }
        /**
     *
     * @param windowSize
     * @param isLazy true will defer table computation until the first multiplication
     * @returns
     */ precompute(_ = 8, g = !0) {
            return $.createCache(this, _), g || this.multiply(Gi), this;
        }
        // TODO: return `this`
        /** A point on curve is valid if it conforms to equation. */ assertValidity() {
            K(this);
        }
        hasEvenY() {
            const { y: _ } = this.toAffine();
            if (!r.isOdd) throw new Error("Field doesn't support isOdd");
            return !r.isOdd(_);
        }
        /** Compare one point to another. */ equals(_) {
            F(_);
            const { X: g, Y: x, Z: w } = this, { X: D, Y: O, Z: U } = _, V = r.eql(r.mul(g, U), r.mul(D, w)), R = r.eql(r.mul(x, U), r.mul(O, w));
            return V && R;
        }
        /** Flips point to one corresponding to (x, -y) in Affine coordinates. */ negate() {
            return new C(this.X, r.neg(this.Y), this.Z);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
            const { a: _, b: g } = i, x = r.mul(g, Gi), { X: w, Y: D, Z: O } = this;
            let U = r.ZERO, V = r.ZERO, R = r.ZERO, m = r.mul(w, w), v = r.mul(D, D), P = r.mul(O, O), N = r.mul(w, D);
            return N = r.add(N, N), R = r.mul(w, O), R = r.add(R, R), U = r.mul(_, R), V = r.mul(x, P), V = r.add(U, V), U = r.sub(v, V), V = r.add(v, V), V = r.mul(U, V), U = r.mul(N, U), R = r.mul(x, R), P = r.mul(_, P), N = r.sub(m, P), N = r.mul(_, N), N = r.add(N, R), R = r.add(m, m), m = r.add(R, m), m = r.add(m, P), m = r.mul(m, N), V = r.add(V, m), P = r.mul(D, O), P = r.add(P, P), m = r.mul(P, N), U = r.sub(U, m), R = r.mul(P, v), R = r.add(R, R), R = r.add(R, R), new C(U, V, R);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(_) {
            F(_);
            const { X: g, Y: x, Z: w } = this, { X: D, Y: O, Z: U } = _;
            let V = r.ZERO, R = r.ZERO, m = r.ZERO;
            const v = i.a, P = r.mul(i.b, Gi);
            let N = r.mul(g, D), Y = r.mul(x, O), ee = r.mul(w, U), ie = r.add(g, x), le = r.add(D, O);
            ie = r.mul(ie, le), le = r.add(N, Y), ie = r.sub(ie, le), le = r.add(g, w);
            let Te = r.add(D, U);
            return le = r.mul(le, Te), Te = r.add(N, ee), le = r.sub(le, Te), Te = r.add(x, w), V = r.add(O, U), Te = r.mul(Te, V), V = r.add(Y, ee), Te = r.sub(Te, V), m = r.mul(v, le), V = r.mul(P, ee), m = r.add(V, m), V = r.sub(Y, m), m = r.add(Y, m), R = r.mul(V, m), Y = r.add(N, N), Y = r.add(Y, N), ee = r.mul(v, ee), le = r.mul(P, le), Y = r.add(Y, ee), ee = r.sub(N, ee), ee = r.mul(v, ee), le = r.add(le, ee), N = r.mul(Y, le), R = r.add(R, N), N = r.mul(Te, le), V = r.mul(ie, V), V = r.sub(V, N), N = r.mul(ie, Y), m = r.mul(Te, m), m = r.add(m, N), new C(V, R, m);
        }
        subtract(_) {
            return this.add(_.negate());
        }
        is0() {
            return this.equals(C.ZERO);
        }
        /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */ multiply(_) {
            const { endo: g } = e;
            if (!n1.isValidNot0(_)) throw new Error("invalid scalar: out of range");
            let x, w;
            const D = (O)=>$.cached(this, O, (U)=>js(C, U));
            if (g) {
                const { k1neg: O, k1: U, k2neg: V, k2: R } = M(_), { p: m, f: v } = D(U), { p: P, f: N } = D(R);
                w = v.add(N), x = j(g.beta, m, P, O, V);
            } else {
                const { p: O, f: U } = D(_);
                x = O, w = U;
            }
            return js(C, [
                x,
                w
            ])[0];
        }
        /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed secret key e.g. sig verification, which works over *public* keys.
     */ multiplyUnsafe(_) {
            const { endo: g } = e, x = this;
            if (!n1.isValid(_)) throw new Error("invalid scalar: out of range");
            if (_ === hs || x.is0()) return C.ZERO;
            if (_ === Sn) return x;
            if ($.hasCache(this)) return this.multiply(_);
            if (g) {
                const { k1neg: w, k1: D, k2neg: O, k2: U } = M(_), { p1: V, p2: R } = py(C, x, D, U);
                return j(g.beta, V, R, w, O);
            } else return $.unsafe(x, _);
        }
        multiplyAndAddUnsafe(_, g, x) {
            const w = this.multiplyUnsafe(g).add(_.multiplyUnsafe(x));
            return w.is0() ? void 0 : w;
        }
        /**
     * Converts Projective point to affine (x, y) coordinates.
     * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
     */ toAffine(_) {
            return H(this, _);
        }
        /**
     * Checks whether Point is free of torsion elements (is in prime subgroup).
     * Always torsion-free for cofactor=1 curves.
     */ isTorsionFree() {
            const { isTorsionFree: _ } = e;
            return o === Sn ? !0 : _ ? _(C, this) : $.unsafe(this, a).is0();
        }
        clearCofactor() {
            const { clearCofactor: _ } = e;
            return o === Sn ? this : _ ? _(C, this) : this.multiplyUnsafe(o);
        }
        isSmallOrder() {
            return this.multiplyUnsafe(o).is0();
        }
        toBytes(_ = !0) {
            return Xs(_, "isCompressed"), this.assertValidity(), f(C, this, _);
        }
        toHex(_ = !0) {
            return Hs(this.toBytes(_));
        }
        toString() {
            return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
        }
        // TODO: remove
        get px() {
            return this.X;
        }
        get py() {
            return this.X;
        }
        get pz() {
            return this.Z;
        }
        toRawBytes(_ = !0) {
            return this.toBytes(_);
        }
        _setWindowSize(_) {
            this.precompute(_);
        }
        static normalizeZ(_) {
            return js(C, _);
        }
        static msm(_, g) {
            return p0(C, n1, _, g);
        }
        static fromPrivateKey(_) {
            return C.BASE.multiply(yn(n1, _));
        }
    }
    C.BASE = new C(i.Gx, i.Gy, r.ONE), C.ZERO = new C(r.ZERO, r.ONE, r.ZERO), C.Fp = r, C.Fn = n1;
    const k = n1.BITS, $ = new g0(C, e.endo ? Math.ceil(k / 2) : k);
    return C.BASE.precompute(8), C;
}
function P0(s) {
    return Uint8Array.of(s ? 2 : 3);
}
function M0(s, e) {
    return {
        secretKey: e.BYTES,
        publicKey: 1 + s.BYTES,
        publicKeyUncompressed: 1 + 2 * s.BYTES,
        publicKeyHasPrefix: !0,
        signature: 2 * e.BYTES
    };
}
function Xv(s, e = {}) {
    const { Fn: t } = s, r = e.randomBytes || qc, n1 = Object.assign(M0(s.Fp, t), {
        seed: d0(t.ORDER)
    });
    function i(f) {
        try {
            return !!yn(t, f);
        } catch  {
            return !1;
        }
    }
    function o(f, p) {
        const { publicKey: y, publicKeyUncompressed: E } = n1;
        try {
            const b = f.length;
            return p === !0 && b !== y || p === !1 && b !== E ? !1 : !!s.fromBytes(f);
        } catch  {
            return !1;
        }
    }
    function a(f = r(n1.seed)) {
        return hy(Or(f, n1.seed, "seed"), t.ORDER);
    }
    function l(f, p = !0) {
        return s.BASE.multiply(yn(t, f)).toBytes(p);
    }
    function c(f) {
        const p = a(f);
        return {
            secretKey: p,
            publicKey: l(p)
        };
    }
    function u(f) {
        if (typeof f == "bigint") return !1;
        if (f instanceof s) return !0;
        const { secretKey: p, publicKey: y, publicKeyUncompressed: E } = n1;
        if (t.allowedLengths || p === y) return;
        const b = Et("key", f).length;
        return b === y || b === E;
    }
    function d1(f, p, y = !0) {
        if (u(f) === !0) throw new Error("first arg must be private key");
        if (u(p) === !1) throw new Error("second arg must be public key");
        const E = yn(t, f);
        return s.fromHex(p).multiply(E).toBytes(y);
    }
    return Object.freeze({
        getPublicKey: l,
        getSharedSecret: d1,
        keygen: c,
        Point: s,
        utils: {
            isValidSecretKey: i,
            isValidPublicKey: o,
            randomSecretKey: a,
            // TODO: remove
            isValidPrivateKey: i,
            randomPrivateKey: a,
            normPrivateKeyToScalar: (f)=>yn(t, f),
            precompute (f = 8, p = s.BASE) {
                return p.precompute(f, !1);
            }
        },
        lengths: n1
    });
}
function Jv(s, e, t = {}) {
    Hf(e), Li(t, {}, {
        hmac: "function",
        lowS: "boolean",
        randomBytes: "function",
        bits2int: "function",
        bits2int_modN: "function"
    });
    const r = t.randomBytes || qc, n1 = t.hmac || ((g, ...x)=>k0(e, g, Kr(...x))), { Fp: i, Fn: o } = s, { ORDER: a, BITS: l } = o, { keygen: c, getPublicKey: u, getSharedSecret: d1, utils: h, lengths: f } = Xv(s, t), p = {
        prehash: !1,
        lowS: typeof t.lowS == "boolean" ? t.lowS : !1,
        format: void 0,
        //'compact' as ECDSASigFormat,
        extraEntropy: !1
    }, y = "compact";
    function E(g) {
        const x = a >> Sn;
        return g > x;
    }
    function b(g, x) {
        if (!o.isValidNot0(x)) throw new Error(`invalid signature ${g}: out of range 1..Point.Fn.ORDER`);
        return x;
    }
    function L(g, x) {
        ec(x);
        const w = f.signature, D = x === "compact" ? w : x === "recovered" ? w + 1 : void 0;
        return Or(g, D, `${x} signature`);
    }
    class A {
        constructor(x, w, D){
            this.r = b("r", x), this.s = b("s", w), D != null && (this.recovery = D), Object.freeze(this);
        }
        static fromBytes(x, w = y) {
            L(x, w);
            let D;
            if (w === "der") {
                const { r: R, s: m } = cs.toSig(Or(x));
                return new A(R, m);
            }
            w === "recovered" && (D = x[0], w = "compact", x = x.subarray(1));
            const O = o.BYTES, U = x.subarray(0, O), V = x.subarray(O, O * 2);
            return new A(o.fromBytes(U), o.fromBytes(V), D);
        }
        static fromHex(x, w) {
            return this.fromBytes(Po(x), w);
        }
        addRecoveryBit(x) {
            return new A(this.r, this.s, x);
        }
        recoverPublicKey(x) {
            const w = i.ORDER, { r: D, s: O, recovery: U } = this;
            if (U == null || ![
                0,
                1,
                2,
                3
            ].includes(U)) throw new Error("recovery id invalid");
            if (a * D0 < w && U > 1) throw new Error("recovery id is ambiguous for h>1 curve");
            const R = U === 2 || U === 3 ? D + a : D;
            if (!i.isValid(R)) throw new Error("recovery id 2 or 3 invalid");
            const m = i.toBytes(R), v = s.fromBytes(Kr(P0((U & 1) === 0), m)), P = o.inv(R), N = M(Et("msgHash", x)), Y = o.create(-N * P), ee = o.create(O * P), ie = s.BASE.multiplyUnsafe(Y).add(v.multiplyUnsafe(ee));
            if (ie.is0()) throw new Error("point at infinify");
            return ie.assertValidity(), ie;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
            return E(this.s);
        }
        toBytes(x = y) {
            if (ec(x), x === "der") return Po(cs.hexFromSig(this));
            const w = o.toBytes(this.r), D = o.toBytes(this.s);
            if (x === "recovered") {
                if (this.recovery == null) throw new Error("recovery bit must be present");
                return Kr(Uint8Array.of(this.recovery), w, D);
            }
            return Kr(w, D);
        }
        toHex(x) {
            return Hs(this.toBytes(x));
        }
        // TODO: remove
        assertValidity() {}
        static fromCompact(x) {
            return A.fromBytes(Et("sig", x), "compact");
        }
        static fromDER(x) {
            return A.fromBytes(Et("sig", x), "der");
        }
        normalizeS() {
            return this.hasHighS() ? new A(this.r, o.neg(this.s), this.recovery) : this;
        }
        toDERRawBytes() {
            return this.toBytes("der");
        }
        toDERHex() {
            return Hs(this.toBytes("der"));
        }
        toCompactRawBytes() {
            return this.toBytes("compact");
        }
        toCompactHex() {
            return Hs(this.toBytes("compact"));
        }
    }
    const F = t.bits2int || function(x) {
        if (x.length > 8192) throw new Error("input is too large");
        const w = la(x), D = x.length * 8 - l;
        return D > 0 ? w >> BigInt(D) : w;
    }, M = t.bits2int_modN || function(x) {
        return o.create(F(x));
    }, H = _i(l);
    function K(g) {
        return Ql("num < 2^" + l, g, hs, H), o.toBytes(g);
    }
    function j(g, x) {
        return Or(g, void 0, "message"), x ? Or(e(g), void 0, "prehashed message") : g;
    }
    function C(g, x, w) {
        if ([
            "recovered",
            "canonical"
        ].some((Y)=>Y in w)) throw new Error("sign() legacy options not supported");
        const { lowS: D, prehash: O, extraEntropy: U } = al(w, p);
        g = j(g, O);
        const V = M(g), R = yn(o, x), m = [
            K(R),
            K(V)
        ];
        if (U != null && U !== !1) {
            const Y = U === !0 ? r(f.secretKey) : U;
            m.push(Et("extraEntropy", Y));
        }
        const v = Kr(...m), P = V;
        function N(Y) {
            const ee = F(Y);
            if (!o.isValidNot0(ee)) return;
            const ie = o.inv(ee), le = s.BASE.multiply(ee).toAffine(), Te = o.create(le.x);
            if (Te === hs) return;
            const De = o.create(ie * o.create(P + Te * R));
            if (De === hs) return;
            let ze = (le.x === Te ? 0 : 2) | Number(le.y & Sn), _e = De;
            return D && E(De) && (_e = o.neg(De), ze ^= 1), new A(Te, _e, ze);
        }
        return {
            seed: v,
            k2sig: N
        };
    }
    function k(g, x, w = {}) {
        g = Et("message", g);
        const { seed: D, k2sig: O } = C(g, x, w);
        return ry(e.outputLen, o.BYTES, n1)(D, O);
    }
    function $(g) {
        let x;
        const w = typeof g == "string" || Ii(g), D = !w && g !== null && typeof g == "object" && typeof g.r == "bigint" && typeof g.s == "bigint";
        if (!w && !D) throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
        if (D) x = new A(g.r, g.s);
        else if (w) {
            try {
                x = A.fromBytes(Et("sig", g), "der");
            } catch (O) {
                if (!(O instanceof cs.Err)) throw O;
            }
            if (!x) try {
                x = A.fromBytes(Et("sig", g), "compact");
            } catch  {
                return !1;
            }
        }
        return x || !1;
    }
    function W(g, x, w, D = {}) {
        const { lowS: O, prehash: U, format: V } = al(D, p);
        if (w = Et("publicKey", w), x = j(Et("message", x), U), "strict" in D) throw new Error("options.strict was renamed to lowS");
        const R = V === void 0 ? $(g) : A.fromBytes(Et("sig", g), V);
        if (R === !1) return !1;
        try {
            const m = s.fromBytes(w);
            if (O && R.hasHighS()) return !1;
            const { r: v, s: P } = R, N = M(x), Y = o.inv(P), ee = o.create(N * Y), ie = o.create(v * Y), le = s.BASE.multiplyUnsafe(ee).add(m.multiplyUnsafe(ie));
            return le.is0() ? !1 : o.create(le.x) === v;
        } catch  {
            return !1;
        }
    }
    function _(g, x, w = {}) {
        const { prehash: D } = al(w, p);
        return x = j(x, D), A.fromBytes(g, "recovered").recoverPublicKey(x).toBytes();
    }
    return Object.freeze({
        keygen: c,
        getPublicKey: u,
        getSharedSecret: d1,
        utils: h,
        lengths: f,
        Point: s,
        sign: k,
        verify: W,
        recoverPublicKey: _,
        Signature: A,
        hash: e
    });
}
function Qv(s) {
    const e = {
        a: s.a,
        b: s.b,
        p: s.Fp.ORDER,
        n: s.n,
        h: s.h,
        Gx: s.Gx,
        Gy: s.Gy
    }, t = s.Fp;
    let r = s.allowedPrivateKeyLengths ? Array.from(new Set(s.allowedPrivateKeyLengths.map((o)=>Math.ceil(o / 2)))) : void 0;
    const n1 = en(e.n, {
        BITS: s.nBitLength,
        allowedLengths: r,
        modFromBytes: s.wrapPrivateKey
    }), i = {
        Fp: t,
        Fn: n1,
        allowInfinityPoint: s.allowInfinityPoint,
        endo: s.endo,
        isTorsionFree: s.isTorsionFree,
        clearCofactor: s.clearCofactor,
        fromBytes: s.fromBytes,
        toBytes: s.toBytes
    };
    return {
        CURVE: e,
        curveOpts: i
    };
}
function eE(s) {
    const { CURVE: e, curveOpts: t } = Qv(s), r = {
        hmac: s.hmac,
        randomBytes: s.randomBytes,
        lowS: s.lowS,
        bits2int: s.bits2int,
        bits2int_modN: s.bits2int_modN
    };
    return {
        CURVE: e,
        curveOpts: t,
        hash: s.hash,
        ecdsaOpts: r
    };
}
function tE(s, e) {
    const t = e.Point;
    return Object.assign({}, e, {
        ProjectivePoint: t,
        CURVE: Object.assign({}, s, c0(t.Fn.ORDER, t.Fn.BITS))
    });
}
function rE(s) {
    const { CURVE: e, curveOpts: t, hash: r, ecdsaOpts: n1 } = eE(s), i = Zv(e, t), o = Jv(i, r, n1);
    return tE(s, o);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function sE(s, e) {
    const t = (r)=>rE({
            ...s,
            hash: r
        });
    return {
        ...t(e),
        create: t
    };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const tu = {
    p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
    n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
    h: BigInt(1),
    a: BigInt(0),
    b: BigInt(7),
    Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
    Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
}, nE = {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    basises: [
        [
            BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
            -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")
        ],
        [
            BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),
            BigInt("0x3086d221a7d46bcde86c90e49284eb15")
        ]
    ]
}, Bd = /* @__PURE__ */ BigInt(2);
function iE(s) {
    const e = tu.p, t = BigInt(3), r = BigInt(6), n1 = BigInt(11), i = BigInt(22), o = BigInt(23), a = BigInt(44), l = BigInt(88), c = s * s * s % e, u = c * c * s % e, d1 = vt(u, t, e) * u % e, h = vt(d1, t, e) * u % e, f = vt(h, Bd, e) * c % e, p = vt(f, n1, e) * f % e, y = vt(p, i, e) * p % e, E = vt(y, a, e) * y % e, b = vt(E, l, e) * E % e, L = vt(b, a, e) * y % e, A = vt(L, t, e) * u % e, F = vt(A, o, e) * p % e, M = vt(F, r, e) * c % e, H = vt(M, Bd, e);
    if (!tc.eql(tc.sqr(H), s)) throw new Error("Cannot find square root");
    return H;
}
const tc = en(tu.p, {
    sqrt: iE
}), oE = sE({
    ...tu,
    Fp: tc,
    lowS: !0,
    endo: nE
}, Xf);
Ri.utils.randomPrivateKey;
Ri.getPublicKey;
function Fd(s) {
    try {
        return Ri.ExtendedPoint.fromHex(s), !0;
    } catch  {
        return !1;
    }
}
const O0 = (s, e)=>Ri.sign(s, e.slice(0, 32)), aE = Ri.verify, ru = (s)=>He.Buffer.isBuffer(s) ? s : s instanceof Uint8Array ? He.Buffer.from(s.buffer, s.byteOffset, s.byteLength) : He.Buffer.from(s);
class lE {
    constructor(e){
        Object.assign(this, e);
    }
    encode() {
        return He.Buffer.from(Ja.serialize(uo, this));
    }
    static decode(e) {
        return Ja.deserialize(uo, this, e);
    }
    static decodeUnchecked(e) {
        return Ja.deserializeUnchecked(uo, this, e);
    }
}
const uo = /* @__PURE__ */ new Map();
var B0;
const cE = 32, ks = 32;
function uE(s) {
    return s._bn !== void 0;
}
let Nd = 1;
class Oe extends lE {
    /**
   * Create a new PublicKey object
   * @param value ed25519 public key as buffer or base-58 encoded string
   */ constructor(e){
        if (super({}), this._bn = void 0, uE(e)) this._bn = e._bn;
        else {
            if (typeof e == "string") {
                const t = ar.decode(e);
                if (t.length != ks) throw new Error("Invalid public key input");
                this._bn = new bd(t);
            } else this._bn = new bd(e);
            if (this._bn.byteLength() > ks) throw new Error("Invalid public key input");
        }
    }
    /**
   * Returns a unique PublicKey for tests and benchmarks using a counter
   */ static unique() {
        const e = new Oe(Nd);
        return Nd += 1, new Oe(e.toBuffer());
    }
    /**
   * Default public key value. The base58-encoded string representation is all ones (as seen below)
   * The underlying BN number is 32 bytes that are all zeros
   */ /**
   * Checks if two publicKeys are equal
   */ equals(e) {
        return this._bn.eq(e._bn);
    }
    /**
   * Return the base-58 representation of the public key
   */ toBase58() {
        return ar.encode(this.toBytes());
    }
    toJSON() {
        return this.toBase58();
    }
    /**
   * Return the byte array representation of the public key in big endian
   */ toBytes() {
        const e = this.toBuffer();
        return new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
    }
    /**
   * Return the Buffer representation of the public key in big endian
   */ toBuffer() {
        const e = this._bn.toArrayLike(He.Buffer);
        if (e.length === ks) return e;
        const t = He.Buffer.alloc(32);
        return e.copy(t, 32 - e.length), t;
    }
    get [Symbol.toStringTag]() {
        return `PublicKey(${this.toString()})`;
    }
    /**
   * Return the base-58 representation of the public key
   */ toString() {
        return this.toBase58();
    }
    /**
   * Derive a public key from another key, a seed, and a program ID.
   * The program ID will also serve as the owner of the public key, giving
   * it permission to write data to the account.
   */ /* eslint-disable require-await */ static async createWithSeed(e, t, r) {
        const n1 = He.Buffer.concat([
            e.toBuffer(),
            He.Buffer.from(t),
            r.toBuffer()
        ]), i = Id(n1);
        return new Oe(i);
    }
    /**
   * Derive a program address from seeds and a program ID.
   */ /* eslint-disable require-await */ static createProgramAddressSync(e, t) {
        let r = He.Buffer.alloc(0);
        e.forEach(function(i) {
            if (i.length > cE) throw new TypeError("Max seed length exceeded");
            r = He.Buffer.concat([
                r,
                ru(i)
            ]);
        }), r = He.Buffer.concat([
            r,
            t.toBuffer(),
            He.Buffer.from("ProgramDerivedAddress")
        ]);
        const n1 = Id(r);
        if (Fd(n1)) throw new Error("Invalid seeds, address must fall off the curve");
        return new Oe(n1);
    }
    /**
   * Async version of createProgramAddressSync
   * For backwards compatibility
   *
   * @deprecated Use {@link createProgramAddressSync} instead
   */ /* eslint-disable require-await */ static async createProgramAddress(e, t) {
        return this.createProgramAddressSync(e, t);
    }
    /**
   * Find a valid program address
   *
   * Valid program addresses must fall off the ed25519 curve.  This function
   * iterates a nonce until it finds one that when combined with the seeds
   * results in a valid program address.
   */ static findProgramAddressSync(e, t) {
        let r = 255, n1;
        for(; r != 0;){
            try {
                const i = e.concat(He.Buffer.from([
                    r
                ]));
                n1 = this.createProgramAddressSync(i, t);
            } catch (i) {
                if (i instanceof TypeError) throw i;
                r--;
                continue;
            }
            return [
                n1,
                r
            ];
        }
        throw new Error("Unable to find a viable program address nonce");
    }
    /**
   * Async version of findProgramAddressSync
   * For backwards compatibility
   *
   * @deprecated Use {@link findProgramAddressSync} instead
   */ static async findProgramAddress(e, t) {
        return this.findProgramAddressSync(e, t);
    }
    /**
   * Check that a pubkey is on the ed25519 curve.
   */ static isOnCurve(e) {
        const t = new Oe(e);
        return Fd(t.toBytes());
    }
}
B0 = Oe;
Oe.default = new B0("11111111111111111111111111111111");
uo.set(Oe, {
    kind: "struct",
    fields: [
        [
            "_bn",
            "u256"
        ]
    ]
});
new Oe("BPFLoader1111111111111111111111111111111111");
const bn = 1232, su = 127, Go = 64;
class Vo {
    constructor(e, t){
        this.staticAccountKeys = void 0, this.accountKeysFromLookups = void 0, this.staticAccountKeys = e, this.accountKeysFromLookups = t;
    }
    keySegments() {
        const e = [
            this.staticAccountKeys
        ];
        return this.accountKeysFromLookups && (e.push(this.accountKeysFromLookups.writable), e.push(this.accountKeysFromLookups.readonly)), e;
    }
    get(e) {
        for (const t of this.keySegments()){
            if (e < t.length) return t[e];
            e -= t.length;
        }
    }
    get length() {
        return this.keySegments().flat().length;
    }
    compileInstructions(e) {
        if (this.length > 256) throw new Error("Account index overflow encountered during compilation");
        const r = /* @__PURE__ */ new Map();
        this.keySegments().flat().forEach((i, o)=>{
            r.set(i.toBase58(), o);
        });
        const n1 = (i)=>{
            const o = r.get(i.toBase58());
            if (o === void 0) throw new Error("Encountered an unknown instruction account key during compilation");
            return o;
        };
        return e.map((i)=>({
                programIdIndex: n1(i.programId),
                accountKeyIndexes: i.keys.map((o)=>n1(o.pubkey)),
                data: i.data
            }));
    }
}
const qe = (s = "publicKey")=>z.blob(32, s), dE = (s = "signature")=>z.blob(64, s), vn = (s = "string")=>{
    const e = z.struct([
        z.u32("length"),
        z.u32("lengthPadding"),
        z.blob(z.offset(z.u32(), -8), "chars")
    ], s), t = e.decode.bind(e), r = e.encode.bind(e), n1 = e;
    return n1.decode = (i, o)=>t(i, o).chars.toString(), n1.encode = (i, o, a)=>{
        const l = {
            chars: He.Buffer.from(i, "utf8")
        };
        return r(l, o, a);
    }, n1.alloc = (i)=>z.u32().span + z.u32().span + He.Buffer.from(i, "utf8").length, n1;
}, hE = (s = "authorized")=>z.struct([
        qe("staker"),
        qe("withdrawer")
    ], s), fE = (s = "lockup")=>z.struct([
        z.ns64("unixTimestamp"),
        z.ns64("epoch"),
        qe("custodian")
    ], s), gE = (s = "voteInit")=>z.struct([
        qe("nodePubkey"),
        qe("authorizedVoter"),
        qe("authorizedWithdrawer"),
        z.u8("commission")
    ], s), pE = (s = "voteAuthorizeWithSeedArgs")=>z.struct([
        z.u32("voteAuthorizationType"),
        qe("currentAuthorityDerivedKeyOwnerPubkey"),
        vn("currentAuthorityDerivedKeySeed"),
        qe("newAuthorized")
    ], s);
function Er(s) {
    let e = 0, t = 0;
    for(;;){
        let r = s.shift();
        if (e |= (r & 127) << t * 7, t += 1, (r & 128) === 0) break;
    }
    return e;
}
function xr(s, e) {
    let t = e;
    for(;;){
        let r = t & 127;
        if (t >>= 7, t == 0) {
            s.push(r);
            break;
        } else r |= 128, s.push(r);
    }
}
function Kt(s, e) {
    if (!s) throw new Error(e || "Assertion failed");
}
class fa {
    constructor(e, t){
        this.payer = void 0, this.keyMetaMap = void 0, this.payer = e, this.keyMetaMap = t;
    }
    static compile(e, t) {
        const r = /* @__PURE__ */ new Map(), n1 = (o)=>{
            const a = o.toBase58();
            let l = r.get(a);
            return l === void 0 && (l = {
                isSigner: !1,
                isWritable: !1,
                isInvoked: !1
            }, r.set(a, l)), l;
        }, i = n1(t);
        i.isSigner = !0, i.isWritable = !0;
        for (const o of e){
            n1(o.programId).isInvoked = !0;
            for (const a of o.keys){
                const l = n1(a.pubkey);
                l.isSigner || (l.isSigner = a.isSigner), l.isWritable || (l.isWritable = a.isWritable);
            }
        }
        return new fa(t, r);
    }
    getMessageComponents() {
        const e = [
            ...this.keyMetaMap.entries()
        ];
        Kt(e.length <= 256, "Max static account keys length exceeded");
        const t = e.filter(([, l])=>l.isSigner && l.isWritable), r = e.filter(([, l])=>l.isSigner && !l.isWritable), n1 = e.filter(([, l])=>!l.isSigner && l.isWritable), i = e.filter(([, l])=>!l.isSigner && !l.isWritable), o = {
            numRequiredSignatures: t.length + r.length,
            numReadonlySignedAccounts: r.length,
            numReadonlyUnsignedAccounts: i.length
        };
        {
            Kt(t.length > 0, "Expected at least one writable signer key");
            const [l] = t[0];
            Kt(l === this.payer.toBase58(), "Expected first writable signer key to be the fee payer");
        }
        const a = [
            ...t.map(([l])=>new Oe(l)),
            ...r.map(([l])=>new Oe(l)),
            ...n1.map(([l])=>new Oe(l)),
            ...i.map(([l])=>new Oe(l))
        ];
        return [
            o,
            a
        ];
    }
    extractTableLookup(e) {
        const [t, r] = this.drainKeysFoundInLookupTable(e.state.addresses, (o)=>!o.isSigner && !o.isInvoked && o.isWritable), [n1, i] = this.drainKeysFoundInLookupTable(e.state.addresses, (o)=>!o.isSigner && !o.isInvoked && !o.isWritable);
        if (!(t.length === 0 && n1.length === 0)) return [
            {
                accountKey: e.key,
                writableIndexes: t,
                readonlyIndexes: n1
            },
            {
                writable: r,
                readonly: i
            }
        ];
    }
    /** @internal */ drainKeysFoundInLookupTable(e, t) {
        const r = new Array(), n1 = new Array();
        for (const [i, o] of this.keyMetaMap.entries())if (t(o)) {
            const a = new Oe(i), l = e.findIndex((c)=>c.equals(a));
            l >= 0 && (Kt(l < 256, "Max lookup table index exceeded"), r.push(l), n1.push(a), this.keyMetaMap.delete(i));
        }
        return [
            r,
            n1
        ];
    }
}
const F0 = "Reached end of buffer unexpectedly";
function ds(s) {
    if (s.length === 0) throw new Error(F0);
    return s.shift();
}
function Sr(s, ...e) {
    const [t] = e;
    if (e.length === 2 ? t + (e[1] ?? 0) > s.length : t >= s.length) throw new Error(F0);
    return s.splice(...e);
}
class Dn {
    constructor(e){
        this.header = void 0, this.accountKeys = void 0, this.recentBlockhash = void 0, this.instructions = void 0, this.indexToProgramIds = /* @__PURE__ */ new Map(), this.header = e.header, this.accountKeys = e.accountKeys.map((t)=>new Oe(t)), this.recentBlockhash = e.recentBlockhash, this.instructions = e.instructions, this.instructions.forEach((t)=>this.indexToProgramIds.set(t.programIdIndex, this.accountKeys[t.programIdIndex]));
    }
    get version() {
        return "legacy";
    }
    get staticAccountKeys() {
        return this.accountKeys;
    }
    get compiledInstructions() {
        return this.instructions.map((e)=>({
                programIdIndex: e.programIdIndex,
                accountKeyIndexes: e.accounts,
                data: ar.decode(e.data)
            }));
    }
    get addressTableLookups() {
        return [];
    }
    getAccountKeys() {
        return new Vo(this.staticAccountKeys);
    }
    static compile(e) {
        const t = fa.compile(e.instructions, e.payerKey), [r, n1] = t.getMessageComponents(), o = new Vo(n1).compileInstructions(e.instructions).map((a)=>({
                programIdIndex: a.programIdIndex,
                accounts: a.accountKeyIndexes,
                data: ar.encode(a.data)
            }));
        return new Dn({
            header: r,
            accountKeys: n1,
            recentBlockhash: e.recentBlockhash,
            instructions: o
        });
    }
    isAccountSigner(e) {
        return e < this.header.numRequiredSignatures;
    }
    isAccountWritable(e) {
        const t = this.header.numRequiredSignatures;
        if (e >= this.header.numRequiredSignatures) {
            const r = e - t, i = this.accountKeys.length - t - this.header.numReadonlyUnsignedAccounts;
            return r < i;
        } else {
            const r = t - this.header.numReadonlySignedAccounts;
            return e < r;
        }
    }
    isProgramId(e) {
        return this.indexToProgramIds.has(e);
    }
    programIds() {
        return [
            ...this.indexToProgramIds.values()
        ];
    }
    nonProgramIds() {
        return this.accountKeys.filter((e, t)=>!this.isProgramId(t));
    }
    serialize() {
        const e = this.accountKeys.length;
        let t = [];
        xr(t, e);
        const r = this.instructions.map((d1)=>{
            const { accounts: h, programIdIndex: f } = d1, p = Array.from(ar.decode(d1.data));
            let y = [];
            xr(y, h.length);
            let E = [];
            return xr(E, p.length), {
                programIdIndex: f,
                keyIndicesCount: He.Buffer.from(y),
                keyIndices: h,
                dataLength: He.Buffer.from(E),
                data: p
            };
        });
        let n1 = [];
        xr(n1, r.length);
        let i = He.Buffer.alloc(bn);
        He.Buffer.from(n1).copy(i);
        let o = n1.length;
        r.forEach((d1)=>{
            const f = z.struct([
                z.u8("programIdIndex"),
                z.blob(d1.keyIndicesCount.length, "keyIndicesCount"),
                z.seq(z.u8("keyIndex"), d1.keyIndices.length, "keyIndices"),
                z.blob(d1.dataLength.length, "dataLength"),
                z.seq(z.u8("userdatum"), d1.data.length, "data")
            ]).encode(d1, i, o);
            o += f;
        }), i = i.slice(0, o);
        const a = z.struct([
            z.blob(1, "numRequiredSignatures"),
            z.blob(1, "numReadonlySignedAccounts"),
            z.blob(1, "numReadonlyUnsignedAccounts"),
            z.blob(t.length, "keyCount"),
            z.seq(qe("key"), e, "keys"),
            qe("recentBlockhash")
        ]), l = {
            numRequiredSignatures: He.Buffer.from([
                this.header.numRequiredSignatures
            ]),
            numReadonlySignedAccounts: He.Buffer.from([
                this.header.numReadonlySignedAccounts
            ]),
            numReadonlyUnsignedAccounts: He.Buffer.from([
                this.header.numReadonlyUnsignedAccounts
            ]),
            keyCount: He.Buffer.from(t),
            keys: this.accountKeys.map((d1)=>ru(d1.toBytes())),
            recentBlockhash: ar.decode(this.recentBlockhash)
        };
        let c = He.Buffer.alloc(2048);
        const u = a.encode(l, c);
        return i.copy(c, u), c.slice(0, u + i.length);
    }
    /**
   * Decode a compiled message into a Message object.
   */ static from(e) {
        let t = [
            ...e
        ];
        const r = ds(t);
        if (r !== (r & su)) throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");
        const n1 = ds(t), i = ds(t), o = Er(t);
        let a = [];
        for(let h = 0; h < o; h++){
            const f = Sr(t, 0, ks);
            a.push(new Oe(He.Buffer.from(f)));
        }
        const l = Sr(t, 0, ks), c = Er(t);
        let u = [];
        for(let h = 0; h < c; h++){
            const f = ds(t), p = Er(t), y = Sr(t, 0, p), E = Er(t), b = Sr(t, 0, E), L = ar.encode(He.Buffer.from(b));
            u.push({
                programIdIndex: f,
                accounts: y,
                data: L
            });
        }
        const d1 = {
            header: {
                numRequiredSignatures: r,
                numReadonlySignedAccounts: n1,
                numReadonlyUnsignedAccounts: i
            },
            recentBlockhash: ar.encode(He.Buffer.from(l)),
            accountKeys: a,
            instructions: u
        };
        return new Dn(d1);
    }
}
class jo {
    constructor(e){
        this.header = void 0, this.staticAccountKeys = void 0, this.recentBlockhash = void 0, this.compiledInstructions = void 0, this.addressTableLookups = void 0, this.header = e.header, this.staticAccountKeys = e.staticAccountKeys, this.recentBlockhash = e.recentBlockhash, this.compiledInstructions = e.compiledInstructions, this.addressTableLookups = e.addressTableLookups;
    }
    get version() {
        return 0;
    }
    get numAccountKeysFromLookups() {
        let e = 0;
        for (const t of this.addressTableLookups)e += t.readonlyIndexes.length + t.writableIndexes.length;
        return e;
    }
    getAccountKeys(e) {
        let t;
        if (e && "accountKeysFromLookups" in e && e.accountKeysFromLookups) {
            if (this.numAccountKeysFromLookups != e.accountKeysFromLookups.writable.length + e.accountKeysFromLookups.readonly.length) throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");
            t = e.accountKeysFromLookups;
        } else if (e && "addressLookupTableAccounts" in e && e.addressLookupTableAccounts) t = this.resolveAddressTableLookups(e.addressLookupTableAccounts);
        else if (this.addressTableLookups.length > 0) throw new Error("Failed to get account keys because address table lookups were not resolved");
        return new Vo(this.staticAccountKeys, t);
    }
    isAccountSigner(e) {
        return e < this.header.numRequiredSignatures;
    }
    isAccountWritable(e) {
        const t = this.header.numRequiredSignatures, r = this.staticAccountKeys.length;
        if (e >= r) {
            const n1 = e - r, i = this.addressTableLookups.reduce((o, a)=>o + a.writableIndexes.length, 0);
            return n1 < i;
        } else if (e >= this.header.numRequiredSignatures) {
            const n1 = e - t, o = r - t - this.header.numReadonlyUnsignedAccounts;
            return n1 < o;
        } else {
            const n1 = t - this.header.numReadonlySignedAccounts;
            return e < n1;
        }
    }
    resolveAddressTableLookups(e) {
        const t = {
            writable: [],
            readonly: []
        };
        for (const r of this.addressTableLookups){
            const n1 = e.find((i)=>i.key.equals(r.accountKey));
            if (!n1) throw new Error(`Failed to find address lookup table account for table key ${r.accountKey.toBase58()}`);
            for (const i of r.writableIndexes)if (i < n1.state.addresses.length) t.writable.push(n1.state.addresses[i]);
            else throw new Error(`Failed to find address for index ${i} in address lookup table ${r.accountKey.toBase58()}`);
            for (const i of r.readonlyIndexes)if (i < n1.state.addresses.length) t.readonly.push(n1.state.addresses[i]);
            else throw new Error(`Failed to find address for index ${i} in address lookup table ${r.accountKey.toBase58()}`);
        }
        return t;
    }
    static compile(e) {
        const t = fa.compile(e.instructions, e.payerKey), r = new Array(), n1 = {
            writable: new Array(),
            readonly: new Array()
        }, i = e.addressLookupTableAccounts || [];
        for (const u of i){
            const d1 = t.extractTableLookup(u);
            if (d1 !== void 0) {
                const [h, { writable: f, readonly: p }] = d1;
                r.push(h), n1.writable.push(...f), n1.readonly.push(...p);
            }
        }
        const [o, a] = t.getMessageComponents(), c = new Vo(a, n1).compileInstructions(e.instructions);
        return new jo({
            header: o,
            staticAccountKeys: a,
            recentBlockhash: e.recentBlockhash,
            compiledInstructions: c,
            addressTableLookups: r
        });
    }
    serialize() {
        const e = Array();
        xr(e, this.staticAccountKeys.length);
        const t = this.serializeInstructions(), r = Array();
        xr(r, this.compiledInstructions.length);
        const n1 = this.serializeAddressTableLookups(), i = Array();
        xr(i, this.addressTableLookups.length);
        const o = z.struct([
            z.u8("prefix"),
            z.struct([
                z.u8("numRequiredSignatures"),
                z.u8("numReadonlySignedAccounts"),
                z.u8("numReadonlyUnsignedAccounts")
            ], "header"),
            z.blob(e.length, "staticAccountKeysLength"),
            z.seq(qe(), this.staticAccountKeys.length, "staticAccountKeys"),
            qe("recentBlockhash"),
            z.blob(r.length, "instructionsLength"),
            z.blob(t.length, "serializedInstructions"),
            z.blob(i.length, "addressTableLookupsLength"),
            z.blob(n1.length, "serializedAddressTableLookups")
        ]), a = new Uint8Array(bn), c = o.encode({
            prefix: 128,
            header: this.header,
            staticAccountKeysLength: new Uint8Array(e),
            staticAccountKeys: this.staticAccountKeys.map((u)=>u.toBytes()),
            recentBlockhash: ar.decode(this.recentBlockhash),
            instructionsLength: new Uint8Array(r),
            serializedInstructions: t,
            addressTableLookupsLength: new Uint8Array(i),
            serializedAddressTableLookups: n1
        }, a);
        return a.slice(0, c);
    }
    serializeInstructions() {
        let e = 0;
        const t = new Uint8Array(bn);
        for (const r of this.compiledInstructions){
            const n1 = Array();
            xr(n1, r.accountKeyIndexes.length);
            const i = Array();
            xr(i, r.data.length);
            const o = z.struct([
                z.u8("programIdIndex"),
                z.blob(n1.length, "encodedAccountKeyIndexesLength"),
                z.seq(z.u8(), r.accountKeyIndexes.length, "accountKeyIndexes"),
                z.blob(i.length, "encodedDataLength"),
                z.blob(r.data.length, "data")
            ]);
            e += o.encode({
                programIdIndex: r.programIdIndex,
                encodedAccountKeyIndexesLength: new Uint8Array(n1),
                accountKeyIndexes: r.accountKeyIndexes,
                encodedDataLength: new Uint8Array(i),
                data: r.data
            }, t, e);
        }
        return t.slice(0, e);
    }
    serializeAddressTableLookups() {
        let e = 0;
        const t = new Uint8Array(bn);
        for (const r of this.addressTableLookups){
            const n1 = Array();
            xr(n1, r.writableIndexes.length);
            const i = Array();
            xr(i, r.readonlyIndexes.length);
            const o = z.struct([
                qe("accountKey"),
                z.blob(n1.length, "encodedWritableIndexesLength"),
                z.seq(z.u8(), r.writableIndexes.length, "writableIndexes"),
                z.blob(i.length, "encodedReadonlyIndexesLength"),
                z.seq(z.u8(), r.readonlyIndexes.length, "readonlyIndexes")
            ]);
            e += o.encode({
                accountKey: r.accountKey.toBytes(),
                encodedWritableIndexesLength: new Uint8Array(n1),
                writableIndexes: r.writableIndexes,
                encodedReadonlyIndexesLength: new Uint8Array(i),
                readonlyIndexes: r.readonlyIndexes
            }, t, e);
        }
        return t.slice(0, e);
    }
    static deserialize(e) {
        let t = [
            ...e
        ];
        const r = ds(t), n1 = r & su;
        Kt(r !== n1, "Expected versioned message but received legacy message");
        const i = n1;
        Kt(i === 0, `Expected versioned message with version 0 but found version ${i}`);
        const o = {
            numRequiredSignatures: ds(t),
            numReadonlySignedAccounts: ds(t),
            numReadonlyUnsignedAccounts: ds(t)
        }, a = [], l = Er(t);
        for(let p = 0; p < l; p++)a.push(new Oe(Sr(t, 0, ks)));
        const c = ar.encode(Sr(t, 0, ks)), u = Er(t), d1 = [];
        for(let p = 0; p < u; p++){
            const y = ds(t), E = Er(t), b = Sr(t, 0, E), L = Er(t), A = new Uint8Array(Sr(t, 0, L));
            d1.push({
                programIdIndex: y,
                accountKeyIndexes: b,
                data: A
            });
        }
        const h = Er(t), f = [];
        for(let p = 0; p < h; p++){
            const y = new Oe(Sr(t, 0, ks)), E = Er(t), b = Sr(t, 0, E), L = Er(t), A = Sr(t, 0, L);
            f.push({
                accountKey: y,
                writableIndexes: b,
                readonlyIndexes: A
            });
        }
        return new jo({
            header: o,
            staticAccountKeys: a,
            recentBlockhash: c,
            compiledInstructions: d1,
            addressTableLookups: f
        });
    }
}
const nu = {
    deserializeMessageVersion (s) {
        const e = s[0], t = e & su;
        return t === e ? "legacy" : t;
    },
    deserialize: (s)=>{
        const e = nu.deserializeMessageVersion(s);
        if (e === "legacy") return Dn.from(s);
        if (e === 0) return jo.deserialize(s);
        throw new Error(`Transaction message version ${e} deserialization is not supported`);
    }
}, mE = He.Buffer.alloc(Go).fill(0);
class Ud {
    constructor(e){
        this.keys = void 0, this.programId = void 0, this.data = He.Buffer.alloc(0), this.programId = e.programId, this.keys = e.keys, e.data && (this.data = e.data);
    }
    /**
   * @internal
   */ toJSON() {
        return {
            keys: this.keys.map(({ pubkey: e, isSigner: t, isWritable: r })=>({
                    pubkey: e.toJSON(),
                    isSigner: t,
                    isWritable: r
                })),
            programId: this.programId.toJSON(),
            data: [
                ...this.data
            ]
        };
    }
}
class Ko {
    /**
   * The first (payer) Transaction signature
   *
   * @returns {Buffer | null} Buffer of payer's signature
   */ get signature() {
        return this.signatures.length > 0 ? this.signatures[0].signature : null;
    }
    /**
   * The transaction fee payer
   */ // Construct a transaction with a blockhash and lastValidBlockHeight
    // Construct a transaction using a durable nonce
    /**
   * @deprecated `TransactionCtorFields` has been deprecated and will be removed in a future version.
   * Please supply a `TransactionBlockhashCtor` instead.
   */ /**
   * Construct an empty Transaction
   */ constructor(e){
        if (this.signatures = [], this.feePayer = void 0, this.instructions = [], this.recentBlockhash = void 0, this.lastValidBlockHeight = void 0, this.nonceInfo = void 0, this.minNonceContextSlot = void 0, this._message = void 0, this._json = void 0, !!e) if (e.feePayer && (this.feePayer = e.feePayer), e.signatures && (this.signatures = e.signatures), Object.prototype.hasOwnProperty.call(e, "nonceInfo")) {
            const { minContextSlot: t, nonceInfo: r } = e;
            this.minNonceContextSlot = t, this.nonceInfo = r;
        } else if (Object.prototype.hasOwnProperty.call(e, "lastValidBlockHeight")) {
            const { blockhash: t, lastValidBlockHeight: r } = e;
            this.recentBlockhash = t, this.lastValidBlockHeight = r;
        } else {
            const { recentBlockhash: t, nonceInfo: r } = e;
            r && (this.nonceInfo = r), this.recentBlockhash = t;
        }
    }
    /**
   * @internal
   */ toJSON() {
        return {
            recentBlockhash: this.recentBlockhash || null,
            feePayer: this.feePayer ? this.feePayer.toJSON() : null,
            nonceInfo: this.nonceInfo ? {
                nonce: this.nonceInfo.nonce,
                nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
            } : null,
            instructions: this.instructions.map((e)=>e.toJSON()),
            signers: this.signatures.map(({ publicKey: e })=>e.toJSON())
        };
    }
    /**
   * Add one or more instructions to this Transaction
   *
   * @param {Array< Transaction | TransactionInstruction | TransactionInstructionCtorFields >} items - Instructions to add to the Transaction
   */ add(...e) {
        if (e.length === 0) throw new Error("No instructions");
        return e.forEach((t)=>{
            "instructions" in t ? this.instructions = this.instructions.concat(t.instructions) : "data" in t && "programId" in t && "keys" in t ? this.instructions.push(t) : this.instructions.push(new Ud(t));
        }), this;
    }
    /**
   * Compile transaction data
   */ compileMessage() {
        if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) return this._message;
        let e, t;
        if (this.nonceInfo ? (e = this.nonceInfo.nonce, this.instructions[0] != this.nonceInfo.nonceInstruction ? t = [
            this.nonceInfo.nonceInstruction,
            ...this.instructions
        ] : t = this.instructions) : (e = this.recentBlockhash, t = this.instructions), !e) throw new Error("Transaction recentBlockhash required");
        t.length < 1 && console.warn("No instructions provided");
        let r;
        if (this.feePayer) r = this.feePayer;
        else if (this.signatures.length > 0 && this.signatures[0].publicKey) r = this.signatures[0].publicKey;
        else throw new Error("Transaction fee payer required");
        for(let y = 0; y < t.length; y++)if (t[y].programId === void 0) throw new Error(`Transaction instruction index ${y} has undefined program id`);
        const n1 = [], i = [];
        t.forEach((y)=>{
            y.keys.forEach((b)=>{
                i.push({
                    ...b
                });
            });
            const E = y.programId.toString();
            n1.includes(E) || n1.push(E);
        }), n1.forEach((y)=>{
            i.push({
                pubkey: new Oe(y),
                isSigner: !1,
                isWritable: !1
            });
        });
        const o = [];
        i.forEach((y)=>{
            const E = y.pubkey.toString(), b = o.findIndex((L)=>L.pubkey.toString() === E);
            b > -1 ? (o[b].isWritable = o[b].isWritable || y.isWritable, o[b].isSigner = o[b].isSigner || y.isSigner) : o.push(y);
        }), o.sort(function(y, E) {
            if (y.isSigner !== E.isSigner) return y.isSigner ? -1 : 1;
            if (y.isWritable !== E.isWritable) return y.isWritable ? -1 : 1;
            const b = {
                localeMatcher: "best fit",
                usage: "sort",
                sensitivity: "variant",
                ignorePunctuation: !1,
                numeric: !1,
                caseFirst: "lower"
            };
            return y.pubkey.toBase58().localeCompare(E.pubkey.toBase58(), "en", b);
        });
        const a = o.findIndex((y)=>y.pubkey.equals(r));
        if (a > -1) {
            const [y] = o.splice(a, 1);
            y.isSigner = !0, y.isWritable = !0, o.unshift(y);
        } else o.unshift({
            pubkey: r,
            isSigner: !0,
            isWritable: !0
        });
        for (const y of this.signatures){
            const E = o.findIndex((b)=>b.pubkey.equals(y.publicKey));
            if (E > -1) o[E].isSigner || (o[E].isSigner = !0, console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));
            else throw new Error(`unknown signer: ${y.publicKey.toString()}`);
        }
        let l = 0, c = 0, u = 0;
        const d1 = [], h = [];
        o.forEach(({ pubkey: y, isSigner: E, isWritable: b })=>{
            E ? (d1.push(y.toString()), l += 1, b || (c += 1)) : (h.push(y.toString()), b || (u += 1));
        });
        const f = d1.concat(h), p = t.map((y)=>{
            const { data: E, programId: b } = y;
            return {
                programIdIndex: f.indexOf(b.toString()),
                accounts: y.keys.map((L)=>f.indexOf(L.pubkey.toString())),
                data: ar.encode(E)
            };
        });
        return p.forEach((y)=>{
            Kt(y.programIdIndex >= 0), y.accounts.forEach((E)=>Kt(E >= 0));
        }), new Dn({
            header: {
                numRequiredSignatures: l,
                numReadonlySignedAccounts: c,
                numReadonlyUnsignedAccounts: u
            },
            accountKeys: f,
            recentBlockhash: e,
            instructions: p
        });
    }
    /**
   * @internal
   */ _compile() {
        const e = this.compileMessage(), t = e.accountKeys.slice(0, e.header.numRequiredSignatures);
        return this.signatures.length === t.length && this.signatures.every((n1, i)=>t[i].equals(n1.publicKey)) || (this.signatures = t.map((r)=>({
                signature: null,
                publicKey: r
            }))), e;
    }
    /**
   * Get a buffer of the Transaction data that need to be covered by signatures
   */ serializeMessage() {
        return this._compile().serialize();
    }
    /**
   * Get the estimated fee associated with a transaction
   *
   * @param {Connection} connection Connection to RPC Endpoint.
   *
   * @returns {Promise<number | null>} The estimated fee for the transaction
   */ async getEstimatedFee(e) {
        return (await e.getFeeForMessage(this.compileMessage())).value;
    }
    /**
   * Specify the public keys which will be used to sign the Transaction.
   * The first signer will be used as the transaction fee payer account.
   *
   * Signatures can be added with either `partialSign` or `addSignature`
   *
   * @deprecated Deprecated since v0.84.0. Only the fee payer needs to be
   * specified and it can be set in the Transaction constructor or with the
   * `feePayer` property.
   */ setSigners(...e) {
        if (e.length === 0) throw new Error("No signers");
        const t = /* @__PURE__ */ new Set();
        this.signatures = e.filter((r)=>{
            const n1 = r.toString();
            return t.has(n1) ? !1 : (t.add(n1), !0);
        }).map((r)=>({
                signature: null,
                publicKey: r
            }));
    }
    /**
   * Sign the Transaction with the specified signers. Multiple signatures may
   * be applied to a Transaction. The first signature is considered "primary"
   * and is used identify and confirm transactions.
   *
   * If the Transaction `feePayer` is not set, the first signer will be used
   * as the transaction fee payer account.
   *
   * Transaction fields should not be modified after the first call to `sign`,
   * as doing so may invalidate the signature and cause the Transaction to be
   * rejected.
   *
   * The Transaction must be assigned a valid `recentBlockhash` before invoking this method
   *
   * @param {Array<Signer>} signers Array of signers that will sign the transaction
   */ sign(...e) {
        if (e.length === 0) throw new Error("No signers");
        const t = /* @__PURE__ */ new Set(), r = [];
        for (const i of e){
            const o = i.publicKey.toString();
            t.has(o) || (t.add(o), r.push(i));
        }
        this.signatures = r.map((i)=>({
                signature: null,
                publicKey: i.publicKey
            }));
        const n1 = this._compile();
        this._partialSign(n1, ...r);
    }
    /**
   * Partially sign a transaction with the specified accounts. All accounts must
   * correspond to either the fee payer or a signer account in the transaction
   * instructions.
   *
   * All the caveats from the `sign` method apply to `partialSign`
   *
   * @param {Array<Signer>} signers Array of signers that will sign the transaction
   */ partialSign(...e) {
        if (e.length === 0) throw new Error("No signers");
        const t = /* @__PURE__ */ new Set(), r = [];
        for (const i of e){
            const o = i.publicKey.toString();
            t.has(o) || (t.add(o), r.push(i));
        }
        const n1 = this._compile();
        this._partialSign(n1, ...r);
    }
    /**
   * @internal
   */ _partialSign(e, ...t) {
        const r = e.serialize();
        t.forEach((n1)=>{
            const i = O0(r, n1.secretKey);
            this._addSignature(n1.publicKey, ru(i));
        });
    }
    /**
   * Add an externally created signature to a transaction. The public key
   * must correspond to either the fee payer or a signer account in the transaction
   * instructions.
   *
   * @param {PublicKey} pubkey Public key that will be added to the transaction.
   * @param {Buffer} signature An externally created signature to add to the transaction.
   */ addSignature(e, t) {
        this._compile(), this._addSignature(e, t);
    }
    /**
   * @internal
   */ _addSignature(e, t) {
        Kt(t.length === 64);
        const r = this.signatures.findIndex((n1)=>e.equals(n1.publicKey));
        if (r < 0) throw new Error(`unknown signer: ${e.toString()}`);
        this.signatures[r].signature = He.Buffer.from(t);
    }
    /**
   * Verify signatures of a Transaction
   * Optional parameter specifies if we're expecting a fully signed Transaction or a partially signed one.
   * If no boolean is provided, we expect a fully signed Transaction by default.
   *
   * @param {boolean} [requireAllSignatures=true] Require a fully signed Transaction
   */ verifySignatures(e = !0) {
        return !this._getMessageSignednessErrors(this.serializeMessage(), e);
    }
    /**
   * @internal
   */ _getMessageSignednessErrors(e, t) {
        const r = {};
        for (const { signature: n1, publicKey: i } of this.signatures)n1 === null ? t && (r.missing || (r.missing = [])).push(i) : aE(n1, e, i.toBytes()) || (r.invalid || (r.invalid = [])).push(i);
        return r.invalid || r.missing ? r : void 0;
    }
    /**
   * Serialize the Transaction in the wire format.
   *
   * @param {Buffer} [config] Config of transaction.
   *
   * @returns {Buffer} Signature of transaction in wire format.
   */ serialize(e) {
        const { requireAllSignatures: t, verifySignatures: r } = Object.assign({
            requireAllSignatures: !0,
            verifySignatures: !0
        }, e), n1 = this.serializeMessage();
        if (r) {
            const i = this._getMessageSignednessErrors(n1, t);
            if (i) {
                let o = "Signature verification failed.";
                throw i.invalid && (o += `
Invalid signature for public key${i.invalid.length === 1 ? "" : "(s)"} [\`${i.invalid.map((a)=>a.toBase58()).join("`, `")}\`].`), i.missing && (o += `
Missing signature for public key${i.missing.length === 1 ? "" : "(s)"} [\`${i.missing.map((a)=>a.toBase58()).join("`, `")}\`].`), new Error(o);
            }
        }
        return this._serialize(n1);
    }
    /**
   * @internal
   */ _serialize(e) {
        const { signatures: t } = this, r = [];
        xr(r, t.length);
        const n1 = r.length + t.length * 64 + e.length, i = He.Buffer.alloc(n1);
        return Kt(t.length < 256), He.Buffer.from(r).copy(i, 0), t.forEach(({ signature: o }, a)=>{
            o !== null && (Kt(o.length === 64, "signature has invalid length"), He.Buffer.from(o).copy(i, r.length + a * 64));
        }), e.copy(i, r.length + t.length * 64), Kt(i.length <= bn, `Transaction too large: ${i.length} > ${bn}`), i;
    }
    /**
   * Deprecated method
   * @internal
   */ get keys() {
        return Kt(this.instructions.length === 1), this.instructions[0].keys.map((e)=>e.pubkey);
    }
    /**
   * Deprecated method
   * @internal
   */ get programId() {
        return Kt(this.instructions.length === 1), this.instructions[0].programId;
    }
    /**
   * Deprecated method
   * @internal
   */ get data() {
        return Kt(this.instructions.length === 1), this.instructions[0].data;
    }
    /**
   * Parse a wire transaction into a Transaction object.
   *
   * @param {Buffer | Uint8Array | Array<number>} buffer Signature of wire Transaction
   *
   * @returns {Transaction} Transaction associated with the signature
   */ static from(e) {
        let t = [
            ...e
        ];
        const r = Er(t);
        let n1 = [];
        for(let i = 0; i < r; i++){
            const o = Sr(t, 0, Go);
            n1.push(ar.encode(He.Buffer.from(o)));
        }
        return Ko.populate(Dn.from(t), n1);
    }
    /**
   * Populate Transaction object from message and signatures
   *
   * @param {Message} message Message of transaction
   * @param {Array<string>} signatures List of signatures to assign to the transaction
   *
   * @returns {Transaction} The populated Transaction
   */ static populate(e, t = []) {
        const r = new Ko();
        return r.recentBlockhash = e.recentBlockhash, e.header.numRequiredSignatures > 0 && (r.feePayer = e.accountKeys[0]), t.forEach((n1, i)=>{
            const o = {
                signature: n1 == ar.encode(mE) ? null : ar.decode(n1),
                publicKey: e.accountKeys[i]
            };
            r.signatures.push(o);
        }), e.instructions.forEach((n1)=>{
            const i = n1.accounts.map((o)=>{
                const a = e.accountKeys[o];
                return {
                    pubkey: a,
                    isSigner: r.signatures.some((l)=>l.publicKey.toString() === a.toString()) || e.isAccountSigner(o),
                    isWritable: e.isAccountWritable(o)
                };
            });
            r.instructions.push(new Ud({
                keys: i,
                programId: e.accountKeys[n1.programIdIndex],
                data: ar.decode(n1.data)
            }));
        }), r._message = e, r._json = r.toJSON(), r;
    }
}
class iu {
    get version() {
        return this.message.version;
    }
    constructor(e, t){
        if (this.signatures = void 0, this.message = void 0, t !== void 0) Kt(t.length === e.header.numRequiredSignatures, "Expected signatures length to be equal to the number of required signatures"), this.signatures = t;
        else {
            const r = [];
            for(let n1 = 0; n1 < e.header.numRequiredSignatures; n1++)r.push(new Uint8Array(Go));
            this.signatures = r;
        }
        this.message = e;
    }
    serialize() {
        const e = this.message.serialize(), t = Array();
        xr(t, this.signatures.length);
        const r = z.struct([
            z.blob(t.length, "encodedSignaturesLength"),
            z.seq(dE(), this.signatures.length, "signatures"),
            z.blob(e.length, "serializedMessage")
        ]), n1 = new Uint8Array(2048), i = r.encode({
            encodedSignaturesLength: new Uint8Array(t),
            signatures: this.signatures,
            serializedMessage: e
        }, n1);
        return n1.slice(0, i);
    }
    static deserialize(e) {
        let t = [
            ...e
        ];
        const r = [], n1 = Er(t);
        for(let o = 0; o < n1; o++)r.push(new Uint8Array(Sr(t, 0, Go)));
        const i = nu.deserialize(new Uint8Array(t));
        return new iu(i, r);
    }
    sign(e) {
        const t = this.message.serialize(), r = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
        for (const n1 of e){
            const i = r.findIndex((o)=>o.equals(n1.publicKey));
            Kt(i >= 0, `Cannot sign with non signer key ${n1.publicKey.toBase58()}`), this.signatures[i] = O0(t, n1.secretKey);
        }
    }
    addSignature(e, t) {
        Kt(t.byteLength === 64, "Signature must be 64 bytes long");
        const n1 = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures).findIndex((i)=>i.equals(e));
        Kt(n1 >= 0, `Can not add signature; \`${e.toBase58()}\` is not required to sign this transaction`), this.signatures[n1] = t;
    }
}
new Oe("SysvarC1ock11111111111111111111111111111111");
new Oe("SysvarEpochSchedu1e111111111111111111111111");
new Oe("Sysvar1nstructions1111111111111111111111111");
new Oe("SysvarRecentB1ockHashes11111111111111111111");
new Oe("SysvarRent111111111111111111111111111111111");
new Oe("SysvarRewards111111111111111111111111111111");
new Oe("SysvarS1otHashes111111111111111111111111111");
new Oe("SysvarS1otHistory11111111111111111111111111");
new Oe("SysvarStakeHistory1111111111111111111111111");
const yE = z.nu64("lamportsPerSignature"), vE = z.struct([
    z.u32("version"),
    z.u32("state"),
    qe("authorizedPubkey"),
    qe("nonce"),
    z.struct([
        yE
    ], "feeCalculator")
]);
vE.span;
function Pn(s) {
    const e = z.blob(8, s), t = e.decode.bind(e), r = e.encode.bind(e), n1 = e, i = pv();
    return n1.decode = (o, a)=>{
        const l = t(o, a);
        return i.decode(l);
    }, n1.encode = (o, a, l)=>{
        const c = i.encode(o);
        return r(c, a, l);
    }, n1;
}
Object.freeze({
    Create: {
        index: 0,
        layout: z.struct([
            z.u32("instruction"),
            z.ns64("lamports"),
            z.ns64("space"),
            qe("programId")
        ])
    },
    Assign: {
        index: 1,
        layout: z.struct([
            z.u32("instruction"),
            qe("programId")
        ])
    },
    Transfer: {
        index: 2,
        layout: z.struct([
            z.u32("instruction"),
            Pn("lamports")
        ])
    },
    CreateWithSeed: {
        index: 3,
        layout: z.struct([
            z.u32("instruction"),
            qe("base"),
            vn("seed"),
            z.ns64("lamports"),
            z.ns64("space"),
            qe("programId")
        ])
    },
    AdvanceNonceAccount: {
        index: 4,
        layout: z.struct([
            z.u32("instruction")
        ])
    },
    WithdrawNonceAccount: {
        index: 5,
        layout: z.struct([
            z.u32("instruction"),
            z.ns64("lamports")
        ])
    },
    InitializeNonceAccount: {
        index: 6,
        layout: z.struct([
            z.u32("instruction"),
            qe("authorized")
        ])
    },
    AuthorizeNonceAccount: {
        index: 7,
        layout: z.struct([
            z.u32("instruction"),
            qe("authorized")
        ])
    },
    Allocate: {
        index: 8,
        layout: z.struct([
            z.u32("instruction"),
            z.ns64("space")
        ])
    },
    AllocateWithSeed: {
        index: 9,
        layout: z.struct([
            z.u32("instruction"),
            qe("base"),
            vn("seed"),
            z.ns64("space"),
            qe("programId")
        ])
    },
    AssignWithSeed: {
        index: 10,
        layout: z.struct([
            z.u32("instruction"),
            qe("base"),
            vn("seed"),
            qe("programId")
        ])
    },
    TransferWithSeed: {
        index: 11,
        layout: z.struct([
            z.u32("instruction"),
            Pn("lamports"),
            vn("seed"),
            qe("programId")
        ])
    },
    UpgradeNonceAccount: {
        index: 12,
        layout: z.struct([
            z.u32("instruction")
        ])
    }
});
new Oe("11111111111111111111111111111111");
new Oe("BPFLoader2111111111111111111111111111111111");
z.struct([
    z.u32("typeIndex"),
    Pn("deactivationSlot"),
    z.nu64("lastExtendedSlot"),
    z.u8("lastExtendedStartIndex"),
    z.u8(),
    // option
    z.seq(qe(), z.offset(z.u8(), -1), "authority")
]);
const St = Di(Qc(Oe), ce(), (s)=>new Oe(s)), N0 = eu([
    ce(),
    gt("base64")
]), ou = Di(Qc(He.Buffer), N0, (s)=>He.Buffer.from(s[0], "base64"));
function U0(s) {
    return ur([
        oe({
            jsonrpc: gt("2.0"),
            id: ce(),
            result: s
        }),
        oe({
            jsonrpc: gt("2.0"),
            id: ce(),
            error: oe({
                code: Un(),
                message: ce(),
                data: Se(bv())
            })
        })
    ]);
}
const EE = U0(Un());
function lt(s) {
    return Di(U0(s), EE, (e)=>"error" in e ? e : {
            ...e,
            result: ti(e.result, s)
        });
}
function Fr(s) {
    return lt(oe({
        context: oe({
            slot: te()
        }),
        value: s
    }));
}
function ga(s) {
    return oe({
        context: oe({
            slot: te()
        }),
        value: s
    });
}
const xE = oe({
    foundation: te(),
    foundationTerm: te(),
    initial: te(),
    taper: te(),
    terminal: te()
});
lt(fe(ge(oe({
    epoch: te(),
    effectiveSlot: te(),
    amount: te(),
    postBalance: te(),
    commission: Se(ge(te()))
}))));
const SE = fe(oe({
    slot: te(),
    prioritizationFee: te()
})), bE = oe({
    total: te(),
    validator: te(),
    foundation: te(),
    epoch: te()
}), TE = oe({
    epoch: te(),
    slotIndex: te(),
    slotsInEpoch: te(),
    absoluteSlot: te(),
    blockHeight: Se(te()),
    transactionCount: Se(te())
}), wE = oe({
    slotsPerEpoch: te(),
    leaderScheduleSlotOffset: te(),
    warmup: Xr(),
    firstNormalEpoch: te(),
    firstNormalSlot: te()
}), AE = T0(ce(), fe(te())), rn = ge(ur([
    oe({}),
    ce()
])), IE = oe({
    err: rn
}), _E = gt("receivedSignature");
oe({
    "solana-core": ce(),
    "feature-set": Se(te())
});
const LE = oe({
    program: ce(),
    programId: St,
    parsed: Un()
}), RE = oe({
    programId: St,
    accounts: fe(St),
    data: ce()
});
Fr(oe({
    err: ge(ur([
        oe({}),
        ce()
    ])),
    logs: ge(fe(ce())),
    accounts: Se(ge(fe(ge(oe({
        executable: Xr(),
        owner: ce(),
        lamports: te(),
        data: fe(ce()),
        rentEpoch: Se(te())
    }))))),
    unitsConsumed: Se(te()),
    returnData: Se(ge(oe({
        programId: ce(),
        data: eu([
            ce(),
            gt("base64")
        ])
    }))),
    innerInstructions: Se(ge(fe(oe({
        index: te(),
        instructions: fe(ur([
            LE,
            RE
        ]))
    }))))
}));
Fr(oe({
    byIdentity: T0(ce(), fe(te())),
    range: oe({
        firstSlot: te(),
        lastSlot: te()
    })
}));
lt(xE);
lt(bE);
lt(SE);
lt(TE);
lt(wE);
lt(AE);
lt(te());
Fr(oe({
    total: te(),
    circulating: te(),
    nonCirculating: te(),
    nonCirculatingAccounts: fe(St)
}));
const CE = oe({
    amount: ce(),
    uiAmount: ge(te()),
    decimals: te(),
    uiAmountString: Se(ce())
});
Fr(fe(oe({
    address: St,
    amount: ce(),
    uiAmount: ge(te()),
    decimals: te(),
    uiAmountString: Se(ce())
})));
Fr(fe(oe({
    pubkey: St,
    account: oe({
        executable: Xr(),
        owner: St,
        lamports: te(),
        data: ou,
        rentEpoch: te()
    })
})));
const rc = oe({
    program: ce(),
    parsed: Un(),
    space: te()
});
Fr(fe(oe({
    pubkey: St,
    account: oe({
        executable: Xr(),
        owner: St,
        lamports: te(),
        data: rc,
        rentEpoch: te()
    })
})));
Fr(fe(oe({
    lamports: te(),
    address: St
})));
const au = oe({
    executable: Xr(),
    owner: St,
    lamports: te(),
    data: ou,
    rentEpoch: te()
});
oe({
    pubkey: St,
    account: au
});
const kE = Di(ur([
    Qc(He.Buffer),
    rc
]), ur([
    N0,
    rc
]), (s)=>Array.isArray(s) ? ti(s, ou) : s), DE = oe({
    executable: Xr(),
    owner: St,
    lamports: te(),
    data: kE,
    rentEpoch: te()
});
oe({
    pubkey: St,
    account: DE
});
oe({
    state: ur([
        gt("active"),
        gt("inactive"),
        gt("activating"),
        gt("deactivating")
    ]),
    active: te(),
    inactive: te()
});
lt(fe(oe({
    signature: ce(),
    slot: te(),
    err: rn,
    memo: ge(ce()),
    blockTime: Se(ge(te()))
})));
lt(fe(oe({
    signature: ce(),
    slot: te(),
    err: rn,
    memo: ge(ce()),
    blockTime: Se(ge(te()))
})));
oe({
    subscription: te(),
    result: ga(au)
});
const PE = oe({
    pubkey: St,
    account: au
});
oe({
    subscription: te(),
    result: ga(PE)
});
const ME = oe({
    parent: te(),
    slot: te(),
    root: te()
});
oe({
    subscription: te(),
    result: ME
});
const OE = ur([
    oe({
        type: ur([
            gt("firstShredReceived"),
            gt("completed"),
            gt("optimisticConfirmation"),
            gt("root")
        ]),
        slot: te(),
        timestamp: te()
    }),
    oe({
        type: gt("createdBank"),
        parent: te(),
        slot: te(),
        timestamp: te()
    }),
    oe({
        type: gt("frozen"),
        slot: te(),
        timestamp: te(),
        stats: oe({
            numTransactionEntries: te(),
            numSuccessfulTransactions: te(),
            numFailedTransactions: te(),
            maxTransactionsPerEntry: te()
        })
    }),
    oe({
        type: gt("dead"),
        slot: te(),
        timestamp: te(),
        err: ce()
    })
]);
oe({
    subscription: te(),
    result: OE
});
oe({
    subscription: te(),
    result: ga(ur([
        IE,
        _E
    ]))
});
oe({
    subscription: te(),
    result: te()
});
oe({
    pubkey: ce(),
    gossip: ge(ce()),
    tpu: ge(ce()),
    rpc: ge(ce()),
    version: ge(ce())
});
const $d = oe({
    votePubkey: ce(),
    nodePubkey: ce(),
    activatedStake: te(),
    epochVoteAccount: Xr(),
    epochCredits: fe(eu([
        te(),
        te(),
        te()
    ])),
    commission: te(),
    lastVote: te(),
    rootSlot: ge(te())
});
lt(oe({
    current: fe($d),
    delinquent: fe($d)
}));
const BE = ur([
    gt("processed"),
    gt("confirmed"),
    gt("finalized")
]), FE = oe({
    slot: te(),
    confirmations: ge(te()),
    err: rn,
    confirmationStatus: Se(BE)
});
Fr(fe(ge(FE)));
lt(te());
const $0 = oe({
    accountKey: St,
    writableIndexes: fe(te()),
    readonlyIndexes: fe(te())
}), lu = oe({
    signatures: fe(ce()),
    message: oe({
        accountKeys: fe(ce()),
        header: oe({
            numRequiredSignatures: te(),
            numReadonlySignedAccounts: te(),
            numReadonlyUnsignedAccounts: te()
        }),
        instructions: fe(oe({
            accounts: fe(te()),
            data: ce(),
            programIdIndex: te()
        })),
        recentBlockhash: ce(),
        addressTableLookups: Se(fe($0))
    })
}), G0 = oe({
    pubkey: St,
    signer: Xr(),
    writable: Xr(),
    source: Se(ur([
        gt("transaction"),
        gt("lookupTable")
    ]))
}), V0 = oe({
    accountKeys: fe(G0),
    signatures: fe(ce())
}), j0 = oe({
    parsed: Un(),
    program: ce(),
    programId: St
}), K0 = oe({
    accounts: fe(St),
    data: ce(),
    programId: St
}), NE = ur([
    K0,
    j0
]), UE = ur([
    oe({
        parsed: Un(),
        program: ce(),
        programId: ce()
    }),
    oe({
        accounts: fe(ce()),
        data: ce(),
        programId: ce()
    })
]), H0 = Di(NE, UE, (s)=>"accounts" in s ? ti(s, K0) : ti(s, j0)), q0 = oe({
    signatures: fe(ce()),
    message: oe({
        accountKeys: fe(G0),
        instructions: fe(H0),
        recentBlockhash: ce(),
        addressTableLookups: Se(ge(fe($0)))
    })
}), Ho = oe({
    accountIndex: te(),
    mint: ce(),
    owner: Se(ce()),
    programId: Se(ce()),
    uiTokenAmount: CE
}), W0 = oe({
    writable: fe(St),
    readonly: fe(St)
}), pa = oe({
    err: rn,
    fee: te(),
    innerInstructions: Se(ge(fe(oe({
        index: te(),
        instructions: fe(oe({
            accounts: fe(te()),
            data: ce(),
            programIdIndex: te()
        }))
    })))),
    preBalances: fe(te()),
    postBalances: fe(te()),
    logMessages: Se(ge(fe(ce()))),
    preTokenBalances: Se(ge(fe(Ho))),
    postTokenBalances: Se(ge(fe(Ho))),
    loadedAddresses: Se(W0),
    computeUnitsConsumed: Se(te()),
    costUnits: Se(te())
}), cu = oe({
    err: rn,
    fee: te(),
    innerInstructions: Se(ge(fe(oe({
        index: te(),
        instructions: fe(H0)
    })))),
    preBalances: fe(te()),
    postBalances: fe(te()),
    logMessages: Se(ge(fe(ce()))),
    preTokenBalances: Se(ge(fe(Ho))),
    postTokenBalances: Se(ge(fe(Ho))),
    loadedAddresses: Se(W0),
    computeUnitsConsumed: Se(te()),
    costUnits: Se(te())
}), $n = ur([
    gt(0),
    gt("legacy")
]), sn = oe({
    pubkey: ce(),
    lamports: te(),
    postBalance: ge(te()),
    rewardType: ge(ce()),
    commission: Se(ge(te()))
});
lt(ge(oe({
    blockhash: ce(),
    previousBlockhash: ce(),
    parentSlot: te(),
    transactions: fe(oe({
        transaction: lu,
        meta: ge(pa),
        version: Se($n)
    })),
    rewards: Se(fe(sn)),
    blockTime: ge(te()),
    blockHeight: ge(te())
})));
lt(ge(oe({
    blockhash: ce(),
    previousBlockhash: ce(),
    parentSlot: te(),
    rewards: Se(fe(sn)),
    blockTime: ge(te()),
    blockHeight: ge(te())
})));
lt(ge(oe({
    blockhash: ce(),
    previousBlockhash: ce(),
    parentSlot: te(),
    transactions: fe(oe({
        transaction: V0,
        meta: ge(pa),
        version: Se($n)
    })),
    rewards: Se(fe(sn)),
    blockTime: ge(te()),
    blockHeight: ge(te())
})));
lt(ge(oe({
    blockhash: ce(),
    previousBlockhash: ce(),
    parentSlot: te(),
    transactions: fe(oe({
        transaction: q0,
        meta: ge(cu),
        version: Se($n)
    })),
    rewards: Se(fe(sn)),
    blockTime: ge(te()),
    blockHeight: ge(te())
})));
lt(ge(oe({
    blockhash: ce(),
    previousBlockhash: ce(),
    parentSlot: te(),
    transactions: fe(oe({
        transaction: V0,
        meta: ge(cu),
        version: Se($n)
    })),
    rewards: Se(fe(sn)),
    blockTime: ge(te()),
    blockHeight: ge(te())
})));
lt(ge(oe({
    blockhash: ce(),
    previousBlockhash: ce(),
    parentSlot: te(),
    rewards: Se(fe(sn)),
    blockTime: ge(te()),
    blockHeight: ge(te())
})));
lt(ge(oe({
    blockhash: ce(),
    previousBlockhash: ce(),
    parentSlot: te(),
    transactions: fe(oe({
        transaction: lu,
        meta: ge(pa)
    })),
    rewards: Se(fe(sn)),
    blockTime: ge(te())
})));
lt(ge(oe({
    blockhash: ce(),
    previousBlockhash: ce(),
    parentSlot: te(),
    signatures: fe(ce()),
    blockTime: ge(te())
})));
lt(ge(oe({
    slot: te(),
    meta: ge(pa),
    blockTime: Se(ge(te())),
    transaction: lu,
    version: Se($n)
})));
lt(ge(oe({
    slot: te(),
    transaction: q0,
    meta: ge(cu),
    blockTime: Se(ge(te())),
    version: Se($n)
})));
Fr(oe({
    blockhash: ce(),
    lastValidBlockHeight: te()
}));
Fr(Xr());
const $E = oe({
    slot: te(),
    numTransactions: te(),
    numSlots: te(),
    samplePeriodSecs: te()
});
lt(fe($E));
Fr(ge(oe({
    feeCalculator: oe({
        lamportsPerSignature: te()
    })
})));
lt(ce());
lt(ce());
const GE = oe({
    err: rn,
    logs: fe(ce()),
    signature: ce()
});
oe({
    result: ga(GE),
    subscription: te()
});
Object.freeze({
    CreateLookupTable: {
        index: 0,
        layout: z.struct([
            z.u32("instruction"),
            Pn("recentSlot"),
            z.u8("bumpSeed")
        ])
    },
    FreezeLookupTable: {
        index: 1,
        layout: z.struct([
            z.u32("instruction")
        ])
    },
    ExtendLookupTable: {
        index: 2,
        layout: z.struct([
            z.u32("instruction"),
            Pn(),
            z.seq(qe(), z.offset(z.u32(), -8), "addresses")
        ])
    },
    DeactivateLookupTable: {
        index: 3,
        layout: z.struct([
            z.u32("instruction")
        ])
    },
    CloseLookupTable: {
        index: 4,
        layout: z.struct([
            z.u32("instruction")
        ])
    }
});
new Oe("AddressLookupTab1e1111111111111111111111111");
Object.freeze({
    RequestUnits: {
        index: 0,
        layout: z.struct([
            z.u8("instruction"),
            z.u32("units"),
            z.u32("additionalFee")
        ])
    },
    RequestHeapFrame: {
        index: 1,
        layout: z.struct([
            z.u8("instruction"),
            z.u32("bytes")
        ])
    },
    SetComputeUnitLimit: {
        index: 2,
        layout: z.struct([
            z.u8("instruction"),
            z.u32("units")
        ])
    },
    SetComputeUnitPrice: {
        index: 3,
        layout: z.struct([
            z.u8("instruction"),
            Pn("microLamports")
        ])
    }
});
new Oe("ComputeBudget111111111111111111111111111111");
z.struct([
    z.u8("numSignatures"),
    z.u8("padding"),
    z.u16("signatureOffset"),
    z.u16("signatureInstructionIndex"),
    z.u16("publicKeyOffset"),
    z.u16("publicKeyInstructionIndex"),
    z.u16("messageDataOffset"),
    z.u16("messageDataSize"),
    z.u16("messageInstructionIndex")
]);
new Oe("Ed25519SigVerify111111111111111111111111111");
oE.utils.isValidPrivateKey;
z.struct([
    z.u8("numSignatures"),
    z.u16("signatureOffset"),
    z.u8("signatureInstructionIndex"),
    z.u16("ethAddressOffset"),
    z.u8("ethAddressInstructionIndex"),
    z.u16("messageDataOffset"),
    z.u16("messageDataSize"),
    z.u8("messageInstructionIndex"),
    z.blob(20, "ethAddress"),
    z.blob(64, "signature"),
    z.u8("recoveryId")
]);
new Oe("KeccakSecp256k11111111111111111111111111111");
var z0;
new Oe("StakeConfig11111111111111111111111111111111");
class Y0 {
    /**
   * Create a new Lockup object
   */ constructor(e, t, r){
        this.unixTimestamp = void 0, this.epoch = void 0, this.custodian = void 0, this.unixTimestamp = e, this.epoch = t, this.custodian = r;
    }
}
z0 = Y0;
Y0.default = new z0(0, 0, Oe.default);
Object.freeze({
    Initialize: {
        index: 0,
        layout: z.struct([
            z.u32("instruction"),
            hE(),
            fE()
        ])
    },
    Authorize: {
        index: 1,
        layout: z.struct([
            z.u32("instruction"),
            qe("newAuthorized"),
            z.u32("stakeAuthorizationType")
        ])
    },
    Delegate: {
        index: 2,
        layout: z.struct([
            z.u32("instruction")
        ])
    },
    Split: {
        index: 3,
        layout: z.struct([
            z.u32("instruction"),
            z.ns64("lamports")
        ])
    },
    Withdraw: {
        index: 4,
        layout: z.struct([
            z.u32("instruction"),
            z.ns64("lamports")
        ])
    },
    Deactivate: {
        index: 5,
        layout: z.struct([
            z.u32("instruction")
        ])
    },
    Merge: {
        index: 7,
        layout: z.struct([
            z.u32("instruction")
        ])
    },
    AuthorizeWithSeed: {
        index: 8,
        layout: z.struct([
            z.u32("instruction"),
            qe("newAuthorized"),
            z.u32("stakeAuthorizationType"),
            vn("authoritySeed"),
            qe("authorityOwner")
        ])
    }
});
new Oe("Stake11111111111111111111111111111111111111");
Object.freeze({
    InitializeAccount: {
        index: 0,
        layout: z.struct([
            z.u32("instruction"),
            gE()
        ])
    },
    Authorize: {
        index: 1,
        layout: z.struct([
            z.u32("instruction"),
            qe("newAuthorized"),
            z.u32("voteAuthorizationType")
        ])
    },
    Withdraw: {
        index: 3,
        layout: z.struct([
            z.u32("instruction"),
            z.ns64("lamports")
        ])
    },
    UpdateValidatorIdentity: {
        index: 4,
        layout: z.struct([
            z.u32("instruction")
        ])
    },
    AuthorizeWithSeed: {
        index: 10,
        layout: z.struct([
            z.u32("instruction"),
            pE()
        ])
    }
});
new Oe("Vote111111111111111111111111111111111111111");
new Oe("Va1idator1nfo111111111111111111111111111111");
oe({
    name: ce(),
    website: Se(ce()),
    details: Se(ce()),
    iconUrl: Se(ce()),
    keybaseUsername: Se(ce())
});
new Oe("Vote111111111111111111111111111111111111111");
z.struct([
    qe("nodePubkey"),
    qe("authorizedWithdrawer"),
    z.u8("commission"),
    z.nu64(),
    // votes.length
    z.seq(z.struct([
        z.nu64("slot"),
        z.u32("confirmationCount")
    ]), z.offset(z.u32(), -8), "votes"),
    z.u8("rootSlotValid"),
    z.nu64("rootSlot"),
    z.nu64(),
    // authorizedVoters.length
    z.seq(z.struct([
        z.nu64("epoch"),
        qe("authorizedVoter")
    ]), z.offset(z.u32(), -8), "authorizedVoters"),
    z.struct([
        z.seq(z.struct([
            qe("authorizedPubkey"),
            z.nu64("epochOfLastAuthorizedSwitch"),
            z.nu64("targetEpoch")
        ]), 32, "buf"),
        z.nu64("idx"),
        z.u8("isEmpty")
    ], "priorVoters"),
    z.nu64(),
    // epochCredits.length
    z.seq(z.struct([
        z.nu64("epoch"),
        z.nu64("credits"),
        z.nu64("prevCredits")
    ]), z.offset(z.u32(), -8), "epochCredits"),
    z.struct([
        z.nu64("slot"),
        z.nu64("timestamp")
    ], "lastTimestamp")
]);
const VE = (s)=>({
        request: s,
        signMessage: (e)=>s({
                method: "signMessage",
                params: {
                    message: e
                }
            }),
        signTransaction: (e)=>s({
                method: "signTransaction",
                params: {
                    transaction: e
                }
            }),
        signAndSendTransaction: (e)=>s({
                method: "signAndSendTransaction",
                params: e
            })
    });
function Gd(s) {
    return Buffer.from(s.serialize({
        verifySignatures: !1
    })).toString("base64");
}
function jE(s) {
    const e = Buffer.from(s, "base64");
    return nu.deserializeMessageVersion(e) === "legacy" ? iu.deserialize(e) : Ko.from(e);
}
function KE(s) {
    return async (t)=>{
        if (t.method === "connect") return await s(t);
        if (t.method === "signMessage") return await s(t);
        if (t.method === "signAndSendTransaction") {
            const { transaction: r } = t.params, n1 = {
                transaction: Gd(r)
            };
            return await s({
                method: "signAndSendTransaction",
                params: n1
            });
        }
        if (t.method === "signTransaction") {
            const { transaction: r } = t.params, n1 = {
                transaction: Gd(r)
            }, { signedTransaction: i } = await s({
                method: "signTransaction",
                params: n1
            });
            return {
                signedTransaction: jE(i)
            };
        }
    };
}
const HE = ({ miniAppHost: s, emitter: e })=>{
    let t, r = null;
    return {
        visible: !1,
        get onback () {
            return r;
        },
        set onback (n){
            r && e.removeListener("backNavigationTriggered", r), r = n, n && e.addListener("backNavigationTriggered", n);
        },
        async show () {
            await s.updateBackState({
                visible: !0
            }), this.visible = !0;
        },
        async hide () {
            await s.updateBackState({
                visible: !1
            }), this.visible = !1;
        },
        async enableWebNavigation () {
            t = qE({
                back: this,
                emitter: e
            });
        },
        async disableWebNavigation () {
            t == null || t(), t = void 0;
        }
    };
};
function qE({ emitter: s, back: e }) {
    const t = WE();
    if (t) return zE({
        emitter: s,
        back: e,
        navigation: t
    });
    if (("TURBOPACK compile-time value", "undefined") < "u") return YE({
        emitter: s,
        back: e,
        window
    });
}
function WE() {
    if (("TURBOPACK compile-time value", "undefined") < "u" && window.navigation !== void 0) return window.navigation;
}
function zE({ emitter: s, back: e, navigation: t }) {
    function r() {
        t.canGoBack ? e.show() : e.hide();
    }
    function n1() {
        e.visible && t.canGoBack && t.back();
    }
    return t.addEventListener("navigatesuccess", r), s.addListener("backNavigationTriggered", n1), ()=>{
        t.removeEventListener("navigatesuccess", r), s.removeListener("backNavigationTriggered", n1);
    };
}
function YE({ emitter: s, back: e, window: t }) {
    e.show();
    function r() {
        e.visible && t.history.back();
    }
    return s.addListener("backNavigationTriggered", r), ()=>{
        s.removeListener("backNavigationTriggered", r);
    };
}
const ZE = "0.1.1";
function XE() {
    return ZE;
}
let JE = class sc extends Error {
    constructor(e, t = {}){
        const r = (()=>{
            var l;
            if (t.cause instanceof sc) {
                if (t.cause.details) return t.cause.details;
                if (t.cause.shortMessage) return t.cause.shortMessage;
            }
            return (l = t.cause) != null && l.message ? t.cause.message : t.details;
        })(), n1 = t.cause instanceof sc && t.cause.docsPath || t.docsPath, o = `https://oxlib.sh${n1 ?? ""}`, a = [
            e || "An error occurred.",
            ...t.metaMessages ? [
                "",
                ...t.metaMessages
            ] : [],
            ...r || n1 ? [
                "",
                r ? `Details: ${r}` : void 0,
                n1 ? `See: ${o}` : void 0
            ] : []
        ].filter((l)=>typeof l == "string").join(`
`);
        super(a, t.cause ? {
            cause: t.cause
        } : void 0), Object.defineProperty(this, "details", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), Object.defineProperty(this, "docs", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), Object.defineProperty(this, "docsPath", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), Object.defineProperty(this, "shortMessage", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), Object.defineProperty(this, "cause", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "BaseError"
        }), Object.defineProperty(this, "version", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: `ox@${XE()}`
        }), this.cause = t.cause, this.details = r, this.docs = o, this.docsPath = n1, this.shortMessage = e;
    }
    walk(e) {
        return Z0(this, e);
    }
};
function Z0(s, e) {
    return e != null && e(s) ? s : s && typeof s == "object" && "cause" in s && s.cause ? Z0(s.cause, e) : e ? null : s;
}
function X0(s, e = {}) {
    const { raw: t = !1 } = e, r = s;
    if (t) return s;
    if (r.error) {
        const { code: n1 } = r.error, i = n1 === Mn.code ? Mn : n1 === ri.code ? ri : n1 === di.code ? di : n1 === ci.code ? ci : n1 === ai.code ? ai : n1 === ui.code ? ui : n1 === oi.code ? oi : n1 === hi.code ? hi : n1 === si.code ? si : n1 === ni.code ? ni : n1 === ii.code ? ii : n1 === li.code ? li : mr;
        throw new i(r.error);
    }
    return r.result;
}
let mr = class extends Error {
    constructor(e){
        const { code: t, message: r, data: n1 } = e;
        super(r), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "RpcResponse.BaseError"
        }), Object.defineProperty(this, "code", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), Object.defineProperty(this, "data", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), this.code = t, this.data = n1;
    }
};
class ri extends mr {
    constructor(e = {}){
        super({
            message: "Missing or invalid parameters.",
            ...e,
            code: ri.code
        }), Object.defineProperty(this, "code", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: -32e3
        }), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "RpcResponse.InvalidInputError"
        });
    }
}
Object.defineProperty(ri, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32e3
});
class si extends mr {
    constructor(e = {}){
        super({
            message: "Requested resource not found.",
            ...e,
            code: si.code
        }), Object.defineProperty(this, "code", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: -32001
        }), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "RpcResponse.ResourceNotFoundError"
        });
    }
}
Object.defineProperty(si, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32001
});
class ni extends mr {
    constructor(e = {}){
        super({
            message: "Requested resource not available.",
            ...e,
            code: ni.code
        }), Object.defineProperty(this, "code", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: -32002
        }), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "RpcResponse.ResourceUnavailableError"
        });
    }
}
Object.defineProperty(ni, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32002
});
class ii extends mr {
    constructor(e = {}){
        super({
            message: "Transaction creation failed.",
            ...e,
            code: ii.code
        }), Object.defineProperty(this, "code", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: -32003
        }), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "RpcResponse.TransactionRejectedError"
        });
    }
}
Object.defineProperty(ii, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32003
});
class oi extends mr {
    constructor(e = {}){
        super({
            message: "Method is not implemented.",
            ...e,
            code: oi.code
        }), Object.defineProperty(this, "code", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: -32004
        }), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "RpcResponse.MethodNotSupportedError"
        });
    }
}
Object.defineProperty(oi, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32004
});
class ai extends mr {
    constructor(e = {}){
        super({
            message: "Rate limit exceeded.",
            ...e,
            code: ai.code
        }), Object.defineProperty(this, "code", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: -32005
        }), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "RpcResponse.LimitExceededError"
        });
    }
}
Object.defineProperty(ai, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32005
});
class li extends mr {
    constructor(e = {}){
        super({
            message: "JSON-RPC version not supported.",
            ...e,
            code: li.code
        }), Object.defineProperty(this, "code", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: -32006
        }), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "RpcResponse.VersionNotSupportedError"
        });
    }
}
Object.defineProperty(li, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32006
});
class ci extends mr {
    constructor(e = {}){
        super({
            message: "Input is not a valid JSON-RPC request.",
            ...e,
            code: ci.code
        }), Object.defineProperty(this, "code", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: -32600
        }), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "RpcResponse.InvalidRequestError"
        });
    }
}
Object.defineProperty(ci, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32600
});
class ui extends mr {
    constructor(e = {}){
        super({
            message: "Method does not exist.",
            ...e,
            code: ui.code
        }), Object.defineProperty(this, "code", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: -32601
        }), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "RpcResponse.MethodNotFoundError"
        });
    }
}
Object.defineProperty(ui, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32601
});
class di extends mr {
    constructor(e = {}){
        super({
            message: "Invalid method parameters.",
            ...e,
            code: di.code
        }), Object.defineProperty(this, "code", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: -32602
        }), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "RpcResponse.InvalidParamsError"
        });
    }
}
Object.defineProperty(di, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32602
});
class Mn extends mr {
    constructor(e = {}){
        super({
            message: "Internal JSON-RPC error.",
            ...e,
            code: Mn.code
        }), Object.defineProperty(this, "code", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: -32603
        }), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "RpcResponse.InternalErrorError"
        });
    }
}
Object.defineProperty(Mn, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32603
});
class hi extends mr {
    constructor(e = {}){
        super({
            message: "Failed to parse JSON-RPC response.",
            ...e,
            code: hi.code
        }), Object.defineProperty(this, "code", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: -32700
        }), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "RpcResponse.ParseError"
        });
    }
}
Object.defineProperty(hi, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32700
});
class nn extends Error {
    constructor(e, t){
        super(t), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ProviderRpcError"
        }), Object.defineProperty(this, "code", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), Object.defineProperty(this, "details", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), this.code = e, this.details = t;
    }
}
class J0 extends nn {
    constructor({ message: e = "The user rejected the request." } = {}){
        super(4001, e), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Provider.UserRejectedRequestError"
        });
    }
}
Object.defineProperty(J0, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: 4001
});
class Q0 extends nn {
    constructor({ message: e = "The requested method and/or account has not been authorized by the user." } = {}){
        super(4100, e), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Provider.UnauthorizedError"
        });
    }
}
Object.defineProperty(Q0, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: 4100
});
class eg extends nn {
    constructor({ message: e = "The provider does not support the requested method." } = {}){
        super(4200, e), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Provider.UnsupportedMethodError"
        });
    }
}
Object.defineProperty(eg, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: 4200
});
class tg extends nn {
    constructor({ message: e = "The provider is disconnected from all chains." } = {}){
        super(4900, e), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Provider.DisconnectedError"
        });
    }
}
Object.defineProperty(tg, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: 4900
});
class rg extends nn {
    constructor({ message: e = "The provider is not connected to the requested chain." } = {}){
        super(4901, e), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Provider.ChainDisconnectedError"
        });
    }
}
Object.defineProperty(rg, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: 4901
});
function QE() {
    const s = new R0();
    return {
        get eventNames () {
            return s.eventNames.bind(s);
        },
        get listenerCount () {
            return s.listenerCount.bind(s);
        },
        get listeners () {
            return s.listeners.bind(s);
        },
        addListener: s.addListener.bind(s),
        emit: s.emit.bind(s),
        off: s.off.bind(s),
        on: s.on.bind(s),
        once: s.once.bind(s),
        removeAllListeners: s.removeAllListeners.bind(s),
        removeListener: s.removeListener.bind(s)
    };
}
function ex(s, e = {}) {
    var r, n1;
    const { includeEvents: t = !0 } = e;
    if (!s) throw new tx();
    return {
        ...t ? {
            on: (r = s.on) == null ? void 0 : r.bind(s),
            removeListener: (n1 = s.removeListener) == null ? void 0 : n1.bind(s)
        } : {},
        async request (i) {
            const o = await s.request(i);
            return o && typeof o == "object" && "jsonrpc" in o ? X0(o) : o;
        }
    };
}
class tx extends JE {
    constructor(){
        super("`provider` is undefined."), Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Provider.IsUndefinedError"
        });
    }
}
function rx(s = {}) {
    let e = s.id ?? 0;
    return {
        prepare (t) {
            return sx({
                id: e++,
                ...t
            });
        },
        get id () {
            return e;
        }
    };
}
function sx(s) {
    return {
        ...s,
        jsonrpc: "2.0"
    };
}
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ const sg = Symbol("Comlink.proxy"), nx = Symbol("Comlink.endpoint"), ix = Symbol("Comlink.releaseProxy"), ll = Symbol("Comlink.finalizer"), ho = Symbol("Comlink.thrown"), ng = (s)=>typeof s == "object" && s !== null || typeof s == "function", ox = {
    canHandle: (s)=>ng(s) && s[sg],
    serialize (s) {
        const { port1: e, port2: t } = new MessageChannel();
        return og(s, e), [
            t,
            [
                t
            ]
        ];
    },
    deserialize (s) {
        return s.start(), lg(s);
    }
}, ax = {
    canHandle: (s)=>ng(s) && ho in s,
    serialize ({ value: s }) {
        let e;
        return s instanceof Error ? e = {
            isError: !0,
            value: {
                message: s.message,
                name: s.name,
                stack: s.stack
            }
        } : e = {
            isError: !1,
            value: s
        }, [
            e,
            []
        ];
    },
    deserialize (s) {
        throw s.isError ? Object.assign(new Error(s.value.message), s.value) : s.value;
    }
}, ig = /* @__PURE__ */ new Map([
    [
        "proxy",
        ox
    ],
    [
        "throw",
        ax
    ]
]);
function lx(s, e) {
    for (const t of s)if (e === t || t === "*" || t instanceof RegExp && t.test(e)) return !0;
    return !1;
}
function og(s, e = globalThis, t = [
    "*"
]) {
    e.addEventListener("message", function r(n1) {
        if (!n1 || !n1.data) return;
        if (!lx(t, n1.origin)) {
            console.warn(`Invalid origin '${n1.origin}' for comlink proxy`);
            return;
        }
        const { id: i, type: o, path: a } = Object.assign({
            path: []
        }, n1.data), l = (n1.data.argumentList || []).map($s);
        let c;
        try {
            const u = a.slice(0, -1).reduce((h, f)=>h[f], s), d1 = a.reduce((h, f)=>h[f], s);
            switch(o){
                case "GET":
                    c = d1;
                    break;
                case "SET":
                    u[a.slice(-1)[0]] = $s(n1.data.value), c = !0;
                    break;
                case "APPLY":
                    c = d1.apply(u, l);
                    break;
                case "CONSTRUCT":
                    {
                        const h = new d1(...l);
                        c = gx(h);
                    }
                    break;
                case "ENDPOINT":
                    {
                        const { port1: h, port2: f } = new MessageChannel();
                        og(s, f), c = fx(h, [
                            h
                        ]);
                    }
                    break;
                case "RELEASE":
                    c = void 0;
                    break;
                default:
                    return;
            }
        } catch (u) {
            c = {
                value: u,
                [ho]: 0
            };
        }
        Promise.resolve(c).catch((u)=>({
                value: u,
                [ho]: 0
            })).then((u)=>{
            const [d1, h] = zo(u);
            e.postMessage(Object.assign(Object.assign({}, d1), {
                id: i
            }), h), o === "RELEASE" && (e.removeEventListener("message", r), ag(e), ll in s && typeof s[ll] == "function" && s[ll]());
        }).catch((u)=>{
            const [d1, h] = zo({
                value: new TypeError("Unserializable return value"),
                [ho]: 0
            });
            e.postMessage(Object.assign(Object.assign({}, d1), {
                id: i
            }), h);
        });
    }), e.start && e.start();
}
function cx(s) {
    return s.constructor.name === "MessagePort";
}
function ag(s) {
    cx(s) && s.close();
}
function lg(s, e) {
    const t = /* @__PURE__ */ new Map();
    return s.addEventListener("message", function(n1) {
        const { data: i } = n1;
        if (!i || !i.id) return;
        const o = t.get(i.id);
        if (o) try {
            o(i);
        } finally{
            t.delete(i.id);
        }
    }), nc(s, t, [], e);
}
function Vi(s) {
    if (s) throw new Error("Proxy has been released and is not useable");
}
function cg(s) {
    return pn(s, /* @__PURE__ */ new Map(), {
        type: "RELEASE"
    }).then(()=>{
        ag(s);
    });
}
const qo = /* @__PURE__ */ new WeakMap(), Wo = "FinalizationRegistry" in globalThis && new FinalizationRegistry((s)=>{
    const e = (qo.get(s) || 0) - 1;
    qo.set(s, e), e === 0 && cg(s);
});
function ux(s, e) {
    const t = (qo.get(e) || 0) + 1;
    qo.set(e, t), Wo && Wo.register(s, e, s);
}
function dx(s) {
    Wo && Wo.unregister(s);
}
function nc(s, e, t = [], r = function() {}) {
    let n1 = !1;
    const i = new Proxy(r, {
        get (o, a) {
            if (Vi(n1), a === ix) return ()=>{
                dx(i), cg(s), e.clear(), n1 = !0;
            };
            if (a === "then") {
                if (t.length === 0) return {
                    then: ()=>i
                };
                const l = pn(s, e, {
                    type: "GET",
                    path: t.map((c)=>c.toString())
                }).then($s);
                return l.then.bind(l);
            }
            return nc(s, e, [
                ...t,
                a
            ]);
        },
        set (o, a, l) {
            Vi(n1);
            const [c, u] = zo(l);
            return pn(s, e, {
                type: "SET",
                path: [
                    ...t,
                    a
                ].map((d1)=>d1.toString()),
                value: c
            }, u).then($s);
        },
        apply (o, a, l) {
            Vi(n1);
            const c = t[t.length - 1];
            if (c === nx) return pn(s, e, {
                type: "ENDPOINT"
            }).then($s);
            if (c === "bind") return nc(s, e, t.slice(0, -1));
            const [u, d1] = Vd(l);
            return pn(s, e, {
                type: "APPLY",
                path: t.map((h)=>h.toString()),
                argumentList: u
            }, d1).then($s);
        },
        construct (o, a) {
            Vi(n1);
            const [l, c] = Vd(a);
            return pn(s, e, {
                type: "CONSTRUCT",
                path: t.map((u)=>u.toString()),
                argumentList: l
            }, c).then($s);
        }
    });
    return ux(i, s), i;
}
function hx(s) {
    return Array.prototype.concat.apply([], s);
}
function Vd(s) {
    const e = s.map(zo);
    return [
        e.map((t)=>t[0]),
        hx(e.map((t)=>t[1]))
    ];
}
const ug = /* @__PURE__ */ new WeakMap();
function fx(s, e) {
    return ug.set(s, e), s;
}
function gx(s) {
    return Object.assign(s, {
        [sg]: !0
    });
}
function px(s, e = globalThis, t = "*") {
    return {
        postMessage: (r, n1)=>s.postMessage(r, t, n1),
        addEventListener: e.addEventListener.bind(e),
        removeEventListener: e.removeEventListener.bind(e)
    };
}
function zo(s) {
    for (const [e, t] of ig)if (t.canHandle(s)) {
        const [r, n1] = t.serialize(s);
        return [
            {
                type: "HANDLER",
                name: e,
                value: r
            },
            n1
        ];
    }
    return [
        {
            type: "RAW",
            value: s
        },
        ug.get(s) || []
    ];
}
function $s(s) {
    switch(s.type){
        case "HANDLER":
            return ig.get(s.name).deserialize(s.value);
        case "RAW":
            return s.value;
    }
}
function pn(s, e, t, r) {
    return new Promise((n1)=>{
        const i = mx();
        e.set(i, n1), s.start && s.start(), s.postMessage(Object.assign({
            id: i
        }, t), r);
    });
}
function mx() {
    return new Array(4).fill(0).map(()=>Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16)).join("-");
}
const yx = {
    postMessage () {},
    addEventListener: ()=>{},
    removeEventListener: ()=>{}
}, vx = {
    postMessage: (s)=>{
        window.ReactNativeWebView.postMessage(JSON.stringify(s));
    },
    addEventListener: (s, e, ...t)=>{
        document.addEventListener("FarcasterFrameCallback", e, ...t);
    },
    removeEventListener: (s, e)=>{
        document.removeEventListener("FarcasterFrameCallback", e);
    }
}, Ex = ("TURBOPACK compile-time value", "undefined") > "u" ? yx : window != null && window.ReactNativeWebView ? vx : px((window == null ? void 0 : window.parent) ?? window), Me = lg(Ex), uu = QE(), xx = rx();
function Sx({ code: s, details: e }) {
    switch(s){
        case 4001:
            return new J0();
        case 4100:
            return new Q0();
        case 4200:
            return new eg();
        case 4900:
            return new tg();
        case 4901:
            return new rg();
        default:
            return new nn(s, e ?? "Unknown provider RPC error");
    }
}
const fi = ex({
    ...uu,
    async request (s) {
        const e = xx.prepare(s);
        try {
            const t = await Me.ethProviderRequestV2(e).then((r)=>X0(r, {
                    request: e,
                    raw: !0
                }));
            if (t.error) throw Sx(t.error);
            return t.result;
        } catch (t) {
            if (t instanceof Error && t.message.match(/cannot read property 'apply'/i)) return await Me.ethProviderRequest(e);
            throw t instanceof nn || t instanceof mr ? t : new Mn({
                message: t instanceof Error ? t.message : void 0
            });
        }
    }
});
async function bx() {
    try {
        const s = await Me.getCapabilities();
        return !s.includes("wallet.getEthereumProvider") && !s.includes("wallet.getEvmProvider") ? void 0 : fi;
    } catch  {
        return fi;
    }
}
function dg(s) {
    const e = new CustomEvent("eip6963:announceProvider", {
        detail: Object.freeze(s)
    });
    window.dispatchEvent(e);
    const t = ()=>window.dispatchEvent(e);
    return window.addEventListener("eip6963:requestProvider", t), ()=>window.removeEventListener("eip6963:requestProvider", t);
}
typeof document < "u" && (document.addEventListener("eip6963:requestProvider", ()=>{
    Me.eip6963RequestProvider();
}), document.addEventListener("FarcasterFrameEthProviderEvent", (s)=>{
    if (s instanceof MessageEvent) {
        const e = s.data;
        uu.emit(e.event, ...e.params);
    }
}), document.addEventListener("FarcasterFrameEvent", (s)=>{
    if (s instanceof MessageEvent) {
        const e = s.data;
        e.event === "eip6963:announceProvider" && dg({
            info: e.info,
            provider: fi
        });
    }
}));
("TURBOPACK compile-time value", "undefined") < "u" && (window.addEventListener("eip6963:requestProvider", ()=>{
    Me.eip6963RequestProvider();
}), window.addEventListener("message", (s)=>{
    if (s instanceof MessageEvent && s.data.type === "frameEthProviderEvent") {
        const e = s.data;
        uu.emit(e.event, ...e.params);
    }
}), window.addEventListener("message", (s)=>{
    if (s instanceof MessageEvent && s.data.type === "frameEvent") {
        const e = s.data.event;
        e.event === "eip6963:announceProvider" && dg({
            info: e.info,
            provider: fi
        });
    }
}));
new TextEncoder();
const hg = new TextDecoder(), Tx = (s)=>{
    const e = atob(s), t = new Uint8Array(e.length);
    for(let r = 0; r < e.length; r++)t[r] = e.charCodeAt(r);
    return t;
}, wx = (s)=>{
    let e = s;
    e instanceof Uint8Array && (e = hg.decode(e)), e = e.replace(/-/g, "+").replace(/_/g, "/").replace(/\s/g, "");
    try {
        return Tx(e);
    } catch  {
        throw new TypeError("The input to be decoded is not correctly encoded.");
    }
}, Ax = wx;
function Ix(s) {
    return typeof s == "object" && s !== null;
}
function _x(s) {
    if (!Ix(s) || Object.prototype.toString.call(s) !== "[object Object]") return !1;
    if (Object.getPrototypeOf(s) === null) return !0;
    let e = s;
    for(; Object.getPrototypeOf(e) !== null;)e = Object.getPrototypeOf(e);
    return Object.getPrototypeOf(s) === e;
}
class dr extends Error {
    constructor(e, t){
        var r;
        super(e, t), this.code = "ERR_JOSE_GENERIC", this.name = this.constructor.name, (r = Error.captureStackTrace) == null || r.call(Error, this, this.constructor);
    }
}
dr.code = "ERR_JOSE_GENERIC";
class Lx extends dr {
    constructor(e, t, r = "unspecified", n1 = "unspecified"){
        super(e, {
            cause: {
                claim: r,
                reason: n1,
                payload: t
            }
        }), this.code = "ERR_JWT_CLAIM_VALIDATION_FAILED", this.claim = r, this.reason = n1, this.payload = t;
    }
}
Lx.code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
class Rx extends dr {
    constructor(e, t, r = "unspecified", n1 = "unspecified"){
        super(e, {
            cause: {
                claim: r,
                reason: n1,
                payload: t
            }
        }), this.code = "ERR_JWT_EXPIRED", this.claim = r, this.reason = n1, this.payload = t;
    }
}
Rx.code = "ERR_JWT_EXPIRED";
class Cx extends dr {
    constructor(){
        super(...arguments), this.code = "ERR_JOSE_ALG_NOT_ALLOWED";
    }
}
Cx.code = "ERR_JOSE_ALG_NOT_ALLOWED";
class kx extends dr {
    constructor(){
        super(...arguments), this.code = "ERR_JOSE_NOT_SUPPORTED";
    }
}
kx.code = "ERR_JOSE_NOT_SUPPORTED";
class Dx extends dr {
    constructor(e = "decryption operation failed", t){
        super(e, t), this.code = "ERR_JWE_DECRYPTION_FAILED";
    }
}
Dx.code = "ERR_JWE_DECRYPTION_FAILED";
class Px extends dr {
    constructor(){
        super(...arguments), this.code = "ERR_JWE_INVALID";
    }
}
Px.code = "ERR_JWE_INVALID";
class Mx extends dr {
    constructor(){
        super(...arguments), this.code = "ERR_JWS_INVALID";
    }
}
Mx.code = "ERR_JWS_INVALID";
class Ts extends dr {
    constructor(){
        super(...arguments), this.code = "ERR_JWT_INVALID";
    }
}
Ts.code = "ERR_JWT_INVALID";
class Ox extends dr {
    constructor(){
        super(...arguments), this.code = "ERR_JWK_INVALID";
    }
}
Ox.code = "ERR_JWK_INVALID";
class Bx extends dr {
    constructor(){
        super(...arguments), this.code = "ERR_JWKS_INVALID";
    }
}
Bx.code = "ERR_JWKS_INVALID";
class Fx extends dr {
    constructor(e = "no applicable key found in the JSON Web Key Set", t){
        super(e, t), this.code = "ERR_JWKS_NO_MATCHING_KEY";
    }
}
Fx.code = "ERR_JWKS_NO_MATCHING_KEY";
class Nx extends dr {
    constructor(e = "multiple matching keys found in the JSON Web Key Set", t){
        super(e, t), this.code = "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
    }
}
Nx.code = "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
class Ux extends dr {
    constructor(e = "request timed out", t){
        super(e, t), this.code = "ERR_JWKS_TIMEOUT";
    }
}
Ux.code = "ERR_JWKS_TIMEOUT";
class $x extends dr {
    constructor(e = "signature verification failed", t){
        super(e, t), this.code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
    }
}
$x.code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
function Gx(s) {
    if (typeof s != "string") throw new Ts("JWTs must use Compact JWS serialization, JWT must be a string");
    const { 1: e, length: t } = s.split(".");
    if (t === 5) throw new Ts("Only JWTs using Compact JWS serialization can be decoded");
    if (t !== 3) throw new Ts("Invalid JWT");
    if (!e) throw new Ts("JWTs must contain a payload");
    let r;
    try {
        r = Ax(e);
    } catch  {
        throw new Ts("Failed to base64url decode the payload");
    }
    let n1;
    try {
        n1 = JSON.parse(hg.decode(r));
    } catch  {
        throw new Ts("Failed to parse the decoded payload as JSON");
    }
    if (!_x(n1)) throw new Ts("Invalid JWT Claims Set");
    return n1;
}
function Vx(s) {
    return Gx(s);
}
class ma extends Error {
    constructor(e, t = {}){
        const r = (()=>{
            var i;
            if (t.cause instanceof ma) {
                if (t.cause.details) return t.cause.details;
                if (t.cause.shortMessage) return t.cause.shortMessage;
            }
            return t.cause && "details" in t.cause && typeof t.cause.details == "string" ? t.cause.details : (i = t.cause) != null && i.message ? t.cause.message : t.details;
        })(), n1 = [
            e || "An error occurred.",
            ...t.metaMessages ? [
                "",
                ...t.metaMessages
            ] : [],
            ...r ? [
                "",
                r ? `Details: ${r}` : void 0
            ] : []
        ].filter((i)=>typeof i == "string").join(`
`);
        super(n1, t.cause ? {
            cause: t.cause
        } : void 0), this.name = "BaseError", this.cause = t.cause, this.details = r, this.shortMessage = e;
    }
}
class fg extends ma {
    constructor({ status: e }){
        super(`Request failed with status ${e}`), this.name = "RequestFailedError";
    }
}
class jx extends ma {
    constructor(e){
        super(e), this.name = "InvalidToken";
    }
}
async function Kx({ origin: s }) {
    const e = await fetch(`${s}/nonce`, {
        method: "POST"
    });
    if (!e.ok) throw new fg({
        status: e.status
    });
    return await e.json();
}
async function Hx({ origin: s }, e) {
    const t = await fetch(`${s}/verify-siwf`, {
        method: "POST",
        headers: new Headers({
            "Content-Type": "application/json"
        }),
        body: JSON.stringify(e)
    });
    if (!t.ok) throw new fg({
        status: t.status
    });
    const r = await t.json();
    if (r.valid === !1) throw new jx(r.message ?? "unknown");
    return {
        token: r.token
    };
}
function qx(s = {}) {
    return {
        origin: s.origin ?? "https://auth.farcaster.xyz"
    };
}
function Wx(s = {}) {
    const e = qx(s);
    return {
        generateNonce: ()=>Kx(e),
        verifySiwf: (t)=>Hx(e, t)
    };
}
const zx = /^(?:(?<scheme>[a-zA-Z][a-zA-Z0-9+-.]*):\/\/)?(?<domain>[a-zA-Z0-9+-.]*(?::[0-9]{1,5})?) (?:wants you to sign in with your Ethereum account:\n)(?<address>0x[a-fA-F0-9]{40})\n\n(?:(?<statement>.*)\n\n)?/, Yx = /(?:URI: (?<uri>.+))\n(?:Version: (?<version>.+))\n(?:Chain ID: (?<chainId>\d+))\n(?:Nonce: (?<nonce>[a-zA-Z0-9]+))\n(?:Issued At: (?<issuedAt>.+))(?:\nExpiration Time: (?<expirationTime>.+))?(?:\nNot Before: (?<notBefore>.+))?(?:\nRequest ID: (?<requestId>.+))?/;
function Zx(s) {
    var d1, h, f;
    const { scheme: e, statement: t, ...r } = ((d1 = s.match(zx)) == null ? void 0 : d1.groups) ?? {}, { chainId: n1, expirationTime: i, issuedAt: o, notBefore: a, requestId: l, ...c } = ((h = s.match(Yx)) == null ? void 0 : h.groups) ?? {}, u = (f = s.split("Resources:")[1]) == null ? void 0 : f.split(`
- `).slice(1);
    return {
        ...r,
        ...c,
        ...n1 ? {
            chainId: Number(n1)
        } : {},
        ...i ? {
            expirationTime: new Date(i)
        } : {},
        ...o ? {
            issuedAt: new Date(o)
        } : {},
        ...a ? {
            notBefore: new Date(a)
        } : {},
        ...l ? {
            requestId: l
        } : {},
        ...u ? {
            resources: u
        } : {},
        ...e ? {
            scheme: e
        } : {},
        ...t ? {
            statement: t
        } : {}
    };
}
const jd = /* @__PURE__ */ (()=>{
    let s, e;
    async function t(r) {
        const n1 = Wx({
            origin: r.quickAuthServerOrigin
        }), { nonce: i } = await n1.generateNonce(), o = await Me.signIn({
            nonce: i,
            acceptAuthAddress: !0
        });
        if (o.result) {
            const a = Zx(o.result.message);
            if (!a.domain) throw new Error("Missing domain on SIWE message");
            const l = await n1.verifySiwf({
                domain: a.domain,
                message: o.result.message,
                signature: o.result.signature
            });
            return s = {
                token: l.token,
                payload: Vx(l.token)
            }, l;
        }
        throw o.error.type === "rejected_by_user" ? new Of() : new Error("Unreachable");
    }
    return {
        get token () {
            if (s && new Date(s.payload.exp * 1e3) > new Date(Date.now() + 15e3)) return s.token;
        },
        async getToken (r = {}) {
            const n1 = r.force ?? !1;
            return s && !n1 && new Date(s.payload.exp * 1e3) > new Date(Date.now() + 15e3) ? {
                token: s.token
            } : (e || (e = t(r)), e.finally(()=>{
                e = void 0;
            }), e);
        },
        async fetch (r, n1) {
            const { token: i } = await this.getToken(), o = new Headers(n1 == null ? void 0 : n1.headers);
            return o.set("Authorization", `Bearer ${i}`), fetch(r, {
                ...n1,
                headers: o
            });
        }
    };
})();
function Xx() {
    const s = new R0();
    return {
        get eventNames () {
            return s.eventNames.bind(s);
        },
        get listenerCount () {
            return s.listenerCount.bind(s);
        },
        get listeners () {
            return s.listeners.bind(s);
        },
        addListener: s.addListener.bind(s),
        emit: s.emit.bind(s),
        off: s.off.bind(s),
        on: s.on.bind(s),
        once: s.once.bind(s),
        removeAllListeners: s.removeAllListeners.bind(s),
        removeListener: s.removeListener.bind(s)
    };
}
const nr = Xx(), { solanaProviderRequest: Kd } = Me;
let gg;
Kd && (gg = VE(KE(Kd)));
async function Hd() {
    let s;
    try {
        s = await Me.getCapabilities();
    } catch  {}
    if (s != null && s.includes("wallet.getSolanaProvider")) return gg;
}
let qd = null;
async function Jx(s = 1e3) {
    if (qd === !0) return !0;
    if (("TURBOPACK compile-time value", "undefined") > "u" || !window.ReactNativeWebView && window === window.parent) return !1;
    const e = await Promise.race([
        Me.context.then((t)=>!!t),
        // Check if context resolves to truthy
        new Promise((t)=>{
            setTimeout(()=>t(!1), s);
        })
    ]).catch(()=>!1);
    return e && (qd = !0), e;
}
const Wd = async ()=>{
    const s = await Me.addFrame();
    if (s.result) return s.result;
    throw s.error.type === "invalid_domain_manifest" ? new Tm() : s.error.type === "rejected_by_user" ? new wm() : new Error("Unreachable");
}, ht = {
    ...nr,
    getCapabilities: Me.getCapabilities,
    getChains: Me.getChains,
    isInMiniApp: Jx,
    context: Me.context,
    back: HE({
        miniAppHost: Me,
        emitter: nr
    }),
    quickAuth: jd,
    actions: {
        setPrimaryButton: Me.setPrimaryButton.bind(Me),
        ready: async (s = {})=>await Me.ready(s),
        close: Me.close.bind(Me),
        viewCast: Me.viewCast.bind(Me),
        viewProfile: Me.viewProfile.bind(Me),
        openMiniApp: Me.openMiniApp.bind(Me),
        signIn: async (s)=>{
            const e = await Me.signIn(s);
            if (e.result) return e.result;
            throw e.error.type === "rejected_by_user" ? new Of() : new Error("Unreachable");
        },
        openUrl: (s)=>{
            const e = typeof s == "string" ? s : s.url;
            return Me.openUrl(e.trim());
        },
        addFrame: Wd,
        addMiniApp: Wd,
        composeCast (s = {}) {
            return Me.composeCast(s);
        },
        viewToken: Me.viewToken.bind(Me),
        sendToken: Me.sendToken.bind(Me),
        swapToken: Me.swapToken.bind(Me),
        requestCameraAndMicrophoneAccess: Me.requestCameraAndMicrophoneAccess.bind(Me)
    },
    experimental: {
        getSolanaProvider: Hd,
        signManifest: async (s)=>{
            const e = await Me.signManifest(s);
            if (e.result) return e.result;
            throw e.error.type === "rejected_by_user" ? new Am() : e.error.type === "invalid_domain" ? new Im() : e.error.type === "generic_error" ? new _m(e.error.message) : new Error("Unreachable");
        },
        quickAuth (s) {
            return jd.getToken(s);
        }
    },
    wallet: {
        ethProvider: fi,
        getEthereumProvider: bx,
        getSolanaProvider: Hd
    },
    haptics: {
        impactOccurred: Me.impactOccurred.bind(Me),
        notificationOccurred: Me.notificationOccurred.bind(Me),
        selectionChanged: Me.selectionChanged.bind(Me)
    }
};
typeof document < "u" && document.addEventListener("FarcasterFrameEvent", (s)=>{
    if (s instanceof MessageEvent) {
        const e = s.data;
        e.event === "primary_button_clicked" ? nr.emit("primaryButtonClicked") : e.event === "miniapp_added" ? nr.emit("miniAppAdded", {
            notificationDetails: e.notificationDetails
        }) : e.event === "miniapp_add_rejected" ? nr.emit("miniAppAddRejected", {
            reason: e.reason
        }) : e.event === "miniapp_removed" ? nr.emit("miniAppRemoved") : e.event === "notifications_enabled" ? nr.emit("notificationsEnabled", {
            notificationDetails: e.notificationDetails
        }) : e.event === "notifications_disabled" ? nr.emit("notificationsDisabled") : e.event === "back_navigation_triggered" && nr.emit("backNavigationTriggered");
    }
});
("TURBOPACK compile-time value", "undefined") < "u" && window.addEventListener("message", (s)=>{
    if (s instanceof MessageEvent && s.data.type === "frameEvent") {
        const e = s.data.event;
        e.event === "primary_button_clicked" ? nr.emit("primaryButtonClicked") : e.event === "miniapp_added" ? nr.emit("miniAppAdded", {
            notificationDetails: e.notificationDetails
        }) : e.event === "miniapp_add_rejected" ? nr.emit("miniAppAddRejected", {
            reason: e.reason
        }) : e.event === "miniapp_removed" ? nr.emit("miniAppRemoved") : e.event === "notifications_enabled" ? nr.emit("notificationsEnabled", {
            notificationDetails: e.notificationDetails
        }) : e.event === "notifications_disabled" ? nr.emit("notificationsDisabled") : e.event === "back_navigation_triggered" && nr.emit("backNavigationTriggered");
    }
});
function Qx(s) {
    if (("TURBOPACK compile-time value", "undefined") > "u") return;
    const e = (t)=>s(t.detail);
    return window.addEventListener("eip6963:announceProvider", e), window.dispatchEvent(new CustomEvent("eip6963:requestProvider")), ()=>window.removeEventListener("eip6963:announceProvider", e);
}
function eS() {
    const s = /* @__PURE__ */ new Set();
    let e = [];
    const t = ()=>Qx((n1)=>{
            e.some(({ info: i })=>i.uuid === n1.info.uuid) || (e = [
                ...e,
                n1
            ], s.forEach((i)=>i(e, {
                    added: [
                        n1
                    ]
                })));
        });
    let r = t();
    return {
        _listeners () {
            return s;
        },
        clear () {
            s.forEach((n1)=>n1([], {
                    removed: [
                        ...e
                    ]
                })), e = [];
        },
        destroy () {
            this.clear(), s.clear(), r == null || r();
        },
        findProvider ({ rdns: n1 }) {
            return e.find((i)=>i.info.rdns === n1);
        },
        getProviders () {
            return e;
        },
        reset () {
            this.clear(), r == null || r(), r = t();
        },
        subscribe (n1, { emitImmediately: i } = {}) {
            return s.add(n1), i && n1(e, {
                added: e
            }), ()=>s.delete(n1);
        }
    };
}
function tS(s, e = {}, t) {
    if (!t || t === "") {
        console.debug("Amplitude: Skipping event tracking - no userId available yet");
        return;
    }
    const r = {
        event_type: s,
        api_key: "0c4fe46171b9bb8eca2ca61eb71f2e19",
        time: Date.now(),
        user_id: t,
        ...Object.keys(e).length && {
            event_properties: e
        }
    };
    fetch("https://api2.amplitude.com/2/httpapi", {
        method: "POST",
        headers: {
            "Content-Type": "application/json"
        },
        body: JSON.stringify({
            api_key: "0c4fe46171b9bb8eca2ca61eb71f2e19",
            events: [
                r
            ]
        })
    }).then((n1)=>{
        n1.ok || console.debug("Amplitude response error:", n1.status, n1.statusText);
    }).catch((n1)=>{
        console.debug("Amplitude tracking error:", n1);
    });
}
const pg = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createContext"])({
    analyticsEnabled: !1,
    backButtonEnabled: !1,
    returnUrl: void 0
}), mg = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].createContext(void 0);
function rS() {
    const { analyticsEnabled: s, backButtonEnabled: e, returnUrl: t } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useContext"])(pg), [r, n1] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useState"])(!1), [i, o] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useState"])(null), [a, l] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useState"])(!1), [c, u] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useState"])(null), [d1, h] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useState"])(""), [f, p] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useState"])({}), [y, E] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useState"])(""), [b, L] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useState"])([]), [A, F] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useState"])(""), M = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useRef"])(/* @__PURE__ */ new Set()), H = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useRef"])(/* @__PURE__ */ new Map()), K = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useRef"])({}), j = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useRef"])("");
    K.current = f, j.current = y;
    const C = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useCallback"])((m, v = {}, P)=>{
        s && tS(m, v, P);
    }, [
        s
    ]), k = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useCallback"])((m)=>{
        L((v)=>{
            const P = [
                ...v,
                m
            ];
            return C("navigation.setActiveTab", {
                ...K.current,
                toTab: m,
                historyLength: P.length
            }, j.current), P;
        }), F(m);
    }, [
        C
    ]), $ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useCallback"])(async (m)=>{
        const v = typeof m == "string" ? m : m.url;
        await ht.isInMiniApp() ? await ht.actions.openUrl(v) : window.open(v, "_blank");
    }, []), W = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useCallback"])(async ()=>{
        await ht.isInMiniApp() ? await ht.actions.close() : window.close();
    }, []), _ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useCallback"])(()=>{
        L((m)=>{
            if (m.length === 0) return t && $(t), m;
            const v = m.slice(0, -1), P = v.length > 0 ? v[v.length - 1] : "";
            return F(P), C("navigation.navBack", {
                ...K.current,
                fromTab: m[m.length - 1],
                toTab: P,
                historyLength: v.length
            }, j.current), v;
        });
    }, [
        C,
        t,
        $
    ]), g = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useCallback"])((m)=>{
        L([
            m
        ]), F(m), C("navigation.setInitialTab", {
            ...K.current,
            tab: m
        }, j.current);
    }, [
        C
    ]), x = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useCallback"])(async (m)=>(C("haptics.impactOccurred", {
            ...K.current,
            hapticType: m
        }, j.current), ht.haptics.impactOccurred(m)), [
        C
    ]), w = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useCallback"])(async (m)=>(C("haptics.notificationOccurred", {
            ...K.current,
            hapticType: m
        }, j.current), ht.haptics.notificationOccurred(m)), [
        C
    ]), D = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useCallback"])(async ()=>(C("haptics.selectionChanged", {
            ...K.current
        }, j.current), ht.haptics.selectionChanged()), [
        C
    ]), O = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useCallback"])(async (m, v)=>(v && s && C("cast.composed", {
            ...K.current,
            castText: m == null ? void 0 : m.text,
            source: v
        }, j.current), ht.actions.composeCast(m)), [
        s,
        C
    ]), U = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useRef"])(_);
    U.current = _, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        if (r) return;
        let m = !0, v = null;
        const P = async ()=>{
            const N = await ht.context;
            if (!m) return;
            if (o(N), ht.on("miniAppAdded", ({ notificationDetails: ee })=>{
                l(!0), u(ee ?? null), h("Frame added"), C("frame.added", K.current, j.current);
            }), ht.on("miniAppAddRejected", ({ reason: ee })=>{
                l(!1), h(`Frame add rejected: ${ee}`), C("frame.add.rejected", K.current, j.current);
            }), ht.on("miniAppRemoved", ()=>{
                l(!1), h("Frame removed"), C("frame.removed", K.current, j.current);
            }), ht.on("notificationsEnabled", ({ notificationDetails: ee })=>{
                u(ee ?? null), h("Notifications enabled"), C("notifications.enabled", K.current, j.current);
            }), ht.on("notificationsDisabled", ()=>{
                u(null), h("Notifications disabled"), C("notifications.disabled", K.current, j.current);
            }), ht.on("primaryButtonClicked", ()=>{
                h("Primary button clicked"), C("primary-button.clicked", K.current, j.current);
            }), v = eS().subscribe(()=>{}), await ht.actions.ready(), e) try {
                ht.back.onback = ()=>{
                    C("back-button.clicked", K.current, j.current), U.current();
                }, await ht.back.show();
            } catch (ee) {
                console.warn("Back button not supported by this client:", ee);
            }
            m && n1(!0);
        };
        if (ht) return P(), ()=>{
            m = !1, ht.removeAllListeners(), ht.back.onback = null, ht.back.hide(), v && v(), H.current.forEach((N)=>clearTimeout(N)), H.current.clear(), M.current.clear();
        };
    }, [
        // Only include stable references that won't change
        e,
        C
    ]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        i != null && i.user && i != null && i.client && (p({
            username: i.user.username,
            clientFid: i.client.clientFid
        }), E(`${i.user.fid}`), C("frame.opened", {
            username: i.user.username,
            clientFid: i.client.clientFid,
            location: i.location,
            added: i.client.added
        }, `${i.user.fid}`));
    }, [
        i,
        C
    ]);
    const [V, R] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useState"])("");
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        const m = ()=>{
            R(window.location.href);
        };
        m(), window.addEventListener("popstate", m);
        const v = window.history.pushState, P = window.history.replaceState;
        return window.history.pushState = function(...N) {
            v.apply(window.history, N), m();
        }, window.history.replaceState = function(...N) {
            P.apply(window.history, N), m();
        }, ()=>{
            window.removeEventListener("popstate", m), window.history.pushState = v, window.history.replaceState = P;
        };
    }, []), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        var Y, ee;
        if (!((Y = i == null ? void 0 : i.user) != null && Y.fid) || !((ee = i == null ? void 0 : i.client) != null && ee.clientFid) || !V) return;
        const m = new URLSearchParams(window.location.search), v = m.get("utm_source"), P = m.get("utm_medium"), N = m.get("utm_campaign");
        if (v === "neynar" && P != null && P.startsWith("share-cast-")) {
            const ie = P.replace("share-cast-", "");
            C("cast.shared", {
                username: i.user.username,
                clientFid: i.client.clientFid,
                sharedByFid: ie
            }, `${i.user.fid}`);
        }
        if (v === "neynar" && N) {
            const ie = `${N}_${i.user.fid}_${Date.now()}`;
            if (M.current.has(ie)) return;
            const Te = H.current.get(ie);
            Te && clearTimeout(Te), M.current.add(ie);
            const De = setTimeout(async ()=>{
                try {
                    const ze = await fetch("https://api.neynar.com/v2/farcaster/frame/notifications/open", {
                        method: "POST",
                        headers: {
                            "content-type": "application/json"
                        },
                        body: JSON.stringify({
                            campaign_id: N,
                            fid: i.user.fid,
                            app_fid: i.client.clientFid
                        })
                    });
                    ze.ok || console.error("Failed to mark notification as opened: ", await ze.text());
                } catch (ze) {
                    console.error("Error marking notification as opened: ", ze);
                } finally{
                    M.current.delete(ie), H.current.delete(ie);
                }
            }, 1e3);
            H.current.set(ie, De);
        }
    }, [
        i,
        C,
        V
    ]), {
        ...ht,
        isSDKLoaded: r,
        context: i,
        added: a,
        notificationDetails: c,
        lastEvent: d1,
        currentTab: A,
        setActiveTab: k,
        setInitialTab: g,
        haptics: {
            impactOccurred: x,
            notificationOccurred: w,
            selectionChanged: D
        },
        actions: {
            ...ht.actions,
            openUrl: $,
            close: W,
            composeCast: O
        }
    };
}
function sS({ children: s }) {
    const e = rS();
    return e.isSDKLoaded ? /* @__PURE__ */ q.jsx(mg.Provider, {
        value: e,
        children: s
    }) : null;
}
function uL({ children: s, analyticsEnabled: e = !1, backButtonEnabled: t = !1, returnUrl: r }) {
    const n1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useMemo"])(()=>({
            analyticsEnabled: e,
            backButtonEnabled: t,
            returnUrl: r
        }), [
        e,
        t,
        r
    ]);
    return /* @__PURE__ */ q.jsx(pg.Provider, {
        value: n1,
        children: /* @__PURE__ */ q.jsx(sS, {
            children: s
        })
    });
}
function dL() {
    const s = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useContext"])(mg);
    if (s === void 0) throw new Error("useMiniApp must be used within a MiniAppProvider");
    return s;
}
var yg = /* @__PURE__ */ ((s)=>(s.Light = "light", s.Dark = "dark", s))(yg || {}), gs = /* @__PURE__ */ ((s)=>(s.FARCASTER = "farcaster", s.NEYNAR = "neynar", s.WARPCAST = "warpcast", s))(gs || {});
function du(s, e = "", { serialize: t = JSON.stringify, deserialize: r = JSON.parse } = {}) {
    const [n1, i] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useState"])(()=>{
        if (("TURBOPACK compile-time value", "undefined") > "u") return e;
        try {
            const l = window.localStorage.getItem(s);
            return l ? r(l) : e;
        } catch (l) {
            return console.error("Error reading from localStorage", l), e;
        }
    });
    return [
        n1,
        (l)=>{
            try {
                const c = l instanceof Function ? l(n1) : l;
                i(c), ("TURBOPACK compile-time value", "undefined") < "u" && window.localStorage.setItem(s, t(c));
            } catch (c) {
                console.error("Error writing to localStorage", c);
            }
        },
        ()=>{
            try {
                window.localStorage.removeItem(s), i(e);
            } catch (l) {
                console.error("Error removing from localStorage", l);
            }
        }
    ];
}
var Gn = /* @__PURE__ */ ((s)=>(s.NEYNAR_AUTHENTICATED_USER = "neynar_authenticated_user", s))(Gn || {});
const vg = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createContext"])(void 0), nS = ({ children: s, _setIsAuthenticated: e, _setUser: t, _onAuthSuccess: r, _onSignout: n1 })=>{
    const { isAuthenticated: i } = ts(), [o, a] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useState"])(!1), [l, c] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useState"])(null), [u] = du(Gn.NEYNAR_AUTHENTICATED_USER);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        e(o);
    }, [
        o
    ]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        a(i);
    }, [
        i
    ]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        u ? (c(u), a(!0)) : (c(null), a(!1));
    }, []), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        t(l);
    }, [
        l
    ]);
    const d1 = (p)=>{
        r && r(p);
    }, h = (p)=>{
        n1 && n1(p);
    }, f = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useMemo"])(()=>({
            isAuthenticated: o,
            user: l,
            setIsAuthenticated: a,
            setUser: c,
            onAuthSuccess: d1,
            onSignout: h
        }), [
        o,
        l
    ]);
    return /* @__PURE__ */ q.jsx(vg.Provider, {
        value: f,
        children: s
    });
}, Eg = ()=>{
    const s = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useContext"])(vg);
    if (!s) throw new Error("useAuth must be used within a AuthContextProvider");
    return s;
}, iS = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("div")({
    classes: [
        "tbaom7c"
    ]
}), oS = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("div")({
    classes: [
        "t1ff44zi"
    ],
    variants: [
        {
            props: {
                type: "success"
            },
            className: "t1ff44zi-1"
        },
        {
            props: {
                type: "error"
            },
            className: "t1ff44zi-2"
        },
        {
            props: {
                type: "warning"
            },
            className: "t1ff44zi-3"
        },
        {
            props: {
                type: "info"
            },
            className: "t1ff44zi-4"
        }
    ]
});
var xg = /* @__PURE__ */ ((s)=>(s.Success = "success", s.Error = "error", s.Warning = "warning", s.Info = "info", s))(xg || {});
const Sg = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createContext"])(void 0), hL = ({ children: s, settings: { clientId: e, defaultTheme: t = yg.Light, eventsCallbacks: r } })=>{
    const [n1] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useState"])(e), [i, o] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useState"])(!1), [a, l] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useState"])(t), [c, u] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useState"])([]), [d1, h] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useState"])(null), f = (A, F)=>{
        const M = {
            type: A,
            message: F
        };
        u((H)=>[
                ...H,
                M
            ]), setTimeout(()=>p(M), 5e3);
    }, p = (A)=>{
        u((F)=>F.filter((M)=>M !== A));
    };
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        const A = document.querySelector(":root");
        A && (a === "light" ? (A.classList.add("theme-light"), A.classList.remove("theme-dark")) : a === "dark" && (A.classList.add("theme-dark"), A.classList.remove("theme-light")));
    }, [
        a
    ]);
    const y = (A)=>{
        o(A);
    }, E = (A)=>{
        h(A);
    }, b = ()=>{
        if (d1) {
            const { signer_uuid: A, ...F } = d1;
            h(null), o(!1), localStorage.removeItem(Gn.NEYNAR_AUTHENTICATED_USER), r != null && r.onSignout && r.onSignout(F);
        }
    }, L = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useMemo"])(()=>({
            client_id: n1,
            theme: a,
            isAuthenticated: i,
            user: d1,
            setTheme: l,
            showToast: f,
            logoutUser: b
        }), [
        n1,
        a,
        i,
        d1,
        l,
        f,
        b
    ]);
    return /* @__PURE__ */ q.jsx(Sg.Provider, {
        value: L,
        children: /* @__PURE__ */ q.jsxs(nS, {
            _setIsAuthenticated: y,
            _setUser: E,
            _onAuthSuccess: r == null ? void 0 : r.onAuthSuccess,
            _onSignout: r == null ? void 0 : r.onSignout,
            children: [
                s,
                /* @__PURE__ */ q.jsx(iS, {
                    children: c.map((A, F)=>/* @__PURE__ */ q.jsx(oS, {
                            type: A.type,
                            children: A.message
                        }, F))
                })
            ]
        })
    });
}, ts = ()=>{
    const s = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useContext"])(Sg);
    if (!s) throw new Error("useNeynarContext must be used within a NeynarContextProvider");
    return s;
}, aS = ()=>/* @__PURE__ */ q.jsxs("svg", {
        width: "18",
        height: "17",
        viewBox: "0 0 18 17",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
            /* @__PURE__ */ q.jsx("path", {
                d: "M13.7222 0H4.27778C2.19137 0 0.5 1.69137 0.5 3.77778V13.2222C0.5 15.3086 2.19137 17 4.27778 17H13.7222C15.8086 17 17.5 15.3086 17.5 13.2222V3.77778C17.5 1.69137 15.8086 0 13.7222 0Z",
                fill: "#855DCD"
            }),
            /* @__PURE__ */ q.jsx("path", {
                d: "M4.88281 2.64453H13.1184V14.3556H11.9095V8.9912H11.8976C11.764 7.50859 10.518 6.34675 9.00059 6.34675C7.4832 6.34675 6.23717 7.50859 6.10356 8.9912H6.0917V14.3556H4.88281V2.64453Z",
                fill: "white"
            }),
            /* @__PURE__ */ q.jsx("path", {
                d: "M2.69141 4.30664L3.18252 5.96886H3.59807V12.6933C3.38943 12.6933 3.2203 12.8625 3.2203 13.0711V13.5244H3.14474C2.9361 13.5244 2.76696 13.6936 2.76696 13.9022V14.3555H6.99807V13.9022C6.99807 13.6936 6.82893 13.5244 6.6203 13.5244H6.54474V13.0711C6.54474 12.8625 6.3756 12.6933 6.16696 12.6933H5.71363V4.30664H2.69141Z",
                fill: "white"
            }),
            /* @__PURE__ */ q.jsx("path", {
                d: "M11.9854 12.6933C11.7768 12.6933 11.6076 12.8625 11.6076 13.0711V13.5244H11.5321C11.3235 13.5244 11.1543 13.6936 11.1543 13.9022V14.3555H15.3854V13.9022C15.3854 13.6936 15.2162 13.5244 15.0076 13.5244H14.9321V13.0711C14.9321 12.8625 14.7629 12.6933 14.5543 12.6933V5.96886H14.9699L15.461 4.30664H12.4387V12.6933H11.9854Z",
                fill: "white"
            })
        ]
    }), zd = ()=>/* @__PURE__ */ q.jsxs("svg", {
        width: "32",
        height: "17",
        viewBox: "0 0 50 28",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
            /* @__PURE__ */ q.jsx("path", {
                fillRule: "evenodd",
                clipRule: "evenodd",
                d: "M38.3744 13.7311C38.3744 16.1209 37.7639 18.368 36.6904 20.3252C32.5685 19.8525 27.847 18.9503 22.8999 17.6247C20.4058 16.9564 18.0151 16.2236 15.7697 15.4495L15.7693 15.4486C15.7579 15.445 15.7465 15.4413 15.7351 15.4376C15.6448 15.4064 15.5547 15.3752 15.4649 15.3439C12.8978 14.399 11.2356 12.2056 11.4168 10.0315L11.4482 10.0399L11.4215 10.0133C13.0427 4.23612 18.3483 0 24.6434 0C32.2268 0 38.3744 6.14762 38.3744 13.7311Z",
                fill: "black"
            }),
            /* @__PURE__ */ q.jsx("path", {
                fillRule: "evenodd",
                clipRule: "evenodd",
                d: "M11.3804 17.2987C12.4882 16.5313 13.9658 16.1804 15.5002 16.3953C17.7731 17.156 20.1682 17.8782 22.6535 18.5441C27.397 19.8151 31.9584 20.7444 36.0833 21.3275C33.623 25.0252 29.4177 27.4619 24.6434 27.4619C18.294 27.4619 12.9511 23.1524 11.3804 17.2987Z",
                fill: "black"
            }),
            /* @__PURE__ */ q.jsx("path", {
                fillRule: "evenodd",
                clipRule: "evenodd",
                d: "M43.0917 13.4458C41.6461 12.6648 39.9756 11.8759 38.1233 11.1029C38.0363 10.6544 37.9275 10.2136 37.7981 9.78174C39.9806 10.6648 41.9403 11.5752 43.6139 12.4794C45.7007 13.6069 47.3703 14.7394 48.4714 15.816C49.5356 16.8566 50.2295 18.0063 49.93 19.1241C49.6304 20.2419 48.4547 20.8906 47.0128 21.2597C45.5209 21.6415 43.5087 21.7875 41.1377 21.7206C39.6046 21.6773 37.9082 21.5444 36.0864 21.3234C36.3086 20.9891 36.5165 20.6446 36.7094 20.2906C38.3134 20.4733 39.8091 20.5841 41.1687 20.6225C43.4946 20.6882 45.3908 20.5409 46.7404 20.1955C48.14 19.8373 48.7389 19.3249 48.8689 18.8398C48.9989 18.3547 48.7364 17.6115 47.7034 16.6015C46.7073 15.6275 45.1388 14.5519 43.0917 13.4458ZM8.86229 3.16772C10.7583 3.22128 12.9038 3.41177 15.2278 3.73661C14.8974 4.04803 14.5824 4.37566 14.2841 4.71822C12.3016 4.46314 10.4678 4.312 8.83127 4.26577C6.50541 4.20006 4.6092 4.34737 3.25958 4.69279C1.86001 5.05099 1.26107 5.56342 1.13109 6.04849C1.00112 6.53356 1.2636 7.27681 2.29657 8.2868C3.29267 9.26075 4.86118 10.3364 6.90828 11.4425C6.94181 11.4606 6.97546 11.4787 7.00923 11.4968C6.84251 11.5938 6.72574 11.7161 6.66353 11.8645C6.57791 12.0688 6.60013 12.3121 6.72013 12.5874C6.60757 12.5279 6.49623 12.4684 6.38612 12.4089C4.29926 11.2814 2.62971 10.1489 1.5286 9.07223C0.464367 8.03166 -0.229485 6.882 0.0700354 5.76418C0.369556 4.64635 1.54528 3.99764 2.98722 3.6286C4.47911 3.24677 6.49126 3.10074 8.86229 3.16772Z",
                fill: "black"
            }),
            /* @__PURE__ */ q.jsx("ellipse", {
                cx: "5.94866",
                cy: "11.5309",
                rx: "3.76009",
                ry: "0.575832",
                transform: "rotate(29.2824 5.94866 11.5309)",
                fill: "black"
            })
        ]
    }), lS = ()=>/* @__PURE__ */ q.jsxs("svg", {
        width: "17",
        height: "17",
        viewBox: "0 0 17 17",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
            /* @__PURE__ */ q.jsx("mask", {
                id: "mask0_875_48",
                maskUnits: "userSpaceOnUse",
                x: "0",
                y: "0",
                width: "17",
                height: "17",
                children: /* @__PURE__ */ q.jsx("path", {
                    d: "M16.9947 0H0V16.9947H16.9947V0Z",
                    fill: "white"
                })
            }),
            /* @__PURE__ */ q.jsxs("g", {
                mask: "url(#mask0_875_48)",
                children: [
                    /* @__PURE__ */ q.jsx("path", {
                        d: "M12.7871 16.9947H4.20765C1.88755 16.9947 0 15.1073 0 12.7871V4.20771C0 1.88756 1.88755 0 4.20765 0H12.7871C15.1072 0 16.9947 1.88756 16.9947 4.20771V12.7871C16.9947 15.1073 15.1072 16.9947 12.7871 16.9947Z",
                        fill: "#472A91"
                    }),
                    /* @__PURE__ */ q.jsx("path", {
                        d: "M11.1523 5.37891L10.3143 8.52601L9.47364 5.37891H7.53893L6.69017 8.54919L5.84419 5.37891H3.64062L5.68823 12.3371H7.58931L8.49835 9.10599L9.40736 12.3371H11.3125L13.3557 5.37891H11.1523Z",
                        fill: "white"
                    })
                ]
            })
        ]
    });
var cS = {};
const ic = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("img")({
    classes: [
        "ippfsqr"
    ]
}), uS = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("button")({
    classes: [
        "b1yzssjb"
    ]
}), dS = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("div")({
    classes: [
        "m1xn8b2e"
    ]
}), hS = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("button")({
    classes: [
        "mwuiqyg"
    ]
}), fS = (s, e)=>{
    if (e) return e;
    switch(s){
        case gs.FARCASTER:
            return "Sign in with Farcaster";
        case gs.NEYNAR:
            return "Sign in with Neynar";
        case gs.WARPCAST:
            return "Sign in with Warpcast";
        default:
            return "Sign in with Neynar";
    }
}, gS = (s, e, t)=>{
    if (e) return e;
    if (t) return /* @__PURE__ */ q.jsx(ic, {
        src: t,
        alt: "Custom logo"
    });
    switch(s){
        case gs.FARCASTER:
            return /* @__PURE__ */ q.jsx(aS, {});
        case gs.NEYNAR:
            return /* @__PURE__ */ q.jsx(zd, {});
        case gs.WARPCAST:
            return /* @__PURE__ */ q.jsx(lS, {});
        default:
            return /* @__PURE__ */ q.jsx(zd, {});
    }
}, pS = ({ children: s, label: e, variant: t = gs.NEYNAR, icon: r, customLogoUrl: n1, modalStyle: i = {}, modalButtonStyle: o = {}, ...a })=>{
    const { client_id: l, user: c, isAuthenticated: u } = ts(), { setIsAuthenticated: d1, setUser: h, onAuthSuccess: f, onSignout: p } = Eg(), [y, E, b] = du(Gn.NEYNAR_AUTHENTICATED_USER), [L, A] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useState"])(!1), F = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useRef"])(null), M = `${cS.NEYNAR_LOGIN_URL ?? "https://app.neynar.com/login"}?client_id=${l}`, H = new URL(M).origin, K = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useRef"])(null), j = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useCallback"])(async (g)=>{
        var x;
        if (g.origin === H && g.data && g.data.is_authenticated) {
            d1(!0), (x = F.current) == null || x.close(), window.removeEventListener("message", j);
            const w = {
                signer_uuid: g.data.signer_uuid,
                ...g.data.user
            };
            E(w), h(w), f({
                user: w
            });
        }
    }, [
        l,
        d1
    ]), C = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useCallback"])(()=>{
        const w = window.screen.width / 2 - 300, O = `width=600,height=700,top=${window.screen.height / 2 - 700 / 2},left=${w}`;
        if (F.current = window.open(M, "_blank", O), !F.current) {
            console.error("Failed to open the authentication window. Please check your pop-up blocker settings.");
            return;
        }
        window.addEventListener("message", j, !1);
    }, [
        l,
        j
    ]), k = ()=>{
        if (c) {
            const g = c;
            b(), d1(!1), W();
            const { signer_uuid: x, ...w } = g;
            p(w);
        }
    }, $ = ()=>A(!0), W = ()=>A(!1);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useEffect"])(()=>()=>{
            window.removeEventListener("message", j);
        }, [
        j
    ]);
    const _ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useCallback"])((g)=>{
        K.current && !K.current.contains(g.target) && W();
    }, []);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useEffect"])(()=>(L ? document.addEventListener("mousedown", _) : document.removeEventListener("mousedown", _), ()=>{
            document.removeEventListener("mousedown", _);
        }), [
        L,
        _
    ]), /* @__PURE__ */ q.jsxs(q.Fragment, {
        children: [
            L && /* @__PURE__ */ q.jsxs(dS, {
                style: i,
                ref: K,
                children: [
                    /* @__PURE__ */ q.jsx(ic, {
                        src: c == null ? void 0 : c.pfp_url,
                        alt: c == null ? void 0 : c.username
                    }),
                    /* @__PURE__ */ q.jsxs("span", {
                        children: [
                            "@",
                            c == null ? void 0 : c.username
                        ]
                    }),
                    /* @__PURE__ */ q.jsx(hS, {
                        style: o,
                        onClick: k,
                        children: "Sign out"
                    })
                ]
            }),
            /* @__PURE__ */ q.jsx(uS, {
                onClick: u ? $ : C,
                ...a,
                children: u ? /* @__PURE__ */ q.jsxs(q.Fragment, {
                    children: [
                        /* @__PURE__ */ q.jsx(ic, {
                            src: c == null ? void 0 : c.pfp_url,
                            alt: `${c == null ? void 0 : c.username} profile picture`
                        }),
                        /* @__PURE__ */ q.jsxs("span", {
                            style: {
                                marginLeft: "10px"
                            },
                            children: [
                                "@",
                                c == null ? void 0 : c.username
                            ]
                        })
                    ]
                }) : /* @__PURE__ */ q.jsxs(q.Fragment, {
                    children: [
                        gS(t, r, n1),
                        /* @__PURE__ */ q.jsx("span", {
                            style: {
                                marginLeft: "5px"
                            },
                            children: fS(t, e)
                        })
                    ]
                })
            })
        ]
    });
}, Yo = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("img")({
    classes: [
        "a11pt0xp"
    ],
    vars: {
        "a11pt0xp-0": [
            (s, e = Gr)=>s.width || "45px",
            !1
        ],
        "a11pt0xp-1": [
            (s, e = Gr)=>s.width || "45px",
            !1
        ]
    }
}), Yd = "https://farcaster.xyz", bg = /(^|\s)\/\w+/g, Tg = /@\w+(\.eth)?/g, wg = /((https?:\/\/)?([a-zA-Z0-9.-]+\.[a-zA-Z]{2,})(\/[^\s]*)?)/g, Zd = new RegExp(`(${bg.source})|(${Tg.source})|(${wg.source})`, "g"), mS = (s)=>bg.test(s) ? `${Yd}/~/channel${s.trim()}` : Tg.test(s) ? `${Yd}/${s.substring(1)}` : wg.test(s) ? s.startsWith("http") ? s : `http://${s}` : "", yS = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("a")({
    classes: [
        "s4xymqs"
    ]
}), vS = (s)=>s.filter((e)=>e.url).map((e)=>e.url), ES = (s, e)=>{
    if (!s) return [];
    const t = vS(e), r = [];
    let n1 = 0, i;
    for(; (i = Zd.exec(s)) !== null;){
        const o = i.index;
        n1 < o && r.push(s.slice(n1, o));
        const a = i[0].trim();
        if (t.includes(a)) r.push(a);
        else {
            const l = mS(a);
            r.push(/* @__PURE__ */ q.jsx(yS, {
                href: l,
                target: "_blank",
                children: a
            }, o));
        }
        n1 = Zd.lastIndex;
    }
    return n1 < s.length && r.push(s.slice(n1)), r;
}, Ir = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("div")({
    classes: [
        "be87m0m"
    ],
    vars: {
        "be87m0m-0": [
            (s, e = Gr)=>s.alignItems || "flex-start",
            !1
        ],
        "be87m0m-1": [
            (s, e = Gr)=>s.justifyContent || "flex-start",
            !1
        ],
        "be87m0m-2": [
            (s, e = Gr)=>s.flexGrow || "initial",
            !0
        ],
        "be87m0m-3": [
            (s, e = Gr)=>s.flexShrink || "initial",
            !0
        ],
        "be87m0m-4": [
            (s, e = Gr)=>s.spacing ?? s.spacingVertical ?? s.spacingTop ?? "0px",
            !1
        ],
        "be87m0m-5": [
            (s, e = Gr)=>s.spacing ?? s.spacingHorizontal ?? s.spacingRight ?? "0px",
            !1
        ],
        "be87m0m-6": [
            (s, e = Gr)=>s.spacing ?? s.spacingVertical ?? s.spacingBottom ?? "0px",
            !1
        ],
        "be87m0m-7": [
            (s, e = Gr)=>s.spacing ?? s.spacingHorizontal ?? s.spacingLeft ?? "0px",
            !1
        ]
    }
}), xS = ()=>Ir, Pr = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])(xS())({
    classes: [
        "ha1dvpi"
    ]
}), ue = Number.isFinite || function(s) {
    return typeof s == "number" && isFinite(s);
}, SS = Number.isSafeInteger || function(s) {
    return typeof s == "number" && Math.abs(s) <= bS;
}, bS = Number.MAX_SAFE_INTEGER || 9007199254740991;
let ve = /* @__PURE__ */ function(s) {
    return s.NETWORK_ERROR = "networkError", s.MEDIA_ERROR = "mediaError", s.KEY_SYSTEM_ERROR = "keySystemError", s.MUX_ERROR = "muxError", s.OTHER_ERROR = "otherError", s;
}({}), J = /* @__PURE__ */ function(s) {
    return s.KEY_SYSTEM_NO_KEYS = "keySystemNoKeys", s.KEY_SYSTEM_NO_ACCESS = "keySystemNoAccess", s.KEY_SYSTEM_NO_SESSION = "keySystemNoSession", s.KEY_SYSTEM_NO_CONFIGURED_LICENSE = "keySystemNoConfiguredLicense", s.KEY_SYSTEM_LICENSE_REQUEST_FAILED = "keySystemLicenseRequestFailed", s.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED = "keySystemServerCertificateRequestFailed", s.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED = "keySystemServerCertificateUpdateFailed", s.KEY_SYSTEM_SESSION_UPDATE_FAILED = "keySystemSessionUpdateFailed", s.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED = "keySystemStatusOutputRestricted", s.KEY_SYSTEM_STATUS_INTERNAL_ERROR = "keySystemStatusInternalError", s.KEY_SYSTEM_DESTROY_MEDIA_KEYS_ERROR = "keySystemDestroyMediaKeysError", s.KEY_SYSTEM_DESTROY_CLOSE_SESSION_ERROR = "keySystemDestroyCloseSessionError", s.KEY_SYSTEM_DESTROY_REMOVE_SESSION_ERROR = "keySystemDestroyRemoveSessionError", s.MANIFEST_LOAD_ERROR = "manifestLoadError", s.MANIFEST_LOAD_TIMEOUT = "manifestLoadTimeOut", s.MANIFEST_PARSING_ERROR = "manifestParsingError", s.MANIFEST_INCOMPATIBLE_CODECS_ERROR = "manifestIncompatibleCodecsError", s.LEVEL_EMPTY_ERROR = "levelEmptyError", s.LEVEL_LOAD_ERROR = "levelLoadError", s.LEVEL_LOAD_TIMEOUT = "levelLoadTimeOut", s.LEVEL_PARSING_ERROR = "levelParsingError", s.LEVEL_SWITCH_ERROR = "levelSwitchError", s.AUDIO_TRACK_LOAD_ERROR = "audioTrackLoadError", s.AUDIO_TRACK_LOAD_TIMEOUT = "audioTrackLoadTimeOut", s.SUBTITLE_LOAD_ERROR = "subtitleTrackLoadError", s.SUBTITLE_TRACK_LOAD_TIMEOUT = "subtitleTrackLoadTimeOut", s.FRAG_LOAD_ERROR = "fragLoadError", s.FRAG_LOAD_TIMEOUT = "fragLoadTimeOut", s.FRAG_DECRYPT_ERROR = "fragDecryptError", s.FRAG_PARSING_ERROR = "fragParsingError", s.FRAG_GAP = "fragGap", s.REMUX_ALLOC_ERROR = "remuxAllocError", s.KEY_LOAD_ERROR = "keyLoadError", s.KEY_LOAD_TIMEOUT = "keyLoadTimeOut", s.BUFFER_ADD_CODEC_ERROR = "bufferAddCodecError", s.BUFFER_INCOMPATIBLE_CODECS_ERROR = "bufferIncompatibleCodecsError", s.BUFFER_APPEND_ERROR = "bufferAppendError", s.BUFFER_APPENDING_ERROR = "bufferAppendingError", s.BUFFER_STALLED_ERROR = "bufferStalledError", s.BUFFER_FULL_ERROR = "bufferFullError", s.BUFFER_SEEK_OVER_HOLE = "bufferSeekOverHole", s.BUFFER_NUDGE_ON_STALL = "bufferNudgeOnStall", s.ASSET_LIST_LOAD_ERROR = "assetListLoadError", s.ASSET_LIST_LOAD_TIMEOUT = "assetListLoadTimeout", s.ASSET_LIST_PARSING_ERROR = "assetListParsingError", s.INTERSTITIAL_ASSET_ITEM_ERROR = "interstitialAssetItemError", s.INTERNAL_EXCEPTION = "internalException", s.INTERNAL_ABORTED = "aborted", s.ATTACH_MEDIA_ERROR = "attachMediaError", s.UNKNOWN = "unknown", s;
}({}), I = /* @__PURE__ */ function(s) {
    return s.MEDIA_ATTACHING = "hlsMediaAttaching", s.MEDIA_ATTACHED = "hlsMediaAttached", s.MEDIA_DETACHING = "hlsMediaDetaching", s.MEDIA_DETACHED = "hlsMediaDetached", s.MEDIA_ENDED = "hlsMediaEnded", s.STALL_RESOLVED = "hlsStallResolved", s.BUFFER_RESET = "hlsBufferReset", s.BUFFER_CODECS = "hlsBufferCodecs", s.BUFFER_CREATED = "hlsBufferCreated", s.BUFFER_APPENDING = "hlsBufferAppending", s.BUFFER_APPENDED = "hlsBufferAppended", s.BUFFER_EOS = "hlsBufferEos", s.BUFFERED_TO_END = "hlsBufferedToEnd", s.BUFFER_FLUSHING = "hlsBufferFlushing", s.BUFFER_FLUSHED = "hlsBufferFlushed", s.MANIFEST_LOADING = "hlsManifestLoading", s.MANIFEST_LOADED = "hlsManifestLoaded", s.MANIFEST_PARSED = "hlsManifestParsed", s.LEVEL_SWITCHING = "hlsLevelSwitching", s.LEVEL_SWITCHED = "hlsLevelSwitched", s.LEVEL_LOADING = "hlsLevelLoading", s.LEVEL_LOADED = "hlsLevelLoaded", s.LEVEL_UPDATED = "hlsLevelUpdated", s.LEVEL_PTS_UPDATED = "hlsLevelPtsUpdated", s.LEVELS_UPDATED = "hlsLevelsUpdated", s.AUDIO_TRACKS_UPDATED = "hlsAudioTracksUpdated", s.AUDIO_TRACK_SWITCHING = "hlsAudioTrackSwitching", s.AUDIO_TRACK_SWITCHED = "hlsAudioTrackSwitched", s.AUDIO_TRACK_LOADING = "hlsAudioTrackLoading", s.AUDIO_TRACK_LOADED = "hlsAudioTrackLoaded", s.AUDIO_TRACK_UPDATED = "hlsAudioTrackUpdated", s.SUBTITLE_TRACKS_UPDATED = "hlsSubtitleTracksUpdated", s.SUBTITLE_TRACKS_CLEARED = "hlsSubtitleTracksCleared", s.SUBTITLE_TRACK_SWITCH = "hlsSubtitleTrackSwitch", s.SUBTITLE_TRACK_LOADING = "hlsSubtitleTrackLoading", s.SUBTITLE_TRACK_LOADED = "hlsSubtitleTrackLoaded", s.SUBTITLE_TRACK_UPDATED = "hlsSubtitleTrackUpdated", s.SUBTITLE_FRAG_PROCESSED = "hlsSubtitleFragProcessed", s.CUES_PARSED = "hlsCuesParsed", s.NON_NATIVE_TEXT_TRACKS_FOUND = "hlsNonNativeTextTracksFound", s.INIT_PTS_FOUND = "hlsInitPtsFound", s.FRAG_LOADING = "hlsFragLoading", s.FRAG_LOAD_EMERGENCY_ABORTED = "hlsFragLoadEmergencyAborted", s.FRAG_LOADED = "hlsFragLoaded", s.FRAG_DECRYPTED = "hlsFragDecrypted", s.FRAG_PARSING_INIT_SEGMENT = "hlsFragParsingInitSegment", s.FRAG_PARSING_USERDATA = "hlsFragParsingUserdata", s.FRAG_PARSING_METADATA = "hlsFragParsingMetadata", s.FRAG_PARSED = "hlsFragParsed", s.FRAG_BUFFERED = "hlsFragBuffered", s.FRAG_CHANGED = "hlsFragChanged", s.FPS_DROP = "hlsFpsDrop", s.FPS_DROP_LEVEL_CAPPING = "hlsFpsDropLevelCapping", s.MAX_AUTO_LEVEL_UPDATED = "hlsMaxAutoLevelUpdated", s.ERROR = "hlsError", s.DESTROYING = "hlsDestroying", s.KEY_LOADING = "hlsKeyLoading", s.KEY_LOADED = "hlsKeyLoaded", s.LIVE_BACK_BUFFER_REACHED = "hlsLiveBackBufferReached", s.BACK_BUFFER_REACHED = "hlsBackBufferReached", s.STEERING_MANIFEST_LOADED = "hlsSteeringManifestLoaded", s.ASSET_LIST_LOADING = "hlsAssetListLoading", s.ASSET_LIST_LOADED = "hlsAssetListLoaded", s.INTERSTITIALS_UPDATED = "hlsInterstitialsUpdated", s.INTERSTITIALS_BUFFERED_TO_BOUNDARY = "hlsInterstitialsBufferedToBoundary", s.INTERSTITIAL_ASSET_PLAYER_CREATED = "hlsInterstitialAssetPlayerCreated", s.INTERSTITIAL_STARTED = "hlsInterstitialStarted", s.INTERSTITIAL_ASSET_STARTED = "hlsInterstitialAssetStarted", s.INTERSTITIAL_ASSET_ENDED = "hlsInterstitialAssetEnded", s.INTERSTITIAL_ASSET_ERROR = "hlsInterstitialAssetError", s.INTERSTITIAL_ENDED = "hlsInterstitialEnded", s.INTERSTITIALS_PRIMARY_RESUMED = "hlsInterstitialsPrimaryResumed", s.PLAYOUT_LIMIT_REACHED = "hlsPlayoutLimitReached", s.EVENT_CUE_ENTER = "hlsEventCueEnter", s;
}({});
var Ke = {
    MANIFEST: "manifest",
    LEVEL: "level",
    AUDIO_TRACK: "audioTrack",
    SUBTITLE_TRACK: "subtitleTrack"
}, pe = {
    MAIN: "main",
    AUDIO: "audio",
    SUBTITLE: "subtitle"
};
class un {
    //  About half of the estimated value will be from the last |halfLife| samples by weight.
    constructor(e, t = 0, r = 0){
        this.halfLife = void 0, this.alpha_ = void 0, this.estimate_ = void 0, this.totalWeight_ = void 0, this.halfLife = e, this.alpha_ = e ? Math.exp(Math.log(0.5) / e) : 0, this.estimate_ = t, this.totalWeight_ = r;
    }
    sample(e, t) {
        const r = Math.pow(this.alpha_, e);
        this.estimate_ = t * (1 - r) + r * this.estimate_, this.totalWeight_ += e;
    }
    getTotalWeight() {
        return this.totalWeight_;
    }
    getEstimate() {
        if (this.alpha_) {
            const e = 1 - Math.pow(this.alpha_, this.totalWeight_);
            if (e) return this.estimate_ / e;
        }
        return this.estimate_;
    }
}
class TS {
    constructor(e, t, r, n1 = 100){
        this.defaultEstimate_ = void 0, this.minWeight_ = void 0, this.minDelayMs_ = void 0, this.slow_ = void 0, this.fast_ = void 0, this.defaultTTFB_ = void 0, this.ttfb_ = void 0, this.defaultEstimate_ = r, this.minWeight_ = 1e-3, this.minDelayMs_ = 50, this.slow_ = new un(e), this.fast_ = new un(t), this.defaultTTFB_ = n1, this.ttfb_ = new un(e);
    }
    update(e, t) {
        const { slow_: r, fast_: n1, ttfb_: i } = this;
        r.halfLife !== e && (this.slow_ = new un(e, r.getEstimate(), r.getTotalWeight())), n1.halfLife !== t && (this.fast_ = new un(t, n1.getEstimate(), n1.getTotalWeight())), i.halfLife !== e && (this.ttfb_ = new un(e, i.getEstimate(), i.getTotalWeight()));
    }
    sample(e, t) {
        e = Math.max(e, this.minDelayMs_);
        const r = 8 * t, n1 = e / 1e3, i = r / n1;
        this.fast_.sample(n1, i), this.slow_.sample(n1, i);
    }
    sampleTTFB(e) {
        const t = e / 1e3, r = Math.sqrt(2) * Math.exp(-Math.pow(t, 2) / 2);
        this.ttfb_.sample(r, Math.max(e, 5));
    }
    canEstimate() {
        return this.fast_.getTotalWeight() >= this.minWeight_;
    }
    getEstimate() {
        return this.canEstimate() ? Math.min(this.fast_.getEstimate(), this.slow_.getEstimate()) : this.defaultEstimate_;
    }
    getEstimateTTFB() {
        return this.ttfb_.getTotalWeight() >= this.minWeight_ ? this.ttfb_.getEstimate() : this.defaultTTFB_;
    }
    get defaultEstimate() {
        return this.defaultEstimate_;
    }
    destroy() {}
}
function wS(s, e, t) {
    return (e = IS(e)) in s ? Object.defineProperty(s, e, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : s[e] = t, s;
}
function nt() {
    return nt = ("TURBOPACK compile-time truthy", 1) ? Object.assign.bind() : "TURBOPACK unreachable", nt.apply(null, arguments);
}
function Xd(s, e) {
    var t = Object.keys(s);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(s);
        e && (r = r.filter(function(n1) {
            return Object.getOwnPropertyDescriptor(s, n1).enumerable;
        })), t.push.apply(t, r);
    }
    return t;
}
function tt(s) {
    for(var e = 1; e < arguments.length; e++){
        var t = arguments[e] != null ? arguments[e] : {};
        e % 2 ? Xd(Object(t), !0).forEach(function(r) {
            wS(s, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(s, Object.getOwnPropertyDescriptors(t)) : Xd(Object(t)).forEach(function(r) {
            Object.defineProperty(s, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return s;
}
function AS(s, e) {
    if (typeof s != "object" || !s) return s;
    var t = s[Symbol.toPrimitive];
    if (t !== void 0) {
        var r = t.call(s, e);
        if (typeof r != "object") return r;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (e === "string" ? String : Number)(s);
}
function IS(s) {
    var e = AS(s, "string");
    return typeof e == "symbol" ? e : e + "";
}
class Rr {
    constructor(e, t){
        this.trace = void 0, this.debug = void 0, this.log = void 0, this.warn = void 0, this.info = void 0, this.error = void 0;
        const r = `[${e}]:`;
        this.trace = As, this.debug = t.debug.bind(null, r), this.log = t.log.bind(null, r), this.warn = t.warn.bind(null, r), this.info = t.info.bind(null, r), this.error = t.error.bind(null, r);
    }
}
const As = function() {}, _S = {
    trace: As,
    debug: As,
    log: As,
    warn: As,
    info: As,
    error: As
};
function oc() {
    return nt({}, _S);
}
function LS(s, e) {
    const t = self.console[s];
    return t ? t.bind(self.console, `${e ? "[" + e + "] " : ""}[${s}] >`) : As;
}
function Jd(s, e, t) {
    return e[s] ? e[s].bind(e) : LS(s, t);
}
const ac = oc();
function RS(s, e, t) {
    const r = oc();
    if (typeof console == "object" && s === !0 || typeof s == "object") {
        const n1 = [
            // Remove out from list here to hard-disable a log-level
            // 'trace',
            "debug",
            "log",
            "info",
            "warn",
            "error"
        ];
        n1.forEach((i)=>{
            r[i] = Jd(i, s, t);
        });
        try {
            r.log(`Debug logs enabled for "${e}" in hls.js version 1.6.12`);
        } catch  {
            return oc();
        }
        n1.forEach((i)=>{
            ac[i] = Jd(i, s);
        });
    } else nt(ac, r);
    return r;
}
const rt = ac;
function Ms(s = !0) {
    return typeof self > "u" ? void 0 : (s || !self.MediaSource) && self.ManagedMediaSource || self.MediaSource || self.WebKitMediaSource;
}
function CS(s) {
    return typeof self < "u" && s === self.ManagedMediaSource;
}
function Ag(s, e) {
    const t = Object.keys(s), r = Object.keys(e), n1 = t.length, i = r.length;
    return !n1 || !i || n1 === i && !t.some((o)=>r.indexOf(o) === -1);
}
function Tr(s, e = !1) {
    if (typeof TextDecoder < "u") {
        const c = new TextDecoder("utf-8").decode(s);
        if (e) {
            const u = c.indexOf("\0");
            return u !== -1 ? c.substring(0, u) : c;
        }
        return c.replace(/\0/g, "");
    }
    const t = s.length;
    let r, n1, i, o = "", a = 0;
    for(; a < t;){
        if (r = s[a++], r === 0 && e) return o;
        if (r === 0 || r === 3) continue;
        switch(r >> 4){
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
                o += String.fromCharCode(r);
                break;
            case 12:
            case 13:
                n1 = s[a++], o += String.fromCharCode((r & 31) << 6 | n1 & 63);
                break;
            case 14:
                n1 = s[a++], i = s[a++], o += String.fromCharCode((r & 15) << 12 | (n1 & 63) << 6 | (i & 63) << 0);
                break;
        }
    }
    return o;
}
function fr(s) {
    let e = "";
    for(let t = 0; t < s.length; t++){
        let r = s[t].toString(16);
        r.length < 2 && (r = "0" + r), e += r;
    }
    return e;
}
function Ig(s) {
    return Uint8Array.from(s.replace(/^0x/, "").replace(/([\da-fA-F]{2}) ?/g, "0x$1 ").replace(/ +$/, "").split(" ")).buffer;
}
function kS(s) {
    return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, "default") ? s.default : s;
}
var cl = {
    exports: {}
}, Qd;
function DS() {
    return Qd || (Qd = 1, function(s, e) {
        (function(t) {
            var r = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/, n1 = /^(?=([^\/?#]*))\1([^]*)$/, i = /(?:\/|^)\.(?=\/)/g, o = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g, a = {
                // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //
                // E.g
                // With opts.alwaysNormalize = false (default, spec compliant)
                // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g
                // With opts.alwaysNormalize = true (not spec compliant)
                // http://a.com/b/cd + /e/f/../g => http://a.com/e/g
                buildAbsoluteURL: function(l, c, u) {
                    if (u = u || {}, l = l.trim(), c = c.trim(), !c) {
                        if (!u.alwaysNormalize) return l;
                        var d1 = a.parseURL(l);
                        if (!d1) throw new Error("Error trying to parse base URL.");
                        return d1.path = a.normalizePath(d1.path), a.buildURLFromParts(d1);
                    }
                    var h = a.parseURL(c);
                    if (!h) throw new Error("Error trying to parse relative URL.");
                    if (h.scheme) return u.alwaysNormalize ? (h.path = a.normalizePath(h.path), a.buildURLFromParts(h)) : c;
                    var f = a.parseURL(l);
                    if (!f) throw new Error("Error trying to parse base URL.");
                    if (!f.netLoc && f.path && f.path[0] !== "/") {
                        var p = n1.exec(f.path);
                        f.netLoc = p[1], f.path = p[2];
                    }
                    f.netLoc && !f.path && (f.path = "/");
                    var y = {
                        // 2c) Otherwise, the embedded URL inherits the scheme of
                        // the base URL.
                        scheme: f.scheme,
                        netLoc: h.netLoc,
                        path: null,
                        params: h.params,
                        query: h.query,
                        fragment: h.fragment
                    };
                    if (!h.netLoc && (y.netLoc = f.netLoc, h.path[0] !== "/")) if (!h.path) y.path = f.path, h.params || (y.params = f.params, h.query || (y.query = f.query));
                    else {
                        var E = f.path, b = E.substring(0, E.lastIndexOf("/") + 1) + h.path;
                        y.path = a.normalizePath(b);
                    }
                    return y.path === null && (y.path = u.alwaysNormalize ? a.normalizePath(h.path) : h.path), a.buildURLFromParts(y);
                },
                parseURL: function(l) {
                    var c = r.exec(l);
                    return c ? {
                        scheme: c[1] || "",
                        netLoc: c[2] || "",
                        path: c[3] || "",
                        params: c[4] || "",
                        query: c[5] || "",
                        fragment: c[6] || ""
                    } : null;
                },
                normalizePath: function(l) {
                    for(l = l.split("").reverse().join("").replace(i, ""); l.length !== (l = l.replace(o, "")).length;);
                    return l.split("").reverse().join("");
                },
                buildURLFromParts: function(l) {
                    return l.scheme + l.netLoc + l.path + l.params + l.query + l.fragment;
                }
            };
            s.exports = a;
        })();
    }(cl)), cl.exports;
}
var hu = DS();
class fu {
    constructor(){
        this.aborted = !1, this.loaded = 0, this.retry = 0, this.total = 0, this.chunkCount = 0, this.bwEstimate = 0, this.loading = {
            start: 0,
            first: 0,
            end: 0
        }, this.parsing = {
            start: 0,
            end: 0
        }, this.buffering = {
            start: 0,
            first: 0,
            end: 0
        };
    }
}
var ot = {
    AUDIO: "audio",
    VIDEO: "video",
    AUDIOVIDEO: "audiovideo"
};
class _g {
    constructor(e){
        this._byteRange = null, this._url = null, this._stats = null, this._streams = null, this.base = void 0, this.relurl = void 0, typeof e == "string" && (e = {
            url: e
        }), this.base = e, MS(this, "stats");
    }
    // setByteRange converts a EXT-X-BYTERANGE attribute into a two element array
    setByteRange(e, t) {
        const r = e.split("@", 2);
        let n1;
        r.length === 1 ? n1 = (t == null ? void 0 : t.byteRangeEndOffset) || 0 : n1 = parseInt(r[1]), this._byteRange = [
            n1,
            parseInt(r[0]) + n1
        ];
    }
    get baseurl() {
        return this.base.url;
    }
    get byteRange() {
        return this._byteRange === null ? [] : this._byteRange;
    }
    get byteRangeStartOffset() {
        return this.byteRange[0];
    }
    get byteRangeEndOffset() {
        return this.byteRange[1];
    }
    get elementaryStreams() {
        return this._streams === null && (this._streams = {
            [ot.AUDIO]: null,
            [ot.VIDEO]: null,
            [ot.AUDIOVIDEO]: null
        }), this._streams;
    }
    set elementaryStreams(e) {
        this._streams = e;
    }
    get hasStats() {
        return this._stats !== null;
    }
    get hasStreams() {
        return this._streams !== null;
    }
    get stats() {
        return this._stats === null && (this._stats = new fu()), this._stats;
    }
    set stats(e) {
        this._stats = e;
    }
    get url() {
        return !this._url && this.baseurl && this.relurl && (this._url = hu.buildAbsoluteURL(this.baseurl, this.relurl, {
            alwaysNormalize: !0
        })), this._url || "";
    }
    set url(e) {
        this._url = e;
    }
    clearElementaryStreamInfo() {
        const { elementaryStreams: e } = this;
        e[ot.AUDIO] = null, e[ot.VIDEO] = null, e[ot.AUDIOVIDEO] = null;
    }
}
function Vt(s) {
    return s.sn !== "initSegment";
}
class ul extends _g {
    constructor(e, t){
        super(t), this._decryptdata = null, this._programDateTime = null, this._ref = null, this._bitrate = void 0, this.rawProgramDateTime = null, this.tagList = [], this.duration = 0, this.sn = 0, this.levelkeys = void 0, this.type = void 0, this.loader = null, this.keyLoader = null, this.level = -1, this.cc = 0, this.startPTS = void 0, this.endPTS = void 0, this.startDTS = void 0, this.endDTS = void 0, this.start = 0, this.playlistOffset = 0, this.deltaPTS = void 0, this.maxStartPTS = void 0, this.minEndPTS = void 0, this.data = void 0, this.bitrateTest = !1, this.title = null, this.initSegment = null, this.endList = void 0, this.gap = void 0, this.urlId = 0, this.type = e;
    }
    get byteLength() {
        if (this.hasStats) {
            const e = this.stats.total;
            if (e) return e;
        }
        if (this.byteRange.length) {
            const e = this.byteRange[0], t = this.byteRange[1];
            if (ue(e) && ue(t)) return t - e;
        }
        return null;
    }
    get bitrate() {
        return this.byteLength ? this.byteLength * 8 / this.duration : this._bitrate ? this._bitrate : null;
    }
    set bitrate(e) {
        this._bitrate = e;
    }
    get decryptdata() {
        const { levelkeys: e } = this;
        if (!e && !this._decryptdata) return null;
        if (!this._decryptdata && this.levelkeys && !this.levelkeys.NONE) {
            const t = this.levelkeys.identity;
            if (t) this._decryptdata = t.getDecryptData(this.sn);
            else {
                const r = Object.keys(this.levelkeys);
                if (r.length === 1) {
                    const n1 = this._decryptdata = this.levelkeys[r[0]] || null;
                    if (n1) return n1.getDecryptData(this.sn);
                }
            }
        }
        return this._decryptdata;
    }
    get end() {
        return this.start + this.duration;
    }
    get endProgramDateTime() {
        if (this.programDateTime === null) return null;
        const e = ue(this.duration) ? this.duration : 0;
        return this.programDateTime + e * 1e3;
    }
    get encrypted() {
        var e;
        if ((e = this._decryptdata) != null && e.encrypted) return !0;
        if (this.levelkeys) {
            var t;
            const r = Object.keys(this.levelkeys), n1 = r.length;
            if (n1 > 1 || n1 === 1 && (t = this.levelkeys[r[0]]) != null && t.encrypted) return !0;
        }
        return !1;
    }
    get programDateTime() {
        return this._programDateTime === null && this.rawProgramDateTime && (this.programDateTime = Date.parse(this.rawProgramDateTime)), this._programDateTime;
    }
    set programDateTime(e) {
        if (!ue(e)) {
            this._programDateTime = this.rawProgramDateTime = null;
            return;
        }
        this._programDateTime = e;
    }
    get ref() {
        return Vt(this) ? (this._ref || (this._ref = {
            base: this.base,
            start: this.start,
            duration: this.duration,
            sn: this.sn,
            programDateTime: this.programDateTime
        }), this._ref) : null;
    }
    addStart(e) {
        this.setStart(this.start + e);
    }
    setStart(e) {
        this.start = e, this._ref && (this._ref.start = e);
    }
    setDuration(e) {
        this.duration = e, this._ref && (this._ref.duration = e);
    }
    setKeyFormat(e) {
        if (this.levelkeys) {
            const t = this.levelkeys[e];
            t && !this._decryptdata && (this._decryptdata = t.getDecryptData(this.sn));
        }
    }
    abortRequests() {
        var e, t;
        (e = this.loader) == null || e.abort(), (t = this.keyLoader) == null || t.abort();
    }
    setElementaryStreamInfo(e, t, r, n1, i, o = !1) {
        const { elementaryStreams: a } = this, l = a[e];
        if (!l) {
            a[e] = {
                startPTS: t,
                endPTS: r,
                startDTS: n1,
                endDTS: i,
                partial: o
            };
            return;
        }
        l.startPTS = Math.min(l.startPTS, t), l.endPTS = Math.max(l.endPTS, r), l.startDTS = Math.min(l.startDTS, n1), l.endDTS = Math.max(l.endDTS, i);
    }
}
class PS extends _g {
    constructor(e, t, r, n1, i){
        super(r), this.fragOffset = 0, this.duration = 0, this.gap = !1, this.independent = !1, this.relurl = void 0, this.fragment = void 0, this.index = void 0, this.duration = e.decimalFloatingPoint("DURATION"), this.gap = e.bool("GAP"), this.independent = e.bool("INDEPENDENT"), this.relurl = e.enumeratedString("URI"), this.fragment = t, this.index = n1;
        const o = e.enumeratedString("BYTERANGE");
        o && this.setByteRange(o, i), i && (this.fragOffset = i.fragOffset + i.duration);
    }
    get start() {
        return this.fragment.start + this.fragOffset;
    }
    get end() {
        return this.start + this.duration;
    }
    get loaded() {
        const { elementaryStreams: e } = this;
        return !!(e.audio || e.video || e.audiovideo);
    }
}
function Lg(s, e) {
    const t = Object.getPrototypeOf(s);
    if (t) {
        const r = Object.getOwnPropertyDescriptor(t, e);
        return r || Lg(t, e);
    }
}
function MS(s, e) {
    const t = Lg(s, e);
    t && (t.enumerable = !0, Object.defineProperty(s, e, t));
}
const eh = Math.pow(2, 32) - 1, OS = [].push, Rg = {
    video: 1,
    audio: 2,
    id3: 3,
    text: 4
};
function jt(s) {
    return String.fromCharCode.apply(null, s);
}
function Cg(s, e) {
    const t = s[e] << 8 | s[e + 1];
    return t < 0 ? 65536 + t : t;
}
function Ie(s, e) {
    const t = kg(s, e);
    return t < 0 ? 4294967296 + t : t;
}
function th(s, e) {
    let t = Ie(s, e);
    return t *= Math.pow(2, 32), t += Ie(s, e + 4), t;
}
function kg(s, e) {
    return s[e] << 24 | s[e + 1] << 16 | s[e + 2] << 8 | s[e + 3];
}
function BS(s) {
    const e = s.byteLength;
    for(let t = 0; t < e;){
        const r = Ie(s, t);
        if (r > 8 && s[t + 4] === 109 && s[t + 5] === 111 && s[t + 6] === 111 && s[t + 7] === 102) return !0;
        t = r > 1 ? t + r : e;
    }
    return !1;
}
function Ge(s, e) {
    const t = [];
    if (!e.length) return t;
    const r = s.byteLength;
    for(let n1 = 0; n1 < r;){
        const i = Ie(s, n1), o = jt(s.subarray(n1 + 4, n1 + 8)), a = i > 1 ? n1 + i : r;
        if (o === e[0]) if (e.length === 1) t.push(s.subarray(n1 + 8, a));
        else {
            const l = Ge(s.subarray(n1 + 8, a), e.slice(1));
            l.length && OS.apply(t, l);
        }
        n1 = a;
    }
    return t;
}
function FS(s) {
    const e = [], t = s[0];
    let r = 8;
    const n1 = Ie(s, r);
    r += 4;
    let i = 0, o = 0;
    t === 0 ? (i = Ie(s, r), o = Ie(s, r + 4), r += 8) : (i = th(s, r), o = th(s, r + 8), r += 16), r += 2;
    let a = s.length + o;
    const l = Cg(s, r);
    r += 2;
    for(let c = 0; c < l; c++){
        let u = r;
        const d1 = Ie(s, u);
        u += 4;
        const h = d1 & 2147483647;
        if ((d1 & 2147483648) >>> 31 === 1) return rt.warn("SIDX has hierarchical references (not supported)"), null;
        const p = Ie(s, u);
        u += 4, e.push({
            referenceSize: h,
            subsegmentDuration: p,
            // unscaled
            info: {
                duration: p / n1,
                start: a,
                end: a + h - 1
            }
        }), a += h, u += 4, r = u;
    }
    return {
        earliestPresentationTime: i,
        timescale: n1,
        version: t,
        referencesCount: l,
        references: e
    };
}
function Dg(s) {
    const e = [], t = Ge(s, [
        "moov",
        "trak"
    ]);
    for(let n1 = 0; n1 < t.length; n1++){
        const i = t[n1], o = Ge(i, [
            "tkhd"
        ])[0];
        if (o) {
            let a = o[0];
            const l = Ie(o, a === 0 ? 12 : 20), c = Ge(i, [
                "mdia",
                "mdhd"
            ])[0];
            if (c) {
                a = c[0];
                const u = Ie(c, a === 0 ? 12 : 20), d1 = Ge(i, [
                    "mdia",
                    "hdlr"
                ])[0];
                if (d1) {
                    const h = jt(d1.subarray(8, 12)), f = {
                        soun: ot.AUDIO,
                        vide: ot.VIDEO
                    }[h], p = Ge(i, [
                        "mdia",
                        "minf",
                        "stbl",
                        "stsd"
                    ])[0], y = NS(p);
                    f ? (e[l] = {
                        timescale: u,
                        type: f,
                        stsd: y
                    }, e[f] = tt({
                        timescale: u,
                        id: l
                    }, y)) : e[l] = {
                        timescale: u,
                        type: h,
                        stsd: y
                    };
                }
            }
        }
    }
    return Ge(s, [
        "moov",
        "mvex",
        "trex"
    ]).forEach((n1)=>{
        const i = Ie(n1, 4), o = e[i];
        o && (o.default = {
            duration: Ie(n1, 12),
            flags: Ie(n1, 20)
        });
    }), e;
}
function NS(s) {
    const e = s.subarray(8), t = e.subarray(86), r = jt(e.subarray(4, 8));
    let n1 = r, i;
    const o = r === "enca" || r === "encv";
    if (o) {
        const c = Ge(e, [
            r
        ])[0].subarray(r === "enca" ? 28 : 78);
        Ge(c, [
            "sinf"
        ]).forEach((d1)=>{
            const h = Ge(d1, [
                "schm"
            ])[0];
            if (h) {
                const f = jt(h.subarray(4, 8));
                if (f === "cbcs" || f === "cenc") {
                    const p = Ge(d1, [
                        "frma"
                    ])[0];
                    p && (n1 = jt(p));
                }
            }
        });
    }
    const a = n1;
    switch(n1){
        case "avc1":
        case "avc2":
        case "avc3":
        case "avc4":
            {
                const l = Ge(t, [
                    "avcC"
                ])[0];
                l && l.length > 3 && (n1 += "." + Ki(l[1]) + Ki(l[2]) + Ki(l[3]), i = ji(a === "avc1" ? "dva1" : "dvav", t));
                break;
            }
        case "mp4a":
            {
                const l = Ge(e, [
                    r
                ])[0], c = Ge(l.subarray(28), [
                    "esds"
                ])[0];
                if (c && c.length > 7) {
                    let u = 4;
                    if (c[u++] !== 3) break;
                    u = dl(c, u), u += 2;
                    const d1 = c[u++];
                    if (d1 & 128 && (u += 2), d1 & 64 && (u += c[u++]), c[u++] !== 4) break;
                    u = dl(c, u);
                    const h = c[u++];
                    if (h === 64) n1 += "." + Ki(h);
                    else break;
                    if (u += 12, c[u++] !== 5) break;
                    u = dl(c, u);
                    const f = c[u++];
                    let p = (f & 248) >> 3;
                    p === 31 && (p += 1 + ((f & 7) << 3) + ((c[u] & 224) >> 5)), n1 += "." + p;
                }
                break;
            }
        case "hvc1":
        case "hev1":
            {
                const l = Ge(t, [
                    "hvcC"
                ])[0];
                if (l && l.length > 12) {
                    const c = l[1], u = [
                        "",
                        "A",
                        "B",
                        "C"
                    ][c >> 6], d1 = c & 31, h = Ie(l, 2), f = (c & 32) >> 5 ? "H" : "L", p = l[12], y = l.subarray(6, 12);
                    n1 += "." + u + d1, n1 += "." + US(h).toString(16).toUpperCase(), n1 += "." + f + p;
                    let E = "";
                    for(let b = y.length; b--;){
                        const L = y[b];
                        (L || E) && (E = "." + L.toString(16).toUpperCase() + E);
                    }
                    n1 += E;
                }
                i = ji(a == "hev1" ? "dvhe" : "dvh1", t);
                break;
            }
        case "dvh1":
        case "dvhe":
        case "dvav":
        case "dva1":
        case "dav1":
            {
                n1 = ji(n1, t) || n1;
                break;
            }
        case "vp09":
            {
                const l = Ge(t, [
                    "vpcC"
                ])[0];
                if (l && l.length > 6) {
                    const c = l[4], u = l[5], d1 = l[6] >> 4 & 15;
                    n1 += "." + Vr(c) + "." + Vr(u) + "." + Vr(d1);
                }
                break;
            }
        case "av01":
            {
                const l = Ge(t, [
                    "av1C"
                ])[0];
                if (l && l.length > 2) {
                    const c = l[1] >>> 5, u = l[1] & 31, d1 = l[2] >>> 7 ? "H" : "M", h = (l[2] & 64) >> 6, f = (l[2] & 32) >> 5, p = c === 2 && h ? f ? 12 : 10 : h ? 10 : 8, y = (l[2] & 16) >> 4, E = (l[2] & 8) >> 3, b = (l[2] & 4) >> 2, L = l[2] & 3;
                    n1 += "." + c + "." + Vr(u) + d1 + "." + Vr(p) + "." + y + "." + E + b + L + "." + Vr(1) + "." + Vr(1) + "." + Vr(1) + "." + 0, i = ji("dav1", t);
                }
                break;
            }
    }
    return {
        codec: n1,
        encrypted: o,
        supplemental: i
    };
}
function ji(s, e) {
    const t = Ge(e, [
        "dvvC"
    ]), r = t.length ? t[0] : Ge(e, [
        "dvcC"
    ])[0];
    if (r) {
        const n1 = r[2] >> 1 & 127, i = r[2] << 5 & 32 | r[3] >> 3 & 31;
        return s + "." + Vr(n1) + "." + Vr(i);
    }
}
function US(s) {
    let e = 0;
    for(let t = 0; t < 32; t++)e |= (s >> t & 1) << 31 - t;
    return e >>> 0;
}
function dl(s, e) {
    const t = e + 5;
    for(; s[e++] & 128 && e < t;);
    return e;
}
function Ki(s) {
    return ("0" + s.toString(16).toUpperCase()).slice(-2);
}
function Vr(s) {
    return (s < 10 ? "0" : "") + s;
}
function $S(s, e) {
    if (!s || !e) return;
    const t = e.keyId;
    t && e.isCommonEncryption && Ge(s, [
        "moov",
        "trak"
    ]).forEach((n1)=>{
        const o = Ge(n1, [
            "mdia",
            "minf",
            "stbl",
            "stsd"
        ])[0].subarray(8);
        let a = Ge(o, [
            "enca"
        ]);
        const l = a.length > 0;
        l || (a = Ge(o, [
            "encv"
        ])), a.forEach((c)=>{
            const u = l ? c.subarray(28) : c.subarray(78);
            Ge(u, [
                "sinf"
            ]).forEach((h)=>{
                const f = Pg(h);
                if (f) {
                    const p = f.subarray(8, 24);
                    p.some((y)=>y !== 0) || (rt.log(`[eme] Patching keyId in 'enc${l ? "a" : "v"}>sinf>>tenc' box: ${fr(p)} -> ${fr(t)}`), f.set(t, 8));
                }
            });
        });
    });
}
function Pg(s) {
    const e = Ge(s, [
        "schm"
    ])[0];
    if (e) {
        const t = jt(e.subarray(4, 8));
        if (t === "cbcs" || t === "cenc") return Ge(s, [
            "schi",
            "tenc"
        ])[0];
    }
    return null;
}
function GS(s, e, t) {
    const r = {}, n1 = Ge(s, [
        "moof",
        "traf"
    ]);
    for(let i = 0; i < n1.length; i++){
        const o = n1[i], a = Ge(o, [
            "tfhd"
        ])[0], l = Ie(a, 4), c = e[l];
        if (!c) continue;
        r[l] || (r[l] = {
            start: NaN,
            duration: 0,
            sampleCount: 0,
            timescale: c.timescale,
            type: c.type
        });
        const u = r[l], d1 = Ge(o, [
            "tfdt"
        ])[0];
        if (d1) {
            const A = d1[0];
            let F = Ie(d1, 4);
            A === 1 && (F === eh ? t.warn("[mp4-demuxer]: Ignoring assumed invalid signed 64-bit track fragment decode time") : (F *= eh + 1, F += Ie(d1, 8))), ue(F) && (!ue(u.start) || F < u.start) && (u.start = F);
        }
        const h = c.default, f = Ie(a, 0) | (h == null ? void 0 : h.flags);
        let p = (h == null ? void 0 : h.duration) || 0;
        f & 8 && (f & 2 ? p = Ie(a, 12) : p = Ie(a, 8));
        const y = Ge(o, [
            "trun"
        ]);
        let E = u.start || 0, b = 0, L = p;
        for(let A = 0; A < y.length; A++){
            const F = y[A], M = Ie(F, 4), H = u.sampleCount;
            u.sampleCount += M;
            const K = F[3] & 1, j = F[3] & 4, C = F[2] & 1, k = F[2] & 2, $ = F[2] & 4, W = F[2] & 8;
            let _ = 8, g = M;
            for(K && (_ += 4), j && M && (!(F[_ + 1] & 1) && u.keyFrameIndex === void 0 && (u.keyFrameIndex = H), _ += 4, C ? (L = Ie(F, _), _ += 4) : L = p, k && (_ += 4), W && (_ += 4), E += L, b += L, g--); g--;)C ? (L = Ie(F, _), _ += 4) : L = p, k && (_ += 4), $ && (F[_ + 1] & 1 || u.keyFrameIndex === void 0 && (u.keyFrameIndex = u.sampleCount - (g + 1), u.keyFrameStart = E), _ += 4), W && (_ += 4), E += L, b += L;
            !b && p && (b += p * M);
        }
        u.duration += b;
    }
    if (!Object.keys(r).some((i)=>r[i].duration)) {
        let i = 1 / 0, o = 0;
        const a = Ge(s, [
            "sidx"
        ]);
        for(let l = 0; l < a.length; l++){
            const c = FS(a[l]);
            if (c != null && c.references) {
                i = Math.min(i, c.earliestPresentationTime / c.timescale);
                const u = c.references.reduce((d1, h)=>d1 + h.info.duration || 0, 0);
                o = Math.max(o, u + c.earliestPresentationTime / c.timescale);
            }
        }
        o && ue(o) && Object.keys(r).forEach((l)=>{
            r[l].duration || (r[l].duration = o * r[l].timescale - r[l].start);
        });
    }
    return r;
}
function VS(s) {
    const e = {
        valid: null,
        remainder: null
    }, t = Ge(s, [
        "moof"
    ]);
    if (t.length < 2) return e.remainder = s, e;
    const r = t[t.length - 1];
    return e.valid = s.slice(0, r.byteOffset - 8), e.remainder = s.slice(r.byteOffset - 8), e;
}
function _r(s, e) {
    const t = new Uint8Array(s.length + e.length);
    return t.set(s), t.set(e, s.length), t;
}
function rh(s, e) {
    const t = [], r = e.samples, n1 = e.timescale, i = e.id;
    let o = !1;
    return Ge(r, [
        "moof"
    ]).map((l)=>{
        const c = l.byteOffset - 8;
        Ge(l, [
            "traf"
        ]).map((d1)=>{
            const h = Ge(d1, [
                "tfdt"
            ]).map((f)=>{
                const p = f[0];
                let y = Ie(f, 4);
                return p === 1 && (y *= Math.pow(2, 32), y += Ie(f, 8)), y / n1;
            })[0];
            return h !== void 0 && (s = h), Ge(d1, [
                "tfhd"
            ]).map((f)=>{
                const p = Ie(f, 4), y = Ie(f, 0) & 16777215, E = (y & 1) !== 0, b = (y & 2) !== 0, L = (y & 8) !== 0;
                let A = 0;
                const F = (y & 16) !== 0;
                let M = 0;
                const H = (y & 32) !== 0;
                let K = 8;
                p === i && (E && (K += 8), b && (K += 4), L && (A = Ie(f, K), K += 4), F && (M = Ie(f, K), K += 4), H && (K += 4), e.type === "video" && (o = ya(e.codec)), Ge(d1, [
                    "trun"
                ]).map((j)=>{
                    const C = j[0], k = Ie(j, 0) & 16777215, $ = (k & 1) !== 0;
                    let W = 0;
                    const _ = (k & 4) !== 0, g = (k & 256) !== 0;
                    let x = 0;
                    const w = (k & 512) !== 0;
                    let D = 0;
                    const O = (k & 1024) !== 0, U = (k & 2048) !== 0;
                    let V = 0;
                    const R = Ie(j, 4);
                    let m = 8;
                    $ && (W = Ie(j, m), m += 4), _ && (m += 4);
                    let v = W + c;
                    for(let P = 0; P < R; P++){
                        if (g ? (x = Ie(j, m), m += 4) : x = A, w ? (D = Ie(j, m), m += 4) : D = M, O && (m += 4), U && (C === 0 ? V = Ie(j, m) : V = kg(j, m), m += 4), e.type === ot.VIDEO) {
                            let N = 0;
                            for(; N < D;){
                                const Y = Ie(r, v);
                                if (v += 4, jS(o, r[v])) {
                                    const ee = r.subarray(v, v + Y);
                                    gu(ee, o ? 2 : 1, s + V / n1, t);
                                }
                                v += Y, N += Y + 4;
                            }
                        }
                        s += x / n1;
                    }
                }));
            });
        });
    }), t;
}
function ya(s) {
    if (!s) return !1;
    const e = s.substring(0, 4);
    return e === "hvc1" || e === "hev1" || // Dolby Vision
    e === "dvh1" || e === "dvhe";
}
function jS(s, e) {
    if (s) {
        const t = e >> 1 & 63;
        return t === 39 || t === 40;
    } else return (e & 31) === 6;
}
function gu(s, e, t, r) {
    const n1 = Mg(s);
    let i = 0;
    i += e;
    let o = 0, a = 0, l = 0;
    for(; i < n1.length;){
        o = 0;
        do {
            if (i >= n1.length) break;
            l = n1[i++], o += l;
        }while (l === 255)
        a = 0;
        do {
            if (i >= n1.length) break;
            l = n1[i++], a += l;
        }while (l === 255)
        const c = n1.length - i;
        let u = i;
        if (a < c) i += a;
        else if (a > c) {
            rt.error(`Malformed SEI payload. ${a} is too small, only ${c} bytes left to parse.`);
            break;
        }
        if (o === 4) {
            if (n1[u++] === 181) {
                const h = Cg(n1, u);
                if (u += 2, h === 49) {
                    const f = Ie(n1, u);
                    if (u += 4, f === 1195456820) {
                        const p = n1[u++];
                        if (p === 3) {
                            const y = n1[u++], E = 31 & y, b = 64 & y, L = b ? 2 + E * 3 : 0, A = new Uint8Array(L);
                            if (b) {
                                A[0] = y;
                                for(let F = 1; F < L; F++)A[F] = n1[u++];
                            }
                            r.push({
                                type: p,
                                payloadType: o,
                                pts: t,
                                bytes: A
                            });
                        }
                    }
                }
            }
        } else if (o === 5 && a > 16) {
            const d1 = [];
            for(let p = 0; p < 16; p++){
                const y = n1[u++].toString(16);
                d1.push(y.length == 1 ? "0" + y : y), (p === 3 || p === 5 || p === 7 || p === 9) && d1.push("-");
            }
            const h = a - 16, f = new Uint8Array(h);
            for(let p = 0; p < h; p++)f[p] = n1[u++];
            r.push({
                payloadType: o,
                pts: t,
                uuid: d1.join(""),
                userData: Tr(f),
                userDataBytes: f
            });
        }
    }
}
function Mg(s) {
    const e = s.byteLength, t = [];
    let r = 1;
    for(; r < e - 2;)s[r] === 0 && s[r + 1] === 0 && s[r + 2] === 3 ? (t.push(r + 2), r += 2) : r++;
    if (t.length === 0) return s;
    const n1 = e - t.length, i = new Uint8Array(n1);
    let o = 0;
    for(r = 0; r < n1; o++, r++)o === t[0] && (o++, t.shift()), i[r] = s[o];
    return i;
}
function KS(s) {
    const e = s[0];
    let t = "", r = "", n1 = 0, i = 0, o = 0, a = 0, l = 0, c = 0;
    if (e === 0) {
        for(; jt(s.subarray(c, c + 1)) !== "\0";)t += jt(s.subarray(c, c + 1)), c += 1;
        for(t += jt(s.subarray(c, c + 1)), c += 1; jt(s.subarray(c, c + 1)) !== "\0";)r += jt(s.subarray(c, c + 1)), c += 1;
        r += jt(s.subarray(c, c + 1)), c += 1, n1 = Ie(s, 12), i = Ie(s, 16), a = Ie(s, 20), l = Ie(s, 24), c = 28;
    } else if (e === 1) {
        c += 4, n1 = Ie(s, c), c += 4;
        const d1 = Ie(s, c);
        c += 4;
        const h = Ie(s, c);
        for(c += 4, o = 2 ** 32 * d1 + h, SS(o) || (o = Number.MAX_SAFE_INTEGER, rt.warn("Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box")), a = Ie(s, c), c += 4, l = Ie(s, c), c += 4; jt(s.subarray(c, c + 1)) !== "\0";)t += jt(s.subarray(c, c + 1)), c += 1;
        for(t += jt(s.subarray(c, c + 1)), c += 1; jt(s.subarray(c, c + 1)) !== "\0";)r += jt(s.subarray(c, c + 1)), c += 1;
        r += jt(s.subarray(c, c + 1)), c += 1;
    }
    const u = s.subarray(c, s.byteLength);
    return {
        schemeIdUri: t,
        value: r,
        timeScale: n1,
        presentationTime: o,
        presentationTimeDelta: i,
        eventDuration: a,
        id: l,
        payload: u
    };
}
function HS(s, ...e) {
    const t = e.length;
    let r = 8, n1 = t;
    for(; n1--;)r += e[n1].byteLength;
    const i = new Uint8Array(r);
    for(i[0] = r >> 24 & 255, i[1] = r >> 16 & 255, i[2] = r >> 8 & 255, i[3] = r & 255, i.set(s, 4), n1 = 0, r = 8; n1 < t; n1++)i.set(e[n1], r), r += e[n1].byteLength;
    return i;
}
function qS(s, e, t) {
    if (s.byteLength !== 16) throw new RangeError("Invalid system id");
    let r, n1;
    r = 0, n1 = new Uint8Array();
    let i;
    r > 0 ? (i = new Uint8Array(4), e.length > 0 && new DataView(i.buffer).setUint32(0, e.length, !1)) : i = new Uint8Array();
    const o = new Uint8Array(4);
    return t.byteLength > 0 && new DataView(o.buffer).setUint32(0, t.byteLength, !1), HS([
        112,
        115,
        115,
        104
    ], new Uint8Array([
        r,
        0,
        0,
        0
    ]), s, // 16 bytes
    i, n1, o, t);
}
function WS(s) {
    const e = [];
    if (s instanceof ArrayBuffer) {
        const t = s.byteLength;
        let r = 0;
        for(; r + 32 < t;){
            const n1 = new DataView(s, r), i = zS(n1);
            e.push(i), r += i.size;
        }
    }
    return e;
}
function zS(s) {
    const e = s.getUint32(0), t = s.byteOffset, r = s.byteLength;
    if (r < e) return {
        offset: t,
        size: r
    };
    if (s.getUint32(4) !== 1886614376) return {
        offset: t,
        size: e
    };
    const i = s.getUint32(8) >>> 24;
    if (i !== 0 && i !== 1) return {
        offset: t,
        size: e
    };
    const o = s.buffer, a = fr(new Uint8Array(o, t + 12, 16));
    let l = null, c = null, u = 0;
    if (i === 0) u = 28;
    else {
        const h = s.getUint32(28);
        if (!h || r < 32 + h * 16) return {
            offset: t,
            size: e
        };
        l = [];
        for(let f = 0; f < h; f++)l.push(new Uint8Array(o, t + 32 + f * 16, 16));
        u = 32 + h * 16;
    }
    if (!u) return {
        offset: t,
        size: e
    };
    const d1 = s.getUint32(u);
    return e - 32 < d1 ? {
        offset: t,
        size: e
    } : (c = new Uint8Array(o, t + u + 4, d1), {
        version: i,
        systemId: a,
        kids: l,
        data: c,
        offset: t,
        size: e
    });
}
const Og = ()=>/\(Windows.+Firefox\//i.test(navigator.userAgent), On = {
    audio: {
        a3ds: 1,
        "ac-3": 0.95,
        "ac-4": 1,
        alac: 0.9,
        alaw: 1,
        dra1: 1,
        "dts+": 1,
        "dts-": 1,
        dtsc: 1,
        dtse: 1,
        dtsh: 1,
        "ec-3": 0.9,
        enca: 1,
        fLaC: 0.9,
        // MP4-RA listed codec entry for FLAC
        flac: 0.9,
        // legacy browser codec name for FLAC
        FLAC: 0.9,
        // some manifests may list "FLAC" with Apple's tools
        g719: 1,
        g726: 1,
        m4ae: 1,
        mha1: 1,
        mha2: 1,
        mhm1: 1,
        mhm2: 1,
        mlpa: 1,
        mp4a: 1,
        "raw ": 1,
        Opus: 1,
        opus: 1,
        // browsers expect this to be lowercase despite MP4RA says 'Opus'
        samr: 1,
        sawb: 1,
        sawp: 1,
        sevc: 1,
        sqcp: 1,
        ssmv: 1,
        twos: 1,
        ulaw: 1
    },
    video: {
        avc1: 1,
        avc2: 1,
        avc3: 1,
        avc4: 1,
        avcp: 1,
        av01: 0.8,
        dav1: 0.8,
        drac: 1,
        dva1: 1,
        dvav: 1,
        dvh1: 0.7,
        dvhe: 0.7,
        encv: 1,
        hev1: 0.75,
        hvc1: 0.75,
        mjp2: 1,
        mp4v: 1,
        mvc1: 1,
        mvc2: 1,
        mvc3: 1,
        mvc4: 1,
        resv: 1,
        rv60: 1,
        s263: 1,
        svc1: 1,
        svc2: 1,
        "vc-1": 1,
        vp08: 1,
        vp09: 0.9
    },
    text: {
        stpp: 1,
        wvtt: 1
    }
};
function pu(s, e) {
    const t = On[e];
    return !!t && !!t[s.slice(0, 4)];
}
function gi(s, e, t = !0) {
    return !s.split(",").some((r)=>!mu(r, e, t));
}
function mu(s, e, t = !0) {
    var r;
    const n1 = Ms(t);
    return (r = n1 == null ? void 0 : n1.isTypeSupported(pi(s, e))) != null ? r : !1;
}
function pi(s, e) {
    return `${e}/mp4;codecs=${s}`;
}
function sh(s) {
    if (s) {
        const e = s.substring(0, 4);
        return On.video[e];
    }
    return 2;
}
function Zo(s) {
    const e = Og();
    return s.split(",").reduce((t, r)=>{
        const i = e && ya(r) ? 9 : On.video[r];
        return i ? (i * 2 + t) / (t ? 3 : 2) : (On.audio[r] + t) / (t ? 2 : 1);
    }, 0);
}
const hl = {};
function YS(s, e = !0) {
    if (hl[s]) return hl[s];
    const t = {
        // Idealy fLaC and Opus would be first (spec-compliant) but
        // some browsers will report that fLaC is supported then fail.
        // see: https://bugs.chromium.org/p/chromium/issues/detail?id=1422728
        flac: [
            "flac",
            "fLaC",
            "FLAC"
        ],
        opus: [
            "opus",
            "Opus"
        ],
        // Replace audio codec info if browser does not support mp4a.40.34,
        // and demuxer can fallback to 'audio/mpeg' or 'audio/mp4;codecs="mp3"'
        "mp4a.40.34": [
            "mp3"
        ]
    }[s];
    for(let n1 = 0; n1 < t.length; n1++){
        var r;
        if (mu(t[n1], "audio", e)) return hl[s] = t[n1], t[n1];
        if (t[n1] === "mp3" && (r = Ms(e)) != null && r.isTypeSupported("audio/mpeg")) return "";
    }
    return s;
}
const ZS = /flac|opus|mp4a\.40\.34/i;
function Xo(s, e = !0) {
    return s.replace(ZS, (t)=>YS(t.toLowerCase(), e));
}
function XS(s, e) {
    const t = [];
    if (s) {
        const r = s.split(",");
        for(let n1 = 0; n1 < r.length; n1++)pu(r[n1], "video") || t.push(r[n1]);
    }
    return e && t.push(e), t.join(",");
}
function fo(s, e) {
    if (s && (s.length > 4 || [
        "ac-3",
        "ec-3",
        "alac",
        "fLaC",
        "Opus"
    ].indexOf(s) !== -1) && (nh(s, "audio") || nh(s, "video"))) return s;
    if (e) {
        const t = e.split(",");
        if (t.length > 1) {
            if (s) {
                for(let r = t.length; r--;)if (t[r].substring(0, 4) === s.substring(0, 4)) return t[r];
            }
            return t[0];
        }
    }
    return e || s;
}
function nh(s, e) {
    return pu(s, e) && mu(s, e);
}
function JS(s) {
    const e = s.split(",");
    for(let t = 0; t < e.length; t++){
        const r = e[t].split(".");
        r.length > 2 && r[0] === "avc1" && (e[t] = `avc1.${parseInt(r[1]).toString(16)}${("000" + parseInt(r[2]).toString(16)).slice(-4)}`);
    }
    return e.join(",");
}
function QS(s) {
    if (s.startsWith("av01.")) {
        const e = s.split("."), t = [
            "0",
            "111",
            "01",
            "01",
            "01",
            "0"
        ];
        for(let r = e.length; r > 4 && r < 10; r++)e[r] = t[r - 4];
        return e.join(".");
    }
    return s;
}
function ih(s) {
    const e = Ms(s) || {
        isTypeSupported: ()=>!1
    };
    return {
        mpeg: e.isTypeSupported("audio/mpeg"),
        mp3: e.isTypeSupported('audio/mp4; codecs="mp3"'),
        ac3: e.isTypeSupported('audio/mp4; codecs="ac-3"')
    };
}
function lc(s) {
    return s.replace(/^.+codecs=["']?([^"']+).*$/, "$1");
}
const eb = {
    supported: !0,
    powerEfficient: !0,
    smooth: !0
}, tb = {
    supported: !1,
    smooth: !1,
    powerEfficient: !1
}, Bg = {
    supported: !0,
    configurations: [],
    decodingInfoResults: [
        eb
    ]
};
function Fg(s, e) {
    return {
        supported: !1,
        configurations: e,
        decodingInfoResults: [
            tb
        ],
        error: s
    };
}
function rb(s, e, t, r, n1, i) {
    const o = s.videoCodec, a = s.audioCodec ? s.audioGroups : null, l = i == null ? void 0 : i.audioCodec, c = i == null ? void 0 : i.channels, u = c ? parseInt(c) : l ? 1 / 0 : 2;
    let d1 = null;
    if (a != null && a.length) try {
        a.length === 1 && a[0] ? d1 = e.groups[a[0]].channels : d1 = a.reduce((h, f)=>{
            if (f) {
                const p = e.groups[f];
                if (!p) throw new Error(`Audio track group ${f} not found`);
                Object.keys(p.channels).forEach((y)=>{
                    h[y] = (h[y] || 0) + p.channels[y];
                });
            }
            return h;
        }, {
            2: 0
        });
    } catch  {
        return !0;
    }
    return o !== void 0 && // Force media capabilities check for HEVC to avoid failure on Windows
    (o.split(",").some((h)=>ya(h)) || s.width > 1920 && s.height > 1088 || s.height > 1920 && s.width > 1088 || s.frameRate > Math.max(r, 30) || s.videoRange !== "SDR" && s.videoRange !== t || s.bitrate > Math.max(n1, 8e6)) || !!d1 && ue(u) && Object.keys(d1).some((h)=>parseInt(h) > u);
}
function Ng(s, e, t, r = {}) {
    const n1 = s.videoCodec;
    if (!n1 && !s.audioCodec || !t) return Promise.resolve(Bg);
    const i = [], o = sb(s), a = o.length, l = nb(s, e, a > 0), c = l.length;
    for(let u = a || 1 * c || 1; u--;){
        const d1 = {
            type: "media-source"
        };
        if (a && (d1.video = o[u % a]), c) {
            d1.audio = l[u % c];
            const h = d1.audio.bitrate;
            d1.video && h && (d1.video.bitrate -= h);
        }
        i.push(d1);
    }
    if (n1) {
        const u = navigator.userAgent;
        if (n1.split(",").some((d1)=>ya(d1)) && Og()) return Promise.resolve(Fg(new Error(`Overriding Windows Firefox HEVC MediaCapabilities result based on user-agent string: (${u})`), i));
    }
    return Promise.all(i.map((u)=>{
        const d1 = ob(u);
        return r[d1] || (r[d1] = t.decodingInfo(u));
    })).then((u)=>({
            supported: !u.some((d1)=>!d1.supported),
            configurations: i,
            decodingInfoResults: u
        })).catch((u)=>({
            supported: !1,
            configurations: i,
            decodingInfoResults: [],
            error: u
        }));
}
function sb(s) {
    var e;
    const t = (e = s.videoCodec) == null ? void 0 : e.split(","), r = Ug(s), n1 = s.width || 640, i = s.height || 480, o = s.frameRate || 30, a = s.videoRange.toLowerCase();
    return t ? t.map((l)=>{
        const c = {
            contentType: pi(QS(l), "video"),
            width: n1,
            height: i,
            bitrate: r,
            framerate: o
        };
        return a !== "sdr" && (c.transferFunction = a), c;
    }) : [];
}
function nb(s, e, t) {
    var r;
    const n1 = (r = s.audioCodec) == null ? void 0 : r.split(","), i = Ug(s);
    return n1 && s.audioGroups ? s.audioGroups.reduce((o, a)=>{
        var l;
        const c = a ? (l = e.groups[a]) == null ? void 0 : l.tracks : null;
        return c ? c.reduce((u, d1)=>{
            if (d1.groupId === a) {
                const h = parseFloat(d1.channels || "");
                n1.forEach((f)=>{
                    const p = {
                        contentType: pi(f, "audio"),
                        bitrate: t ? ib(f, i) : i
                    };
                    h && (p.channels = "" + h), u.push(p);
                });
            }
            return u;
        }, o) : o;
    }, []) : [];
}
function ib(s, e) {
    if (e <= 1) return 1;
    let t = 128e3;
    return s === "ec-3" ? t = 768e3 : s === "ac-3" && (t = 64e4), Math.min(e / 2, t);
}
function Ug(s) {
    return Math.ceil(Math.max(s.bitrate * 0.9, s.averageBitrate) / 1e3) * 1e3 || 1;
}
function ob(s) {
    let e = "";
    const { audio: t, video: r } = s;
    if (r) {
        const n1 = lc(r.contentType);
        e += `${n1}_r${r.height}x${r.width}f${Math.ceil(r.framerate)}${r.transferFunction || "sd"}_${Math.ceil(r.bitrate / 1e5)}`;
    }
    if (t) {
        const n1 = lc(t.contentType);
        e += `${r ? "_" : ""}${n1}_c${t.channels}`;
    }
    return e;
}
const cc = [
    "NONE",
    "TYPE-0",
    "TYPE-1",
    null
];
function ab(s) {
    return cc.indexOf(s) > -1;
}
const Jo = [
    "SDR",
    "PQ",
    "HLG"
];
function lb(s) {
    return !!s && Jo.indexOf(s) > -1;
}
var go = {
    No: "",
    Yes: "YES",
    v2: "v2"
};
function oh(s) {
    const { canSkipUntil: e, canSkipDateRanges: t, age: r } = s, n1 = r < e / 2;
    return e && n1 ? t ? go.v2 : go.Yes : go.No;
}
class ah {
    constructor(e, t, r){
        this.msn = void 0, this.part = void 0, this.skip = void 0, this.msn = e, this.part = t, this.skip = r;
    }
    addDirectives(e) {
        const t = new self.URL(e);
        return this.msn !== void 0 && t.searchParams.set("_HLS_msn", this.msn.toString()), this.part !== void 0 && t.searchParams.set("_HLS_part", this.part.toString()), this.skip && t.searchParams.set("_HLS_skip", this.skip), t.href;
    }
}
class mi {
    constructor(e){
        if (this._attrs = void 0, this.audioCodec = void 0, this.bitrate = void 0, this.codecSet = void 0, this.url = void 0, this.frameRate = void 0, this.height = void 0, this.id = void 0, this.name = void 0, this.supplemental = void 0, this.videoCodec = void 0, this.width = void 0, this.details = void 0, this.fragmentError = 0, this.loadError = 0, this.loaded = void 0, this.realBitrate = 0, this.supportedPromise = void 0, this.supportedResult = void 0, this._avgBitrate = 0, this._audioGroups = void 0, this._subtitleGroups = void 0, this._urlId = 0, this.url = [
            e.url
        ], this._attrs = [
            e.attrs
        ], this.bitrate = e.bitrate, e.details && (this.details = e.details), this.id = e.id || 0, this.name = e.name, this.width = e.width || 0, this.height = e.height || 0, this.frameRate = e.attrs.optionalFloat("FRAME-RATE", 0), this._avgBitrate = e.attrs.decimalInteger("AVERAGE-BANDWIDTH"), this.audioCodec = e.audioCodec, this.videoCodec = e.videoCodec, this.codecSet = [
            e.videoCodec,
            e.audioCodec
        ].filter((r)=>!!r).map((r)=>r.substring(0, 4)).join(","), "supplemental" in e) {
            var t;
            this.supplemental = e.supplemental;
            const r = (t = e.supplemental) == null ? void 0 : t.videoCodec;
            r && r !== e.videoCodec && (this.codecSet += `,${r.substring(0, 4)}`);
        }
        this.addGroupId("audio", e.attrs.AUDIO), this.addGroupId("text", e.attrs.SUBTITLES);
    }
    get maxBitrate() {
        return Math.max(this.realBitrate, this.bitrate);
    }
    get averageBitrate() {
        return this._avgBitrate || this.realBitrate || this.bitrate;
    }
    get attrs() {
        return this._attrs[0];
    }
    get codecs() {
        return this.attrs.CODECS || "";
    }
    get pathwayId() {
        return this.attrs["PATHWAY-ID"] || ".";
    }
    get videoRange() {
        return this.attrs["VIDEO-RANGE"] || "SDR";
    }
    get score() {
        return this.attrs.optionalFloat("SCORE", 0);
    }
    get uri() {
        return this.url[0] || "";
    }
    hasAudioGroup(e) {
        return lh(this._audioGroups, e);
    }
    hasSubtitleGroup(e) {
        return lh(this._subtitleGroups, e);
    }
    get audioGroups() {
        return this._audioGroups;
    }
    get subtitleGroups() {
        return this._subtitleGroups;
    }
    addGroupId(e, t) {
        if (t) {
            if (e === "audio") {
                let r = this._audioGroups;
                r || (r = this._audioGroups = []), r.indexOf(t) === -1 && r.push(t);
            } else if (e === "text") {
                let r = this._subtitleGroups;
                r || (r = this._subtitleGroups = []), r.indexOf(t) === -1 && r.push(t);
            }
        }
    }
    // Deprecated methods (retained for backwards compatibility)
    get urlId() {
        return 0;
    }
    set urlId(e) {}
    get audioGroupIds() {
        return this.audioGroups ? [
            this.audioGroupId
        ] : void 0;
    }
    get textGroupIds() {
        return this.subtitleGroups ? [
            this.textGroupId
        ] : void 0;
    }
    get audioGroupId() {
        var e;
        return (e = this.audioGroups) == null ? void 0 : e[0];
    }
    get textGroupId() {
        var e;
        return (e = this.subtitleGroups) == null ? void 0 : e[0];
    }
    addFallback() {}
}
function lh(s, e) {
    return !e || !s ? !1 : s.indexOf(e) !== -1;
}
function cb() {
    if (typeof matchMedia == "function") {
        const s = matchMedia("(dynamic-range: high)"), e = matchMedia("bad query");
        if (s.media !== e.media) return s.matches === !0;
    }
    return !1;
}
function ub(s, e) {
    let t = !1, r = [];
    if (s && (t = s !== "SDR", r = [
        s
    ]), e) {
        r = e.allowedVideoRanges || Jo.slice(0);
        const n1 = r.join("") !== "SDR" && !e.videoCodec;
        t = e.preferHDR !== void 0 ? e.preferHDR : n1 && cb(), t || (r = [
            "SDR"
        ]);
    }
    return {
        preferHDR: t,
        allowedVideoRanges: r
    };
}
const db = (s)=>{
    const e = /* @__PURE__ */ new WeakSet();
    return (t, r)=>{
        if (s && (r = s(t, r)), typeof r == "object" && r !== null) {
            if (e.has(r)) return;
            e.add(r);
        }
        return r;
    };
}, at = (s, e)=>JSON.stringify(s, db(e));
function hb(s, e, t, r, n1) {
    const i = Object.keys(s), o = r == null ? void 0 : r.channels, a = r == null ? void 0 : r.audioCodec, l = n1 == null ? void 0 : n1.videoCodec, c = o && parseInt(o) === 2;
    let u = !1, d1 = !1, h = 1 / 0, f = 1 / 0, p = 1 / 0, y = 1 / 0, E = 0, b = [];
    const { preferHDR: L, allowedVideoRanges: A } = ub(e, n1);
    for(let j = i.length; j--;){
        const C = s[i[j]];
        u || (u = C.channels[2] > 0), h = Math.min(h, C.minHeight), f = Math.min(f, C.minFramerate), p = Math.min(p, C.minBitrate), A.filter(($)=>C.videoRanges[$] > 0).length > 0 && (d1 = !0);
    }
    h = ue(h) ? h : 0, f = ue(f) ? f : 0;
    const F = Math.max(1080, h), M = Math.max(30, f);
    p = ue(p) ? p : t, t = Math.max(p, t), d1 || (e = void 0);
    const H = i.length > 1;
    return {
        codecSet: i.reduce((j, C)=>{
            const k = s[C];
            if (C === j) return j;
            if (b = d1 ? A.filter(($)=>k.videoRanges[$] > 0) : [], H) {
                if (k.minBitrate > t) return Ur(C, `min bitrate of ${k.minBitrate} > current estimate of ${t}`), j;
                if (!k.hasDefaultAudio) return Ur(C, "no renditions with default or auto-select sound found"), j;
                if (a && C.indexOf(a.substring(0, 4)) % 5 !== 0) return Ur(C, `audio codec preference "${a}" not found`), j;
                if (o && !c) {
                    if (!k.channels[o]) return Ur(C, `no renditions with ${o} channel sound found (channels options: ${Object.keys(k.channels)})`), j;
                } else if ((!a || c) && u && k.channels[2] === 0) return Ur(C, "no renditions with stereo sound found"), j;
                if (k.minHeight > F) return Ur(C, `min resolution of ${k.minHeight} > maximum of ${F}`), j;
                if (k.minFramerate > M) return Ur(C, `min framerate of ${k.minFramerate} > maximum of ${M}`), j;
                if (!b.some(($)=>k.videoRanges[$] > 0)) return Ur(C, `no variants with VIDEO-RANGE of ${at(b)} found`), j;
                if (l && C.indexOf(l.substring(0, 4)) % 5 !== 0) return Ur(C, `video codec preference "${l}" not found`), j;
                if (k.maxScore < E) return Ur(C, `max score of ${k.maxScore} < selected max of ${E}`), j;
            }
            return j && (Zo(C) >= Zo(j) || k.fragmentError > s[j].fragmentError) ? j : (y = k.minIndex, E = k.maxScore, C);
        }, void 0),
        videoRanges: b,
        preferHDR: L,
        minFramerate: f,
        minBitrate: p,
        minIndex: y
    };
}
function Ur(s, e) {
    rt.log(`[abr] start candidates with "${s}" ignored because ${e}`);
}
function $g(s) {
    return s.reduce((e, t)=>{
        let r = e.groups[t.groupId];
        r || (r = e.groups[t.groupId] = {
            tracks: [],
            channels: {
                2: 0
            },
            hasDefault: !1,
            hasAutoSelect: !1
        }), r.tracks.push(t);
        const n1 = t.channels || "2";
        return r.channels[n1] = (r.channels[n1] || 0) + 1, r.hasDefault = r.hasDefault || t.default, r.hasAutoSelect = r.hasAutoSelect || t.autoselect, r.hasDefault && (e.hasDefaultAudio = !0), r.hasAutoSelect && (e.hasAutoSelectAudio = !0), e;
    }, {
        hasDefaultAudio: !1,
        hasAutoSelectAudio: !1,
        groups: {}
    });
}
function fb(s, e, t, r) {
    return s.slice(t, r + 1).reduce((n1, i, o)=>{
        if (!i.codecSet) return n1;
        const a = i.audioGroups;
        let l = n1[i.codecSet];
        l || (n1[i.codecSet] = l = {
            minBitrate: 1 / 0,
            minHeight: 1 / 0,
            minFramerate: 1 / 0,
            minIndex: o,
            maxScore: 0,
            videoRanges: {
                SDR: 0
            },
            channels: {
                2: 0
            },
            hasDefaultAudio: !a,
            fragmentError: 0
        }), l.minBitrate = Math.min(l.minBitrate, i.bitrate);
        const c = Math.min(i.height, i.width);
        return l.minHeight = Math.min(l.minHeight, c), l.minFramerate = Math.min(l.minFramerate, i.frameRate), l.minIndex = Math.min(l.minIndex, o), l.maxScore = Math.max(l.maxScore, i.score), l.fragmentError += i.fragmentError, l.videoRanges[i.videoRange] = (l.videoRanges[i.videoRange] || 0) + 1, a && a.forEach((u)=>{
            if (!u) return;
            const d1 = e.groups[u];
            d1 && (l.hasDefaultAudio = l.hasDefaultAudio || e.hasDefaultAudio ? d1.hasDefault : d1.hasAutoSelect || !e.hasDefaultAudio && !e.hasAutoSelectAudio, Object.keys(d1.channels).forEach((h)=>{
                l.channels[h] = (l.channels[h] || 0) + d1.channels[h];
            }));
        }), n1;
    }, {});
}
function ch(s) {
    if (!s) return s;
    const { lang: e, assocLang: t, characteristics: r, channels: n1, audioCodec: i } = s;
    return {
        lang: e,
        assocLang: t,
        characteristics: r,
        channels: n1,
        audioCodec: i
    };
}
function Wr(s, e, t) {
    if ("attrs" in s) {
        const r = e.indexOf(s);
        if (r !== -1) return r;
    }
    for(let r = 0; r < e.length; r++){
        const n1 = e[r];
        if (qs(s, n1, t)) return r;
    }
    return -1;
}
function qs(s, e, t) {
    const { groupId: r, name: n1, lang: i, assocLang: o, default: a } = s, l = s.forced;
    return (r === void 0 || e.groupId === r) && (n1 === void 0 || e.name === n1) && (i === void 0 || gb(i, e.lang)) && (i === void 0 || e.assocLang === o) && (a === void 0 || e.default === a) && (l === void 0 || e.forced === l) && (!("characteristics" in s) || pb(s.characteristics || "", e.characteristics)) && (t === void 0 || t(s, e));
}
function gb(s, e = "--") {
    return s.length === e.length ? s === e : s.startsWith(e) || e.startsWith(s);
}
function pb(s, e = "") {
    const t = s.split(","), r = e.split(",");
    return t.length === r.length && !t.some((n1)=>r.indexOf(n1) === -1);
}
function Us(s, e) {
    const { audioCodec: t, channels: r } = s;
    return (t === void 0 || (e.audioCodec || "").substring(0, 4) === t.substring(0, 4)) && (r === void 0 || r === (e.channels || "2"));
}
function mb(s, e, t, r, n1) {
    const i = e[r], a = e.reduce((h, f, p)=>{
        const y = f.uri;
        return (h[y] || (h[y] = [])).push(p), h;
    }, {})[i.uri];
    a.length > 1 && (r = Math.max.apply(Math, a));
    const l = i.videoRange, c = i.frameRate, u = i.codecSet.substring(0, 4), d1 = uh(e, r, (h)=>{
        if (h.videoRange !== l || h.frameRate !== c || h.codecSet.substring(0, 4) !== u) return !1;
        const f = h.audioGroups, p = t.filter((y)=>!f || f.indexOf(y.groupId) !== -1);
        return Wr(s, p, n1) > -1;
    });
    return d1 > -1 ? d1 : uh(e, r, (h)=>{
        const f = h.audioGroups, p = t.filter((y)=>!f || f.indexOf(y.groupId) !== -1);
        return Wr(s, p, n1) > -1;
    });
}
function uh(s, e, t) {
    for(let r = e; r > -1; r--)if (t(s[r])) return r;
    for(let r = e + 1; r < s.length; r++)if (t(s[r])) return r;
    return -1;
}
function Qo(s, e) {
    var t;
    return !!s && s !== ((t = e.loadLevelObj) == null ? void 0 : t.uri);
}
class yb extends Rr {
    constructor(e){
        super("abr", e.logger), this.hls = void 0, this.lastLevelLoadSec = 0, this.lastLoadedFragLevel = -1, this.firstSelection = -1, this._nextAutoLevel = -1, this.nextAutoLevelKey = "", this.audioTracksByGroup = null, this.codecTiers = null, this.timer = -1, this.fragCurrent = null, this.partCurrent = null, this.bitrateTestDelay = 0, this.rebufferNotice = -1, this.supportedCache = {}, this.bwEstimator = void 0, this._abandonRulesCheck = (t)=>{
            var r;
            const { fragCurrent: n1, partCurrent: i, hls: o } = this, { autoLevelEnabled: a, media: l } = o;
            if (!n1 || !l) return;
            const c = performance.now(), u = i ? i.stats : n1.stats, d1 = i ? i.duration : n1.duration, h = c - u.loading.start, f = o.minAutoLevel, p = n1.level, y = this._nextAutoLevel;
            if (u.aborted || u.loaded && u.loaded === u.total || p <= f) {
                this.clearTimer(), this._nextAutoLevel = -1;
                return;
            }
            if (!a) return;
            const E = y > -1 && y !== p, b = !!t || E;
            if (!b && (l.paused || !l.playbackRate || !l.readyState)) return;
            const L = o.mainForwardBufferInfo;
            if (!b && L === null) return;
            const A = this.bwEstimator.getEstimateTTFB(), F = Math.abs(l.playbackRate);
            if (h <= Math.max(A, 1e3 * (d1 / (F * 2)))) return;
            const M = L ? L.len / F : 0, H = u.loading.first ? u.loading.first - u.loading.start : -1, K = u.loaded && H > -1, j = this.getBwEstimate(), C = o.levels, k = C[p], $ = Math.max(u.loaded, Math.round(d1 * (n1.bitrate || k.averageBitrate) / 8));
            let W = K ? h - H : h;
            W < 1 && K && (W = Math.min(h, u.loaded * 8 / j));
            const _ = K ? u.loaded * 1e3 / W : 0, g = A / 1e3, x = _ ? ($ - u.loaded) / _ : $ * 8 / j + g;
            if (x <= M) return;
            const w = _ ? _ * 8 : j, D = ((r = (t == null ? void 0 : t.details) || this.hls.latestLevelDetails) == null ? void 0 : r.live) === !0, O = this.hls.config.abrBandWidthUpFactor;
            let U = Number.POSITIVE_INFINITY, V;
            for(V = p - 1; V > f; V--){
                const P = C[V].maxBitrate, N = !C[V].details || D;
                if (U = this.getTimeToLoadFrag(g, w, d1 * P, N), U < Math.min(M, d1 + g)) break;
            }
            if (U >= x || U > d1 * 10) return;
            K ? this.bwEstimator.sample(h - Math.min(A, H), u.loaded) : this.bwEstimator.sampleTTFB(h);
            const R = C[V].maxBitrate;
            this.getBwEstimate() * O > R && this.resetEstimator(R);
            const m = this.findBestLevel(R, f, V, 0, M, 1, 1);
            m > -1 && (V = m), this.warn(`Fragment ${n1.sn}${i ? " part " + i.index : ""} of level ${p} is loading too slowly;
      Fragment duration: ${n1.duration.toFixed(3)}
      Time to underbuffer: ${M.toFixed(3)} s
      Estimated load time for current fragment: ${x.toFixed(3)} s
      Estimated load time for down switch fragment: ${U.toFixed(3)} s
      TTFB estimate: ${H | 0} ms
      Current BW estimate: ${ue(j) ? j | 0 : "Unknown"} bps
      New BW estimate: ${this.getBwEstimate() | 0} bps
      Switching to level ${V} @ ${R | 0} bps`), o.nextLoadLevel = o.nextAutoLevel = V, this.clearTimer();
            const v = ()=>{
                if (this.clearTimer(), this.fragCurrent === n1 && this.hls.loadLevel === V && V > 0) {
                    const P = this.getStarvationDelay();
                    if (this.warn(`Aborting inflight request ${V > 0 ? "and switching down" : ""}
      Fragment duration: ${n1.duration.toFixed(3)} s
      Time to underbuffer: ${P.toFixed(3)} s`), n1.abortRequests(), this.fragCurrent = this.partCurrent = null, V > f) {
                        let N = this.findBestLevel(this.hls.levels[f].bitrate, f, V, 0, P, 1, 1);
                        N === -1 && (N = f), this.hls.nextLoadLevel = this.hls.nextAutoLevel = N, this.resetEstimator(this.hls.levels[N].bitrate);
                    }
                }
            };
            E || x > U * 2 ? v() : this.timer = self.setInterval(v, U * 1e3), o.trigger(I.FRAG_LOAD_EMERGENCY_ABORTED, {
                frag: n1,
                part: i,
                stats: u
            });
        }, this.hls = e, this.bwEstimator = this.initEstimator(), this.registerListeners();
    }
    resetEstimator(e) {
        e && (this.log(`setting initial bwe to ${e}`), this.hls.config.abrEwmaDefaultEstimate = e), this.firstSelection = -1, this.bwEstimator = this.initEstimator();
    }
    initEstimator() {
        const e = this.hls.config;
        return new TS(e.abrEwmaSlowVoD, e.abrEwmaFastVoD, e.abrEwmaDefaultEstimate);
    }
    registerListeners() {
        const { hls: e } = this;
        e.on(I.MANIFEST_LOADING, this.onManifestLoading, this), e.on(I.FRAG_LOADING, this.onFragLoading, this), e.on(I.FRAG_LOADED, this.onFragLoaded, this), e.on(I.FRAG_BUFFERED, this.onFragBuffered, this), e.on(I.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on(I.LEVEL_LOADED, this.onLevelLoaded, this), e.on(I.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(I.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this), e.on(I.ERROR, this.onError, this);
    }
    unregisterListeners() {
        const { hls: e } = this;
        e && (e.off(I.MANIFEST_LOADING, this.onManifestLoading, this), e.off(I.FRAG_LOADING, this.onFragLoading, this), e.off(I.FRAG_LOADED, this.onFragLoaded, this), e.off(I.FRAG_BUFFERED, this.onFragBuffered, this), e.off(I.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off(I.LEVEL_LOADED, this.onLevelLoaded, this), e.off(I.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(I.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this), e.off(I.ERROR, this.onError, this));
    }
    destroy() {
        this.unregisterListeners(), this.clearTimer(), this.hls = this._abandonRulesCheck = this.supportedCache = null, this.fragCurrent = this.partCurrent = null;
    }
    onManifestLoading(e, t) {
        this.lastLoadedFragLevel = -1, this.firstSelection = -1, this.lastLevelLoadSec = 0, this.supportedCache = {}, this.fragCurrent = this.partCurrent = null, this.onLevelsUpdated(), this.clearTimer();
    }
    onLevelsUpdated() {
        this.lastLoadedFragLevel > -1 && this.fragCurrent && (this.lastLoadedFragLevel = this.fragCurrent.level), this._nextAutoLevel = -1, this.onMaxAutoLevelUpdated(), this.codecTiers = null, this.audioTracksByGroup = null;
    }
    onMaxAutoLevelUpdated() {
        this.firstSelection = -1, this.nextAutoLevelKey = "";
    }
    onFragLoading(e, t) {
        const r = t.frag;
        if (!this.ignoreFragment(r)) {
            if (!r.bitrateTest) {
                var n1;
                this.fragCurrent = r, this.partCurrent = (n1 = t.part) != null ? n1 : null;
            }
            this.clearTimer(), this.timer = self.setInterval(this._abandonRulesCheck, 100);
        }
    }
    onLevelSwitching(e, t) {
        this.clearTimer();
    }
    onError(e, t) {
        if (!t.fatal) switch(t.details){
            case J.BUFFER_ADD_CODEC_ERROR:
            case J.BUFFER_APPEND_ERROR:
                this.lastLoadedFragLevel = -1, this.firstSelection = -1;
                break;
            case J.FRAG_LOAD_TIMEOUT:
                {
                    const r = t.frag, { fragCurrent: n1, partCurrent: i } = this;
                    if (r && n1 && r.sn === n1.sn && r.level === n1.level) {
                        const o = performance.now(), a = i ? i.stats : r.stats, l = o - a.loading.start, c = a.loading.first ? a.loading.first - a.loading.start : -1;
                        if (a.loaded && c > -1) {
                            const d1 = this.bwEstimator.getEstimateTTFB();
                            this.bwEstimator.sample(l - Math.min(d1, c), a.loaded);
                        } else this.bwEstimator.sampleTTFB(l);
                    }
                    break;
                }
        }
    }
    getTimeToLoadFrag(e, t, r, n1) {
        const i = e + r / t, o = n1 ? e + this.lastLevelLoadSec : 0;
        return i + o;
    }
    onLevelLoaded(e, t) {
        const r = this.hls.config, { loading: n1 } = t.stats, i = n1.end - n1.first;
        ue(i) && (this.lastLevelLoadSec = i / 1e3), t.details.live ? this.bwEstimator.update(r.abrEwmaSlowLive, r.abrEwmaFastLive) : this.bwEstimator.update(r.abrEwmaSlowVoD, r.abrEwmaFastVoD), this.timer > -1 && this._abandonRulesCheck(t.levelInfo);
    }
    onFragLoaded(e, { frag: t, part: r }) {
        const n1 = r ? r.stats : t.stats;
        if (t.type === pe.MAIN && this.bwEstimator.sampleTTFB(n1.loading.first - n1.loading.start), !this.ignoreFragment(t)) {
            if (this.clearTimer(), t.level === this._nextAutoLevel && (this._nextAutoLevel = -1), this.firstSelection = -1, this.hls.config.abrMaxWithRealBitrate) {
                const i = r ? r.duration : t.duration, o = this.hls.levels[t.level], a = (o.loaded ? o.loaded.bytes : 0) + n1.loaded, l = (o.loaded ? o.loaded.duration : 0) + i;
                o.loaded = {
                    bytes: a,
                    duration: l
                }, o.realBitrate = Math.round(8 * a / l);
            }
            if (t.bitrateTest) {
                const i = {
                    stats: n1,
                    frag: t,
                    part: r,
                    id: t.type
                };
                this.onFragBuffered(I.FRAG_BUFFERED, i), t.bitrateTest = !1;
            } else this.lastLoadedFragLevel = t.level;
        }
    }
    onFragBuffered(e, t) {
        const { frag: r, part: n1 } = t, i = n1 != null && n1.stats.loaded ? n1.stats : r.stats;
        if (i.aborted || this.ignoreFragment(r)) return;
        const o = i.parsing.end - i.loading.start - Math.min(i.loading.first - i.loading.start, this.bwEstimator.getEstimateTTFB());
        this.bwEstimator.sample(o, i.loaded), i.bwEstimate = this.getBwEstimate(), r.bitrateTest ? this.bitrateTestDelay = o / 1e3 : this.bitrateTestDelay = 0;
    }
    ignoreFragment(e) {
        return e.type !== pe.MAIN || e.sn === "initSegment";
    }
    clearTimer() {
        this.timer > -1 && (self.clearInterval(this.timer), this.timer = -1);
    }
    get firstAutoLevel() {
        const { maxAutoLevel: e, minAutoLevel: t } = this.hls, r = this.getBwEstimate(), n1 = this.hls.config.maxStarvationDelay, i = this.findBestLevel(r, t, e, 0, n1, 1, 1);
        if (i > -1) return i;
        const o = this.hls.firstLevel, a = Math.min(Math.max(o, t), e);
        return this.warn(`Could not find best starting auto level. Defaulting to first in playlist ${o} clamped to ${a}`), a;
    }
    get forcedAutoLevel() {
        return this.nextAutoLevelKey ? -1 : this._nextAutoLevel;
    }
    // return next auto level
    get nextAutoLevel() {
        const e = this.forcedAutoLevel, r = this.bwEstimator.canEstimate(), n1 = this.lastLoadedFragLevel > -1;
        if (e !== -1 && (!r || !n1 || this.nextAutoLevelKey === this.getAutoLevelKey())) return e;
        const i = r && n1 ? this.getNextABRAutoLevel() : this.firstAutoLevel;
        if (e !== -1) {
            const o = this.hls.levels;
            if (o.length > Math.max(e, i) && o[e].loadError <= o[i].loadError) return e;
        }
        return this._nextAutoLevel = i, this.nextAutoLevelKey = this.getAutoLevelKey(), i;
    }
    getAutoLevelKey() {
        return `${this.getBwEstimate()}_${this.getStarvationDelay().toFixed(2)}`;
    }
    getNextABRAutoLevel() {
        const { fragCurrent: e, partCurrent: t, hls: r } = this;
        if (r.levels.length <= 1) return r.loadLevel;
        const { maxAutoLevel: n1, config: i, minAutoLevel: o } = r, a = t ? t.duration : e ? e.duration : 0, l = this.getBwEstimate(), c = this.getStarvationDelay();
        let u = i.abrBandWidthFactor, d1 = i.abrBandWidthUpFactor;
        if (c) {
            const E = this.findBestLevel(l, o, n1, c, 0, u, d1);
            if (E >= 0) return this.rebufferNotice = -1, E;
        }
        let h = a ? Math.min(a, i.maxStarvationDelay) : i.maxStarvationDelay;
        if (!c) {
            const E = this.bitrateTestDelay;
            E && (h = (a ? Math.min(a, i.maxLoadingDelay) : i.maxLoadingDelay) - E, this.info(`bitrate test took ${Math.round(1e3 * E)}ms, set first fragment max fetchDuration to ${Math.round(1e3 * h)} ms`), u = d1 = 1);
        }
        const f = this.findBestLevel(l, o, n1, c, h, u, d1);
        if (this.rebufferNotice !== f && (this.rebufferNotice = f, this.info(`${c ? "rebuffering expected" : "buffer is empty"}, optimal quality level ${f}`)), f > -1) return f;
        const p = r.levels[o], y = r.loadLevelObj;
        return y && (p == null ? void 0 : p.bitrate) < y.bitrate ? o : r.loadLevel;
    }
    getStarvationDelay() {
        const e = this.hls, t = e.media;
        if (!t) return 1 / 0;
        const r = t && t.playbackRate !== 0 ? Math.abs(t.playbackRate) : 1, n1 = e.mainForwardBufferInfo;
        return (n1 ? n1.len : 0) / r;
    }
    getBwEstimate() {
        return this.bwEstimator.canEstimate() ? this.bwEstimator.getEstimate() : this.hls.config.abrEwmaDefaultEstimate;
    }
    findBestLevel(e, t, r, n1, i, o, a) {
        var l;
        const c = n1 + i, u = this.lastLoadedFragLevel, d1 = u === -1 ? this.hls.firstLevel : u, { fragCurrent: h, partCurrent: f } = this, { levels: p, allAudioTracks: y, loadLevel: E, config: b } = this.hls;
        if (p.length === 1) return 0;
        const L = p[d1], A = !!((l = this.hls.latestLevelDetails) != null && l.live), F = E === -1 || u === -1;
        let M, H = "SDR", K = (L == null ? void 0 : L.frameRate) || 0;
        const { audioPreference: j, videoPreference: C } = b, k = this.audioTracksByGroup || (this.audioTracksByGroup = $g(y));
        let $ = -1;
        if (F) {
            if (this.firstSelection !== -1) return this.firstSelection;
            const w = this.codecTiers || (this.codecTiers = fb(p, k, t, r)), D = hb(w, H, e, j, C), { codecSet: O, videoRanges: U, minFramerate: V, minBitrate: R, minIndex: m, preferHDR: v } = D;
            $ = m, M = O, H = v ? U[U.length - 1] : U[0], K = V, e = Math.max(e, R), this.log(`picked start tier ${at(D)}`);
        } else M = L == null ? void 0 : L.codecSet, H = L == null ? void 0 : L.videoRange;
        const W = f ? f.duration : h ? h.duration : 0, _ = this.bwEstimator.getEstimateTTFB() / 1e3, g = [];
        for(let w = r; w >= t; w--){
            var x;
            const D = p[w], O = w > d1;
            if (!D) continue;
            if (b.useMediaCapabilities && !D.supportedResult && !D.supportedPromise) {
                const N = navigator.mediaCapabilities;
                typeof (N == null ? void 0 : N.decodingInfo) == "function" && rb(D, k, H, K, e, j) ? (D.supportedPromise = Ng(D, k, N, this.supportedCache), D.supportedPromise.then((Y)=>{
                    if (!this.hls) return;
                    D.supportedResult = Y;
                    const ee = this.hls.levels, ie = ee.indexOf(D);
                    Y.error ? this.warn(`MediaCapabilities decodingInfo error: "${Y.error}" for level ${ie} ${at(Y)}`) : Y.supported ? Y.decodingInfoResults.some((le)=>le.smooth === !1 || le.powerEfficient === !1) && this.log(`MediaCapabilities decodingInfo for level ${ie} not smooth or powerEfficient: ${at(Y)}`) : (this.warn(`Unsupported MediaCapabilities decodingInfo result for level ${ie} ${at(Y)}`), ie > -1 && ee.length > 1 && (this.log(`Removing unsupported level ${ie}`), this.hls.removeLevel(ie), this.hls.loadLevel === -1 && (this.hls.nextLoadLevel = 0)));
                }).catch((Y)=>{
                    this.warn(`Error handling MediaCapabilities decodingInfo: ${Y}`);
                })) : D.supportedResult = Bg;
            }
            if ((M && D.codecSet !== M || H && D.videoRange !== H || O && K > D.frameRate || !O && K > 0 && K < D.frameRate || (x = D.supportedResult) != null && (x = x.decodingInfoResults) != null && x.some((N)=>N.smooth === !1)) && (!F || w !== $)) {
                g.push(w);
                continue;
            }
            const U = D.details, V = (f ? U == null ? void 0 : U.partTarget : U == null ? void 0 : U.averagetargetduration) || W;
            let R;
            O ? R = a * e : R = o * e;
            const m = W && n1 >= W * 2 && i === 0 ? D.averageBitrate : D.maxBitrate, v = this.getTimeToLoadFrag(_, R, m * V, U === void 0);
            if (// if adjusted bw is greater than level bitrate AND
            R >= m && // no level change, or new level has no error history
            (w === u || D.loadError === 0 && D.fragmentError === 0) && // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches
            // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...
            // special case to support startLevel = -1 (bitrateTest) on live streams : in that case we should not exit loop so that findBestLevel will return -1
            (v <= _ || !ue(v) || A && !this.bitrateTestDelay || v < c)) {
                const N = this.forcedAutoLevel;
                return w !== E && (N === -1 || N !== E) && (g.length && this.trace(`Skipped level(s) ${g.join(",")} of ${r} max with CODECS and VIDEO-RANGE:"${p[g[0]].codecs}" ${p[g[0]].videoRange}; not compatible with "${M}" ${H}`), this.info(`switch candidate:${d1}->${w} adjustedbw(${Math.round(R)})-bitrate=${Math.round(R - m)} ttfb:${_.toFixed(1)} avgDuration:${V.toFixed(1)} maxFetchDuration:${c.toFixed(1)} fetchDuration:${v.toFixed(1)} firstSelection:${F} codecSet:${D.codecSet} videoRange:${D.videoRange} hls.loadLevel:${E}`)), F && (this.firstSelection = w), w;
            }
        }
        return -1;
    }
    set nextAutoLevel(e) {
        const t = this.deriveNextAutoLevel(e);
        this._nextAutoLevel !== t && (this.nextAutoLevelKey = "", this._nextAutoLevel = t);
    }
    deriveNextAutoLevel(e) {
        const { maxAutoLevel: t, minAutoLevel: r } = this.hls;
        return Math.min(Math.max(e, r), t);
    }
}
const Gg = {
    /**
   * Searches for an item in an array which matches a certain condition.
   * This requires the condition to only match one item in the array,
   * and for the array to be ordered.
   *
   * @param list The array to search.
   * @param comparisonFn
   *      Called and provided a candidate item as the first argument.
   *      Should return:
   *          > -1 if the item should be located at a lower index than the provided item.
   *          > 1 if the item should be located at a higher index than the provided item.
   *          > 0 if the item is the item you're looking for.
   *
   * @returns the object if found, otherwise returns null
   */ search: function(s, e) {
        let t = 0, r = s.length - 1, n1 = null, i = null;
        for(; t <= r;){
            n1 = (t + r) / 2 | 0, i = s[n1];
            const o = e(i);
            if (o > 0) t = n1 + 1;
            else if (o < 0) r = n1 - 1;
            else return i;
        }
        return null;
    }
};
function vb(s, e, t) {
    if (e === null || !Array.isArray(s) || !s.length || !ue(e)) return null;
    const r = s[0].programDateTime;
    if (e < (r || 0)) return null;
    const n1 = s[s.length - 1].endProgramDateTime;
    if (e >= (n1 || 0)) return null;
    for(let i = 0; i < s.length; ++i){
        const o = s[i];
        if (xb(e, t, o)) return o;
    }
    return null;
}
function Js(s, e, t = 0, r = 0, n1 = 5e-3) {
    let i = null;
    if (s) {
        i = e[1 + s.sn - e[0].sn] || null;
        const a = s.endDTS - t;
        a > 0 && a < 15e-7 && (t += 15e-7), i && s.level !== i.level && i.end <= s.end && (i = e[2 + s.sn - e[0].sn] || null);
    } else t === 0 && e[0].start === 0 && (i = e[0]);
    if (i && ((!s || s.level === i.level) && dh(t, r, i) === 0 || Eb(i, s, Math.min(n1, r)))) return i;
    const o = Gg.search(e, dh.bind(null, t, r));
    return o && (o !== s || !i) ? o : i;
}
function Eb(s, e, t) {
    if (e && e.start === 0 && e.level < s.level && (e.endPTS || 0) > 0) {
        const r = e.tagList.reduce((n1, i)=>(i[0] === "INF" && (n1 += parseFloat(i[1])), n1), t);
        return s.start <= r;
    }
    return !1;
}
function dh(s = 0, e = 0, t) {
    if (t.start <= s && t.start + t.duration > s) return 0;
    const r = Math.min(e, t.duration + (t.deltaPTS ? t.deltaPTS : 0));
    return t.start + t.duration - r <= s ? 1 : t.start - r > s && t.start ? -1 : 0;
}
function xb(s, e, t) {
    const r = Math.min(e, t.duration + (t.deltaPTS ? t.deltaPTS : 0)) * 1e3;
    return (t.endProgramDateTime || 0) - r > s;
}
function Vg(s, e, t) {
    if (s && s.startCC <= e && s.endCC >= e) {
        let r = s.fragments;
        const { fragmentHint: n1 } = s;
        n1 && (r = r.concat(n1));
        let i;
        return Gg.search(r, (o)=>o.cc < e ? 1 : o.cc > e ? -1 : (i = o, o.end <= t ? 1 : o.start > t ? -1 : 0)), i || null;
    }
    return null;
}
function ea(s) {
    switch(s.details){
        case J.FRAG_LOAD_TIMEOUT:
        case J.KEY_LOAD_TIMEOUT:
        case J.LEVEL_LOAD_TIMEOUT:
        case J.MANIFEST_LOAD_TIMEOUT:
            return !0;
    }
    return !1;
}
function jg(s) {
    return s.details.startsWith("key");
}
function Kg(s) {
    return jg(s) && !!s.frag && !s.frag.decryptdata;
}
function hh(s, e) {
    const t = ea(e);
    return s.default[`${t ? "timeout" : "error"}Retry`];
}
function yu(s, e) {
    const t = s.backoff === "linear" ? 1 : Math.pow(2, e);
    return Math.min(t * s.retryDelayMs, s.maxRetryDelayMs);
}
function fh(s) {
    return tt(tt({}, s), {
        errorRetry: null,
        timeoutRetry: null
    });
}
function ta(s, e, t, r) {
    if (!s) return !1;
    const n1 = r == null ? void 0 : r.code, i = e < s.maxNumRetry && (Sb(n1) || !!t);
    return s.shouldRetry ? s.shouldRetry(s, e, t, r, i) : i;
}
function Sb(s) {
    return uc(s) || !!s && (s < 400 || s > 499);
}
function uc(s) {
    return s === 0 && navigator.onLine === !1;
}
var Zt = {
    DoNothing: 0,
    SendAlternateToPenaltyBox: 2,
    RemoveAlternatePermanently: 3,
    RetryRequest: 5
}, vr = {
    None: 0,
    MoveAllAlternatesMatchingHost: 1,
    MoveAllAlternatesMatchingHDCP: 2,
    MoveAllAlternatesMatchingKey: 4
};
class bb extends Rr {
    constructor(e){
        super("error-controller", e.logger), this.hls = void 0, this.playlistError = 0, this.hls = e, this.registerListeners();
    }
    registerListeners() {
        const e = this.hls;
        e.on(I.ERROR, this.onError, this), e.on(I.MANIFEST_LOADING, this.onManifestLoading, this), e.on(I.LEVEL_UPDATED, this.onLevelUpdated, this);
    }
    unregisterListeners() {
        const e = this.hls;
        e && (e.off(I.ERROR, this.onError, this), e.off(I.ERROR, this.onErrorOut, this), e.off(I.MANIFEST_LOADING, this.onManifestLoading, this), e.off(I.LEVEL_UPDATED, this.onLevelUpdated, this));
    }
    destroy() {
        this.unregisterListeners(), this.hls = null;
    }
    startLoad(e) {}
    stopLoad() {
        this.playlistError = 0;
    }
    getVariantLevelIndex(e) {
        return (e == null ? void 0 : e.type) === pe.MAIN ? e.level : this.getVariantIndex();
    }
    getVariantIndex() {
        var e;
        const t = this.hls, r = t.currentLevel;
        return (e = t.loadLevelObj) != null && e.details || r === -1 ? t.loadLevel : r;
    }
    variantHasKey(e, t) {
        if (e) {
            var r;
            if ((r = e.details) != null && r.hasKey(t)) return !0;
            const n1 = e.audioGroups;
            if (n1) return this.hls.allAudioTracks.filter((o)=>n1.indexOf(o.groupId) >= 0).some((o)=>{
                var a;
                return (a = o.details) == null ? void 0 : a.hasKey(t);
            });
        }
        return !1;
    }
    onManifestLoading() {
        this.playlistError = 0;
    }
    onLevelUpdated() {
        this.playlistError = 0;
    }
    onError(e, t) {
        var r;
        if (t.fatal) return;
        const n1 = this.hls, i = t.context;
        switch(t.details){
            case J.FRAG_LOAD_ERROR:
            case J.FRAG_LOAD_TIMEOUT:
            case J.KEY_LOAD_ERROR:
            case J.KEY_LOAD_TIMEOUT:
                t.errorAction = this.getFragRetryOrSwitchAction(t);
                return;
            case J.FRAG_PARSING_ERROR:
                if ((r = t.frag) != null && r.gap) {
                    t.errorAction = Tn();
                    return;
                }
            // falls through
            case J.FRAG_GAP:
            case J.FRAG_DECRYPT_ERROR:
                {
                    t.errorAction = this.getFragRetryOrSwitchAction(t), t.errorAction.action = Zt.SendAlternateToPenaltyBox;
                    return;
                }
            case J.LEVEL_EMPTY_ERROR:
            case J.LEVEL_PARSING_ERROR:
                {
                    var o;
                    const l = t.parent === pe.MAIN ? t.level : n1.loadLevel;
                    t.details === J.LEVEL_EMPTY_ERROR && (o = t.context) != null && (o = o.levelDetails) != null && o.live ? t.errorAction = this.getPlaylistRetryOrSwitchAction(t, l) : (t.levelRetry = !1, t.errorAction = this.getLevelSwitchAction(t, l));
                }
                return;
            case J.LEVEL_LOAD_ERROR:
            case J.LEVEL_LOAD_TIMEOUT:
                typeof (i == null ? void 0 : i.level) == "number" && (t.errorAction = this.getPlaylistRetryOrSwitchAction(t, i.level));
                return;
            case J.AUDIO_TRACK_LOAD_ERROR:
            case J.AUDIO_TRACK_LOAD_TIMEOUT:
            case J.SUBTITLE_LOAD_ERROR:
            case J.SUBTITLE_TRACK_LOAD_TIMEOUT:
                if (i) {
                    const l = n1.loadLevelObj;
                    if (l && (i.type === Ke.AUDIO_TRACK && l.hasAudioGroup(i.groupId) || i.type === Ke.SUBTITLE_TRACK && l.hasSubtitleGroup(i.groupId))) {
                        t.errorAction = this.getPlaylistRetryOrSwitchAction(t, n1.loadLevel), t.errorAction.action = Zt.SendAlternateToPenaltyBox, t.errorAction.flags = vr.MoveAllAlternatesMatchingHost;
                        return;
                    }
                }
                return;
            case J.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED:
                t.errorAction = {
                    action: Zt.SendAlternateToPenaltyBox,
                    flags: vr.MoveAllAlternatesMatchingHDCP
                };
                return;
            case J.KEY_SYSTEM_SESSION_UPDATE_FAILED:
            case J.KEY_SYSTEM_STATUS_INTERNAL_ERROR:
            case J.KEY_SYSTEM_NO_SESSION:
                t.errorAction = {
                    action: Zt.SendAlternateToPenaltyBox,
                    flags: vr.MoveAllAlternatesMatchingKey
                };
                return;
            case J.BUFFER_ADD_CODEC_ERROR:
            case J.REMUX_ALLOC_ERROR:
            case J.BUFFER_APPEND_ERROR:
                if (!t.errorAction) {
                    var a;
                    t.errorAction = this.getLevelSwitchAction(t, (a = t.level) != null ? a : n1.loadLevel);
                }
                return;
            case J.INTERNAL_EXCEPTION:
            case J.BUFFER_APPENDING_ERROR:
            case J.BUFFER_FULL_ERROR:
            case J.LEVEL_SWITCH_ERROR:
            case J.BUFFER_STALLED_ERROR:
            case J.BUFFER_SEEK_OVER_HOLE:
            case J.BUFFER_NUDGE_ON_STALL:
                t.errorAction = Tn();
                return;
        }
        t.type === ve.KEY_SYSTEM_ERROR && (t.levelRetry = !1, t.errorAction = Tn());
    }
    getPlaylistRetryOrSwitchAction(e, t) {
        const r = this.hls, n1 = hh(r.config.playlistLoadPolicy, e), i = this.playlistError++;
        if (ta(n1, i, ea(e), e.response)) return {
            action: Zt.RetryRequest,
            flags: vr.None,
            retryConfig: n1,
            retryCount: i
        };
        const a = this.getLevelSwitchAction(e, t);
        return n1 && (a.retryConfig = n1, a.retryCount = i), a;
    }
    getFragRetryOrSwitchAction(e) {
        const t = this.hls, r = this.getVariantLevelIndex(e.frag), n1 = t.levels[r], { fragLoadPolicy: i, keyLoadPolicy: o } = t.config, a = hh(jg(e) ? o : i, e), l = t.levels.reduce((u, d1)=>u + d1.fragmentError, 0);
        if (n1 && (e.details !== J.FRAG_GAP && n1.fragmentError++, !Kg(e) && ta(a, l, ea(e), e.response))) return {
            action: Zt.RetryRequest,
            flags: vr.None,
            retryConfig: a,
            retryCount: l
        };
        const c = this.getLevelSwitchAction(e, r);
        return a && (c.retryConfig = a, c.retryCount = l), c;
    }
    getLevelSwitchAction(e, t) {
        const r = this.hls;
        t == null && (t = r.loadLevel);
        const n1 = this.hls.levels[t];
        if (n1) {
            var i, o;
            const c = e.details;
            n1.loadError++, c === J.BUFFER_APPEND_ERROR && n1.fragmentError++;
            let u = -1;
            const { levels: d1, loadLevel: h, minAutoLevel: f, maxAutoLevel: p } = r;
            !r.autoLevelEnabled && !r.config.preserveManualLevelOnError && (r.loadLevel = -1);
            const y = (i = e.frag) == null ? void 0 : i.type, b = (y === pe.AUDIO && c === J.FRAG_PARSING_ERROR || e.sourceBufferName === "audio" && (c === J.BUFFER_ADD_CODEC_ERROR || c === J.BUFFER_APPEND_ERROR)) && d1.some(({ audioCodec: H })=>n1.audioCodec !== H), A = e.sourceBufferName === "video" && (c === J.BUFFER_ADD_CODEC_ERROR || c === J.BUFFER_APPEND_ERROR) && d1.some(({ codecSet: H, audioCodec: K })=>n1.codecSet !== H && n1.audioCodec === K), { type: F, groupId: M } = (o = e.context) != null ? o : {};
            for(let H = d1.length; H--;){
                const K = (H + h) % d1.length;
                if (K !== h && K >= f && K <= p && d1[K].loadError === 0) {
                    var a, l;
                    const j = d1[K];
                    if (c === J.FRAG_GAP && y === pe.MAIN && e.frag) {
                        const C = d1[K].details;
                        if (C) {
                            const k = Js(e.frag, C.fragments, e.frag.start);
                            if (k != null && k.gap) continue;
                        }
                    } else {
                        if (F === Ke.AUDIO_TRACK && j.hasAudioGroup(M) || F === Ke.SUBTITLE_TRACK && j.hasSubtitleGroup(M)) continue;
                        if (y === pe.AUDIO && (a = n1.audioGroups) != null && a.some((C)=>j.hasAudioGroup(C)) || y === pe.SUBTITLE && (l = n1.subtitleGroups) != null && l.some((C)=>j.hasSubtitleGroup(C)) || b && n1.audioCodec === j.audioCodec || A && n1.codecSet === j.codecSet || !b && n1.codecSet !== j.codecSet) continue;
                    }
                    u = K;
                    break;
                }
            }
            if (u > -1 && r.loadLevel !== u) return e.levelRetry = !0, this.playlistError = 0, {
                action: Zt.SendAlternateToPenaltyBox,
                flags: vr.None,
                nextAutoLevel: u
            };
        }
        return {
            action: Zt.SendAlternateToPenaltyBox,
            flags: vr.MoveAllAlternatesMatchingHost
        };
    }
    onErrorOut(e, t) {
        var r;
        switch((r = t.errorAction) == null ? void 0 : r.action){
            case Zt.DoNothing:
                break;
            case Zt.SendAlternateToPenaltyBox:
                this.sendAlternateToPenaltyBox(t), !t.errorAction.resolved && t.details !== J.FRAG_GAP ? t.fatal = !0 : /MediaSource readyState: ended/.test(t.error.message) && (this.warn(`MediaSource ended after "${t.sourceBufferName}" sourceBuffer append error. Attempting to recover from media error.`), this.hls.recoverMediaError());
                break;
        }
        if (t.fatal) {
            this.hls.stopLoad();
            return;
        }
    }
    sendAlternateToPenaltyBox(e) {
        const t = this.hls, r = e.errorAction;
        if (!r) return;
        const { flags: n1 } = r, i = r.nextAutoLevel;
        switch(n1){
            case vr.None:
                this.switchLevel(e, i);
                break;
            case vr.MoveAllAlternatesMatchingHDCP:
                {
                    const l = this.getVariantLevelIndex(e.frag), c = t.levels[l], u = c == null ? void 0 : c.attrs["HDCP-LEVEL"];
                    if (r.hdcpLevel = u, u === "NONE") this.warn("HDCP policy resticted output with HDCP-LEVEL=NONE");
                    else if (u) {
                        t.maxHdcpLevel = cc[cc.indexOf(u) - 1], r.resolved = !0, this.warn(`Restricting playback to HDCP-LEVEL of "${t.maxHdcpLevel}" or lower`);
                        break;
                    }
                }
            // eslint-disable-next-line no-fallthrough
            case vr.MoveAllAlternatesMatchingKey:
                {
                    const l = e.decryptdata;
                    if (l) {
                        const c = this.hls.levels, u = c.length;
                        for(let h = u; h--;)if (this.variantHasKey(c[h], l)) {
                            var o, a;
                            this.log(`Banned key found in level ${h} (${c[h].bitrate}bps) or audio group "${(o = c[h].audioGroups) == null ? void 0 : o.join(",")}" (${(a = e.frag) == null ? void 0 : a.type} fragment) ${fr(l.keyId || [])}`), c[h].fragmentError++, c[h].loadError++, this.log(`Removing level ${h} with key error (${e.error})`), this.hls.removeLevel(h);
                        }
                        const d1 = e.frag;
                        if (this.hls.levels.length < u) r.resolved = !0;
                        else if (d1 && d1.type !== pe.MAIN) {
                            const h = d1.decryptdata;
                            h && !l.matches(h) && (r.resolved = !0);
                        }
                    }
                    break;
                }
        }
        r.resolved || this.switchLevel(e, i);
    }
    switchLevel(e, t) {
        if (t !== void 0 && e.errorAction && (this.warn(`switching to level ${t} after ${e.details}`), this.hls.nextAutoLevel = t, e.errorAction.resolved = !0, this.hls.nextLoadLevel = this.hls.nextAutoLevel, e.details === J.BUFFER_ADD_CODEC_ERROR && e.mimeType && e.sourceBufferName !== "audiovideo")) {
            const r = lc(e.mimeType), n1 = this.hls.levels;
            for(let i = n1.length; i--;)n1[i][`${e.sourceBufferName}Codec`] === r && (this.log(`Removing level ${i} for ${e.details} ("${r}" not supported)`), this.hls.removeLevel(i));
        }
    }
}
function Tn(s) {
    const e = {
        action: Zt.DoNothing,
        flags: vr.None
    };
    return s && (e.resolved = !0), e;
}
var Ht = {
    NOT_LOADED: "NOT_LOADED",
    APPENDING: "APPENDING",
    PARTIAL: "PARTIAL",
    OK: "OK"
};
class Tb {
    constructor(e){
        this.activePartLists = /* @__PURE__ */ Object.create(null), this.endListFragments = /* @__PURE__ */ Object.create(null), this.fragments = /* @__PURE__ */ Object.create(null), this.timeRanges = /* @__PURE__ */ Object.create(null), this.bufferPadding = 0.2, this.hls = void 0, this.hasGaps = !1, this.hls = e, this._registerListeners();
    }
    _registerListeners() {
        const { hls: e } = this;
        e && (e.on(I.MANIFEST_LOADING, this.onManifestLoading, this), e.on(I.BUFFER_APPENDED, this.onBufferAppended, this), e.on(I.FRAG_BUFFERED, this.onFragBuffered, this), e.on(I.FRAG_LOADED, this.onFragLoaded, this));
    }
    _unregisterListeners() {
        const { hls: e } = this;
        e && (e.off(I.MANIFEST_LOADING, this.onManifestLoading, this), e.off(I.BUFFER_APPENDED, this.onBufferAppended, this), e.off(I.FRAG_BUFFERED, this.onFragBuffered, this), e.off(I.FRAG_LOADED, this.onFragLoaded, this));
    }
    destroy() {
        this._unregisterListeners(), this.hls = this.fragments = this.activePartLists = this.endListFragments = this.timeRanges = null;
    }
    /**
   * Return a Fragment or Part with an appended range that matches the position and levelType
   * Otherwise, return null
   */ getAppendedFrag(e, t) {
        const r = this.activePartLists[t];
        if (r) for(let n1 = r.length; n1--;){
            const i = r[n1];
            if (!i) break;
            if (i.start <= e && e <= i.end && i.loaded) return i;
        }
        return this.getBufferedFrag(e, t);
    }
    /**
   * Return a buffered Fragment that matches the position and levelType.
   * A buffered Fragment is one whose loading, parsing and appending is done (completed or "partial" meaning aborted).
   * If not found any Fragment, return null
   */ getBufferedFrag(e, t) {
        return this.getFragAtPos(e, t, !0);
    }
    getFragAtPos(e, t, r) {
        const { fragments: n1 } = this, i = Object.keys(n1);
        for(let o = i.length; o--;){
            const a = n1[i[o]];
            if ((a == null ? void 0 : a.body.type) === t && (!r || a.buffered)) {
                const l = a.body;
                if (l.start <= e && e <= l.end) return l;
            }
        }
        return null;
    }
    /**
   * Partial fragments effected by coded frame eviction will be removed
   * The browser will unload parts of the buffer to free up memory for new buffer data
   * Fragments will need to be reloaded when the buffer is freed up, removing partial fragments will allow them to reload(since there might be parts that are still playable)
   */ detectEvictedFragments(e, t, r, n1, i) {
        this.timeRanges && (this.timeRanges[e] = t);
        const o = (n1 == null ? void 0 : n1.fragment.sn) || -1;
        Object.keys(this.fragments).forEach((a)=>{
            const l = this.fragments[a];
            if (!l || o >= l.body.sn) return;
            if (!l.buffered && (!l.loaded || i)) {
                l.body.type === r && this.removeFragment(l.body);
                return;
            }
            const c = l.range[e];
            if (c) {
                if (c.time.length === 0) {
                    this.removeFragment(l.body);
                    return;
                }
                c.time.some((u)=>{
                    const d1 = !this.isTimeBuffered(u.startPTS, u.endPTS, t);
                    return d1 && this.removeFragment(l.body), d1;
                });
            }
        });
    }
    /**
   * Checks if the fragment passed in is loaded in the buffer properly
   * Partially loaded fragments will be registered as a partial fragment
   */ detectPartialFragments(e) {
        const t = this.timeRanges;
        if (!t || e.frag.sn === "initSegment") return;
        const r = e.frag, n1 = dn(r), i = this.fragments[n1];
        if (!i || i.buffered && r.gap) return;
        const o = !r.relurl;
        Object.keys(t).forEach((a)=>{
            const l = r.elementaryStreams[a];
            if (!l) return;
            const c = t[a], u = o || l.partial === !0;
            i.range[a] = this.getBufferedTimes(r, e.part, u, c);
        }), i.loaded = null, Object.keys(i.range).length ? (i.buffered = !0, (i.body.endList = r.endList || i.body.endList) && (this.endListFragments[i.body.type] = i), Hi(i) || this.removeParts(r.sn - 1, r.type)) : this.removeFragment(i.body);
    }
    removeParts(e, t) {
        const r = this.activePartLists[t];
        r && (this.activePartLists[t] = gh(r, (n1)=>n1.fragment.sn >= e));
    }
    fragBuffered(e, t) {
        const r = dn(e);
        let n1 = this.fragments[r];
        !n1 && t && (n1 = this.fragments[r] = {
            body: e,
            appendedPTS: null,
            loaded: null,
            buffered: !1,
            range: /* @__PURE__ */ Object.create(null)
        }, e.gap && (this.hasGaps = !0)), n1 && (n1.loaded = null, n1.buffered = !0);
    }
    getBufferedTimes(e, t, r, n1) {
        const i = {
            time: [],
            partial: r
        }, o = e.start, a = e.end, l = e.minEndPTS || a, c = e.maxStartPTS || o;
        for(let u = 0; u < n1.length; u++){
            const d1 = n1.start(u) - this.bufferPadding, h = n1.end(u) + this.bufferPadding;
            if (c >= d1 && l <= h) {
                i.time.push({
                    startPTS: Math.max(o, n1.start(u)),
                    endPTS: Math.min(a, n1.end(u))
                });
                break;
            } else if (o < h && a > d1) {
                const f = Math.max(o, n1.start(u)), p = Math.min(a, n1.end(u));
                p > f && (i.partial = !0, i.time.push({
                    startPTS: f,
                    endPTS: p
                }));
            } else if (a <= d1) break;
        }
        return i;
    }
    /**
   * Gets the partial fragment for a certain time
   */ getPartialFragment(e) {
        let t = null, r, n1, i, o = 0;
        const { bufferPadding: a, fragments: l } = this;
        return Object.keys(l).forEach((c)=>{
            const u = l[c];
            u && Hi(u) && (n1 = u.body.start - a, i = u.body.end + a, e >= n1 && e <= i && (r = Math.min(e - n1, i - e), o <= r && (t = u.body, o = r)));
        }), t;
    }
    isEndListAppended(e) {
        const t = this.endListFragments[e];
        return t !== void 0 && (t.buffered || Hi(t));
    }
    getState(e) {
        const t = dn(e), r = this.fragments[t];
        return r ? r.buffered ? Hi(r) ? Ht.PARTIAL : Ht.OK : Ht.APPENDING : Ht.NOT_LOADED;
    }
    isTimeBuffered(e, t, r) {
        let n1, i;
        for(let o = 0; o < r.length; o++){
            if (n1 = r.start(o) - this.bufferPadding, i = r.end(o) + this.bufferPadding, e >= n1 && t <= i) return !0;
            if (t <= n1) return !1;
        }
        return !1;
    }
    onManifestLoading() {
        this.removeAllFragments();
    }
    onFragLoaded(e, t) {
        if (t.frag.sn === "initSegment" || t.frag.bitrateTest) return;
        const r = t.frag, n1 = t.part ? null : t, i = dn(r);
        this.fragments[i] = {
            body: r,
            appendedPTS: null,
            loaded: n1,
            buffered: !1,
            range: /* @__PURE__ */ Object.create(null)
        };
    }
    onBufferAppended(e, t) {
        const { frag: r, part: n1, timeRanges: i, type: o } = t;
        if (r.sn === "initSegment") return;
        const a = r.type;
        if (n1) {
            let c = this.activePartLists[a];
            c || (this.activePartLists[a] = c = []), c.push(n1);
        }
        this.timeRanges = i;
        const l = i[o];
        this.detectEvictedFragments(o, l, a, n1);
    }
    onFragBuffered(e, t) {
        this.detectPartialFragments(t);
    }
    hasFragment(e) {
        const t = dn(e);
        return !!this.fragments[t];
    }
    hasFragments(e) {
        const { fragments: t } = this, r = Object.keys(t);
        if (!e) return r.length > 0;
        for(let n1 = r.length; n1--;){
            const i = t[r[n1]];
            if ((i == null ? void 0 : i.body.type) === e) return !0;
        }
        return !1;
    }
    hasParts(e) {
        var t;
        return !!((t = this.activePartLists[e]) != null && t.length);
    }
    removeFragmentsInRange(e, t, r, n1, i) {
        n1 && !this.hasGaps || Object.keys(this.fragments).forEach((o)=>{
            const a = this.fragments[o];
            if (!a) return;
            const l = a.body;
            l.type !== r || n1 && !l.gap || l.start < t && l.end > e && (a.buffered || i) && this.removeFragment(l);
        });
    }
    removeFragment(e) {
        const t = dn(e);
        e.clearElementaryStreamInfo();
        const r = this.activePartLists[e.type];
        if (r) {
            const n1 = e.sn;
            this.activePartLists[e.type] = gh(r, (i)=>i.fragment.sn !== n1);
        }
        delete this.fragments[t], e.endList && delete this.endListFragments[e.type];
    }
    removeAllFragments() {
        var e;
        this.fragments = /* @__PURE__ */ Object.create(null), this.endListFragments = /* @__PURE__ */ Object.create(null), this.activePartLists = /* @__PURE__ */ Object.create(null), this.hasGaps = !1;
        const t = (e = this.hls) == null || (e = e.latestLevelDetails) == null ? void 0 : e.partList;
        t && t.forEach((r)=>r.clearElementaryStreamInfo());
    }
}
function Hi(s) {
    var e, t, r;
    return s.buffered && !!(s.body.gap || (e = s.range.video) != null && e.partial || (t = s.range.audio) != null && t.partial || (r = s.range.audiovideo) != null && r.partial);
}
function dn(s) {
    return `${s.type}_${s.level}_${s.sn}`;
}
function gh(s, e) {
    return s.filter((t)=>{
        const r = e(t);
        return r || t.clearElementaryStreamInfo(), r;
    });
}
var Os = {
    cbc: 0,
    ctr: 1
};
class wb {
    constructor(e, t, r){
        this.subtle = void 0, this.aesIV = void 0, this.aesMode = void 0, this.subtle = e, this.aesIV = t, this.aesMode = r;
    }
    decrypt(e, t) {
        switch(this.aesMode){
            case Os.cbc:
                return this.subtle.decrypt({
                    name: "AES-CBC",
                    iv: this.aesIV
                }, t, e);
            case Os.ctr:
                return this.subtle.decrypt({
                    name: "AES-CTR",
                    counter: this.aesIV,
                    length: 64
                }, //64 : NIST SP800-38A standard suggests that the counter should occupy half of the counter block
                t, e);
            default:
                throw new Error(`[AESCrypto] invalid aes mode ${this.aesMode}`);
        }
    }
}
function Ab(s) {
    const e = s.byteLength, t = e && new DataView(s.buffer).getUint8(e - 1);
    return t ? s.slice(0, e - t) : s;
}
class Ib {
    constructor(){
        this.rcon = [
            0,
            1,
            2,
            4,
            8,
            16,
            32,
            64,
            128,
            27,
            54
        ], this.subMix = [
            new Uint32Array(256),
            new Uint32Array(256),
            new Uint32Array(256),
            new Uint32Array(256)
        ], this.invSubMix = [
            new Uint32Array(256),
            new Uint32Array(256),
            new Uint32Array(256),
            new Uint32Array(256)
        ], this.sBox = new Uint32Array(256), this.invSBox = new Uint32Array(256), this.key = new Uint32Array(0), this.ksRows = 0, this.keySize = 0, this.keySchedule = void 0, this.invKeySchedule = void 0, this.initTable();
    }
    // Using view.getUint32() also swaps the byte order.
    uint8ArrayToUint32Array_(e) {
        const t = new DataView(e), r = new Uint32Array(4);
        for(let n1 = 0; n1 < 4; n1++)r[n1] = t.getUint32(n1 * 4);
        return r;
    }
    initTable() {
        const e = this.sBox, t = this.invSBox, r = this.subMix, n1 = r[0], i = r[1], o = r[2], a = r[3], l = this.invSubMix, c = l[0], u = l[1], d1 = l[2], h = l[3], f = new Uint32Array(256);
        let p = 0, y = 0, E = 0;
        for(E = 0; E < 256; E++)E < 128 ? f[E] = E << 1 : f[E] = E << 1 ^ 283;
        for(E = 0; E < 256; E++){
            let b = y ^ y << 1 ^ y << 2 ^ y << 3 ^ y << 4;
            b = b >>> 8 ^ b & 255 ^ 99, e[p] = b, t[b] = p;
            const L = f[p], A = f[L], F = f[A];
            let M = f[b] * 257 ^ b * 16843008;
            n1[p] = M << 24 | M >>> 8, i[p] = M << 16 | M >>> 16, o[p] = M << 8 | M >>> 24, a[p] = M, M = F * 16843009 ^ A * 65537 ^ L * 257 ^ p * 16843008, c[b] = M << 24 | M >>> 8, u[b] = M << 16 | M >>> 16, d1[b] = M << 8 | M >>> 24, h[b] = M, p ? (p = L ^ f[f[f[F ^ L]]], y ^= f[f[y]]) : p = y = 1;
        }
    }
    expandKey(e) {
        const t = this.uint8ArrayToUint32Array_(e);
        let r = !0, n1 = 0;
        for(; n1 < t.length && r;)r = t[n1] === this.key[n1], n1++;
        if (r) return;
        this.key = t;
        const i = this.keySize = t.length;
        if (i !== 4 && i !== 6 && i !== 8) throw new Error("Invalid aes key size=" + i);
        const o = this.ksRows = (i + 6 + 1) * 4;
        let a, l;
        const c = this.keySchedule = new Uint32Array(o), u = this.invKeySchedule = new Uint32Array(o), d1 = this.sBox, h = this.rcon, f = this.invSubMix, p = f[0], y = f[1], E = f[2], b = f[3];
        let L, A;
        for(a = 0; a < o; a++){
            if (a < i) {
                L = c[a] = t[a];
                continue;
            }
            A = L, a % i === 0 ? (A = A << 8 | A >>> 24, A = d1[A >>> 24] << 24 | d1[A >>> 16 & 255] << 16 | d1[A >>> 8 & 255] << 8 | d1[A & 255], A ^= h[a / i | 0] << 24) : i > 6 && a % i === 4 && (A = d1[A >>> 24] << 24 | d1[A >>> 16 & 255] << 16 | d1[A >>> 8 & 255] << 8 | d1[A & 255]), c[a] = L = (c[a - i] ^ A) >>> 0;
        }
        for(l = 0; l < o; l++)a = o - l, l & 3 ? A = c[a] : A = c[a - 4], l < 4 || a <= 4 ? u[l] = A : u[l] = p[d1[A >>> 24]] ^ y[d1[A >>> 16 & 255]] ^ E[d1[A >>> 8 & 255]] ^ b[d1[A & 255]], u[l] = u[l] >>> 0;
    }
    // Adding this as a method greatly improves performance.
    networkToHostOrderSwap(e) {
        return e << 24 | (e & 65280) << 8 | (e & 16711680) >> 8 | e >>> 24;
    }
    decrypt(e, t, r) {
        const n1 = this.keySize + 6, i = this.invKeySchedule, o = this.invSBox, a = this.invSubMix, l = a[0], c = a[1], u = a[2], d1 = a[3], h = this.uint8ArrayToUint32Array_(r);
        let f = h[0], p = h[1], y = h[2], E = h[3];
        const b = new Int32Array(e), L = new Int32Array(b.length);
        let A, F, M, H, K, j, C, k, $, W, _, g, x, w;
        const D = this.networkToHostOrderSwap;
        for(; t < b.length;){
            for($ = D(b[t]), W = D(b[t + 1]), _ = D(b[t + 2]), g = D(b[t + 3]), K = $ ^ i[0], j = g ^ i[1], C = _ ^ i[2], k = W ^ i[3], x = 4, w = 1; w < n1; w++)A = l[K >>> 24] ^ c[j >> 16 & 255] ^ u[C >> 8 & 255] ^ d1[k & 255] ^ i[x], F = l[j >>> 24] ^ c[C >> 16 & 255] ^ u[k >> 8 & 255] ^ d1[K & 255] ^ i[x + 1], M = l[C >>> 24] ^ c[k >> 16 & 255] ^ u[K >> 8 & 255] ^ d1[j & 255] ^ i[x + 2], H = l[k >>> 24] ^ c[K >> 16 & 255] ^ u[j >> 8 & 255] ^ d1[C & 255] ^ i[x + 3], K = A, j = F, C = M, k = H, x = x + 4;
            A = o[K >>> 24] << 24 ^ o[j >> 16 & 255] << 16 ^ o[C >> 8 & 255] << 8 ^ o[k & 255] ^ i[x], F = o[j >>> 24] << 24 ^ o[C >> 16 & 255] << 16 ^ o[k >> 8 & 255] << 8 ^ o[K & 255] ^ i[x + 1], M = o[C >>> 24] << 24 ^ o[k >> 16 & 255] << 16 ^ o[K >> 8 & 255] << 8 ^ o[j & 255] ^ i[x + 2], H = o[k >>> 24] << 24 ^ o[K >> 16 & 255] << 16 ^ o[j >> 8 & 255] << 8 ^ o[C & 255] ^ i[x + 3], L[t] = D(A ^ f), L[t + 1] = D(H ^ p), L[t + 2] = D(M ^ y), L[t + 3] = D(F ^ E), f = $, p = W, y = _, E = g, t = t + 4;
        }
        return L.buffer;
    }
}
class _b {
    constructor(e, t, r){
        this.subtle = void 0, this.key = void 0, this.aesMode = void 0, this.subtle = e, this.key = t, this.aesMode = r;
    }
    expandKey() {
        const e = Lb(this.aesMode);
        return this.subtle.importKey("raw", this.key, {
            name: e
        }, !1, [
            "encrypt",
            "decrypt"
        ]);
    }
}
function Lb(s) {
    switch(s){
        case Os.cbc:
            return "AES-CBC";
        case Os.ctr:
            return "AES-CTR";
        default:
            throw new Error(`[FastAESKey] invalid aes mode ${s}`);
    }
}
const Rb = 16;
class vu {
    constructor(e, { removePKCS7Padding: t = !0 } = {}){
        if (this.logEnabled = !0, this.removePKCS7Padding = void 0, this.subtle = null, this.softwareDecrypter = null, this.key = null, this.fastAesKey = null, this.remainderData = null, this.currentIV = null, this.currentResult = null, this.useSoftware = void 0, this.enableSoftwareAES = void 0, this.enableSoftwareAES = e.enableSoftwareAES, this.removePKCS7Padding = t, t) try {
            const r = self.crypto;
            r && (this.subtle = r.subtle || r.webkitSubtle);
        } catch  {}
        this.useSoftware = !this.subtle;
    }
    destroy() {
        this.subtle = null, this.softwareDecrypter = null, this.key = null, this.fastAesKey = null, this.remainderData = null, this.currentIV = null, this.currentResult = null;
    }
    isSync() {
        return this.useSoftware;
    }
    flush() {
        const { currentResult: e, remainderData: t } = this;
        if (!e || t) return this.reset(), null;
        const r = new Uint8Array(e);
        return this.reset(), this.removePKCS7Padding ? Ab(r) : r;
    }
    reset() {
        this.currentResult = null, this.currentIV = null, this.remainderData = null, this.softwareDecrypter && (this.softwareDecrypter = null);
    }
    decrypt(e, t, r, n1) {
        return this.useSoftware ? new Promise((i, o)=>{
            const a = ArrayBuffer.isView(e) ? e : new Uint8Array(e);
            this.softwareDecrypt(a, t, r, n1);
            const l = this.flush();
            l ? i(l.buffer) : o(new Error("[softwareDecrypt] Failed to decrypt data"));
        }) : this.webCryptoDecrypt(new Uint8Array(e), t, r, n1);
    }
    // Software decryption is progressive. Progressive decryption may not return a result on each call. Any cached
    // data is handled in the flush() call
    softwareDecrypt(e, t, r, n1) {
        const { currentIV: i, currentResult: o, remainderData: a } = this;
        if (n1 !== Os.cbc || t.byteLength !== 16) return rt.warn("SoftwareDecrypt: can only handle AES-128-CBC"), null;
        this.logOnce("JS AES decrypt"), a && (e = _r(a, e), this.remainderData = null);
        const l = this.getValidChunk(e);
        if (!l.length) return null;
        i && (r = i);
        let c = this.softwareDecrypter;
        c || (c = this.softwareDecrypter = new Ib()), c.expandKey(t);
        const u = o;
        return this.currentResult = c.decrypt(l.buffer, 0, r), this.currentIV = l.slice(-16).buffer, u || null;
    }
    webCryptoDecrypt(e, t, r, n1) {
        if (this.key !== t || !this.fastAesKey) {
            if (!this.subtle) return Promise.resolve(this.onWebCryptoError(e, t, r, n1));
            this.key = t, this.fastAesKey = new _b(this.subtle, t, n1);
        }
        return this.fastAesKey.expandKey().then((i)=>this.subtle ? (this.logOnce("WebCrypto AES decrypt"), new wb(this.subtle, new Uint8Array(r), n1).decrypt(e.buffer, i)) : Promise.reject(new Error("web crypto not initialized"))).catch((i)=>(rt.warn(`[decrypter]: WebCrypto Error, disable WebCrypto API, ${i.name}: ${i.message}`), this.onWebCryptoError(e, t, r, n1)));
    }
    onWebCryptoError(e, t, r, n1) {
        const i = this.enableSoftwareAES;
        if (i) {
            this.useSoftware = !0, this.logEnabled = !0, this.softwareDecrypt(e, t, r, n1);
            const o = this.flush();
            if (o) return o.buffer;
        }
        throw new Error("WebCrypto" + (i ? " and softwareDecrypt" : "") + ": failed to decrypt data");
    }
    getValidChunk(e) {
        let t = e;
        const r = e.length - e.length % Rb;
        return r !== e.length && (t = e.slice(0, r), this.remainderData = e.slice(r)), t;
    }
    logOnce(e) {
        this.logEnabled && (rt.log(`[decrypter]: ${e}`), this.logEnabled = !1);
    }
}
const ph = Math.pow(2, 17);
class Cb {
    constructor(e){
        this.config = void 0, this.loader = null, this.partLoadTimeout = -1, this.config = e;
    }
    destroy() {
        this.loader && (this.loader.destroy(), this.loader = null);
    }
    abort() {
        this.loader && this.loader.abort();
    }
    load(e, t) {
        const r = e.url;
        if (!r) return Promise.reject(new as({
            type: ve.NETWORK_ERROR,
            details: J.FRAG_LOAD_ERROR,
            fatal: !1,
            frag: e,
            error: new Error(`Fragment does not have a ${r ? "part list" : "url"}`),
            networkDetails: null
        }));
        this.abort();
        const n1 = this.config, i = n1.fLoader, o = n1.loader;
        return new Promise((a, l)=>{
            if (this.loader && this.loader.destroy(), e.gap) if (e.tagList.some((p)=>p[0] === "GAP")) {
                l(yh(e));
                return;
            } else e.gap = !1;
            const c = this.loader = i ? new i(n1) : new o(n1), u = mh(e);
            e.loader = c;
            const d1 = fh(n1.fragLoadPolicy.default), h = {
                loadPolicy: d1,
                timeout: d1.maxLoadTimeMs,
                maxRetry: 0,
                retryDelay: 0,
                maxRetryDelay: 0,
                highWaterMark: e.sn === "initSegment" ? 1 / 0 : ph
            };
            e.stats = c.stats;
            const f = {
                onSuccess: (p, y, E, b)=>{
                    this.resetLoader(e, c);
                    let L = p.data;
                    E.resetIV && e.decryptdata && (e.decryptdata.iv = new Uint8Array(L.slice(0, 16)), L = L.slice(16)), a({
                        frag: e,
                        part: null,
                        payload: L,
                        networkDetails: b
                    });
                },
                onError: (p, y, E, b)=>{
                    this.resetLoader(e, c), l(new as({
                        type: ve.NETWORK_ERROR,
                        details: J.FRAG_LOAD_ERROR,
                        fatal: !1,
                        frag: e,
                        response: tt({
                            url: r,
                            data: void 0
                        }, p),
                        error: new Error(`HTTP Error ${p.code} ${p.text}`),
                        networkDetails: E,
                        stats: b
                    }));
                },
                onAbort: (p, y, E)=>{
                    this.resetLoader(e, c), l(new as({
                        type: ve.NETWORK_ERROR,
                        details: J.INTERNAL_ABORTED,
                        fatal: !1,
                        frag: e,
                        error: new Error("Aborted"),
                        networkDetails: E,
                        stats: p
                    }));
                },
                onTimeout: (p, y, E)=>{
                    this.resetLoader(e, c), l(new as({
                        type: ve.NETWORK_ERROR,
                        details: J.FRAG_LOAD_TIMEOUT,
                        fatal: !1,
                        frag: e,
                        error: new Error(`Timeout after ${h.timeout}ms`),
                        networkDetails: E,
                        stats: p
                    }));
                }
            };
            t && (f.onProgress = (p, y, E, b)=>t({
                    frag: e,
                    part: null,
                    payload: E,
                    networkDetails: b
                })), c.load(u, h, f);
        });
    }
    loadPart(e, t, r) {
        this.abort();
        const n1 = this.config, i = n1.fLoader, o = n1.loader;
        return new Promise((a, l)=>{
            if (this.loader && this.loader.destroy(), e.gap || t.gap) {
                l(yh(e, t));
                return;
            }
            const c = this.loader = i ? new i(n1) : new o(n1), u = mh(e, t);
            e.loader = c;
            const d1 = fh(n1.fragLoadPolicy.default), h = {
                loadPolicy: d1,
                timeout: d1.maxLoadTimeMs,
                maxRetry: 0,
                retryDelay: 0,
                maxRetryDelay: 0,
                highWaterMark: ph
            };
            t.stats = c.stats, c.load(u, h, {
                onSuccess: (f, p, y, E)=>{
                    this.resetLoader(e, c), this.updateStatsFromPart(e, t);
                    const b = {
                        frag: e,
                        part: t,
                        payload: f.data,
                        networkDetails: E
                    };
                    r(b), a(b);
                },
                onError: (f, p, y, E)=>{
                    this.resetLoader(e, c), l(new as({
                        type: ve.NETWORK_ERROR,
                        details: J.FRAG_LOAD_ERROR,
                        fatal: !1,
                        frag: e,
                        part: t,
                        response: tt({
                            url: u.url,
                            data: void 0
                        }, f),
                        error: new Error(`HTTP Error ${f.code} ${f.text}`),
                        networkDetails: y,
                        stats: E
                    }));
                },
                onAbort: (f, p, y)=>{
                    e.stats.aborted = t.stats.aborted, this.resetLoader(e, c), l(new as({
                        type: ve.NETWORK_ERROR,
                        details: J.INTERNAL_ABORTED,
                        fatal: !1,
                        frag: e,
                        part: t,
                        error: new Error("Aborted"),
                        networkDetails: y,
                        stats: f
                    }));
                },
                onTimeout: (f, p, y)=>{
                    this.resetLoader(e, c), l(new as({
                        type: ve.NETWORK_ERROR,
                        details: J.FRAG_LOAD_TIMEOUT,
                        fatal: !1,
                        frag: e,
                        part: t,
                        error: new Error(`Timeout after ${h.timeout}ms`),
                        networkDetails: y,
                        stats: f
                    }));
                }
            });
        });
    }
    updateStatsFromPart(e, t) {
        const r = e.stats, n1 = t.stats, i = n1.total;
        if (r.loaded += n1.loaded, i) {
            const l = Math.round(e.duration / t.duration), c = Math.min(Math.round(r.loaded / i), l), d1 = (l - c) * Math.round(r.loaded / c);
            r.total = r.loaded + d1;
        } else r.total = Math.max(r.loaded, r.total);
        const o = r.loading, a = n1.loading;
        o.start ? o.first += a.first - a.start : (o.start = a.start, o.first = a.first), o.end = a.end;
    }
    resetLoader(e, t) {
        e.loader = null, this.loader === t && (self.clearTimeout(this.partLoadTimeout), this.loader = null), t.destroy();
    }
}
function mh(s, e = null) {
    const t = e || s, r = {
        frag: s,
        part: e,
        responseType: "arraybuffer",
        url: t.url,
        headers: {},
        rangeStart: 0,
        rangeEnd: 0
    }, n1 = t.byteRangeStartOffset, i = t.byteRangeEndOffset;
    if (ue(n1) && ue(i)) {
        var o;
        let a = n1, l = i;
        if (s.sn === "initSegment" && kb((o = s.decryptdata) == null ? void 0 : o.method)) {
            const c = i - n1;
            c % 16 && (l = i + (16 - c % 16)), n1 !== 0 && (r.resetIV = !0, a = n1 - 16);
        }
        r.rangeStart = a, r.rangeEnd = l;
    }
    return r;
}
function yh(s, e) {
    const t = new Error(`GAP ${s.gap ? "tag" : "attribute"} found`), r = {
        type: ve.MEDIA_ERROR,
        details: J.FRAG_GAP,
        fatal: !1,
        frag: s,
        error: t,
        networkDetails: null
    };
    return e && (r.part = e), (e || s).stats.aborted = !0, new as(r);
}
function kb(s) {
    return s === "AES-128" || s === "AES-256";
}
class as extends Error {
    constructor(e){
        super(e.error.message), this.data = void 0, this.data = e;
    }
}
class Hg extends Rr {
    constructor(e, t){
        super(e, t), this._boundTick = void 0, this._tickTimer = null, this._tickInterval = null, this._tickCallCount = 0, this._boundTick = this.tick.bind(this);
    }
    destroy() {
        this.onHandlerDestroying(), this.onHandlerDestroyed();
    }
    onHandlerDestroying() {
        this.clearNextTick(), this.clearInterval();
    }
    onHandlerDestroyed() {}
    hasInterval() {
        return !!this._tickInterval;
    }
    hasNextTick() {
        return !!this._tickTimer;
    }
    /**
   * @param millis - Interval time (ms)
   * @eturns True when interval has been scheduled, false when already scheduled (no effect)
   */ setInterval(e) {
        return this._tickInterval ? !1 : (this._tickCallCount = 0, this._tickInterval = self.setInterval(this._boundTick, e), !0);
    }
    /**
   * @returns True when interval was cleared, false when none was set (no effect)
   */ clearInterval() {
        return this._tickInterval ? (self.clearInterval(this._tickInterval), this._tickInterval = null, !0) : !1;
    }
    /**
   * @returns True when timeout was cleared, false when none was set (no effect)
   */ clearNextTick() {
        return this._tickTimer ? (self.clearTimeout(this._tickTimer), this._tickTimer = null, !0) : !1;
    }
    /**
   * Will call the subclass doTick implementation in this main loop tick
   * or in the next one (via setTimeout(,0)) in case it has already been called
   * in this tick (in case this is a re-entrant call).
   */ tick() {
        this._tickCallCount++, this._tickCallCount === 1 && (this.doTick(), this._tickCallCount > 1 && this.tickImmediate(), this._tickCallCount = 0);
    }
    tickImmediate() {
        this.clearNextTick(), this._tickTimer = self.setTimeout(this._boundTick, 0);
    }
    /**
   * For subclass to implement task logic
   * @abstract
   */ doTick() {}
}
class Eu {
    constructor(e, t, r, n1 = 0, i = -1, o = !1){
        this.level = void 0, this.sn = void 0, this.part = void 0, this.id = void 0, this.size = void 0, this.partial = void 0, this.transmuxing = qi(), this.buffering = {
            audio: qi(),
            video: qi(),
            audiovideo: qi()
        }, this.level = e, this.sn = t, this.id = r, this.size = n1, this.part = i, this.partial = o;
    }
}
function qi() {
    return {
        start: 0,
        executeStart: 0,
        executeEnd: 0,
        end: 0
    };
}
const vh = {
    length: 0,
    start: ()=>0,
    end: ()=>0
};
class Ce {
    /**
   * Return true if `media`'s buffered include `position`
   */ static isBuffered(e, t) {
        if (e) {
            const r = Ce.getBuffered(e);
            for(let n1 = r.length; n1--;)if (t >= r.start(n1) && t <= r.end(n1)) return !0;
        }
        return !1;
    }
    static bufferedRanges(e) {
        if (e) {
            const t = Ce.getBuffered(e);
            return Ce.timeRangesToArray(t);
        }
        return [];
    }
    static timeRangesToArray(e) {
        const t = [];
        for(let r = 0; r < e.length; r++)t.push({
            start: e.start(r),
            end: e.end(r)
        });
        return t;
    }
    static bufferInfo(e, t, r) {
        if (e) {
            const n1 = Ce.bufferedRanges(e);
            if (n1.length) return Ce.bufferedInfo(n1, t, r);
        }
        return {
            len: 0,
            start: t,
            end: t,
            bufferedIndex: -1
        };
    }
    static bufferedInfo(e, t, r) {
        t = Math.max(0, t), e.length > 1 && e.sort((u, d1)=>u.start - d1.start || d1.end - u.end);
        let n1 = -1, i = [];
        if (r) for(let u = 0; u < e.length; u++){
            t >= e[u].start && t <= e[u].end && (n1 = u);
            const d1 = i.length;
            if (d1) {
                const h = i[d1 - 1].end;
                e[u].start - h < r ? e[u].end > h && (i[d1 - 1].end = e[u].end) : i.push(e[u]);
            } else i.push(e[u]);
        }
        else i = e;
        let o = 0, a, l = t, c = t;
        for(let u = 0; u < i.length; u++){
            const d1 = i[u].start, h = i[u].end;
            if (n1 === -1 && t >= d1 && t <= h && (n1 = u), t + r >= d1 && t < h) l = d1, c = h, o = c - t;
            else if (t + r < d1) {
                a = d1;
                break;
            }
        }
        return {
            len: o,
            start: l || 0,
            end: c || 0,
            nextStart: a,
            buffered: e,
            bufferedIndex: n1
        };
    }
    /**
   * Safe method to get buffered property.
   * SourceBuffer.buffered may throw if SourceBuffer is removed from it's MediaSource
   */ static getBuffered(e) {
        try {
            return e.buffered || vh;
        } catch (t) {
            return rt.log("failed to get media.buffered", t), vh;
        }
    }
}
const qg = /\{\$([a-zA-Z0-9-_]+)\}/g;
function Eh(s) {
    return qg.test(s);
}
function dc(s, e) {
    if (s.variableList !== null || s.hasVariableRefs) {
        const t = s.variableList;
        return e.replace(qg, (r)=>{
            const n1 = r.substring(2, r.length - 1), i = t == null ? void 0 : t[n1];
            return i === void 0 ? (s.playlistParsingError || (s.playlistParsingError = new Error(`Missing preceding EXT-X-DEFINE tag for Variable Reference: "${n1}"`)), r) : i;
        });
    }
    return e;
}
function xh(s, e, t) {
    let r = s.variableList;
    r || (s.variableList = r = {});
    let n1, i;
    if ("QUERYPARAM" in e) {
        n1 = e.QUERYPARAM;
        try {
            const o = new self.URL(t).searchParams;
            if (o.has(n1)) i = o.get(n1);
            else throw new Error(`"${n1}" does not match any query parameter in URI: "${t}"`);
        } catch (o) {
            s.playlistParsingError || (s.playlistParsingError = new Error(`EXT-X-DEFINE QUERYPARAM: ${o.message}`));
        }
    } else n1 = e.NAME, i = e.VALUE;
    n1 in r ? s.playlistParsingError || (s.playlistParsingError = new Error(`EXT-X-DEFINE duplicate Variable Name declarations: "${n1}"`)) : r[n1] = i || "";
}
function Db(s, e, t) {
    const r = e.IMPORT;
    if (t && r in t) {
        let n1 = s.variableList;
        n1 || (s.variableList = n1 = {}), n1[r] = t[r];
    } else s.playlistParsingError || (s.playlistParsingError = new Error(`EXT-X-DEFINE IMPORT attribute not found in Multivariant Playlist: "${r}"`));
}
const Pb = /^(\d+)x(\d+)$/, Sh = /(.+?)=(".*?"|.*?)(?:,|$)/g;
class ft {
    constructor(e, t){
        typeof e == "string" && (e = ft.parseAttrList(e, t)), nt(this, e);
    }
    get clientAttrs() {
        return Object.keys(this).filter((e)=>e.substring(0, 2) === "X-");
    }
    decimalInteger(e) {
        const t = parseInt(this[e], 10);
        return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t;
    }
    hexadecimalInteger(e) {
        if (this[e]) {
            let t = (this[e] || "0x").slice(2);
            t = (t.length & 1 ? "0" : "") + t;
            const r = new Uint8Array(t.length / 2);
            for(let n1 = 0; n1 < t.length / 2; n1++)r[n1] = parseInt(t.slice(n1 * 2, n1 * 2 + 2), 16);
            return r;
        }
        return null;
    }
    hexadecimalIntegerAsNumber(e) {
        const t = parseInt(this[e], 16);
        return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t;
    }
    decimalFloatingPoint(e) {
        return parseFloat(this[e]);
    }
    optionalFloat(e, t) {
        const r = this[e];
        return r ? parseFloat(r) : t;
    }
    enumeratedString(e) {
        return this[e];
    }
    enumeratedStringList(e, t) {
        const r = this[e];
        return (r ? r.split(/[ ,]+/) : []).reduce((n1, i)=>(n1[i.toLowerCase()] = !0, n1), t);
    }
    bool(e) {
        return this[e] === "YES";
    }
    decimalResolution(e) {
        const t = Pb.exec(this[e]);
        if (t !== null) return {
            width: parseInt(t[1], 10),
            height: parseInt(t[2], 10)
        };
    }
    static parseAttrList(e, t) {
        let r;
        const n1 = {};
        for(Sh.lastIndex = 0; (r = Sh.exec(e)) !== null;){
            const o = r[1].trim();
            let a = r[2];
            const l = a.indexOf('"') === 0 && a.lastIndexOf('"') === a.length - 1;
            let c = !1;
            if (l) a = a.slice(1, -1);
            else switch(o){
                case "IV":
                case "SCTE35-CMD":
                case "SCTE35-IN":
                case "SCTE35-OUT":
                    c = !0;
            }
            if (t && (l || c)) a = dc(t, a);
            else if (!c && !l) switch(o){
                case "CLOSED-CAPTIONS":
                    if (a === "NONE") break;
                // falls through
                case "ALLOWED-CPC":
                case "CLASS":
                case "ASSOC-LANGUAGE":
                case "AUDIO":
                case "BYTERANGE":
                case "CHANNELS":
                case "CHARACTERISTICS":
                case "CODECS":
                case "DATA-ID":
                case "END-DATE":
                case "GROUP-ID":
                case "ID":
                case "IMPORT":
                case "INSTREAM-ID":
                case "KEYFORMAT":
                case "KEYFORMATVERSIONS":
                case "LANGUAGE":
                case "NAME":
                case "PATHWAY-ID":
                case "QUERYPARAM":
                case "RECENTLY-REMOVED-DATERANGES":
                case "SERVER-URI":
                case "STABLE-RENDITION-ID":
                case "STABLE-VARIANT-ID":
                case "START-DATE":
                case "SUBTITLES":
                case "SUPPLEMENTAL-CODECS":
                case "URI":
                case "VALUE":
                case "VIDEO":
                case "X-ASSET-LIST":
                case "X-ASSET-URI":
                    rt.warn(`${e}: attribute ${o} is missing quotes`);
            }
            n1[o] = a;
        }
        return n1;
    }
}
const Mb = "com.apple.hls.interstitial";
function Ob(s) {
    return s !== "ID" && s !== "CLASS" && s !== "CUE" && s !== "START-DATE" && s !== "DURATION" && s !== "END-DATE" && s !== "END-ON-NEXT";
}
function Bb(s) {
    return s === "SCTE35-OUT" || s === "SCTE35-IN" || s === "SCTE35-CMD";
}
class Wg {
    constructor(e, t, r = 0){
        var n1;
        if (this.attr = void 0, this.tagAnchor = void 0, this.tagOrder = void 0, this._startDate = void 0, this._endDate = void 0, this._dateAtEnd = void 0, this._cue = void 0, this._badValueForSameId = void 0, this.tagAnchor = (t == null ? void 0 : t.tagAnchor) || null, this.tagOrder = (n1 = t == null ? void 0 : t.tagOrder) != null ? n1 : r, t) {
            const i = t.attr;
            for(const o in i)if (Object.prototype.hasOwnProperty.call(e, o) && e[o] !== i[o]) {
                rt.warn(`DATERANGE tag attribute: "${o}" does not match for tags with ID: "${e.ID}"`), this._badValueForSameId = o;
                break;
            }
            e = nt(new ft({}), i, e);
        }
        if (this.attr = e, t ? (this._startDate = t._startDate, this._cue = t._cue, this._endDate = t._endDate, this._dateAtEnd = t._dateAtEnd) : this._startDate = new Date(e["START-DATE"]), "END-DATE" in this.attr) {
            const i = (t == null ? void 0 : t.endDate) || new Date(this.attr["END-DATE"]);
            ue(i.getTime()) && (this._endDate = i);
        }
    }
    get id() {
        return this.attr.ID;
    }
    get class() {
        return this.attr.CLASS;
    }
    get cue() {
        const e = this._cue;
        return e === void 0 ? this._cue = this.attr.enumeratedStringList(this.attr.CUE ? "CUE" : "X-CUE", {
            pre: !1,
            post: !1,
            once: !1
        }) : e;
    }
    get startTime() {
        const { tagAnchor: e } = this;
        return e === null || e.programDateTime === null ? (rt.warn(`Expected tagAnchor Fragment with PDT set for DateRange "${this.id}": ${e}`), NaN) : e.start + (this.startDate.getTime() - e.programDateTime) / 1e3;
    }
    get startDate() {
        return this._startDate;
    }
    get endDate() {
        const e = this._endDate || this._dateAtEnd;
        if (e) return e;
        const t = this.duration;
        return t !== null ? this._dateAtEnd = new Date(this._startDate.getTime() + t * 1e3) : null;
    }
    get duration() {
        if ("DURATION" in this.attr) {
            const e = this.attr.decimalFloatingPoint("DURATION");
            if (ue(e)) return e;
        } else if (this._endDate) return (this._endDate.getTime() - this._startDate.getTime()) / 1e3;
        return null;
    }
    get plannedDuration() {
        return "PLANNED-DURATION" in this.attr ? this.attr.decimalFloatingPoint("PLANNED-DURATION") : null;
    }
    get endOnNext() {
        return this.attr.bool("END-ON-NEXT");
    }
    get isInterstitial() {
        return this.class === Mb;
    }
    get isValid() {
        return !!this.id && !this._badValueForSameId && ue(this.startDate.getTime()) && (this.duration === null || this.duration >= 0) && (!this.endOnNext || !!this.class) && (!this.attr.CUE || !this.cue.pre && !this.cue.post || this.cue.pre !== this.cue.post) && (!this.isInterstitial || "X-ASSET-URI" in this.attr || "X-ASSET-LIST" in this.attr);
    }
}
const Fb = 10;
class Nb {
    constructor(e){
        this.PTSKnown = !1, this.alignedSliding = !1, this.averagetargetduration = void 0, this.endCC = 0, this.endSN = 0, this.fragments = void 0, this.fragmentHint = void 0, this.partList = null, this.dateRanges = void 0, this.dateRangeTagCount = 0, this.live = !0, this.requestScheduled = -1, this.ageHeader = 0, this.advancedDateTime = void 0, this.updated = !0, this.advanced = !0, this.misses = 0, this.startCC = 0, this.startSN = 0, this.startTimeOffset = null, this.targetduration = 0, this.totalduration = 0, this.type = null, this.url = void 0, this.m3u8 = "", this.version = null, this.canBlockReload = !1, this.canSkipUntil = 0, this.canSkipDateRanges = !1, this.skippedSegments = 0, this.recentlyRemovedDateranges = void 0, this.partHoldBack = 0, this.holdBack = 0, this.partTarget = 0, this.preloadHint = void 0, this.renditionReports = void 0, this.tuneInGoal = 0, this.deltaUpdateFailed = void 0, this.driftStartTime = 0, this.driftEndTime = 0, this.driftStart = 0, this.driftEnd = 0, this.encryptedFragments = void 0, this.playlistParsingError = null, this.variableList = null, this.hasVariableRefs = !1, this.appliedTimelineOffset = void 0, this.fragments = [], this.encryptedFragments = [], this.dateRanges = {}, this.url = e;
    }
    reloaded(e) {
        if (!e) {
            this.advanced = !0, this.updated = !0;
            return;
        }
        const t = this.lastPartSn - e.lastPartSn, r = this.lastPartIndex - e.lastPartIndex;
        this.updated = this.endSN !== e.endSN || !!r || !!t || !this.live, this.advanced = this.endSN > e.endSN || t > 0 || t === 0 && r > 0, this.updated || this.advanced ? this.misses = Math.floor(e.misses * 0.6) : this.misses = e.misses + 1;
    }
    hasKey(e) {
        return this.encryptedFragments.some((t)=>{
            let r = t.decryptdata;
            return r || (t.setKeyFormat(e.keyFormat), r = t.decryptdata), !!r && e.matches(r);
        });
    }
    get hasProgramDateTime() {
        return this.fragments.length ? ue(this.fragments[this.fragments.length - 1].programDateTime) : !1;
    }
    get levelTargetDuration() {
        return this.averagetargetduration || this.targetduration || Fb;
    }
    get drift() {
        const e = this.driftEndTime - this.driftStartTime;
        return e > 0 ? (this.driftEnd - this.driftStart) * 1e3 / e : 1;
    }
    get edge() {
        return this.partEnd || this.fragmentEnd;
    }
    get partEnd() {
        var e;
        return (e = this.partList) != null && e.length ? this.partList[this.partList.length - 1].end : this.fragmentEnd;
    }
    get fragmentEnd() {
        return this.fragments.length ? this.fragments[this.fragments.length - 1].end : 0;
    }
    get fragmentStart() {
        return this.fragments.length ? this.fragments[0].start : 0;
    }
    get age() {
        return this.advancedDateTime ? Math.max(Date.now() - this.advancedDateTime, 0) / 1e3 : 0;
    }
    get lastPartIndex() {
        var e;
        return (e = this.partList) != null && e.length ? this.partList[this.partList.length - 1].index : -1;
    }
    get maxPartIndex() {
        const e = this.partList;
        if (e) {
            const t = this.lastPartIndex;
            if (t !== -1) {
                for(let r = e.length; r--;)if (e[r].index > t) return e[r].index;
                return t;
            }
        }
        return 0;
    }
    get lastPartSn() {
        var e;
        return (e = this.partList) != null && e.length ? this.partList[this.partList.length - 1].fragment.sn : this.endSN;
    }
    get expired() {
        if (this.live && this.age && this.misses < 3) {
            const e = this.partEnd - this.fragmentStart;
            return this.age > Math.max(e, this.totalduration) + this.levelTargetDuration;
        }
        return !1;
    }
}
function xu(s, e) {
    return s.length === e.length ? !s.some((t, r)=>t !== e[r]) : !1;
}
function bh(s, e) {
    return !s && !e ? !0 : !s || !e ? !1 : xu(s, e);
}
function wn(s) {
    return s === "AES-128" || s === "AES-256" || s === "AES-256-CTR";
}
function Su(s) {
    switch(s){
        case "AES-128":
        case "AES-256":
            return Os.cbc;
        case "AES-256-CTR":
            return Os.ctr;
        default:
            throw new Error(`invalid full segment method ${s}`);
    }
}
function bu(s) {
    return Uint8Array.from(atob(s), (e)=>e.charCodeAt(0));
}
function hc(s) {
    return Uint8Array.from(unescape(encodeURIComponent(s)), (e)=>e.charCodeAt(0));
}
function Ub(s) {
    const e = hc(s).subarray(0, 16), t = new Uint8Array(16);
    return t.set(e, 16 - e.length), t;
}
function zg(s) {
    const e = function(r, n1, i) {
        const o = r[n1];
        r[n1] = r[i], r[i] = o;
    };
    e(s, 0, 3), e(s, 1, 2), e(s, 4, 5), e(s, 6, 7);
}
function $b(s) {
    const e = s.split(":");
    let t = null;
    if (e[0] === "data" && e.length === 2) {
        const r = e[1].split(";"), n1 = r[r.length - 1].split(",");
        if (n1.length === 2) {
            const i = n1[0] === "base64", o = n1[1];
            i ? (r.splice(-1, 1), t = bu(o)) : t = Ub(o);
        }
    }
    return t;
}
const ra = typeof self < "u" ? self : void 0;
var pt = {
    CLEARKEY: "org.w3.clearkey",
    FAIRPLAY: "com.apple.fps",
    PLAYREADY: "com.microsoft.playready",
    WIDEVINE: "com.widevine.alpha"
}, lr = {
    CLEARKEY: "org.w3.clearkey",
    FAIRPLAY: "com.apple.streamingkeydelivery",
    PLAYREADY: "com.microsoft.playready",
    WIDEVINE: "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed"
};
function po(s) {
    switch(s){
        case lr.FAIRPLAY:
            return pt.FAIRPLAY;
        case lr.PLAYREADY:
            return pt.PLAYREADY;
        case lr.WIDEVINE:
            return pt.WIDEVINE;
        case lr.CLEARKEY:
            return pt.CLEARKEY;
    }
}
function fl(s) {
    switch(s){
        case pt.FAIRPLAY:
            return lr.FAIRPLAY;
        case pt.PLAYREADY:
            return lr.PLAYREADY;
        case pt.WIDEVINE:
            return lr.WIDEVINE;
        case pt.CLEARKEY:
            return lr.CLEARKEY;
    }
}
function zn(s) {
    const { drmSystems: e, widevineLicenseUrl: t } = s, r = e ? [
        pt.FAIRPLAY,
        pt.WIDEVINE,
        pt.PLAYREADY,
        pt.CLEARKEY
    ].filter((n1)=>!!e[n1]) : [];
    return !r[pt.WIDEVINE] && t && r.push(pt.WIDEVINE), r;
}
const Yg = function(s) {
    return ra != null && (s = ra.navigator) != null && s.requestMediaKeySystemAccess ? self.navigator.requestMediaKeySystemAccess.bind(self.navigator) : null;
}();
function Gb(s, e, t, r) {
    let n1;
    switch(s){
        case pt.FAIRPLAY:
            n1 = [
                "cenc",
                "sinf"
            ];
            break;
        case pt.WIDEVINE:
        case pt.PLAYREADY:
            n1 = [
                "cenc"
            ];
            break;
        case pt.CLEARKEY:
            n1 = [
                "cenc",
                "keyids"
            ];
            break;
        default:
            throw new Error(`Unknown key-system: ${s}`);
    }
    return Vb(n1, e, t, r);
}
function Vb(s, e, t, r) {
    return [
        {
            initDataTypes: s,
            persistentState: r.persistentState || "optional",
            distinctiveIdentifier: r.distinctiveIdentifier || "optional",
            sessionTypes: r.sessionTypes || [
                r.sessionType || "temporary"
            ],
            audioCapabilities: e.map((i)=>({
                    contentType: `audio/mp4; codecs=${i}`,
                    robustness: r.audioRobustness || "",
                    encryptionScheme: r.audioEncryptionScheme || null
                })),
            videoCapabilities: t.map((i)=>({
                    contentType: `video/mp4; codecs=${i}`,
                    robustness: r.videoRobustness || "",
                    encryptionScheme: r.videoEncryptionScheme || null
                }))
        }
    ];
}
function jb(s) {
    var e;
    return !!s && (s.sessionType === "persistent-license" || !!((e = s.sessionTypes) != null && e.some((t)=>t === "persistent-license")));
}
function Kb(s) {
    const e = new Uint16Array(s.buffer, s.byteOffset, s.byteLength / 2), t = String.fromCharCode.apply(null, Array.from(e)), r = t.substring(t.indexOf("<"), t.length), o = new DOMParser().parseFromString(r, "text/xml").getElementsByTagName("KID")[0];
    if (o) {
        const a = o.childNodes[0] ? o.childNodes[0].nodeValue : o.getAttribute("VALUE");
        if (a) {
            const l = bu(a).subarray(0, 16);
            return zg(l), l;
        }
    }
    return null;
}
let Wi = {};
class yi {
    static clearKeyUriToKeyIdMap() {
        Wi = {};
    }
    static setKeyIdForUri(e, t) {
        Wi[e] = t;
    }
    constructor(e, t, r, n1 = [
        1
    ], i = null, o){
        this.uri = void 0, this.method = void 0, this.keyFormat = void 0, this.keyFormatVersions = void 0, this.encrypted = void 0, this.isCommonEncryption = void 0, this.iv = null, this.key = null, this.keyId = null, this.pssh = null, this.method = e, this.uri = t, this.keyFormat = r, this.keyFormatVersions = n1, this.iv = i, this.encrypted = e ? e !== "NONE" : !1, this.isCommonEncryption = this.encrypted && !wn(e), o != null && o.startsWith("0x") && (this.keyId = new Uint8Array(Ig(o)));
    }
    matches(e) {
        return e.uri === this.uri && e.method === this.method && e.encrypted === this.encrypted && e.keyFormat === this.keyFormat && xu(e.keyFormatVersions, this.keyFormatVersions) && bh(e.iv, this.iv) && bh(e.keyId, this.keyId);
    }
    isSupported() {
        if (this.method) {
            if (wn(this.method) || this.method === "NONE") return !0;
            if (this.keyFormat === "identity") return this.method === "SAMPLE-AES";
            switch(this.keyFormat){
                case lr.FAIRPLAY:
                case lr.WIDEVINE:
                case lr.PLAYREADY:
                case lr.CLEARKEY:
                    return [
                        "SAMPLE-AES",
                        "SAMPLE-AES-CENC",
                        "SAMPLE-AES-CTR"
                    ].indexOf(this.method) !== -1;
            }
        }
        return !1;
    }
    getDecryptData(e) {
        if (!this.encrypted || !this.uri) return null;
        if (wn(this.method)) {
            let n1 = this.iv;
            return n1 || (typeof e != "number" && (rt.warn(`missing IV for initialization segment with method="${this.method}" - compliance issue`), e = 0), n1 = Hb(e)), new yi(this.method, this.uri, "identity", this.keyFormatVersions, n1);
        }
        if (this.pssh && this.keyId) return this;
        const t = $b(this.uri);
        if (t) switch(this.keyFormat){
            case lr.WIDEVINE:
                if (this.pssh = t, !this.keyId) {
                    const n1 = WS(t.buffer);
                    if (n1.length) {
                        var r;
                        const i = n1[0];
                        this.keyId = (r = i.kids) != null && r.length ? i.kids[0] : null;
                    }
                }
                if (!this.keyId) {
                    const n1 = t.length - 22;
                    this.keyId = t.subarray(n1, n1 + 16);
                }
                break;
            case lr.PLAYREADY:
                {
                    const n1 = new Uint8Array([
                        154,
                        4,
                        240,
                        121,
                        152,
                        64,
                        66,
                        134,
                        171,
                        146,
                        230,
                        91,
                        224,
                        136,
                        95,
                        149
                    ]);
                    this.pssh = qS(n1, null, t), this.keyId = Kb(t);
                    break;
                }
            default:
                {
                    let n1 = t.subarray(0, 16);
                    if (n1.length !== 16) {
                        const i = new Uint8Array(16);
                        i.set(n1, 16 - n1.length), n1 = i;
                    }
                    this.keyId = n1;
                    break;
                }
        }
        if (!this.keyId || this.keyId.byteLength !== 16) {
            let n1 = Wi[this.uri];
            if (!n1) {
                const i = Object.keys(Wi).length % Number.MAX_SAFE_INTEGER;
                n1 = new Uint8Array(16), new DataView(n1.buffer, 12, 4).setUint32(0, i), yi.setKeyIdForUri(this.uri, n1);
            }
            this.keyId = n1;
        }
        return this;
    }
}
function Hb(s) {
    const e = new Uint8Array(16);
    for(let t = 12; t < 16; t++)e[t] = s >> 8 * (15 - t) & 255;
    return e;
}
const Th = /#EXT-X-STREAM-INF:([^\r\n]*)(?:[\r\n](?:#[^\r\n]*)?)*([^\r\n]+)|#EXT-X-(SESSION-DATA|SESSION-KEY|DEFINE|CONTENT-STEERING|START):([^\r\n]*)[\r\n]+/g, wh = /#EXT-X-MEDIA:(.*)/g, qb = /^#EXT(?:INF|-X-TARGETDURATION):/m, gl = new RegExp([
    /#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source,
    // duration (#EXTINF:<duration>,<title>), group 1 => duration, group 2 => title
    /(?!#) *(\S[^\r\n]*)/.source,
    // segment URI, group 3 => the URI (note newline is not eaten)
    /#.*/.source
].join("|"), "g"), Wb = new RegExp([
    /#EXT-X-(PROGRAM-DATE-TIME|BYTERANGE|DATERANGE|DEFINE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/.source,
    /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\d+)/.source,
    /#EXT-X-(DISCONTINUITY|ENDLIST|GAP|INDEPENDENT-SEGMENTS)/.source,
    /(#)([^:]*):(.*)/.source,
    /(#)(.*)(?:.*)\r?\n?/.source
].join("|"));
class zr {
    static findGroup(e, t) {
        for(let r = 0; r < e.length; r++){
            const n1 = e[r];
            if (n1.id === t) return n1;
        }
    }
    static resolve(e, t) {
        return hu.buildAbsoluteURL(t, e, {
            alwaysNormalize: !0
        });
    }
    static isMediaPlaylist(e) {
        return qb.test(e);
    }
    static parseMasterPlaylist(e, t) {
        const r = Eh(e), n1 = {
            contentSteering: null,
            levels: [],
            playlistParsingError: null,
            sessionData: null,
            sessionKeys: null,
            startTimeOffset: null,
            variableList: null,
            hasVariableRefs: r
        }, i = [];
        if (Th.lastIndex = 0, !e.startsWith("#EXTM3U")) return n1.playlistParsingError = new Error("no EXTM3U delimiter"), n1;
        let o;
        for(; (o = Th.exec(e)) != null;)if (o[1]) {
            var a;
            const c = new ft(o[1], n1), u = dc(n1, o[2]), d1 = {
                attrs: c,
                bitrate: c.decimalInteger("BANDWIDTH") || c.decimalInteger("AVERAGE-BANDWIDTH"),
                name: c.NAME,
                url: zr.resolve(u, t)
            }, h = c.decimalResolution("RESOLUTION");
            h && (d1.width = h.width, d1.height = h.height), _h(c.CODECS, d1);
            const f = c["SUPPLEMENTAL-CODECS"];
            f && (d1.supplemental = {}, _h(f, d1.supplemental)), (a = d1.unknownCodecs) != null && a.length || i.push(d1), n1.levels.push(d1);
        } else if (o[3]) {
            const c = o[3], u = o[4];
            switch(c){
                case "SESSION-DATA":
                    {
                        const d1 = new ft(u, n1), h = d1["DATA-ID"];
                        h && (n1.sessionData === null && (n1.sessionData = {}), n1.sessionData[h] = d1);
                        break;
                    }
                case "SESSION-KEY":
                    {
                        const d1 = Ah(u, t, n1);
                        d1.encrypted && d1.isSupported() ? (n1.sessionKeys === null && (n1.sessionKeys = []), n1.sessionKeys.push(d1)) : rt.warn(`[Keys] Ignoring invalid EXT-X-SESSION-KEY tag: "${u}"`);
                        break;
                    }
                case "DEFINE":
                    {
                        {
                            const d1 = new ft(u, n1);
                            xh(n1, d1, t);
                        }
                        break;
                    }
                case "CONTENT-STEERING":
                    {
                        const d1 = new ft(u, n1);
                        n1.contentSteering = {
                            uri: zr.resolve(d1["SERVER-URI"], t),
                            pathwayId: d1["PATHWAY-ID"] || "."
                        };
                        break;
                    }
                case "START":
                    {
                        n1.startTimeOffset = Ih(u);
                        break;
                    }
            }
        }
        const l = i.length > 0 && i.length < n1.levels.length;
        return n1.levels = l ? i : n1.levels, n1.levels.length === 0 && (n1.playlistParsingError = new Error("no levels found in manifest")), n1;
    }
    static parseMasterPlaylistMedia(e, t, r) {
        let n1;
        const i = {}, o = r.levels, a = {
            AUDIO: o.map((c)=>({
                    id: c.attrs.AUDIO,
                    audioCodec: c.audioCodec
                })),
            SUBTITLES: o.map((c)=>({
                    id: c.attrs.SUBTITLES,
                    textCodec: c.textCodec
                })),
            "CLOSED-CAPTIONS": []
        };
        let l = 0;
        for(wh.lastIndex = 0; (n1 = wh.exec(e)) !== null;){
            const c = new ft(n1[1], r), u = c.TYPE;
            if (u) {
                const d1 = a[u], h = i[u] || [];
                i[u] = h;
                const f = c.LANGUAGE, p = c["ASSOC-LANGUAGE"], y = c.CHANNELS, E = c.CHARACTERISTICS, b = c["INSTREAM-ID"], L = {
                    attrs: c,
                    bitrate: 0,
                    id: l++,
                    groupId: c["GROUP-ID"] || "",
                    name: c.NAME || f || "",
                    type: u,
                    default: c.bool("DEFAULT"),
                    autoselect: c.bool("AUTOSELECT"),
                    forced: c.bool("FORCED"),
                    lang: f,
                    url: c.URI ? zr.resolve(c.URI, t) : ""
                };
                if (p && (L.assocLang = p), y && (L.channels = y), E && (L.characteristics = E), b && (L.instreamId = b), d1 != null && d1.length) {
                    const A = zr.findGroup(d1, L.groupId) || d1[0];
                    Lh(L, A, "audioCodec"), Lh(L, A, "textCodec");
                }
                h.push(L);
            }
        }
        return i;
    }
    static parseLevelPlaylist(e, t, r, n1, i, o) {
        var a;
        const l = {
            url: t
        }, c = new Nb(t), u = c.fragments, d1 = [];
        let h = null, f = 0, p = 0, y = 0, E = 0, b = 0, L = null, A = new ul(n1, l), F, M, H, K = -1, j = !1, C = null, k;
        if (gl.lastIndex = 0, c.m3u8 = e, c.hasVariableRefs = Eh(e), ((a = gl.exec(e)) == null ? void 0 : a[0]) !== "#EXTM3U") return c.playlistParsingError = new Error("Missing format identifier #EXTM3U"), c;
        for(; (F = gl.exec(e)) !== null;){
            j && (j = !1, A = new ul(n1, l), A.playlistOffset = y, A.setStart(y), A.sn = f, A.cc = E, b && (A.bitrate = b), A.level = r, h && (A.initSegment = h, h.rawProgramDateTime && (A.rawProgramDateTime = h.rawProgramDateTime, h.rawProgramDateTime = null), C && (A.setByteRange(C), C = null)));
            const g = F[1];
            if (g) {
                A.duration = parseFloat(g);
                const x = (" " + F[2]).slice(1);
                A.title = x || null, A.tagList.push(x ? [
                    "INF",
                    g,
                    x
                ] : [
                    "INF",
                    g
                ]);
            } else if (F[3]) {
                if (ue(A.duration)) {
                    A.playlistOffset = y, A.setStart(y), H && Ch(A, H, c), A.sn = f, A.level = r, A.cc = E, u.push(A);
                    const x = (" " + F[3]).slice(1);
                    A.relurl = dc(c, x), fc(A, L, d1), L = A, y += A.duration, f++, p = 0, j = !0;
                }
            } else {
                if (F = F[0].match(Wb), !F) {
                    rt.warn("No matches on slow regex match for level playlist!");
                    continue;
                }
                for(M = 1; M < F.length && F[M] === void 0; M++);
                const x = (" " + F[M]).slice(1), w = (" " + F[M + 1]).slice(1), D = F[M + 2] ? (" " + F[M + 2]).slice(1) : null;
                switch(x){
                    case "BYTERANGE":
                        L ? A.setByteRange(w, L) : A.setByteRange(w);
                        break;
                    case "PROGRAM-DATE-TIME":
                        A.rawProgramDateTime = w, A.tagList.push([
                            "PROGRAM-DATE-TIME",
                            w
                        ]), K === -1 && (K = u.length);
                        break;
                    case "PLAYLIST-TYPE":
                        c.type && ns(c, x, F), c.type = w.toUpperCase();
                        break;
                    case "MEDIA-SEQUENCE":
                        c.startSN !== 0 ? ns(c, x, F) : u.length > 0 && kh(c, x, F), f = c.startSN = parseInt(w);
                        break;
                    case "SKIP":
                        {
                            c.skippedSegments && ns(c, x, F);
                            const O = new ft(w, c), U = O.decimalInteger("SKIPPED-SEGMENTS");
                            if (ue(U)) {
                                c.skippedSegments += U;
                                for(let R = U; R--;)u.push(null);
                                f += U;
                            }
                            const V = O.enumeratedString("RECENTLY-REMOVED-DATERANGES");
                            V && (c.recentlyRemovedDateranges = (c.recentlyRemovedDateranges || []).concat(V.split("	")));
                            break;
                        }
                    case "TARGETDURATION":
                        c.targetduration !== 0 && ns(c, x, F), c.targetduration = Math.max(parseInt(w), 1);
                        break;
                    case "VERSION":
                        c.version !== null && ns(c, x, F), c.version = parseInt(w);
                        break;
                    case "INDEPENDENT-SEGMENTS":
                        break;
                    case "ENDLIST":
                        c.live || ns(c, x, F), c.live = !1;
                        break;
                    case "#":
                        (w || D) && A.tagList.push(D ? [
                            w,
                            D
                        ] : [
                            w
                        ]);
                        break;
                    case "DISCONTINUITY":
                        E++, A.tagList.push([
                            "DIS"
                        ]);
                        break;
                    case "GAP":
                        A.gap = !0, A.tagList.push([
                            x
                        ]);
                        break;
                    case "BITRATE":
                        A.tagList.push([
                            x,
                            w
                        ]), b = parseInt(w) * 1e3, ue(b) ? A.bitrate = b : b = 0;
                        break;
                    case "DATERANGE":
                        {
                            const O = new ft(w, c), U = new Wg(O, c.dateRanges[O.ID], c.dateRangeTagCount);
                            c.dateRangeTagCount++, U.isValid || c.skippedSegments ? c.dateRanges[U.id] = U : rt.warn(`Ignoring invalid DATERANGE tag: "${w}"`), A.tagList.push([
                                "EXT-X-DATERANGE",
                                w
                            ]);
                            break;
                        }
                    case "DEFINE":
                        {
                            {
                                const O = new ft(w, c);
                                "IMPORT" in O ? Db(c, O, o) : xh(c, O, t);
                            }
                            break;
                        }
                    case "DISCONTINUITY-SEQUENCE":
                        c.startCC !== 0 ? ns(c, x, F) : u.length > 0 && kh(c, x, F), c.startCC = E = parseInt(w);
                        break;
                    case "KEY":
                        {
                            const O = Ah(w, t, c);
                            if (O.isSupported()) {
                                if (O.method === "NONE") {
                                    H = void 0;
                                    break;
                                }
                                H || (H = {});
                                const U = H[O.keyFormat];
                                U != null && U.matches(O) || (U && (H = nt({}, H)), H[O.keyFormat] = O);
                            } else rt.warn(`[Keys] Ignoring unsupported EXT-X-KEY tag: "${w}"`);
                            break;
                        }
                    case "START":
                        c.startTimeOffset = Ih(w);
                        break;
                    case "MAP":
                        {
                            const O = new ft(w, c);
                            if (A.duration) {
                                const U = new ul(n1, l);
                                Rh(U, O, r, H), h = U, A.initSegment = h, h.rawProgramDateTime && !A.rawProgramDateTime && (A.rawProgramDateTime = h.rawProgramDateTime);
                            } else {
                                const U = A.byteRangeEndOffset;
                                if (U) {
                                    const V = A.byteRangeStartOffset;
                                    C = `${U - V}@${V}`;
                                } else C = null;
                                Rh(A, O, r, H), h = A, j = !0;
                            }
                            h.cc = E;
                            break;
                        }
                    case "SERVER-CONTROL":
                        {
                            k && ns(c, x, F), k = new ft(w), c.canBlockReload = k.bool("CAN-BLOCK-RELOAD"), c.canSkipUntil = k.optionalFloat("CAN-SKIP-UNTIL", 0), c.canSkipDateRanges = c.canSkipUntil > 0 && k.bool("CAN-SKIP-DATERANGES"), c.partHoldBack = k.optionalFloat("PART-HOLD-BACK", 0), c.holdBack = k.optionalFloat("HOLD-BACK", 0);
                            break;
                        }
                    case "PART-INF":
                        {
                            c.partTarget && ns(c, x, F);
                            const O = new ft(w);
                            c.partTarget = O.decimalFloatingPoint("PART-TARGET");
                            break;
                        }
                    case "PART":
                        {
                            let O = c.partList;
                            O || (O = c.partList = []);
                            const U = p > 0 ? O[O.length - 1] : void 0, V = p++, R = new ft(w, c), m = new PS(R, A, l, V, U);
                            O.push(m), A.duration += m.duration;
                            break;
                        }
                    case "PRELOAD-HINT":
                        {
                            const O = new ft(w, c);
                            c.preloadHint = O;
                            break;
                        }
                    case "RENDITION-REPORT":
                        {
                            const O = new ft(w, c);
                            c.renditionReports = c.renditionReports || [], c.renditionReports.push(O);
                            break;
                        }
                    default:
                        rt.warn(`line parsed but not handled: ${F}`);
                        break;
                }
            }
        }
        L && !L.relurl ? (u.pop(), y -= L.duration, c.partList && (c.fragmentHint = L)) : c.partList && (fc(A, L, d1), A.cc = E, c.fragmentHint = A, H && Ch(A, H, c)), c.targetduration || (c.playlistParsingError = new Error("Missing Target Duration"));
        const $ = u.length, W = u[0], _ = u[$ - 1];
        if (y += c.skippedSegments * c.targetduration, y > 0 && $ && _) {
            c.averagetargetduration = y / $;
            const g = _.sn;
            c.endSN = g !== "initSegment" ? g : 0, c.live || (_.endList = !0), K > 0 && (Yb(u, K), W && d1.unshift(W));
        }
        return c.fragmentHint && (y += c.fragmentHint.duration), c.totalduration = y, d1.length && c.dateRangeTagCount && W && Zg(d1, c), c.endCC = E, c;
    }
}
function Zg(s, e) {
    let t = s.length;
    if (!t) if (e.hasProgramDateTime) {
        const a = e.fragments[e.fragments.length - 1];
        s.push(a), t++;
    } else return;
    const r = s[t - 1], n1 = e.live ? 1 / 0 : e.totalduration, i = Object.keys(e.dateRanges);
    for(let a = i.length; a--;){
        const l = e.dateRanges[i[a]], c = l.startDate.getTime();
        l.tagAnchor = r.ref;
        for(let u = t; u--;){
            var o;
            if (((o = s[u]) == null ? void 0 : o.sn) < e.startSN) break;
            const d1 = zb(e, c, s, u, n1);
            if (d1 !== -1) {
                l.tagAnchor = e.fragments[d1].ref;
                break;
            }
        }
    }
}
function zb(s, e, t, r, n1) {
    const i = t[r];
    if (i) {
        const a = i.programDateTime;
        if (e >= a || r === 0) {
            var o;
            const l = (((o = t[r + 1]) == null ? void 0 : o.start) || n1) - i.start;
            if (e <= a + l * 1e3) {
                const c = t[r].sn - s.startSN;
                if (c < 0) return -1;
                const u = s.fragments;
                if (u.length > t.length) {
                    const h = (t[r + 1] || u[u.length - 1]).sn - s.startSN;
                    for(let f = h; f > c; f--){
                        const p = u[f].programDateTime;
                        if (e >= p && e < p + u[f].duration * 1e3) return f;
                    }
                }
                return c;
            }
        }
    }
    return -1;
}
function Ah(s, e, t) {
    var r, n1;
    const i = new ft(s, t), o = (r = i.METHOD) != null ? r : "", a = i.URI, l = i.hexadecimalInteger("IV"), c = i.KEYFORMATVERSIONS, u = (n1 = i.KEYFORMAT) != null ? n1 : "identity";
    a && i.IV && !l && rt.error(`Invalid IV: ${i.IV}`);
    const d1 = a ? zr.resolve(a, e) : "", h = (c || "1").split("/").map(Number).filter(Number.isFinite);
    return new yi(o, d1, u, h, l, i.KEYID);
}
function Ih(s) {
    const t = new ft(s).decimalFloatingPoint("TIME-OFFSET");
    return ue(t) ? t : null;
}
function _h(s, e) {
    let t = (s || "").split(/[ ,]+/).filter((r)=>r);
    [
        "video",
        "audio",
        "text"
    ].forEach((r)=>{
        const n1 = t.filter((i)=>pu(i, r));
        n1.length && (e[`${r}Codec`] = n1.map((i)=>i.split("/")[0]).join(","), t = t.filter((i)=>n1.indexOf(i) === -1));
    }), e.unknownCodecs = t;
}
function Lh(s, e, t) {
    const r = e[t];
    r && (s[t] = r);
}
function Yb(s, e) {
    let t = s[e];
    for(let r = e; r--;){
        const n1 = s[r];
        if (!n1) return;
        n1.programDateTime = t.programDateTime - n1.duration * 1e3, t = n1;
    }
}
function fc(s, e, t) {
    s.rawProgramDateTime ? t.push(s) : e != null && e.programDateTime && (s.programDateTime = e.endProgramDateTime);
}
function Rh(s, e, t, r) {
    s.relurl = e.URI, e.BYTERANGE && s.setByteRange(e.BYTERANGE), s.level = t, s.sn = "initSegment", r && (s.levelkeys = r), s.initSegment = null;
}
function Ch(s, e, t) {
    s.levelkeys = e;
    const { encryptedFragments: r } = t;
    (!r.length || r[r.length - 1].levelkeys !== e) && Object.keys(e).some((n1)=>e[n1].isCommonEncryption) && r.push(s);
}
function ns(s, e, t) {
    s.playlistParsingError = new Error(`#EXT-X-${e} must not appear more than once (${t[0]})`);
}
function kh(s, e, t) {
    s.playlistParsingError = new Error(`#EXT-X-${e} must appear before the first Media Segment (${t[0]})`);
}
function pl(s, e) {
    const t = e.startPTS;
    if (ue(t)) {
        let r = 0, n1;
        e.sn > s.sn ? (r = t - s.start, n1 = s) : (r = s.start - t, n1 = e), n1.duration !== r && n1.setDuration(r);
    } else e.sn > s.sn ? s.cc === e.cc && s.minEndPTS ? e.setStart(s.start + (s.minEndPTS - s.start)) : e.setStart(s.start + s.duration) : e.setStart(Math.max(s.start - e.duration, 0));
}
function Xg(s, e, t, r, n1, i, o) {
    r - t <= 0 && (o.warn("Fragment should have a positive duration", e), r = t + e.duration, i = n1 + e.duration);
    let l = t, c = r;
    const u = e.startPTS, d1 = e.endPTS;
    if (ue(u)) {
        const b = Math.abs(u - t);
        s && b > s.totalduration ? o.warn(`media timestamps and playlist times differ by ${b}s for level ${e.level} ${s.url}`) : ue(e.deltaPTS) ? e.deltaPTS = Math.max(b, e.deltaPTS) : e.deltaPTS = b, l = Math.max(t, u), t = Math.min(t, u), n1 = e.startDTS !== void 0 ? Math.min(n1, e.startDTS) : n1, c = Math.min(r, d1), r = Math.max(r, d1), i = e.endDTS !== void 0 ? Math.max(i, e.endDTS) : i;
    }
    const h = t - e.start;
    e.start !== 0 && e.setStart(t), e.setDuration(r - e.start), e.startPTS = t, e.maxStartPTS = l, e.startDTS = n1, e.endPTS = r, e.minEndPTS = c, e.endDTS = i;
    const f = e.sn;
    if (!s || f < s.startSN || f > s.endSN) return 0;
    let p;
    const y = f - s.startSN, E = s.fragments;
    for(E[y] = e, p = y; p > 0; p--)pl(E[p], E[p - 1]);
    for(p = y; p < E.length - 1; p++)pl(E[p], E[p + 1]);
    return s.fragmentHint && pl(E[E.length - 1], s.fragmentHint), s.PTSKnown = s.alignedSliding = !0, h;
}
function Zb(s, e, t) {
    if (s === e) return;
    let r = null;
    const n1 = s.fragments;
    for(let u = n1.length - 1; u >= 0; u--){
        const d1 = n1[u].initSegment;
        if (d1) {
            r = d1;
            break;
        }
    }
    s.fragmentHint && delete s.fragmentHint.endPTS;
    let i;
    Qb(s, e, (u, d1, h, f)=>{
        if ((!e.startCC || e.skippedSegments) && d1.cc !== u.cc) {
            const p = u.cc - d1.cc;
            for(let y = h; y < f.length; y++)f[y].cc += p;
            e.endCC = f[f.length - 1].cc;
        }
        ue(u.startPTS) && ue(u.endPTS) && (d1.setStart(d1.startPTS = u.startPTS), d1.startDTS = u.startDTS, d1.maxStartPTS = u.maxStartPTS, d1.endPTS = u.endPTS, d1.endDTS = u.endDTS, d1.minEndPTS = u.minEndPTS, d1.setDuration(u.endPTS - u.startPTS), d1.duration && (i = d1), e.PTSKnown = e.alignedSliding = !0), u.hasStreams && (d1.elementaryStreams = u.elementaryStreams), d1.loader = u.loader, u.hasStats && (d1.stats = u.stats), u.initSegment && (d1.initSegment = u.initSegment, r = u.initSegment);
    });
    const o = e.fragments, a = e.fragmentHint ? o.concat(e.fragmentHint) : o;
    if (r && a.forEach((u)=>{
        var d1;
        u && (!u.initSegment || u.initSegment.relurl === ((d1 = r) == null ? void 0 : d1.relurl)) && (u.initSegment = r);
    }), e.skippedSegments) {
        if (e.deltaUpdateFailed = o.some((u)=>!u), e.deltaUpdateFailed) {
            t.warn("[level-helper] Previous playlist missing segments skipped in delta playlist");
            for(let u = e.skippedSegments; u--;)o.shift();
            e.startSN = o[0].sn;
        } else {
            e.canSkipDateRanges && (e.dateRanges = Xb(s.dateRanges, e, t));
            const u = s.fragments.filter((d1)=>d1.rawProgramDateTime);
            if (s.hasProgramDateTime && !e.hasProgramDateTime) for(let d1 = 1; d1 < a.length; d1++)a[d1].programDateTime === null && fc(a[d1], a[d1 - 1], u);
            Zg(u, e);
        }
        e.endCC = o[o.length - 1].cc;
    }
    if (!e.startCC) {
        var l;
        const u = ep(s, e.startSN - 1);
        e.startCC = (l = u == null ? void 0 : u.cc) != null ? l : o[0].cc;
    }
    Jb(s.partList, e.partList, (u, d1)=>{
        d1.elementaryStreams = u.elementaryStreams, d1.stats = u.stats;
    }), i ? Xg(e, i, i.startPTS, i.endPTS, i.startDTS, i.endDTS, t) : Jg(s, e), o.length && (e.totalduration = e.edge - o[0].start), e.driftStartTime = s.driftStartTime, e.driftStart = s.driftStart;
    const c = e.advancedDateTime;
    if (e.advanced && c) {
        const u = e.edge;
        e.driftStart || (e.driftStartTime = c, e.driftStart = u), e.driftEndTime = c, e.driftEnd = u;
    } else e.driftEndTime = s.driftEndTime, e.driftEnd = s.driftEnd, e.advancedDateTime = s.advancedDateTime;
    e.requestScheduled === -1 && (e.requestScheduled = s.requestScheduled);
}
function Xb(s, e, t) {
    const { dateRanges: r, recentlyRemovedDateranges: n1 } = e, i = nt({}, s);
    n1 && n1.forEach((l)=>{
        delete i[l];
    });
    const a = Object.keys(i).length;
    return a ? (Object.keys(r).forEach((l)=>{
        const c = i[l], u = new Wg(r[l].attr, c);
        u.isValid ? (i[l] = u, c || (u.tagOrder += a)) : t.warn(`Ignoring invalid Playlist Delta Update DATERANGE tag: "${at(r[l].attr)}"`);
    }), i) : r;
}
function Jb(s, e, t) {
    if (s && e) {
        let r = 0;
        for(let n1 = 0, i = s.length; n1 <= i; n1++){
            const o = s[n1], a = e[n1 + r];
            o && a && o.index === a.index && o.fragment.sn === a.fragment.sn ? t(o, a) : r--;
        }
    }
}
function Qb(s, e, t) {
    const r = e.skippedSegments, n1 = Math.max(s.startSN, e.startSN) - e.startSN, i = (s.fragmentHint ? 1 : 0) + (r ? e.endSN : Math.min(s.endSN, e.endSN)) - e.startSN, o = e.startSN - s.startSN, a = e.fragmentHint ? e.fragments.concat(e.fragmentHint) : e.fragments, l = s.fragmentHint ? s.fragments.concat(s.fragmentHint) : s.fragments;
    for(let c = n1; c <= i; c++){
        const u = l[o + c];
        let d1 = a[c];
        if (r && !d1 && u && (d1 = e.fragments[c] = u), u && d1) {
            t(u, d1, c, a);
            const h = u.relurl, f = d1.relurl;
            if (h && eT(h, f)) {
                e.playlistParsingError = Dh(`media sequence mismatch ${d1.sn}:`, s, e, u, d1);
                return;
            } else if (u.cc !== d1.cc) {
                e.playlistParsingError = Dh(`discontinuity sequence mismatch (${u.cc}!=${d1.cc})`, s, e, u, d1);
                return;
            }
        }
    }
}
function Dh(s, e, t, r, n1) {
    return new Error(`${s} ${n1.url}
Playlist starting @${e.startSN}
${e.m3u8}

Playlist starting @${t.startSN}
${t.m3u8}`);
}
function Jg(s, e, t = !0) {
    const r = e.startSN + e.skippedSegments - s.startSN, n1 = s.fragments, i = r >= 0;
    let o = 0;
    if (i && r < n1.length) o = n1[r].start;
    else if (i && e.startSN === s.endSN + 1) o = s.fragmentEnd;
    else if (i && t) o = s.fragmentStart + r * e.levelTargetDuration;
    else if (!e.skippedSegments && e.fragmentStart === 0) o = s.fragmentStart;
    else return;
    gc(e, o);
}
function gc(s, e) {
    if (e) {
        const t = s.fragments;
        for(let r = s.skippedSegments; r < t.length; r++)t[r].addStart(e);
        s.fragmentHint && s.fragmentHint.addStart(e);
    }
}
function Qg(s, e = 1 / 0) {
    let t = 1e3 * s.targetduration;
    if (s.updated) {
        const r = s.fragments;
        if (r.length && t * 4 > e) {
            const i = r[r.length - 1].duration * 1e3;
            i < t && (t = i);
        }
    } else t /= 2;
    return Math.round(t);
}
function ep(s, e, t) {
    if (!s) return null;
    let r = s.fragments[e - s.startSN];
    return r || (r = s.fragmentHint, r && r.sn === e) ? r : e < s.startSN && t && t.sn === e ? t : null;
}
function Ph(s, e, t) {
    return s ? tp(s.partList, e, t) : null;
}
function tp(s, e, t) {
    if (s) for(let r = s.length; r--;){
        const n1 = s[r];
        if (n1.index === t && n1.fragment.sn === e) return n1;
    }
    return null;
}
function rp(s) {
    s.forEach((e, t)=>{
        var r;
        (r = e.details) == null || r.fragments.forEach((n1)=>{
            n1.level = t, n1.initSegment && (n1.initSegment.level = t);
        });
    });
}
function eT(s, e) {
    return s !== e && e ? Mh(s) !== Mh(e) : !1;
}
function Mh(s) {
    return s.replace(/\?[^?]*$/, "");
}
function Yn(s, e) {
    for(let r = 0, n1 = s.length; r < n1; r++){
        var t;
        if (((t = s[r]) == null ? void 0 : t.cc) === e) return s[r];
    }
    return null;
}
function tT(s, e) {
    return !!(s && e.startCC < s.endCC && e.endCC > s.startCC);
}
function Oh(s, e) {
    const t = s.start + e;
    s.startPTS = t, s.setStart(t), s.endPTS = t + s.duration;
}
function sp(s, e) {
    const t = e.fragments;
    for(let r = 0, n1 = t.length; r < n1; r++)Oh(t[r], s);
    e.fragmentHint && Oh(e.fragmentHint, s), e.alignedSliding = !0;
}
function rT(s, e) {
    s && (np(e, s), e.alignedSliding || sa(e, s), !e.alignedSliding && !e.skippedSegments && Jg(s, e, !1));
}
function np(s, e) {
    if (!tT(e, s)) return;
    const t = Math.min(e.endCC, s.endCC), r = Yn(e.fragments, t), n1 = Yn(s.fragments, t);
    if (!r || !n1) return;
    rt.log(`Aligning playlist at start of dicontinuity sequence ${t}`);
    const i = r.start - n1.start;
    sp(i, s);
}
function sa(s, e) {
    if (!s.hasProgramDateTime || !e.hasProgramDateTime) return;
    const t = s.fragments, r = e.fragments;
    if (!t.length || !r.length) return;
    let n1, i;
    const o = Math.min(e.endCC, s.endCC);
    e.startCC < o && s.startCC < o && (n1 = Yn(r, o), i = Yn(t, o)), (!n1 || !i) && (n1 = r[Math.floor(r.length / 2)], i = Yn(t, n1.cc) || t[Math.floor(t.length / 2)]);
    const a = n1.programDateTime, l = i.programDateTime;
    if (!a || !l) return;
    const c = (l - a) / 1e3 - (i.start - n1.start);
    sp(c, s);
}
function cr(s, e, t) {
    pr(s, e, t), s.addEventListener(e, t);
}
function pr(s, e, t) {
    s.removeEventListener(e, t);
}
const sT = {
    toString: function(s) {
        let e = "";
        const t = s.length;
        for(let r = 0; r < t; r++)e += `[${s.start(r).toFixed(3)}-${s.end(r).toFixed(3)}]`;
        return e;
    }
}, ne = {
    STOPPED: "STOPPED",
    IDLE: "IDLE",
    KEY_LOADING: "KEY_LOADING",
    FRAG_LOADING: "FRAG_LOADING",
    FRAG_LOADING_WAITING_RETRY: "FRAG_LOADING_WAITING_RETRY",
    WAITING_TRACK: "WAITING_TRACK",
    PARSING: "PARSING",
    PARSED: "PARSED",
    ENDED: "ENDED",
    ERROR: "ERROR",
    WAITING_INIT_PTS: "WAITING_INIT_PTS",
    WAITING_LEVEL: "WAITING_LEVEL"
};
class Tu extends Hg {
    constructor(e, t, r, n1, i){
        super(n1, e.logger), this.hls = void 0, this.fragPrevious = null, this.fragCurrent = null, this.fragmentTracker = void 0, this.transmuxer = null, this._state = ne.STOPPED, this.playlistType = void 0, this.media = null, this.mediaBuffer = null, this.config = void 0, this.bitrateTest = !1, this.lastCurrentTime = 0, this.nextLoadPosition = 0, this.startPosition = 0, this.startTimeOffset = null, this.retryDate = 0, this.levels = null, this.fragmentLoader = void 0, this.keyLoader = void 0, this.levelLastLoaded = null, this.startFragRequested = !1, this.decrypter = void 0, this.initPTS = [], this.buffering = !0, this.loadingParts = !1, this.loopSn = void 0, this.onMediaSeeking = ()=>{
            const { config: o, fragCurrent: a, media: l, mediaBuffer: c, state: u } = this, d1 = l ? l.currentTime : 0, h = Ce.bufferInfo(c || l, d1, o.maxBufferHole), f = !h.len;
            if (this.log(`Media seeking to ${ue(d1) ? d1.toFixed(3) : d1}, state: ${u}, ${f ? "out of" : "in"} buffer`), this.state === ne.ENDED) this.resetLoadingState();
            else if (a) {
                const p = o.maxFragLookUpTolerance, y = a.start - p, E = a.start + a.duration + p;
                if (f || E < h.start || y > h.end) {
                    const b = d1 > E;
                    (d1 < y || b) && (b && a.loader && (this.log(`Cancelling fragment load for seek (sn: ${a.sn})`), a.abortRequests(), this.resetLoadingState()), this.fragPrevious = null);
                }
            }
            if (l) {
                this.fragmentTracker.removeFragmentsInRange(d1, 1 / 0, this.playlistType, !0);
                const p = this.lastCurrentTime;
                if (d1 > p && (this.lastCurrentTime = d1), !this.loadingParts) {
                    const y = Math.max(h.end, d1), E = this.shouldLoadParts(this.getLevelDetails(), y);
                    E && (this.log(`LL-Part loading ON after seeking to ${d1.toFixed(2)} with buffer @${y.toFixed(2)}`), this.loadingParts = E);
                }
            }
            this.hls.hasEnoughToStart || (this.log(`Setting ${f ? "startPosition" : "nextLoadPosition"} to ${d1} for seek without enough to start`), this.nextLoadPosition = d1, f && (this.startPosition = d1)), f && this.state === ne.IDLE && this.tickImmediate();
        }, this.onMediaEnded = ()=>{
            this.log("setting startPosition to 0 because media ended"), this.startPosition = this.lastCurrentTime = 0;
        }, this.playlistType = i, this.hls = e, this.fragmentLoader = new Cb(e.config), this.keyLoader = r, this.fragmentTracker = t, this.config = e.config, this.decrypter = new vu(e.config);
    }
    registerListeners() {
        const { hls: e } = this;
        e.on(I.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(I.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(I.MANIFEST_LOADING, this.onManifestLoading, this), e.on(I.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(I.ERROR, this.onError, this);
    }
    unregisterListeners() {
        const { hls: e } = this;
        e.off(I.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(I.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(I.MANIFEST_LOADING, this.onManifestLoading, this), e.off(I.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(I.ERROR, this.onError, this);
    }
    doTick() {
        this.onTickEnd();
    }
    onTickEnd() {}
    startLoad(e) {}
    stopLoad() {
        if (this.state === ne.STOPPED) return;
        this.fragmentLoader.abort(), this.keyLoader.abort(this.playlistType);
        const e = this.fragCurrent;
        e != null && e.loader && (e.abortRequests(), this.fragmentTracker.removeFragment(e)), this.resetTransmuxer(), this.fragCurrent = null, this.fragPrevious = null, this.clearInterval(), this.clearNextTick(), this.state = ne.STOPPED;
    }
    get startPositionValue() {
        const { nextLoadPosition: e, startPosition: t } = this;
        return t === -1 && e ? e : t;
    }
    get bufferingEnabled() {
        return this.buffering;
    }
    pauseBuffering() {
        this.buffering = !1;
    }
    resumeBuffering() {
        this.buffering = !0;
    }
    get inFlightFrag() {
        return {
            frag: this.fragCurrent,
            state: this.state
        };
    }
    _streamEnded(e, t) {
        if (t.live || !this.media) return !1;
        const r = e.end || 0, n1 = this.config.timelineOffset || 0;
        if (r <= n1) return !1;
        const i = e.buffered;
        this.config.maxBufferHole && i && i.length > 1 && (e = Ce.bufferedInfo(i, e.start, 0));
        const o = e.nextStart;
        if (o && o > n1 && o < t.edge || this.media.currentTime < e.start) return !1;
        const l = t.partList;
        if (l != null && l.length) {
            const u = l[l.length - 1];
            return Ce.isBuffered(this.media, u.start + u.duration / 2);
        }
        const c = t.fragments[t.fragments.length - 1].type;
        return this.fragmentTracker.isEndListAppended(c);
    }
    getLevelDetails() {
        if (this.levels && this.levelLastLoaded !== null) return this.levelLastLoaded.details;
    }
    get timelineOffset() {
        const e = this.config.timelineOffset;
        if (e) {
            var t;
            return ((t = this.getLevelDetails()) == null ? void 0 : t.appliedTimelineOffset) || e;
        }
        return 0;
    }
    onMediaAttached(e, t) {
        const r = this.media = this.mediaBuffer = t.media;
        cr(r, "seeking", this.onMediaSeeking), cr(r, "ended", this.onMediaEnded);
        const n1 = this.config;
        this.levels && n1.autoStartLoad && this.state === ne.STOPPED && this.startLoad(n1.startPosition);
    }
    onMediaDetaching(e, t) {
        const r = !!t.transferMedia, n1 = this.media;
        if (n1 !== null) {
            if (n1.ended && (this.log("MSE detaching and video ended, reset startPosition"), this.startPosition = this.lastCurrentTime = 0), pr(n1, "seeking", this.onMediaSeeking), pr(n1, "ended", this.onMediaEnded), this.keyLoader && !r && this.keyLoader.detach(), this.media = this.mediaBuffer = null, this.loopSn = void 0, r) {
                this.resetLoadingState(), this.resetTransmuxer();
                return;
            }
            this.loadingParts = !1, this.fragmentTracker.removeAllFragments(), this.stopLoad();
        }
    }
    onManifestLoading() {
        this.initPTS = [], this.levels = this.levelLastLoaded = this.fragCurrent = null, this.lastCurrentTime = this.startPosition = 0, this.startFragRequested = !1;
    }
    onError(e, t) {}
    onManifestLoaded(e, t) {
        this.startTimeOffset = t.startTimeOffset;
    }
    onHandlerDestroying() {
        this.stopLoad(), this.transmuxer && (this.transmuxer.destroy(), this.transmuxer = null), super.onHandlerDestroying(), this.hls = this.onMediaSeeking = this.onMediaEnded = null;
    }
    onHandlerDestroyed() {
        this.state = ne.STOPPED, this.fragmentLoader && this.fragmentLoader.destroy(), this.keyLoader && this.keyLoader.destroy(), this.decrypter && this.decrypter.destroy(), this.hls = this.log = this.warn = this.decrypter = this.keyLoader = this.fragmentLoader = this.fragmentTracker = null, super.onHandlerDestroyed();
    }
    loadFragment(e, t, r) {
        this.startFragRequested = !0, this._loadFragForPlayback(e, t, r);
    }
    _loadFragForPlayback(e, t, r) {
        const n1 = (i)=>{
            const o = i.frag;
            if (this.fragContextChanged(o)) {
                this.warn(`${o.type} sn: ${o.sn}${i.part ? " part: " + i.part.index : ""} of ${this.fragInfo(o, !1, i.part)}) was dropped during download.`), this.fragmentTracker.removeFragment(o);
                return;
            }
            o.stats.chunkCount++, this._handleFragmentLoadProgress(i);
        };
        this._doFragLoad(e, t, r, n1).then((i)=>{
            if (!i) return;
            const o = this.state, a = i.frag;
            if (this.fragContextChanged(a)) {
                (o === ne.FRAG_LOADING || !this.fragCurrent && o === ne.PARSING) && (this.fragmentTracker.removeFragment(a), this.state = ne.IDLE);
                return;
            }
            "payload" in i && (this.log(`Loaded ${a.type} sn: ${a.sn} of ${this.playlistLabel()} ${a.level}`), this.hls.trigger(I.FRAG_LOADED, i)), this._handleFragmentLoadComplete(i);
        }).catch((i)=>{
            this.state === ne.STOPPED || this.state === ne.ERROR || (this.warn(`Frag error: ${(i == null ? void 0 : i.message) || i}`), this.resetFragmentLoading(e));
        });
    }
    clearTrackerIfNeeded(e) {
        var t;
        const { fragmentTracker: r } = this;
        if (r.getState(e) === Ht.APPENDING) {
            const i = e.type, o = this.getFwdBufferInfo(this.mediaBuffer, i), a = Math.max(e.duration, o ? o.len : this.config.maxBufferLength), l = this.backtrackFragment;
            ((l ? e.sn - l.sn : 0) === 1 || this.reduceMaxBufferLength(a, e.duration)) && r.removeFragment(e);
        } else ((t = this.mediaBuffer) == null ? void 0 : t.buffered.length) === 0 ? r.removeAllFragments() : r.hasParts(e.type) && (r.detectPartialFragments({
            frag: e,
            part: null,
            stats: e.stats,
            id: e.type
        }), r.getState(e) === Ht.PARTIAL && r.removeFragment(e));
    }
    checkLiveUpdate(e) {
        if (e.updated && !e.live) {
            const t = e.fragments[e.fragments.length - 1];
            this.fragmentTracker.detectPartialFragments({
                frag: t,
                part: null,
                stats: t.stats,
                id: t.type
            });
        }
        e.fragments[0] || (e.deltaUpdateFailed = !0);
    }
    waitForLive(e) {
        const t = e.details;
        return (t == null ? void 0 : t.live) && t.type !== "EVENT" && (this.levelLastLoaded !== e || t.expired);
    }
    flushMainBuffer(e, t, r = null) {
        if (!(e - t)) return;
        const n1 = {
            startOffset: e,
            endOffset: t,
            type: r
        };
        this.hls.trigger(I.BUFFER_FLUSHING, n1);
    }
    _loadInitSegment(e, t) {
        this._doFragLoad(e, t).then((r)=>{
            const n1 = r == null ? void 0 : r.frag;
            if (!n1 || this.fragContextChanged(n1) || !this.levels) throw new Error("init load aborted");
            return r;
        }).then((r)=>{
            const { hls: n1 } = this, { frag: i, payload: o } = r, a = i.decryptdata;
            if (o && o.byteLength > 0 && a != null && a.key && a.iv && wn(a.method)) {
                const l = self.performance.now();
                return this.decrypter.decrypt(new Uint8Array(o), a.key.buffer, a.iv.buffer, Su(a.method)).catch((c)=>{
                    throw n1.trigger(I.ERROR, {
                        type: ve.MEDIA_ERROR,
                        details: J.FRAG_DECRYPT_ERROR,
                        fatal: !1,
                        error: c,
                        reason: c.message,
                        frag: i
                    }), c;
                }).then((c)=>{
                    const u = self.performance.now();
                    return n1.trigger(I.FRAG_DECRYPTED, {
                        frag: i,
                        payload: c,
                        stats: {
                            tstart: l,
                            tdecrypt: u
                        }
                    }), r.payload = c, this.completeInitSegmentLoad(r);
                });
            }
            return this.completeInitSegmentLoad(r);
        }).catch((r)=>{
            this.state === ne.STOPPED || this.state === ne.ERROR || (this.warn(r), this.resetFragmentLoading(e));
        });
    }
    completeInitSegmentLoad(e) {
        const { levels: t } = this;
        if (!t) throw new Error("init load aborted, missing levels");
        const r = e.frag.stats;
        this.state !== ne.STOPPED && (this.state = ne.IDLE), e.frag.data = new Uint8Array(e.payload), r.parsing.start = r.buffering.start = self.performance.now(), r.parsing.end = r.buffering.end = self.performance.now(), this.tick();
    }
    unhandledEncryptionError(e, t) {
        var r, n1;
        const i = e.tracks;
        if (i && !t.encrypted && ((r = i.audio) != null && r.encrypted || (n1 = i.video) != null && n1.encrypted) && (!this.config.emeEnabled || !this.keyLoader.emeController)) {
            const o = this.media, a = new Error(`Encrypted track with no key in ${this.fragInfo(t)} (media ${o ? "attached mediaKeys: " + o.mediaKeys : "detached"})`);
            return this.warn(a.message), !o || o.mediaKeys ? !1 : (this.hls.trigger(I.ERROR, {
                type: ve.KEY_SYSTEM_ERROR,
                details: J.KEY_SYSTEM_NO_KEYS,
                fatal: !1,
                error: a,
                frag: t
            }), this.resetTransmuxer(), !0);
        }
        return !1;
    }
    fragContextChanged(e) {
        const { fragCurrent: t } = this;
        return !e || !t || e.sn !== t.sn || e.level !== t.level;
    }
    fragBufferedComplete(e, t) {
        const r = this.mediaBuffer ? this.mediaBuffer : this.media;
        if (this.log(`Buffered ${e.type} sn: ${e.sn}${t ? " part: " + t.index : ""} of ${this.fragInfo(e, !1, t)} > buffer:${r ? sT.toString(Ce.getBuffered(r)) : "(detached)"})`), Vt(e)) {
            var n1;
            if (e.type !== pe.SUBTITLE) {
                const o = e.elementaryStreams;
                if (!Object.keys(o).some((a)=>!!o[a])) {
                    this.state = ne.IDLE;
                    return;
                }
            }
            const i = (n1 = this.levels) == null ? void 0 : n1[e.level];
            i != null && i.fragmentError && (this.log(`Resetting level fragment error count of ${i.fragmentError} on frag buffered`), i.fragmentError = 0);
        }
        this.state = ne.IDLE;
    }
    _handleFragmentLoadComplete(e) {
        const { transmuxer: t } = this;
        if (!t) return;
        const { frag: r, part: n1, partsLoaded: i } = e, o = !i || i.length === 0 || i.some((l)=>!l), a = new Eu(r.level, r.sn, r.stats.chunkCount + 1, 0, n1 ? n1.index : -1, !o);
        t.flush(a);
    }
    _handleFragmentLoadProgress(e) {}
    _doFragLoad(e, t, r = null, n1) {
        var i;
        this.fragCurrent = e;
        const o = t.details;
        if (!this.levels || !o) throw new Error(`frag load aborted, missing level${o ? "" : " detail"}s`);
        let a = null;
        if (e.encrypted && !((i = e.decryptdata) != null && i.key)) {
            if (this.log(`Loading key for ${e.sn} of [${o.startSN}-${o.endSN}], ${this.playlistLabel()} ${e.level}`), this.state = ne.KEY_LOADING, this.fragCurrent = e, a = this.keyLoader.load(e).then((h)=>{
                if (!this.fragContextChanged(h.frag)) return this.hls.trigger(I.KEY_LOADED, h), this.state === ne.KEY_LOADING && (this.state = ne.IDLE), h;
            }), this.hls.trigger(I.KEY_LOADING, {
                frag: e
            }), this.fragCurrent === null) return this.log("context changed in KEY_LOADING"), Promise.resolve(null);
        } else e.encrypted || (a = this.keyLoader.loadClear(e, o.encryptedFragments, this.startFragRequested), a && this.log("[eme] blocking frag load until media-keys acquired"));
        const l = this.fragPrevious;
        if (Vt(e) && (!l || e.sn !== l.sn)) {
            const h = this.shouldLoadParts(t.details, e.end);
            h !== this.loadingParts && (this.log(`LL-Part loading ${h ? "ON" : "OFF"} loading sn ${l == null ? void 0 : l.sn}->${e.sn}`), this.loadingParts = h);
        }
        if (r = Math.max(e.start, r || 0), this.loadingParts && Vt(e)) {
            const h = o.partList;
            if (h && n1) {
                r > o.fragmentEnd && o.fragmentHint && (e = o.fragmentHint);
                const f = this.getNextPart(h, e, r);
                if (f > -1) {
                    const p = h[f];
                    e = this.fragCurrent = p.fragment, this.log(`Loading ${e.type} sn: ${e.sn} part: ${p.index} (${f}/${h.length - 1}) of ${this.fragInfo(e, !1, p)}) cc: ${e.cc} [${o.startSN}-${o.endSN}], target: ${parseFloat(r.toFixed(3))}`), this.nextLoadPosition = p.start + p.duration, this.state = ne.FRAG_LOADING;
                    let y;
                    return a ? y = a.then((E)=>!E || this.fragContextChanged(E.frag) ? null : this.doFragPartsLoad(e, p, t, n1)).catch((E)=>this.handleFragLoadError(E)) : y = this.doFragPartsLoad(e, p, t, n1).catch((E)=>this.handleFragLoadError(E)), this.hls.trigger(I.FRAG_LOADING, {
                        frag: e,
                        part: p,
                        targetBufferTime: r
                    }), this.fragCurrent === null ? Promise.reject(new Error("frag load aborted, context changed in FRAG_LOADING parts")) : y;
                } else if (!e.url || this.loadedEndOfParts(h, r)) return Promise.resolve(null);
            }
        }
        if (Vt(e) && this.loadingParts) {
            var c;
            this.log(`LL-Part loading OFF after next part miss @${r.toFixed(2)} Check buffer at sn: ${e.sn} loaded parts: ${(c = o.partList) == null ? void 0 : c.filter((h)=>h.loaded).map((h)=>`[${h.start}-${h.end}]`)}`), this.loadingParts = !1;
        } else if (!e.url) return Promise.resolve(null);
        this.log(`Loading ${e.type} sn: ${e.sn} of ${this.fragInfo(e, !1)}) cc: ${e.cc} ${"[" + o.startSN + "-" + o.endSN + "]"}, target: ${parseFloat(r.toFixed(3))}`), ue(e.sn) && !this.bitrateTest && (this.nextLoadPosition = e.start + e.duration), this.state = ne.FRAG_LOADING;
        const u = this.config.progressive;
        let d1;
        return u && a ? d1 = a.then((h)=>!h || this.fragContextChanged(h.frag) ? null : this.fragmentLoader.load(e, n1)).catch((h)=>this.handleFragLoadError(h)) : d1 = Promise.all([
            this.fragmentLoader.load(e, u ? n1 : void 0),
            a
        ]).then(([h])=>(!u && n1 && n1(h), h)).catch((h)=>this.handleFragLoadError(h)), this.hls.trigger(I.FRAG_LOADING, {
            frag: e,
            targetBufferTime: r
        }), this.fragCurrent === null ? Promise.reject(new Error("frag load aborted, context changed in FRAG_LOADING")) : d1;
    }
    doFragPartsLoad(e, t, r, n1) {
        return new Promise((i, o)=>{
            var a;
            const l = [], c = (a = r.details) == null ? void 0 : a.partList, u = (d1)=>{
                this.fragmentLoader.loadPart(e, d1, n1).then((h)=>{
                    l[d1.index] = h;
                    const f = h.part;
                    this.hls.trigger(I.FRAG_LOADED, h);
                    const p = Ph(r.details, e.sn, d1.index + 1) || tp(c, e.sn, d1.index + 1);
                    if (p) u(p);
                    else return i({
                        frag: e,
                        part: f,
                        partsLoaded: l
                    });
                }).catch(o);
            };
            u(t);
        });
    }
    handleFragLoadError(e) {
        if ("data" in e) {
            const t = e.data;
            t.frag && t.details === J.INTERNAL_ABORTED ? this.handleFragLoadAborted(t.frag, t.part) : t.frag && t.type === ve.KEY_SYSTEM_ERROR ? (t.frag.abortRequests(), this.resetStartWhenNotLoaded(), this.resetFragmentLoading(t.frag)) : this.hls.trigger(I.ERROR, t);
        } else this.hls.trigger(I.ERROR, {
            type: ve.OTHER_ERROR,
            details: J.INTERNAL_EXCEPTION,
            err: e,
            error: e,
            fatal: !0
        });
        return null;
    }
    _handleTransmuxerFlush(e) {
        const t = this.getCurrentContext(e);
        if (!t || this.state !== ne.PARSING) {
            !this.fragCurrent && this.state !== ne.STOPPED && this.state !== ne.ERROR && (this.state = ne.IDLE);
            return;
        }
        const { frag: r, part: n1, level: i } = t, o = self.performance.now();
        r.stats.parsing.end = o, n1 && (n1.stats.parsing.end = o);
        const a = this.getLevelDetails(), c = a && r.sn > a.endSN || this.shouldLoadParts(a, r.end);
        c !== this.loadingParts && (this.log(`LL-Part loading ${c ? "ON" : "OFF"} after parsing segment ending @${r.end.toFixed(2)}`), this.loadingParts = c), this.updateLevelTiming(r, n1, i, e.partial);
    }
    shouldLoadParts(e, t) {
        if (this.config.lowLatencyMode) {
            if (!e) return this.loadingParts;
            if (e.partList) {
                var r;
                const i = e.partList[0];
                if (i.fragment.type === pe.SUBTITLE) return !1;
                const o = i.end + (((r = e.fragmentHint) == null ? void 0 : r.duration) || 0);
                if (t >= o) {
                    var n1;
                    if ((this.hls.hasEnoughToStart ? ((n1 = this.media) == null ? void 0 : n1.currentTime) || this.lastCurrentTime : this.getLoadPosition()) > i.start - i.fragment.duration) return !0;
                }
            }
        }
        return !1;
    }
    getCurrentContext(e) {
        const { levels: t, fragCurrent: r } = this, { level: n1, sn: i, part: o } = e;
        if (!(t != null && t[n1])) return this.warn(`Levels object was unset while buffering fragment ${i} of ${this.playlistLabel()} ${n1}. The current chunk will not be buffered.`), null;
        const a = t[n1], l = a.details, c = o > -1 ? Ph(l, i, o) : null, u = c ? c.fragment : ep(l, i, r);
        return u ? (r && r !== u && (u.stats = r.stats), {
            frag: u,
            part: c,
            level: a
        }) : null;
    }
    bufferFragmentData(e, t, r, n1, i) {
        if (this.state !== ne.PARSING) return;
        const { data1: o, data2: a } = e;
        let l = o;
        if (a && (l = _r(o, a)), !l.length) return;
        const c = this.initPTS[t.cc], u = c ? -c.baseTime / c.timescale : void 0, d1 = {
            type: e.type,
            frag: t,
            part: r,
            chunkMeta: n1,
            offset: u,
            parent: t.type,
            data: l
        };
        if (this.hls.trigger(I.BUFFER_APPENDING, d1), e.dropped && e.independent && !r) {
            if (i) return;
            this.flushBufferGap(t);
        }
    }
    flushBufferGap(e) {
        const t = this.media;
        if (!t) return;
        if (!Ce.isBuffered(t, t.currentTime)) {
            this.flushMainBuffer(0, e.start);
            return;
        }
        const r = t.currentTime, n1 = Ce.bufferInfo(t, r, 0), i = e.duration, o = Math.min(this.config.maxFragLookUpTolerance * 2, i * 0.25), a = Math.max(Math.min(e.start - o, n1.end - o), r + o);
        e.start - a > o && this.flushMainBuffer(a, e.start);
    }
    getFwdBufferInfo(e, t) {
        var r;
        const n1 = this.getLoadPosition();
        if (!ue(n1)) return null;
        const o = this.lastCurrentTime > n1 || (r = this.media) != null && r.paused ? 0 : this.config.maxBufferHole;
        return this.getFwdBufferInfoAtPos(e, n1, t, o);
    }
    getFwdBufferInfoAtPos(e, t, r, n1) {
        const i = Ce.bufferInfo(e, t, n1);
        if (i.len === 0 && i.nextStart !== void 0) {
            const o = this.fragmentTracker.getBufferedFrag(t, r);
            if (o && (i.nextStart <= o.end || o.gap)) {
                const a = Math.max(Math.min(i.nextStart, o.end) - t, n1);
                return Ce.bufferInfo(e, t, a);
            }
        }
        return i;
    }
    getMaxBufferLength(e) {
        const { config: t } = this;
        let r;
        return e ? r = Math.max(8 * t.maxBufferSize / e, t.maxBufferLength) : r = t.maxBufferLength, Math.min(r, t.maxMaxBufferLength);
    }
    reduceMaxBufferLength(e, t) {
        const r = this.config, n1 = Math.max(Math.min(e - t, r.maxBufferLength), t), i = Math.max(e - t * 3, r.maxMaxBufferLength / 2, n1);
        return i >= n1 ? (r.maxMaxBufferLength = i, this.warn(`Reduce max buffer length to ${i}s`), !0) : !1;
    }
    getAppendedFrag(e, t = pe.MAIN) {
        const r = this.fragmentTracker ? this.fragmentTracker.getAppendedFrag(e, t) : null;
        return r && "fragment" in r ? r.fragment : r;
    }
    getNextFragment(e, t) {
        const r = t.fragments, n1 = r.length;
        if (!n1) return null;
        const { config: i } = this, o = r[0].start, a = i.lowLatencyMode && !!t.partList;
        let l = null;
        if (t.live) {
            const d1 = i.initialLiveManifestSize;
            if (n1 < d1) return this.warn(`Not enough fragments to start playback (have: ${n1}, need: ${d1})`), null;
            if (!t.PTSKnown && !this.startFragRequested && this.startPosition === -1 || e < o) {
                var c;
                a && !this.loadingParts && (this.log("LL-Part loading ON for initial live fragment"), this.loadingParts = !0), l = this.getInitialLiveFragment(t);
                const h = this.hls.startPosition, f = this.hls.liveSyncPosition, p = l ? (h !== -1 && h >= o ? h : f) || l.start : e;
                this.log(`Setting startPosition to ${p} to match start frag at live edge. mainStart: ${h} liveSyncPosition: ${f} frag.start: ${(c = l) == null ? void 0 : c.start}`), this.startPosition = this.nextLoadPosition = p;
            }
        } else e <= o && (l = r[0]);
        if (!l) {
            const d1 = this.loadingParts ? t.partEnd : t.fragmentEnd;
            l = this.getFragmentAtPosition(e, d1, t);
        }
        let u = this.filterReplacedPrimary(l, t);
        if (!u && l) {
            const d1 = l.sn - t.startSN;
            u = this.filterReplacedPrimary(r[d1 + 1] || null, t);
        }
        return this.mapToInitFragWhenRequired(u);
    }
    isLoopLoading(e, t) {
        const r = this.fragmentTracker.getState(e);
        return (r === Ht.OK || r === Ht.PARTIAL && !!e.gap) && this.nextLoadPosition > t;
    }
    getNextFragmentLoopLoading(e, t, r, n1, i) {
        let o = null;
        if (e.gap && (o = this.getNextFragment(this.nextLoadPosition, t), o && !o.gap && r.nextStart)) {
            const a = this.getFwdBufferInfoAtPos(this.mediaBuffer ? this.mediaBuffer : this.media, r.nextStart, n1, 0);
            if (a !== null && r.len + a.len >= i) {
                const l = o.sn;
                return this.loopSn !== l && (this.log(`buffer full after gaps in "${n1}" playlist starting at sn: ${l}`), this.loopSn = l), null;
            }
        }
        return this.loopSn = void 0, o;
    }
    get primaryPrefetch() {
        if (Bh(this.config)) {
            var e;
            if ((e = this.hls.interstitialsManager) == null || (e = e.playingItem) == null ? void 0 : e.event) return !0;
        }
        return !1;
    }
    filterReplacedPrimary(e, t) {
        if (!e) return e;
        if (Bh(this.config) && e.type !== pe.SUBTITLE) {
            const r = this.hls.interstitialsManager, n1 = r == null ? void 0 : r.bufferingItem;
            if (n1) {
                const o = n1.event;
                if (o) {
                    if (o.appendInPlace || Math.abs(e.start - n1.start) > 1 || n1.start === 0) return null;
                } else if (e.end <= n1.start && (t == null ? void 0 : t.live) === !1 || e.start > n1.end && n1.nextEvent && (n1.nextEvent.appendInPlace || e.start - n1.end > 1)) return null;
            }
            const i = r == null ? void 0 : r.playerQueue;
            if (i) for(let o = i.length; o--;){
                const a = i[o].interstitial;
                if (a.appendInPlace && e.start >= a.startTime && e.end <= a.resumeTime) return null;
            }
        }
        return e;
    }
    mapToInitFragWhenRequired(e) {
        return e != null && e.initSegment && !e.initSegment.data && !this.bitrateTest ? e.initSegment : e;
    }
    getNextPart(e, t, r) {
        let n1 = -1, i = !1, o = !0;
        for(let a = 0, l = e.length; a < l; a++){
            const c = e[a];
            if (o = o && !c.independent, n1 > -1 && r < c.start) break;
            const u = c.loaded;
            u ? n1 = -1 : (i || (c.independent || o) && c.fragment === t) && (c.fragment !== t && this.warn(`Need buffer at ${r} but next unloaded part starts at ${c.start}`), n1 = a), i = u;
        }
        return n1;
    }
    loadedEndOfParts(e, t) {
        let r;
        for(let n1 = e.length; n1--;){
            if (r = e[n1], !r.loaded) return !1;
            if (t > r.start) return !0;
        }
        return !1;
    }
    /*
   This method is used find the best matching first fragment for a live playlist. This fragment is used to calculate the
   "sliding" of the playlist, which is its offset from the start of playback. After sliding we can compute the real
   start and end times for each fragment in the playlist (after which this method will not need to be called).
  */ getInitialLiveFragment(e) {
        const t = e.fragments, r = this.fragPrevious;
        let n1 = null;
        if (r) {
            if (e.hasProgramDateTime && (this.log(`Live playlist, switching playlist, load frag with same PDT: ${r.programDateTime}`), n1 = vb(t, r.endProgramDateTime, this.config.maxFragLookUpTolerance)), !n1) {
                const i = r.sn + 1;
                if (i >= e.startSN && i <= e.endSN) {
                    const o = t[i - e.startSN];
                    r.cc === o.cc && (n1 = o, this.log(`Live playlist, switching playlist, load frag with next SN: ${n1.sn}`));
                }
                n1 || (n1 = Vg(e, r.cc, r.end), n1 && this.log(`Live playlist, switching playlist, load frag with same CC: ${n1.sn}`));
            }
        } else {
            const i = this.hls.liveSyncPosition;
            i !== null && (n1 = this.getFragmentAtPosition(i, this.bitrateTest ? e.fragmentEnd : e.edge, e));
        }
        return n1;
    }
    /*
  This method finds the best matching fragment given the provided position.
   */ getFragmentAtPosition(e, t, r) {
        const { config: n1 } = this;
        let { fragPrevious: i } = this, { fragments: o, endSN: a } = r;
        const { fragmentHint: l } = r, { maxFragLookUpTolerance: c } = n1, u = r.partList, d1 = !!(this.loadingParts && u != null && u.length && l);
        d1 && !this.bitrateTest && u[u.length - 1].fragment.sn === l.sn && (o = o.concat(l), a = l.sn);
        let h;
        if (e < t) {
            var f;
            const y = e < this.lastCurrentTime || e > t - c || (f = this.media) != null && f.paused || !this.startFragRequested ? 0 : c;
            h = Js(i, o, e, y);
        } else h = o[o.length - 1];
        if (h) {
            const p = h.sn - r.startSN, y = this.fragmentTracker.getState(h);
            if ((y === Ht.OK || y === Ht.PARTIAL && h.gap) && (i = h), i && h.sn === i.sn && (!d1 || u[0].fragment.sn > h.sn || !r.live) && h.level === i.level) {
                const b = o[p + 1];
                h.sn < a && this.fragmentTracker.getState(b) !== Ht.OK ? h = b : h = null;
            }
        }
        return h;
    }
    alignPlaylists(e, t, r) {
        const n1 = e.fragments.length;
        if (!n1) return this.warn("No fragments in live playlist"), 0;
        const i = e.fragmentStart, o = !t, a = e.alignedSliding && ue(i);
        if (o || !a && !i) {
            rT(r, e);
            const l = e.fragmentStart;
            return this.log(`Live playlist sliding: ${l.toFixed(2)} start-sn: ${t ? t.startSN : "na"}->${e.startSN} fragments: ${n1}`), l;
        }
        return i;
    }
    waitForCdnTuneIn(e) {
        return e.live && e.canBlockReload && e.partTarget && e.tuneInGoal > Math.max(e.partHoldBack, e.partTarget * 3);
    }
    setStartPosition(e, t) {
        let r = this.startPosition;
        r < t && (r = -1);
        const n1 = this.timelineOffset;
        if (r === -1) {
            const i = this.startTimeOffset !== null, o = i ? this.startTimeOffset : e.startTimeOffset;
            o !== null && ue(o) ? (r = t + o, o < 0 && (r += e.edge), r = Math.min(Math.max(t, r), t + e.totalduration), this.log(`Setting startPosition to ${r} for start time offset ${o} found in ${i ? "multivariant" : "media"} playlist`), this.startPosition = r) : e.live ? (r = this.hls.liveSyncPosition || t, this.log(`Setting startPosition to -1 to start at live edge ${r}`), this.startPosition = -1) : (this.log("setting startPosition to 0 by default"), this.startPosition = r = 0), this.lastCurrentTime = r + n1;
        }
        this.nextLoadPosition = r + n1;
    }
    getLoadPosition() {
        var e;
        const { media: t } = this;
        let r = 0;
        return (e = this.hls) != null && e.hasEnoughToStart && t ? r = t.currentTime : this.nextLoadPosition >= 0 && (r = this.nextLoadPosition), r;
    }
    handleFragLoadAborted(e, t) {
        this.transmuxer && e.type === this.playlistType && Vt(e) && e.stats.aborted && (this.log(`Fragment ${e.sn}${t ? " part " + t.index : ""} of ${this.playlistLabel()} ${e.level} was aborted`), this.resetFragmentLoading(e));
    }
    resetFragmentLoading(e) {
        (!this.fragCurrent || !this.fragContextChanged(e) && this.state !== ne.FRAG_LOADING_WAITING_RETRY) && (this.state = ne.IDLE);
    }
    onFragmentOrKeyLoadError(e, t) {
        var r;
        if (t.chunkMeta && !t.frag) {
            const b = this.getCurrentContext(t.chunkMeta);
            b && (t.frag = b.frag);
        }
        const n1 = t.frag;
        if (!n1 || n1.type !== e || !this.levels) return;
        if (this.fragContextChanged(n1)) {
            var i;
            this.warn(`Frag load error must match current frag to retry ${n1.url} > ${(i = this.fragCurrent) == null ? void 0 : i.url}`);
            return;
        }
        const o = t.details === J.FRAG_GAP;
        o && this.fragmentTracker.fragBuffered(n1, !0);
        const a = t.errorAction;
        if (!a) {
            this.state = ne.ERROR;
            return;
        }
        const { action: l, flags: c, retryCount: u = 0, retryConfig: d1 } = a, h = !!d1, f = h && l === Zt.RetryRequest, p = h && !a.resolved && c === vr.MoveAllAlternatesMatchingHost, y = (r = this.hls.latestLevelDetails) == null ? void 0 : r.live;
        if (!f && p && Vt(n1) && !n1.endList && y && !Kg(t)) this.resetFragmentErrors(e), this.treatAsGap(n1), a.resolved = !0;
        else if ((f || p) && u < d1.maxNumRetry) {
            var E;
            const b = uc((E = t.response) == null ? void 0 : E.code), L = yu(d1, u);
            if (this.resetStartWhenNotLoaded(), this.retryDate = self.performance.now() + L, this.state = ne.FRAG_LOADING_WAITING_RETRY, a.resolved = !0, b) {
                this.log("Waiting for connection (offline)"), this.retryDate = 1 / 0, t.reason = "offline";
                return;
            }
            this.warn(`Fragment ${n1.sn} of ${e} ${n1.level} errored with ${t.details}, retrying loading ${u + 1}/${d1.maxNumRetry} in ${L}ms`);
        } else if (d1) if (this.resetFragmentErrors(e), u < d1.maxNumRetry) !o && l !== Zt.RemoveAlternatePermanently && (a.resolved = !0);
        else {
            this.warn(`${t.details} reached or exceeded max retry (${u})`);
            return;
        }
        else l === Zt.SendAlternateToPenaltyBox ? this.state = ne.WAITING_LEVEL : this.state = ne.ERROR;
        this.tickImmediate();
    }
    checkRetryDate() {
        const e = self.performance.now(), t = this.retryDate, r = t === 1 / 0;
        (!t || e >= t || r && !uc(0)) && (r && this.log("Connection restored (online)"), this.resetStartWhenNotLoaded(), this.state = ne.IDLE);
    }
    reduceLengthAndFlushBuffer(e) {
        if (this.state === ne.PARSING || this.state === ne.PARSED) {
            const t = e.frag, r = e.parent, n1 = this.getFwdBufferInfo(this.mediaBuffer, r), i = n1 && n1.len > 0.5;
            i && this.reduceMaxBufferLength(n1.len, (t == null ? void 0 : t.duration) || 10);
            const o = !i;
            return o && this.warn(`Buffer full error while media.currentTime (${this.getLoadPosition()}) is not buffered, flush ${r} buffer`), t && (this.fragmentTracker.removeFragment(t), this.nextLoadPosition = t.start), this.resetLoadingState(), o;
        }
        return !1;
    }
    resetFragmentErrors(e) {
        e === pe.AUDIO && (this.fragCurrent = null), this.hls.hasEnoughToStart || (this.startFragRequested = !1), this.state !== ne.STOPPED && (this.state = ne.IDLE);
    }
    afterBufferFlushed(e, t, r) {
        if (!e) return;
        const n1 = Ce.getBuffered(e);
        this.fragmentTracker.detectEvictedFragments(t, n1, r), this.state === ne.ENDED && this.resetLoadingState();
    }
    resetLoadingState() {
        this.log("Reset loading state"), this.fragCurrent = null, this.fragPrevious = null, this.state !== ne.STOPPED && (this.state = ne.IDLE);
    }
    resetStartWhenNotLoaded() {
        if (!this.hls.hasEnoughToStart) {
            this.startFragRequested = !1;
            const e = this.levelLastLoaded, t = e ? e.details : null;
            t != null && t.live ? (this.log("resetting startPosition for live start"), this.startPosition = -1, this.setStartPosition(t, t.fragmentStart), this.resetLoadingState()) : this.nextLoadPosition = this.startPosition;
        }
    }
    resetWhenMissingContext(e) {
        this.log(`Loading context changed while buffering sn ${e.sn} of ${this.playlistLabel()} ${e.level === -1 ? "<removed>" : e.level}. This chunk will not be buffered.`), this.removeUnbufferedFrags(), this.resetStartWhenNotLoaded(), this.resetLoadingState();
    }
    removeUnbufferedFrags(e = 0) {
        this.fragmentTracker.removeFragmentsInRange(e, 1 / 0, this.playlistType, !1, !0);
    }
    updateLevelTiming(e, t, r, n1) {
        const i = r.details;
        if (!i) {
            this.warn("level.details undefined");
            return;
        }
        if (!Object.keys(e.elementaryStreams).reduce((l, c)=>{
            const u = e.elementaryStreams[c];
            if (u) {
                const d1 = u.endPTS - u.startPTS;
                if (d1 <= 0) return this.warn(`Could not parse fragment ${e.sn} ${c} duration reliably (${d1})`), l || !1;
                const h = n1 ? 0 : Xg(i, e, u.startPTS, u.endPTS, u.startDTS, u.endDTS, this);
                return this.hls.trigger(I.LEVEL_PTS_UPDATED, {
                    details: i,
                    level: r,
                    drift: h,
                    type: c,
                    frag: e,
                    start: u.startPTS,
                    end: u.endPTS
                }), !0;
            }
            return l;
        }, !1)) {
            var a;
            if (r.fragmentError === 0 && this.treatAsGap(e, r), ((a = this.transmuxer) == null ? void 0 : a.error) === null) {
                const l = new Error(`Found no media in fragment ${e.sn} of ${this.playlistLabel()} ${e.level} resetting transmuxer to fallback to playlist timing`);
                if (this.warn(l.message), this.hls.trigger(I.ERROR, {
                    type: ve.MEDIA_ERROR,
                    details: J.FRAG_PARSING_ERROR,
                    fatal: !1,
                    error: l,
                    frag: e,
                    reason: `Found no media in msn ${e.sn} of ${this.playlistLabel()} "${r.url}"`
                }), !this.hls) return;
                this.resetTransmuxer();
            }
        }
        this.state = ne.PARSED, this.log(`Parsed ${e.type} sn: ${e.sn}${t ? " part: " + t.index : ""} of ${this.fragInfo(e, !1, t)})`), this.hls.trigger(I.FRAG_PARSED, {
            frag: e,
            part: t
        });
    }
    playlistLabel() {
        return this.playlistType === pe.MAIN ? "level" : "track";
    }
    fragInfo(e, t = !0, r) {
        var n1, i;
        return `${this.playlistLabel()} ${e.level} (${r ? "part" : "frag"}:[${((n1 = t && !r ? e.startPTS : (r || e).start) != null ? n1 : NaN).toFixed(3)}-${((i = t && !r ? e.endPTS : (r || e).end) != null ? i : NaN).toFixed(3)}]${r && e.type === "main" ? "INDEPENDENT=" + (r.independent ? "YES" : "NO") : ""}`;
    }
    treatAsGap(e, t) {
        t && t.fragmentError++, e.gap = !0, this.fragmentTracker.removeFragment(e), this.fragmentTracker.fragBuffered(e, !0);
    }
    resetTransmuxer() {
        var e;
        (e = this.transmuxer) == null || e.reset();
    }
    recoverWorkerError(e) {
        e.event === "demuxerWorker" && (this.fragmentTracker.removeAllFragments(), this.transmuxer && (this.transmuxer.destroy(), this.transmuxer = null), this.resetStartWhenNotLoaded(), this.resetLoadingState());
    }
    set state(e) {
        const t = this._state;
        t !== e && (this._state = e, this.log(`${t}->${e}`));
    }
    get state() {
        return this._state;
    }
}
function Bh(s) {
    return !!s.interstitialsController && s.enableInterstitialPlayback !== !1;
}
class ip {
    constructor(){
        this.chunks = [], this.dataLength = 0;
    }
    push(e) {
        this.chunks.push(e), this.dataLength += e.length;
    }
    flush() {
        const { chunks: e, dataLength: t } = this;
        let r;
        if (e.length) e.length === 1 ? r = e[0] : r = nT(e, t);
        else return new Uint8Array(0);
        return this.reset(), r;
    }
    reset() {
        this.chunks.length = 0, this.dataLength = 0;
    }
}
function nT(s, e) {
    const t = new Uint8Array(e);
    let r = 0;
    for(let n1 = 0; n1 < s.length; n1++){
        const i = s[n1];
        t.set(i, r), r += i.length;
    }
    return t;
}
var ml = {
    exports: {}
}, Fh;
function iT() {
    return Fh || (Fh = 1, function(s) {
        var e = Object.prototype.hasOwnProperty, t = "~";
        function r() {}
        Object.create && (r.prototype = /* @__PURE__ */ Object.create(null), new r().__proto__ || (t = !1));
        function n1(l, c, u) {
            this.fn = l, this.context = c, this.once = u || !1;
        }
        function i(l, c, u, d1, h) {
            if (typeof u != "function") throw new TypeError("The listener must be a function");
            var f = new n1(u, d1 || l, h), p = t ? t + c : c;
            return l._events[p] ? l._events[p].fn ? l._events[p] = [
                l._events[p],
                f
            ] : l._events[p].push(f) : (l._events[p] = f, l._eventsCount++), l;
        }
        function o(l, c) {
            --l._eventsCount === 0 ? l._events = new r() : delete l._events[c];
        }
        function a() {
            this._events = new r(), this._eventsCount = 0;
        }
        a.prototype.eventNames = function() {
            var c = [], u, d1;
            if (this._eventsCount === 0) return c;
            for(d1 in u = this._events)e.call(u, d1) && c.push(t ? d1.slice(1) : d1);
            return Object.getOwnPropertySymbols ? c.concat(Object.getOwnPropertySymbols(u)) : c;
        }, a.prototype.listeners = function(c) {
            var u = t ? t + c : c, d1 = this._events[u];
            if (!d1) return [];
            if (d1.fn) return [
                d1.fn
            ];
            for(var h = 0, f = d1.length, p = new Array(f); h < f; h++)p[h] = d1[h].fn;
            return p;
        }, a.prototype.listenerCount = function(c) {
            var u = t ? t + c : c, d1 = this._events[u];
            return d1 ? d1.fn ? 1 : d1.length : 0;
        }, a.prototype.emit = function(c, u, d1, h, f, p) {
            var y = t ? t + c : c;
            if (!this._events[y]) return !1;
            var E = this._events[y], b = arguments.length, L, A;
            if (E.fn) {
                switch(E.once && this.removeListener(c, E.fn, void 0, !0), b){
                    case 1:
                        return E.fn.call(E.context), !0;
                    case 2:
                        return E.fn.call(E.context, u), !0;
                    case 3:
                        return E.fn.call(E.context, u, d1), !0;
                    case 4:
                        return E.fn.call(E.context, u, d1, h), !0;
                    case 5:
                        return E.fn.call(E.context, u, d1, h, f), !0;
                    case 6:
                        return E.fn.call(E.context, u, d1, h, f, p), !0;
                }
                for(A = 1, L = new Array(b - 1); A < b; A++)L[A - 1] = arguments[A];
                E.fn.apply(E.context, L);
            } else {
                var F = E.length, M;
                for(A = 0; A < F; A++)switch(E[A].once && this.removeListener(c, E[A].fn, void 0, !0), b){
                    case 1:
                        E[A].fn.call(E[A].context);
                        break;
                    case 2:
                        E[A].fn.call(E[A].context, u);
                        break;
                    case 3:
                        E[A].fn.call(E[A].context, u, d1);
                        break;
                    case 4:
                        E[A].fn.call(E[A].context, u, d1, h);
                        break;
                    default:
                        if (!L) for(M = 1, L = new Array(b - 1); M < b; M++)L[M - 1] = arguments[M];
                        E[A].fn.apply(E[A].context, L);
                }
            }
            return !0;
        }, a.prototype.on = function(c, u, d1) {
            return i(this, c, u, d1, !1);
        }, a.prototype.once = function(c, u, d1) {
            return i(this, c, u, d1, !0);
        }, a.prototype.removeListener = function(c, u, d1, h) {
            var f = t ? t + c : c;
            if (!this._events[f]) return this;
            if (!u) return o(this, f), this;
            var p = this._events[f];
            if (p.fn) p.fn === u && (!h || p.once) && (!d1 || p.context === d1) && o(this, f);
            else {
                for(var y = 0, E = [], b = p.length; y < b; y++)(p[y].fn !== u || h && !p[y].once || d1 && p[y].context !== d1) && E.push(p[y]);
                E.length ? this._events[f] = E.length === 1 ? E[0] : E : o(this, f);
            }
            return this;
        }, a.prototype.removeAllListeners = function(c) {
            var u;
            return c ? (u = t ? t + c : c, this._events[u] && o(this, u)) : (this._events = new r(), this._eventsCount = 0), this;
        }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = t, a.EventEmitter = a, s.exports = a;
    }(ml)), ml.exports;
}
var oT = iT(), wu = /* @__PURE__ */ kS(oT);
const vi = "1.6.12", Bn = {};
function aT() {
    return typeof __HLS_WORKER_BUNDLE__ == "function";
}
function lT() {
    const s = Bn[vi];
    if (s) return s.clientCount++, s;
    const e = new self.Blob([
        `var exports={};var module={exports:exports};function define(f){f()};define.amd=true;(${__HLS_WORKER_BUNDLE__.toString()})(true);`
    ], {
        type: "text/javascript"
    }), t = self.URL.createObjectURL(e), n1 = {
        worker: new self.Worker(t),
        objectURL: t,
        clientCount: 1
    };
    return Bn[vi] = n1, n1;
}
function cT(s) {
    const e = Bn[s];
    if (e) return e.clientCount++, e;
    const t = new self.URL(s, self.location.href).href, n1 = {
        worker: new self.Worker(t),
        scriptURL: t,
        clientCount: 1
    };
    return Bn[s] = n1, n1;
}
function uT(s) {
    const e = Bn[s || vi];
    if (e && e.clientCount-- === 1) {
        const { worker: r, objectURL: n1 } = e;
        delete Bn[s || vi], n1 && self.URL.revokeObjectURL(n1), r.terminate();
    }
}
function op(s, e) {
    return e + 10 <= s.length && s[e] === 51 && s[e + 1] === 68 && s[e + 2] === 73 && s[e + 3] < 255 && s[e + 4] < 255 && s[e + 6] < 128 && s[e + 7] < 128 && s[e + 8] < 128 && s[e + 9] < 128;
}
function Au(s, e) {
    return e + 10 <= s.length && s[e] === 73 && s[e + 1] === 68 && s[e + 2] === 51 && s[e + 3] < 255 && s[e + 4] < 255 && s[e + 6] < 128 && s[e + 7] < 128 && s[e + 8] < 128 && s[e + 9] < 128;
}
function va(s, e) {
    let t = 0;
    return t = (s[e] & 127) << 21, t |= (s[e + 1] & 127) << 14, t |= (s[e + 2] & 127) << 7, t |= s[e + 3] & 127, t;
}
function Ei(s, e) {
    const t = e;
    let r = 0;
    for(; Au(s, e);){
        r += 10;
        const n1 = va(s, e + 6);
        r += n1, op(s, e + 10) && (r += 10), e += r;
    }
    if (r > 0) return s.subarray(t, t + r);
}
function dT(s, e, t, r) {
    const n1 = [
        96e3,
        88200,
        64e3,
        48e3,
        44100,
        32e3,
        24e3,
        22050,
        16e3,
        12e3,
        11025,
        8e3,
        7350
    ], i = e[t + 2], o = i >> 2 & 15;
    if (o > 12) {
        const f = new Error(`invalid ADTS sampling index:${o}`);
        s.emit(I.ERROR, I.ERROR, {
            type: ve.MEDIA_ERROR,
            details: J.FRAG_PARSING_ERROR,
            fatal: !0,
            error: f,
            reason: f.message
        });
        return;
    }
    const a = (i >> 6 & 3) + 1, l = e[t + 3] >> 6 & 3 | (i & 1) << 2, c = "mp4a.40." + a, u = n1[o];
    let d1 = o;
    (a === 5 || a === 29) && (d1 -= 3);
    const h = [
        a << 3 | (d1 & 14) >> 1,
        (d1 & 1) << 7 | l << 3
    ];
    return rt.log(`manifest codec:${r}, parsed codec:${c}, channels:${l}, rate:${u} (ADTS object type:${a} sampling index:${o})`), {
        config: h,
        samplerate: u,
        channelCount: l,
        codec: c,
        parsedCodec: c,
        manifestCodec: r
    };
}
function ap(s, e) {
    return s[e] === 255 && (s[e + 1] & 246) === 240;
}
function lp(s, e) {
    return s[e + 1] & 1 ? 7 : 9;
}
function Iu(s, e) {
    return (s[e + 3] & 3) << 11 | s[e + 4] << 3 | (s[e + 5] & 224) >>> 5;
}
function hT(s, e) {
    return e + 5 < s.length;
}
function na(s, e) {
    return e + 1 < s.length && ap(s, e);
}
function fT(s, e) {
    return hT(s, e) && ap(s, e) && Iu(s, e) <= s.length - e;
}
function gT(s, e) {
    if (na(s, e)) {
        const t = lp(s, e);
        if (e + t >= s.length) return !1;
        const r = Iu(s, e);
        if (r <= t) return !1;
        const n1 = e + r;
        return n1 === s.length || na(s, n1);
    }
    return !1;
}
function cp(s, e, t, r, n1) {
    if (!s.samplerate) {
        const i = dT(e, t, r, n1);
        if (!i) return;
        nt(s, i);
    }
}
function up(s) {
    return 1024 * 9e4 / s;
}
function pT(s, e) {
    const t = lp(s, e);
    if (e + t <= s.length) {
        const r = Iu(s, e) - t;
        if (r > 0) return {
            headerLength: t,
            frameLength: r
        };
    }
}
function dp(s, e, t, r, n1) {
    const i = up(s.samplerate), o = r + n1 * i, a = pT(e, t);
    let l;
    if (a) {
        const { frameLength: d1, headerLength: h } = a, f = h + d1, p = Math.max(0, t + f - e.length);
        p ? (l = new Uint8Array(f - h), l.set(e.subarray(t + h, e.length), 0)) : l = e.subarray(t + h, t + f);
        const y = {
            unit: l,
            pts: o
        };
        return p || s.samples.push(y), {
            sample: y,
            length: f,
            missing: p
        };
    }
    const c = e.length - t;
    return l = new Uint8Array(c), l.set(e.subarray(t, e.length), 0), {
        sample: {
            unit: l,
            pts: o
        },
        length: c,
        missing: -1
    };
}
function mT(s, e) {
    return Au(s, e) && va(s, e + 6) + 10 <= s.length - e;
}
function yT(s) {
    return s instanceof ArrayBuffer ? s : s.byteOffset == 0 && s.byteLength == s.buffer.byteLength ? s.buffer : new Uint8Array(s).buffer;
}
function yl(s, e = 0, t = 1 / 0) {
    return vT(s, e, t, Uint8Array);
}
function vT(s, e, t, r) {
    const n1 = ET(s);
    let i = 1;
    "BYTES_PER_ELEMENT" in r && (i = r.BYTES_PER_ELEMENT);
    const o = xT(s) ? s.byteOffset : 0, a = (o + s.byteLength) / i, l = (o + e) / i, c = Math.floor(Math.max(0, Math.min(l, a))), u = Math.floor(Math.min(c + Math.max(t, 0), a));
    return new r(n1, c, u - c);
}
function ET(s) {
    return s instanceof ArrayBuffer ? s : s.buffer;
}
function xT(s) {
    return s && s.buffer instanceof ArrayBuffer && s.byteLength !== void 0 && s.byteOffset !== void 0;
}
function ST(s) {
    const e = {
        key: s.type,
        description: "",
        data: "",
        mimeType: null,
        pictureType: null
    }, t = 3;
    if (s.size < 2) return;
    if (s.data[0] !== t) {
        console.log("Ignore frame with unrecognized character encoding");
        return;
    }
    const r = s.data.subarray(1).indexOf(0);
    if (r === -1) return;
    const n1 = Tr(yl(s.data, 1, r)), i = s.data[2 + r], o = s.data.subarray(3 + r).indexOf(0);
    if (o === -1) return;
    const a = Tr(yl(s.data, 3 + r, o));
    let l;
    return n1 === "-->" ? l = Tr(yl(s.data, 4 + r + o)) : l = yT(s.data.subarray(4 + r + o)), e.mimeType = n1, e.pictureType = i, e.description = a, e.data = l, e;
}
function bT(s) {
    if (s.size < 2) return;
    const e = Tr(s.data, !0), t = new Uint8Array(s.data.subarray(e.length + 1));
    return {
        key: s.type,
        info: e,
        data: t.buffer
    };
}
function TT(s) {
    if (s.size < 2) return;
    if (s.type === "TXXX") {
        let t = 1;
        const r = Tr(s.data.subarray(t), !0);
        t += r.length + 1;
        const n1 = Tr(s.data.subarray(t));
        return {
            key: s.type,
            info: r,
            data: n1
        };
    }
    const e = Tr(s.data.subarray(1));
    return {
        key: s.type,
        info: "",
        data: e
    };
}
function wT(s) {
    if (s.type === "WXXX") {
        if (s.size < 2) return;
        let t = 1;
        const r = Tr(s.data.subarray(t), !0);
        t += r.length + 1;
        const n1 = Tr(s.data.subarray(t));
        return {
            key: s.type,
            info: r,
            data: n1
        };
    }
    const e = Tr(s.data);
    return {
        key: s.type,
        info: "",
        data: e
    };
}
function AT(s) {
    return s.type === "PRIV" ? bT(s) : s.type[0] === "W" ? wT(s) : s.type === "APIC" ? ST(s) : TT(s);
}
function IT(s) {
    const e = String.fromCharCode(s[0], s[1], s[2], s[3]), t = va(s, 4), r = 10;
    return {
        type: e,
        size: t,
        data: s.subarray(r, r + t)
    };
}
const zi = 10, _T = 10;
function hp(s) {
    let e = 0;
    const t = [];
    for(; Au(s, e);){
        const r = va(s, e + 6);
        s[e + 5] >> 6 & 1 && (e += zi), e += zi;
        const n1 = e + r;
        for(; e + _T < n1;){
            const i = IT(s.subarray(e)), o = AT(i);
            o && t.push(o), e += i.size + zi;
        }
        op(s, e) && (e += zi);
    }
    return t;
}
function fp(s) {
    return s && s.key === "PRIV" && s.info === "com.apple.streaming.transportStreamTimestamp";
}
function LT(s) {
    if (s.data.byteLength === 8) {
        const e = new Uint8Array(s.data), t = e[3] & 1;
        let r = (e[4] << 23) + (e[5] << 15) + (e[6] << 7) + e[7];
        return r /= 45, t && (r += 4772185884e-2), Math.round(r);
    }
}
function _u(s) {
    const e = hp(s);
    for(let t = 0; t < e.length; t++){
        const r = e[t];
        if (fp(r)) return LT(r);
    }
}
let br = /* @__PURE__ */ function(s) {
    return s.audioId3 = "org.id3", s.dateRange = "com.apple.quicktime.HLS", s.emsg = "https://aomedia.org/emsg/ID3", s.misbklv = "urn:misb:KLV:bin:1910.1", s;
}({});
function jr(s = "", e = 9e4) {
    return {
        type: s,
        id: -1,
        pid: -1,
        inputTimeScale: e,
        sequenceNumber: -1,
        samples: [],
        dropped: 0
    };
}
class Lu {
    constructor(){
        this._audioTrack = void 0, this._id3Track = void 0, this.frameIndex = 0, this.cachedData = null, this.basePTS = null, this.initPTS = null, this.lastPTS = null;
    }
    resetInitSegment(e, t, r, n1) {
        this._id3Track = {
            type: "id3",
            id: 3,
            pid: -1,
            inputTimeScale: 9e4,
            sequenceNumber: 0,
            samples: [],
            dropped: 0
        };
    }
    resetTimeStamp(e) {
        this.initPTS = e, this.resetContiguity();
    }
    resetContiguity() {
        this.basePTS = null, this.lastPTS = null, this.frameIndex = 0;
    }
    canParse(e, t) {
        return !1;
    }
    appendFrame(e, t, r) {}
    // feed incoming data to the front of the parsing pipeline
    demux(e, t) {
        this.cachedData && (e = _r(this.cachedData, e), this.cachedData = null);
        let r = Ei(e, 0), n1 = r ? r.length : 0, i;
        const o = this._audioTrack, a = this._id3Track, l = r ? _u(r) : void 0, c = e.length;
        for((this.basePTS === null || this.frameIndex === 0 && ue(l)) && (this.basePTS = RT(l, t, this.initPTS), this.lastPTS = this.basePTS), this.lastPTS === null && (this.lastPTS = this.basePTS), r && r.length > 0 && a.samples.push({
            pts: this.lastPTS,
            dts: this.lastPTS,
            data: r,
            type: br.audioId3,
            duration: Number.POSITIVE_INFINITY
        }); n1 < c;){
            if (this.canParse(e, n1)) {
                const u = this.appendFrame(o, e, n1);
                u ? (this.frameIndex++, this.lastPTS = u.sample.pts, n1 += u.length, i = n1) : n1 = c;
            } else mT(e, n1) ? (r = Ei(e, n1), a.samples.push({
                pts: this.lastPTS,
                dts: this.lastPTS,
                data: r,
                type: br.audioId3,
                duration: Number.POSITIVE_INFINITY
            }), n1 += r.length, i = n1) : n1++;
            if (n1 === c && i !== c) {
                const u = e.slice(i);
                this.cachedData ? this.cachedData = _r(this.cachedData, u) : this.cachedData = u;
            }
        }
        return {
            audioTrack: o,
            videoTrack: jr(),
            id3Track: a,
            textTrack: jr()
        };
    }
    demuxSampleAes(e, t, r) {
        return Promise.reject(new Error(`[${this}] This demuxer does not support Sample-AES decryption`));
    }
    flush(e) {
        const t = this.cachedData;
        return t && (this.cachedData = null, this.demux(t, 0)), {
            audioTrack: this._audioTrack,
            videoTrack: jr(),
            id3Track: this._id3Track,
            textTrack: jr()
        };
    }
    destroy() {
        this.cachedData = null, this._audioTrack = this._id3Track = void 0;
    }
}
const RT = (s, e, t)=>{
    if (ue(s)) return s * 90;
    const r = t ? t.baseTime * 9e4 / t.timescale : 0;
    return e * 9e4 + r;
};
let Yi = null;
const CT = [
    32,
    64,
    96,
    128,
    160,
    192,
    224,
    256,
    288,
    320,
    352,
    384,
    416,
    448,
    32,
    48,
    56,
    64,
    80,
    96,
    112,
    128,
    160,
    192,
    224,
    256,
    320,
    384,
    32,
    40,
    48,
    56,
    64,
    80,
    96,
    112,
    128,
    160,
    192,
    224,
    256,
    320,
    32,
    48,
    56,
    64,
    80,
    96,
    112,
    128,
    144,
    160,
    176,
    192,
    224,
    256,
    8,
    16,
    24,
    32,
    40,
    48,
    56,
    64,
    80,
    96,
    112,
    128,
    144,
    160
], kT = [
    44100,
    48e3,
    32e3,
    22050,
    24e3,
    16e3,
    11025,
    12e3,
    8e3
], DT = [
    // MPEG 2.5
    [
        0,
        // Reserved
        72,
        // Layer3
        144,
        // Layer2
        12
    ],
    // Reserved
    [
        0,
        // Reserved
        0,
        // Layer3
        0,
        // Layer2
        0
    ],
    // MPEG 2
    [
        0,
        // Reserved
        72,
        // Layer3
        144,
        // Layer2
        12
    ],
    // MPEG 1
    [
        0,
        // Reserved
        144,
        // Layer3
        144,
        // Layer2
        12
    ]
], PT = [
    0,
    // Reserved
    1,
    // Layer3
    1,
    // Layer2
    4
];
function gp(s, e, t, r, n1) {
    if (t + 24 > e.length) return;
    const i = pp(e, t);
    if (i && t + i.frameLength <= e.length) {
        const o = i.samplesPerFrame * 9e4 / i.sampleRate, a = r + n1 * o, l = {
            unit: e.subarray(t, t + i.frameLength),
            pts: a,
            dts: a
        };
        return s.config = [], s.channelCount = i.channelCount, s.samplerate = i.sampleRate, s.samples.push(l), {
            sample: l,
            length: i.frameLength,
            missing: 0
        };
    }
}
function pp(s, e) {
    const t = s[e + 1] >> 3 & 3, r = s[e + 1] >> 1 & 3, n1 = s[e + 2] >> 4 & 15, i = s[e + 2] >> 2 & 3;
    if (t !== 1 && n1 !== 0 && n1 !== 15 && i !== 3) {
        const o = s[e + 2] >> 1 & 1, a = s[e + 3] >> 6, l = t === 3 ? 3 - r : r === 3 ? 3 : 4, c = CT[l * 14 + n1 - 1] * 1e3, d1 = kT[(t === 3 ? 0 : t === 2 ? 1 : 2) * 3 + i], h = a === 3 ? 1 : 2, f = DT[t][r], p = PT[r], y = f * 8 * p, E = Math.floor(f * c / d1 + o) * p;
        if (Yi === null) {
            const A = (navigator.userAgent || "").match(/Chrome\/(\d+)/i);
            Yi = A ? parseInt(A[1]) : 0;
        }
        return !!Yi && Yi <= 87 && r === 2 && c >= 224e3 && a === 0 && (s[e + 3] = s[e + 3] | 128), {
            sampleRate: d1,
            channelCount: h,
            frameLength: E,
            samplesPerFrame: y
        };
    }
}
function Ru(s, e) {
    return s[e] === 255 && (s[e + 1] & 224) === 224 && (s[e + 1] & 6) !== 0;
}
function mp(s, e) {
    return e + 1 < s.length && Ru(s, e);
}
function MT(s, e) {
    return Ru(s, e) && 4 <= s.length - e;
}
function yp(s, e) {
    if (e + 1 < s.length && Ru(s, e)) {
        const r = pp(s, e);
        let n1 = 4;
        r != null && r.frameLength && (n1 = r.frameLength);
        const i = e + n1;
        return i === s.length || mp(s, i);
    }
    return !1;
}
class OT extends Lu {
    constructor(e, t){
        super(), this.observer = void 0, this.config = void 0, this.observer = e, this.config = t;
    }
    resetInitSegment(e, t, r, n1) {
        super.resetInitSegment(e, t, r, n1), this._audioTrack = {
            container: "audio/adts",
            type: "audio",
            id: 2,
            pid: -1,
            sequenceNumber: 0,
            segmentCodec: "aac",
            samples: [],
            manifestCodec: t,
            duration: n1,
            inputTimeScale: 9e4,
            dropped: 0
        };
    }
    // Source for probe info - https://wiki.multimedia.cx/index.php?title=ADTS
    static probe(e, t) {
        if (!e) return !1;
        const r = Ei(e, 0);
        let n1 = (r == null ? void 0 : r.length) || 0;
        if (yp(e, n1)) return !1;
        for(let i = e.length; n1 < i; n1++)if (gT(e, n1)) return t.log("ADTS sync word found !"), !0;
        return !1;
    }
    canParse(e, t) {
        return fT(e, t);
    }
    appendFrame(e, t, r) {
        cp(e, this.observer, t, r, e.manifestCodec);
        const n1 = dp(e, t, r, this.basePTS, this.frameIndex);
        if (n1 && n1.missing === 0) return n1;
    }
}
const vp = (s, e)=>{
    let t = 0, r = 5;
    e += r;
    const n1 = new Uint32Array(1), i = new Uint32Array(1), o = new Uint8Array(1);
    for(; r > 0;){
        o[0] = s[e];
        const a = Math.min(r, 8), l = 8 - a;
        i[0] = 4278190080 >>> 24 + l << l, n1[0] = (o[0] & i[0]) >> l, t = t ? t << a | n1[0] : n1[0], e += 1, r -= a;
    }
    return t;
};
class BT extends Lu {
    constructor(e){
        super(), this.observer = void 0, this.observer = e;
    }
    resetInitSegment(e, t, r, n1) {
        super.resetInitSegment(e, t, r, n1), this._audioTrack = {
            container: "audio/ac-3",
            type: "audio",
            id: 2,
            pid: -1,
            sequenceNumber: 0,
            segmentCodec: "ac3",
            samples: [],
            manifestCodec: t,
            duration: n1,
            inputTimeScale: 9e4,
            dropped: 0
        };
    }
    canParse(e, t) {
        return t + 64 < e.length;
    }
    appendFrame(e, t, r) {
        const n1 = Ep(e, t, r, this.basePTS, this.frameIndex);
        if (n1 !== -1) return {
            sample: e.samples[e.samples.length - 1],
            length: n1,
            missing: 0
        };
    }
    static probe(e) {
        if (!e) return !1;
        const t = Ei(e, 0);
        if (!t) return !1;
        const r = t.length;
        return e[r] === 11 && e[r + 1] === 119 && _u(t) !== void 0 && // check the bsid to confirm ac-3
        vp(e, r) < 16;
    }
}
function Ep(s, e, t, r, n1) {
    if (t + 8 > e.length || e[t] !== 11 || e[t + 1] !== 119) return -1;
    const i = e[t + 4] >> 6;
    if (i >= 3) return -1;
    const a = [
        48e3,
        44100,
        32e3
    ][i], l = e[t + 4] & 63, u = [
        64,
        69,
        96,
        64,
        70,
        96,
        80,
        87,
        120,
        80,
        88,
        120,
        96,
        104,
        144,
        96,
        105,
        144,
        112,
        121,
        168,
        112,
        122,
        168,
        128,
        139,
        192,
        128,
        140,
        192,
        160,
        174,
        240,
        160,
        175,
        240,
        192,
        208,
        288,
        192,
        209,
        288,
        224,
        243,
        336,
        224,
        244,
        336,
        256,
        278,
        384,
        256,
        279,
        384,
        320,
        348,
        480,
        320,
        349,
        480,
        384,
        417,
        576,
        384,
        418,
        576,
        448,
        487,
        672,
        448,
        488,
        672,
        512,
        557,
        768,
        512,
        558,
        768,
        640,
        696,
        960,
        640,
        697,
        960,
        768,
        835,
        1152,
        768,
        836,
        1152,
        896,
        975,
        1344,
        896,
        976,
        1344,
        1024,
        1114,
        1536,
        1024,
        1115,
        1536,
        1152,
        1253,
        1728,
        1152,
        1254,
        1728,
        1280,
        1393,
        1920,
        1280,
        1394,
        1920
    ][l * 3 + i] * 2;
    if (t + u > e.length) return -1;
    const d1 = e[t + 6] >> 5;
    let h = 0;
    d1 === 2 ? h += 2 : (d1 & 1 && d1 !== 1 && (h += 2), d1 & 4 && (h += 2));
    const f = (e[t + 6] << 8 | e[t + 7]) >> 12 - h & 1, y = [
        2,
        1,
        2,
        3,
        3,
        4,
        4,
        5
    ][d1] + f, E = e[t + 5] >> 3, b = e[t + 5] & 7, L = new Uint8Array([
        i << 6 | E << 1 | b >> 2,
        (b & 3) << 6 | d1 << 3 | f << 2 | l >> 4,
        l << 4 & 224
    ]), A = 1536 / a * 9e4, F = r + n1 * A, M = e.subarray(t, t + u);
    return s.config = L, s.channelCount = y, s.samplerate = a, s.samples.push({
        unit: M,
        pts: F
    }), u;
}
class FT extends Lu {
    resetInitSegment(e, t, r, n1) {
        super.resetInitSegment(e, t, r, n1), this._audioTrack = {
            container: "audio/mpeg",
            type: "audio",
            id: 2,
            pid: -1,
            sequenceNumber: 0,
            segmentCodec: "mp3",
            samples: [],
            manifestCodec: t,
            duration: n1,
            inputTimeScale: 9e4,
            dropped: 0
        };
    }
    static probe(e) {
        if (!e) return !1;
        const t = Ei(e, 0);
        let r = (t == null ? void 0 : t.length) || 0;
        if (t && e[r] === 11 && e[r + 1] === 119 && _u(t) !== void 0 && // check the bsid to confirm ac-3 or ec-3 (not mp3)
        vp(e, r) <= 16) return !1;
        for(let n1 = e.length; r < n1; r++)if (yp(e, r)) return rt.log("MPEG Audio sync word found !"), !0;
        return !1;
    }
    canParse(e, t) {
        return MT(e, t);
    }
    appendFrame(e, t, r) {
        if (this.basePTS !== null) return gp(e, t, r, this.basePTS, this.frameIndex);
    }
}
const NT = /\/emsg[-/]ID3/i;
class UT {
    constructor(e, t){
        this.remainderData = null, this.timeOffset = 0, this.config = void 0, this.videoTrack = void 0, this.audioTrack = void 0, this.id3Track = void 0, this.txtTrack = void 0, this.config = t;
    }
    resetTimeStamp() {}
    resetInitSegment(e, t, r, n1) {
        const i = this.videoTrack = jr("video", 1), o = this.audioTrack = jr("audio", 1), a = this.txtTrack = jr("text", 1);
        if (this.id3Track = jr("id3", 1), this.timeOffset = 0, !(e != null && e.byteLength)) return;
        const l = Dg(e);
        if (l.video) {
            const { id: c, timescale: u, codec: d1, supplemental: h } = l.video;
            i.id = c, i.timescale = a.timescale = u, i.codec = d1, i.supplemental = h;
        }
        if (l.audio) {
            const { id: c, timescale: u, codec: d1 } = l.audio;
            o.id = c, o.timescale = u, o.codec = d1;
        }
        a.id = Rg.text, i.sampleDuration = 0, i.duration = o.duration = n1;
    }
    resetContiguity() {
        this.remainderData = null;
    }
    static probe(e) {
        return BS(e);
    }
    demux(e, t) {
        this.timeOffset = t;
        let r = e;
        const n1 = this.videoTrack, i = this.txtTrack;
        if (this.config.progressive) {
            this.remainderData && (r = _r(this.remainderData, e));
            const a = VS(r);
            this.remainderData = a.remainder, n1.samples = a.valid || new Uint8Array();
        } else n1.samples = r;
        const o = this.extractID3Track(n1, t);
        return i.samples = rh(t, n1), {
            videoTrack: n1,
            audioTrack: this.audioTrack,
            id3Track: o,
            textTrack: this.txtTrack
        };
    }
    flush() {
        const e = this.timeOffset, t = this.videoTrack, r = this.txtTrack;
        t.samples = this.remainderData || new Uint8Array(), this.remainderData = null;
        const n1 = this.extractID3Track(t, this.timeOffset);
        return r.samples = rh(e, t), {
            videoTrack: t,
            audioTrack: jr(),
            id3Track: n1,
            textTrack: jr()
        };
    }
    extractID3Track(e, t) {
        const r = this.id3Track;
        if (e.samples.length) {
            const n1 = Ge(e.samples, [
                "emsg"
            ]);
            n1 && n1.forEach((i)=>{
                const o = KS(i);
                if (NT.test(o.schemeIdUri)) {
                    const a = Nh(o, t);
                    let l = o.eventDuration === 4294967295 ? Number.POSITIVE_INFINITY : o.eventDuration / o.timeScale;
                    l <= 1e-3 && (l = Number.POSITIVE_INFINITY);
                    const c = o.payload;
                    r.samples.push({
                        data: c,
                        len: c.byteLength,
                        dts: a,
                        pts: a,
                        type: br.emsg,
                        duration: l
                    });
                } else if (this.config.enableEmsgKLVMetadata && o.schemeIdUri.startsWith("urn:misb:KLV:bin:1910.1")) {
                    const a = Nh(o, t);
                    r.samples.push({
                        data: o.payload,
                        len: o.payload.byteLength,
                        dts: a,
                        pts: a,
                        type: br.misbklv,
                        duration: Number.POSITIVE_INFINITY
                    });
                }
            });
        }
        return r;
    }
    demuxSampleAes(e, t, r) {
        return Promise.reject(new Error("The MP4 demuxer does not support SAMPLE-AES decryption"));
    }
    destroy() {
        this.config = null, this.remainderData = null, this.videoTrack = this.audioTrack = this.id3Track = this.txtTrack = void 0;
    }
}
function Nh(s, e) {
    return ue(s.presentationTime) ? s.presentationTime / s.timeScale : e + s.presentationTimeDelta / s.timeScale;
}
class $T {
    constructor(e, t, r){
        this.keyData = void 0, this.decrypter = void 0, this.keyData = r, this.decrypter = new vu(t, {
            removePKCS7Padding: !1
        });
    }
    decryptBuffer(e) {
        return this.decrypter.decrypt(e, this.keyData.key.buffer, this.keyData.iv.buffer, Os.cbc);
    }
    // AAC - encrypt all full 16 bytes blocks starting from offset 16
    decryptAacSample(e, t, r) {
        const n1 = e[t].unit;
        if (n1.length <= 16) return;
        const i = n1.subarray(16, n1.length - n1.length % 16), o = i.buffer.slice(i.byteOffset, i.byteOffset + i.length);
        this.decryptBuffer(o).then((a)=>{
            const l = new Uint8Array(a);
            n1.set(l, 16), this.decrypter.isSync() || this.decryptAacSamples(e, t + 1, r);
        }).catch(r);
    }
    decryptAacSamples(e, t, r) {
        for(;; t++){
            if (t >= e.length) {
                r();
                return;
            }
            if (!(e[t].unit.length < 32) && (this.decryptAacSample(e, t, r), !this.decrypter.isSync())) return;
        }
    }
    // AVC - encrypt one 16 bytes block out of ten, starting from offset 32
    getAvcEncryptedData(e) {
        const t = Math.floor((e.length - 48) / 160) * 16 + 16, r = new Int8Array(t);
        let n1 = 0;
        for(let i = 32; i < e.length - 16; i += 160, n1 += 16)r.set(e.subarray(i, i + 16), n1);
        return r;
    }
    getAvcDecryptedUnit(e, t) {
        const r = new Uint8Array(t);
        let n1 = 0;
        for(let i = 32; i < e.length - 16; i += 160, n1 += 16)e.set(r.subarray(n1, n1 + 16), i);
        return e;
    }
    decryptAvcSample(e, t, r, n1, i) {
        const o = Mg(i.data), a = this.getAvcEncryptedData(o);
        this.decryptBuffer(a.buffer).then((l)=>{
            i.data = this.getAvcDecryptedUnit(o, l), this.decrypter.isSync() || this.decryptAvcSamples(e, t, r + 1, n1);
        }).catch(n1);
    }
    decryptAvcSamples(e, t, r, n1) {
        if (e instanceof Uint8Array) throw new Error("Cannot decrypt samples of type Uint8Array");
        for(;; t++, r = 0){
            if (t >= e.length) {
                n1();
                return;
            }
            const i = e[t].units;
            for(; !(r >= i.length); r++){
                const o = i[r];
                if (!(o.data.length <= 48 || o.type !== 1 && o.type !== 5) && (this.decryptAvcSample(e, t, r, n1, o), !this.decrypter.isSync())) return;
            }
        }
    }
}
class xp {
    constructor(){
        this.VideoSample = null;
    }
    createVideoSample(e, t, r) {
        return {
            key: e,
            frame: !1,
            pts: t,
            dts: r,
            units: [],
            length: 0
        };
    }
    getLastNalUnit(e) {
        var t;
        let r = this.VideoSample, n1;
        if ((!r || r.units.length === 0) && (r = e[e.length - 1]), (t = r) != null && t.units) {
            const i = r.units;
            n1 = i[i.length - 1];
        }
        return n1;
    }
    pushAccessUnit(e, t) {
        if (e.units.length && e.frame) {
            if (e.pts === void 0) {
                const r = t.samples, n1 = r.length;
                if (n1) {
                    const i = r[n1 - 1];
                    e.pts = i.pts, e.dts = i.dts;
                } else {
                    t.dropped++;
                    return;
                }
            }
            t.samples.push(e);
        }
    }
    parseNALu(e, t, r) {
        const n1 = t.byteLength;
        let i = e.naluState || 0;
        const o = i, a = [];
        let l = 0, c, u, d1, h = -1, f = 0;
        for(i === -1 && (h = 0, f = this.getNALuType(t, 0), i = 0, l = 1); l < n1;){
            if (c = t[l++], !i) {
                i = c ? 0 : 1;
                continue;
            }
            if (i === 1) {
                i = c ? 0 : 2;
                continue;
            }
            if (!c) i = 3;
            else if (c === 1) {
                if (u = l - i - 1, h >= 0) {
                    const p = {
                        data: t.subarray(h, u),
                        type: f
                    };
                    a.push(p);
                } else {
                    const p = this.getLastNalUnit(e.samples);
                    p && (o && l <= 4 - o && p.state && (p.data = p.data.subarray(0, p.data.byteLength - o)), u > 0 && (p.data = _r(p.data, t.subarray(0, u)), p.state = 0));
                }
                l < n1 ? (d1 = this.getNALuType(t, l), h = l, f = d1, i = 0) : i = -1;
            } else i = 0;
        }
        if (h >= 0 && i >= 0) {
            const p = {
                data: t.subarray(h, n1),
                type: f,
                state: i
            };
            a.push(p);
        }
        if (a.length === 0) {
            const p = this.getLastNalUnit(e.samples);
            p && (p.data = _r(p.data, t));
        }
        return e.naluState = i, a;
    }
}
class Zn {
    constructor(e){
        this.data = void 0, this.bytesAvailable = void 0, this.word = void 0, this.bitsAvailable = void 0, this.data = e, this.bytesAvailable = e.byteLength, this.word = 0, this.bitsAvailable = 0;
    }
    // ():void
    loadWord() {
        const e = this.data, t = this.bytesAvailable, r = e.byteLength - t, n1 = new Uint8Array(4), i = Math.min(4, t);
        if (i === 0) throw new Error("no bytes available");
        n1.set(e.subarray(r, r + i)), this.word = new DataView(n1.buffer).getUint32(0), this.bitsAvailable = i * 8, this.bytesAvailable -= i;
    }
    // (count:int):void
    skipBits(e) {
        let t;
        e = Math.min(e, this.bytesAvailable * 8 + this.bitsAvailable), this.bitsAvailable > e ? (this.word <<= e, this.bitsAvailable -= e) : (e -= this.bitsAvailable, t = e >> 3, e -= t << 3, this.bytesAvailable -= t, this.loadWord(), this.word <<= e, this.bitsAvailable -= e);
    }
    // (size:int):uint
    readBits(e) {
        let t = Math.min(this.bitsAvailable, e);
        const r = this.word >>> 32 - t;
        if (e > 32 && rt.error("Cannot read more than 32 bits at a time"), this.bitsAvailable -= t, this.bitsAvailable > 0) this.word <<= t;
        else if (this.bytesAvailable > 0) this.loadWord();
        else throw new Error("no bits available");
        return t = e - t, t > 0 && this.bitsAvailable ? r << t | this.readBits(t) : r;
    }
    // ():uint
    skipLZ() {
        let e;
        for(e = 0; e < this.bitsAvailable; ++e)if ((this.word & 2147483648 >>> e) !== 0) return this.word <<= e, this.bitsAvailable -= e, e;
        return this.loadWord(), e + this.skipLZ();
    }
    // ():void
    skipUEG() {
        this.skipBits(1 + this.skipLZ());
    }
    // ():void
    skipEG() {
        this.skipBits(1 + this.skipLZ());
    }
    // ():uint
    readUEG() {
        const e = this.skipLZ();
        return this.readBits(e + 1) - 1;
    }
    // ():int
    readEG() {
        const e = this.readUEG();
        return 1 & e ? 1 + e >>> 1 : -1 * (e >>> 1);
    }
    // Some convenience functions
    // :Boolean
    readBoolean() {
        return this.readBits(1) === 1;
    }
    // ():int
    readUByte() {
        return this.readBits(8);
    }
    // ():int
    readUShort() {
        return this.readBits(16);
    }
    // ():int
    readUInt() {
        return this.readBits(32);
    }
}
class GT extends xp {
    parsePES(e, t, r, n1) {
        const i = this.parseNALu(e, r.data, n1);
        let o = this.VideoSample, a, l = !1;
        r.data = null, o && i.length && !e.audFound && (this.pushAccessUnit(o, e), o = this.VideoSample = this.createVideoSample(!1, r.pts, r.dts)), i.forEach((c)=>{
            var u, d1;
            switch(c.type){
                // NDR
                case 1:
                    {
                        let y = !1;
                        a = !0;
                        const E = c.data;
                        if (l && E.length > 4) {
                            const b = this.readSliceType(E);
                            (b === 2 || b === 4 || b === 7 || b === 9) && (y = !0);
                        }
                        if (y) {
                            var h;
                            (h = o) != null && h.frame && !o.key && (this.pushAccessUnit(o, e), o = this.VideoSample = null);
                        }
                        o || (o = this.VideoSample = this.createVideoSample(!0, r.pts, r.dts)), o.frame = !0, o.key = y;
                        break;
                    }
                case 5:
                    a = !0, (u = o) != null && u.frame && !o.key && (this.pushAccessUnit(o, e), o = this.VideoSample = null), o || (o = this.VideoSample = this.createVideoSample(!0, r.pts, r.dts)), o.key = !0, o.frame = !0;
                    break;
                // SEI
                case 6:
                    {
                        a = !0, gu(c.data, 1, r.pts, t.samples);
                        break;
                    }
                case 7:
                    {
                        var f, p;
                        a = !0, l = !0;
                        const y = c.data, E = this.readSPS(y);
                        if (!e.sps || e.width !== E.width || e.height !== E.height || ((f = e.pixelRatio) == null ? void 0 : f[0]) !== E.pixelRatio[0] || ((p = e.pixelRatio) == null ? void 0 : p[1]) !== E.pixelRatio[1]) {
                            e.width = E.width, e.height = E.height, e.pixelRatio = E.pixelRatio, e.sps = [
                                y
                            ];
                            const b = y.subarray(1, 4);
                            let L = "avc1.";
                            for(let A = 0; A < 3; A++){
                                let F = b[A].toString(16);
                                F.length < 2 && (F = "0" + F), L += F;
                            }
                            e.codec = L;
                        }
                        break;
                    }
                // PPS
                case 8:
                    a = !0, e.pps = [
                        c.data
                    ];
                    break;
                // AUD
                case 9:
                    a = !0, e.audFound = !0, (d1 = o) != null && d1.frame && (this.pushAccessUnit(o, e), o = null), o || (o = this.VideoSample = this.createVideoSample(!1, r.pts, r.dts));
                    break;
                // Filler Data
                case 12:
                    a = !0;
                    break;
                default:
                    a = !1;
                    break;
            }
            o && a && o.units.push(c);
        }), n1 && o && (this.pushAccessUnit(o, e), this.VideoSample = null);
    }
    getNALuType(e, t) {
        return e[t] & 31;
    }
    readSliceType(e) {
        const t = new Zn(e);
        return t.readUByte(), t.readUEG(), t.readUEG();
    }
    /**
   * The scaling list is optionally transmitted as part of a sequence parameter
   * set and is not relevant to transmuxing.
   * @param count the number of entries in this scaling list
   * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1
   */ skipScalingList(e, t) {
        let r = 8, n1 = 8, i;
        for(let o = 0; o < e; o++)n1 !== 0 && (i = t.readEG(), n1 = (r + i + 256) % 256), r = n1 === 0 ? r : n1;
    }
    /**
   * Read a sequence parameter set and return some interesting video
   * properties. A sequence parameter set is the H264 metadata that
   * describes the properties of upcoming video frames.
   * @returns an object with configuration parsed from the
   * sequence parameter set, including the dimensions of the
   * associated video frames.
   */ readSPS(e) {
        const t = new Zn(e);
        let r = 0, n1 = 0, i = 0, o = 0, a, l, c;
        const u = t.readUByte.bind(t), d1 = t.readBits.bind(t), h = t.readUEG.bind(t), f = t.readBoolean.bind(t), p = t.skipBits.bind(t), y = t.skipEG.bind(t), E = t.skipUEG.bind(t), b = this.skipScalingList.bind(this);
        u();
        const L = u();
        if (d1(5), p(3), u(), E(), L === 100 || L === 110 || L === 122 || L === 244 || L === 44 || L === 83 || L === 86 || L === 118 || L === 128) {
            const j = h();
            if (j === 3 && p(1), E(), E(), p(1), f()) for(l = j !== 3 ? 8 : 12, c = 0; c < l; c++)f() && (c < 6 ? b(16, t) : b(64, t));
        }
        E();
        const A = h();
        if (A === 0) h();
        else if (A === 1) for(p(1), y(), y(), a = h(), c = 0; c < a; c++)y();
        E(), p(1);
        const F = h(), M = h(), H = d1(1);
        H === 0 && p(1), p(1), f() && (r = h(), n1 = h(), i = h(), o = h());
        let K = [
            1,
            1
        ];
        if (f() && f()) switch(u()){
            case 1:
                K = [
                    1,
                    1
                ];
                break;
            case 2:
                K = [
                    12,
                    11
                ];
                break;
            case 3:
                K = [
                    10,
                    11
                ];
                break;
            case 4:
                K = [
                    16,
                    11
                ];
                break;
            case 5:
                K = [
                    40,
                    33
                ];
                break;
            case 6:
                K = [
                    24,
                    11
                ];
                break;
            case 7:
                K = [
                    20,
                    11
                ];
                break;
            case 8:
                K = [
                    32,
                    11
                ];
                break;
            case 9:
                K = [
                    80,
                    33
                ];
                break;
            case 10:
                K = [
                    18,
                    11
                ];
                break;
            case 11:
                K = [
                    15,
                    11
                ];
                break;
            case 12:
                K = [
                    64,
                    33
                ];
                break;
            case 13:
                K = [
                    160,
                    99
                ];
                break;
            case 14:
                K = [
                    4,
                    3
                ];
                break;
            case 15:
                K = [
                    3,
                    2
                ];
                break;
            case 16:
                K = [
                    2,
                    1
                ];
                break;
            case 255:
                {
                    K = [
                        u() << 8 | u(),
                        u() << 8 | u()
                    ];
                    break;
                }
        }
        return {
            width: Math.ceil((F + 1) * 16 - r * 2 - n1 * 2),
            height: (2 - H) * (M + 1) * 16 - (H ? 2 : 4) * (i + o),
            pixelRatio: K
        };
    }
}
class VT extends xp {
    constructor(...e){
        super(...e), this.initVPS = null;
    }
    parsePES(e, t, r, n1) {
        const i = this.parseNALu(e, r.data, n1);
        let o = this.VideoSample, a, l = !1;
        r.data = null, o && i.length && !e.audFound && (this.pushAccessUnit(o, e), o = this.VideoSample = this.createVideoSample(!1, r.pts, r.dts)), i.forEach((c)=>{
            var u, d1;
            switch(c.type){
                // NON-IDR, NON RANDOM ACCESS SLICE
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                    o || (o = this.VideoSample = this.createVideoSample(!1, r.pts, r.dts)), o.frame = !0, a = !0;
                    break;
                // CRA, BLA (random access picture)
                case 16:
                case 17:
                case 18:
                case 21:
                    if (a = !0, l) {
                        var h;
                        (h = o) != null && h.frame && !o.key && (this.pushAccessUnit(o, e), o = this.VideoSample = null);
                    }
                    o || (o = this.VideoSample = this.createVideoSample(!0, r.pts, r.dts)), o.key = !0, o.frame = !0;
                    break;
                // IDR
                case 19:
                case 20:
                    a = !0, (u = o) != null && u.frame && !o.key && (this.pushAccessUnit(o, e), o = this.VideoSample = null), o || (o = this.VideoSample = this.createVideoSample(!0, r.pts, r.dts)), o.key = !0, o.frame = !0;
                    break;
                // SEI
                case 39:
                    a = !0, gu(c.data, 2, // NALu header size
                    r.pts, t.samples);
                    break;
                // VPS
                case 32:
                    a = !0, e.vps || (typeof e.params != "object" && (e.params = {}), e.params = nt(e.params, this.readVPS(c.data)), this.initVPS = c.data), e.vps = [
                        c.data
                    ];
                    break;
                // SPS
                case 33:
                    if (a = !0, l = !0, e.vps !== void 0 && e.vps[0] !== this.initVPS && e.sps !== void 0 && !this.matchSPS(e.sps[0], c.data) && (this.initVPS = e.vps[0], e.sps = e.pps = void 0), !e.sps) {
                        const f = this.readSPS(c.data);
                        e.width = f.width, e.height = f.height, e.pixelRatio = f.pixelRatio, e.codec = f.codecString, e.sps = [], typeof e.params != "object" && (e.params = {});
                        for(const p in f.params)e.params[p] = f.params[p];
                    }
                    this.pushParameterSet(e.sps, c.data, e.vps), o || (o = this.VideoSample = this.createVideoSample(!0, r.pts, r.dts)), o.key = !0;
                    break;
                // PPS
                case 34:
                    if (a = !0, typeof e.params == "object") {
                        if (!e.pps) {
                            e.pps = [];
                            const f = this.readPPS(c.data);
                            for(const p in f)e.params[p] = f[p];
                        }
                        this.pushParameterSet(e.pps, c.data, e.vps);
                    }
                    break;
                // ACCESS UNIT DELIMITER
                case 35:
                    a = !0, e.audFound = !0, (d1 = o) != null && d1.frame && (this.pushAccessUnit(o, e), o = null), o || (o = this.VideoSample = this.createVideoSample(!1, r.pts, r.dts));
                    break;
                default:
                    a = !1;
                    break;
            }
            o && a && o.units.push(c);
        }), n1 && o && (this.pushAccessUnit(o, e), this.VideoSample = null);
    }
    pushParameterSet(e, t, r) {
        (r && r[0] === this.initVPS || !r && !e.length) && e.push(t);
    }
    getNALuType(e, t) {
        return (e[t] & 126) >>> 1;
    }
    ebsp2rbsp(e) {
        const t = new Uint8Array(e.byteLength);
        let r = 0;
        for(let n1 = 0; n1 < e.byteLength; n1++)n1 >= 2 && e[n1] === 3 && e[n1 - 1] === 0 && e[n1 - 2] === 0 || (t[r] = e[n1], r++);
        return new Uint8Array(t.buffer, 0, r);
    }
    pushAccessUnit(e, t) {
        super.pushAccessUnit(e, t), this.initVPS && (this.initVPS = null);
    }
    readVPS(e) {
        const t = new Zn(e);
        t.readUByte(), t.readUByte(), t.readBits(4), t.skipBits(2), t.readBits(6);
        const r = t.readBits(3), n1 = t.readBoolean();
        return {
            numTemporalLayers: r + 1,
            temporalIdNested: n1
        };
    }
    readSPS(e) {
        const t = new Zn(this.ebsp2rbsp(e));
        t.readUByte(), t.readUByte(), t.readBits(4);
        const r = t.readBits(3);
        t.readBoolean();
        const n1 = t.readBits(2), i = t.readBoolean(), o = t.readBits(5), a = t.readUByte(), l = t.readUByte(), c = t.readUByte(), u = t.readUByte(), d1 = t.readUByte(), h = t.readUByte(), f = t.readUByte(), p = t.readUByte(), y = t.readUByte(), E = t.readUByte(), b = t.readUByte(), L = [], A = [];
        for(let ye = 0; ye < r; ye++)L.push(t.readBoolean()), A.push(t.readBoolean());
        if (r > 0) for(let ye = r; ye < 8; ye++)t.readBits(2);
        for(let ye = 0; ye < r; ye++)L[ye] && (t.readUByte(), t.readUByte(), t.readUByte(), t.readUByte(), t.readUByte(), t.readUByte(), t.readUByte(), t.readUByte(), t.readUByte(), t.readUByte(), t.readUByte()), A[ye] && t.readUByte();
        t.readUEG();
        const F = t.readUEG();
        F == 3 && t.skipBits(1);
        const M = t.readUEG(), H = t.readUEG(), K = t.readBoolean();
        let j = 0, C = 0, k = 0, $ = 0;
        K && (j += t.readUEG(), C += t.readUEG(), k += t.readUEG(), $ += t.readUEG());
        const W = t.readUEG(), _ = t.readUEG(), g = t.readUEG(), x = t.readBoolean();
        for(let ye = x ? 0 : r; ye <= r; ye++)t.skipUEG(), t.skipUEG(), t.skipUEG();
        if (t.skipUEG(), t.skipUEG(), t.skipUEG(), t.skipUEG(), t.skipUEG(), t.skipUEG(), t.readBoolean() && t.readBoolean()) for(let be = 0; be < 4; be++)for(let Fe = 0; Fe < (be === 3 ? 2 : 6); Fe++)if (!t.readBoolean()) t.readUEG();
        else {
            const we = Math.min(64, 1 << 4 + (be << 1));
            be > 1 && t.readEG();
            for(let Ne = 0; Ne < we; Ne++)t.readEG();
        }
        t.readBoolean(), t.readBoolean(), t.readBoolean() && (t.readUByte(), t.skipUEG(), t.skipUEG(), t.readBoolean());
        const O = t.readUEG();
        let U = 0;
        for(let ye = 0; ye < O; ye++){
            let be = !1;
            if (ye !== 0 && (be = t.readBoolean()), be) {
                ye === O && t.readUEG(), t.readBoolean(), t.readUEG();
                let Fe = 0;
                for(let Xe = 0; Xe <= U; Xe++){
                    const we = t.readBoolean();
                    let Ne = !1;
                    we || (Ne = t.readBoolean()), (we || Ne) && Fe++;
                }
                U = Fe;
            } else {
                const Fe = t.readUEG(), Xe = t.readUEG();
                U = Fe + Xe;
                for(let we = 0; we < Fe; we++)t.readUEG(), t.readBoolean();
                for(let we = 0; we < Xe; we++)t.readUEG(), t.readBoolean();
            }
        }
        if (t.readBoolean()) {
            const ye = t.readUEG();
            for(let be = 0; be < ye; be++){
                for(let Fe = 0; Fe < g + 4; Fe++)t.readBits(1);
                t.readBits(1);
            }
        }
        let R = 0, m = 1, v = 1, P = !0, N = 1, Y = 0;
        t.readBoolean(), t.readBoolean();
        let ee = !1;
        if (t.readBoolean()) {
            if (t.readBoolean()) {
                const dt = t.readUByte(), Je = [
                    1,
                    12,
                    10,
                    16,
                    40,
                    24,
                    20,
                    32,
                    80,
                    18,
                    15,
                    64,
                    160,
                    4,
                    3,
                    2
                ], Qe = [
                    1,
                    11,
                    11,
                    11,
                    33,
                    11,
                    11,
                    11,
                    33,
                    11,
                    11,
                    33,
                    99,
                    3,
                    2,
                    1
                ];
                dt > 0 && dt < 16 ? (m = Je[dt - 1], v = Qe[dt - 1]) : dt === 255 && (m = t.readBits(16), v = t.readBits(16));
            }
            if (t.readBoolean() && t.readBoolean(), t.readBoolean() && (t.readBits(3), t.readBoolean(), t.readBoolean() && (t.readUByte(), t.readUByte(), t.readUByte())), t.readBoolean() && (t.readUEG(), t.readUEG()), t.readBoolean(), t.readBoolean(), t.readBoolean(), ee = t.readBoolean(), ee && (t.skipUEG(), t.skipUEG(), t.skipUEG(), t.skipUEG()), t.readBoolean() && (N = t.readBits(32), Y = t.readBits(32), t.readBoolean() && t.readUEG(), t.readBoolean())) {
                const Qe = t.readBoolean(), it = t.readBoolean();
                let je = !1;
                (Qe || it) && (je = t.readBoolean(), je && (t.readUByte(), t.readBits(5), t.readBoolean(), t.readBits(5)), t.readBits(4), t.readBits(4), je && t.readBits(4), t.readBits(5), t.readBits(5), t.readBits(5));
                for(let B = 0; B <= r; B++){
                    P = t.readBoolean();
                    const S = P || t.readBoolean();
                    let T = !1;
                    S ? t.readEG() : T = t.readBoolean();
                    const G = T ? 1 : t.readUEG() + 1;
                    if (Qe) for(let Z = 0; Z < G; Z++)t.readUEG(), t.readUEG(), je && (t.readUEG(), t.readUEG()), t.skipBits(1);
                    if (it) for(let Z = 0; Z < G; Z++)t.readUEG(), t.readUEG(), je && (t.readUEG(), t.readUEG()), t.skipBits(1);
                }
            }
            t.readBoolean() && (t.readBoolean(), t.readBoolean(), t.readBoolean(), R = t.readUEG());
        }
        let le = M, Te = H;
        if (K) {
            let ye = 1, be = 1;
            F === 1 ? ye = be = 2 : F == 2 && (ye = 2), le = M - ye * C - ye * j, Te = H - be * $ - be * k;
        }
        const De = n1 ? [
            "A",
            "B",
            "C"
        ][n1] : "", ze = a << 24 | l << 16 | c << 8 | u;
        let _e = 0;
        for(let ye = 0; ye < 32; ye++)_e = (_e | (ze >> ye & 1) << 31 - ye) >>> 0;
        let xe = _e.toString(16);
        return o === 1 && xe === "2" && (xe = "6"), {
            codecString: `hvc1.${De}${o}.${xe}.${i ? "H" : "L"}${b}.B0`,
            params: {
                general_tier_flag: i,
                general_profile_idc: o,
                general_profile_space: n1,
                general_profile_compatibility_flags: [
                    a,
                    l,
                    c,
                    u
                ],
                general_constraint_indicator_flags: [
                    d1,
                    h,
                    f,
                    p,
                    y,
                    E
                ],
                general_level_idc: b,
                bit_depth: W + 8,
                bit_depth_luma_minus8: W,
                bit_depth_chroma_minus8: _,
                min_spatial_segmentation_idc: R,
                chroma_format_idc: F,
                frame_rate: {
                    fixed: P,
                    fps: Y / N
                }
            },
            width: le,
            height: Te,
            pixelRatio: [
                m,
                v
            ]
        };
    }
    readPPS(e) {
        const t = new Zn(this.ebsp2rbsp(e));
        t.readUByte(), t.readUByte(), t.skipUEG(), t.skipUEG(), t.skipBits(2), t.skipBits(3), t.skipBits(2), t.skipUEG(), t.skipUEG(), t.skipEG(), t.skipBits(2), t.readBoolean() && t.skipUEG(), t.skipEG(), t.skipEG(), t.skipBits(4);
        const n1 = t.readBoolean(), i = t.readBoolean();
        let o = 1;
        return i && n1 ? o = 0 : i ? o = 3 : n1 && (o = 2), {
            parallelismType: o
        };
    }
    matchSPS(e, t) {
        return String.fromCharCode.apply(null, e).substr(3) === String.fromCharCode.apply(null, t).substr(3);
    }
}
const Wt = 188;
class Is {
    constructor(e, t, r, n1){
        this.logger = void 0, this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.sampleAes = null, this.pmtParsed = !1, this.audioCodec = void 0, this.videoCodec = void 0, this._pmtId = -1, this._videoTrack = void 0, this._audioTrack = void 0, this._id3Track = void 0, this._txtTrack = void 0, this.aacOverFlow = null, this.remainderData = null, this.videoParser = void 0, this.observer = e, this.config = t, this.typeSupported = r, this.logger = n1, this.videoParser = null;
    }
    static probe(e, t) {
        const r = Is.syncOffset(e);
        return r > 0 && t.warn(`MPEG2-TS detected but first sync word found @ offset ${r}`), r !== -1;
    }
    static syncOffset(e) {
        const t = e.length;
        let r = Math.min(Wt * 5, t - Wt) + 1, n1 = 0;
        for(; n1 < r;){
            let i = !1, o = -1, a = 0;
            for(let l = n1; l < t; l += Wt)if (e[l] === 71 && (t - l === Wt || e[l + Wt] === 71)) {
                if (a++, o === -1 && (o = l, o !== 0 && (r = Math.min(o + Wt * 99, e.length - Wt) + 1)), i || (i = pc(e, l) === 0), i && a > 1 && (o === 0 && a > 2 || l + Wt > r)) return o;
            } else {
                if (a) return -1;
                break;
            }
            n1++;
        }
        return -1;
    }
    /**
   * Creates a track model internal to demuxer used to drive remuxing input
   */ static createTrack(e, t) {
        return {
            container: e === "video" || e === "audio" ? "video/mp2t" : void 0,
            type: e,
            id: Rg[e],
            pid: -1,
            inputTimeScale: 9e4,
            sequenceNumber: 0,
            samples: [],
            dropped: 0,
            duration: e === "audio" ? t : void 0
        };
    }
    /**
   * Initializes a new init segment on the demuxer/remuxer interface. Needed for discontinuities/track-switches (or at stream start)
   * Resets all internal track instances of the demuxer.
   */ resetInitSegment(e, t, r, n1) {
        this.pmtParsed = !1, this._pmtId = -1, this._videoTrack = Is.createTrack("video"), this._videoTrack.duration = n1, this._audioTrack = Is.createTrack("audio", n1), this._id3Track = Is.createTrack("id3"), this._txtTrack = Is.createTrack("text"), this._audioTrack.segmentCodec = "aac", this.videoParser = null, this.aacOverFlow = null, this.remainderData = null, this.audioCodec = t, this.videoCodec = r;
    }
    resetTimeStamp() {}
    resetContiguity() {
        const { _audioTrack: e, _videoTrack: t, _id3Track: r } = this;
        e && (e.pesData = null), t && (t.pesData = null), r && (r.pesData = null), this.aacOverFlow = null, this.remainderData = null;
    }
    demux(e, t, r = !1, n1 = !1) {
        r || (this.sampleAes = null);
        let i;
        const o = this._videoTrack, a = this._audioTrack, l = this._id3Track, c = this._txtTrack;
        let u = o.pid, d1 = o.pesData, h = a.pid, f = l.pid, p = a.pesData, y = l.pesData, E = null, b = this.pmtParsed, L = this._pmtId, A = e.length;
        if (this.remainderData && (e = _r(this.remainderData, e), A = e.length, this.remainderData = null), A < Wt && !n1) return this.remainderData = e, {
            audioTrack: a,
            videoTrack: o,
            id3Track: l,
            textTrack: c
        };
        const F = Math.max(0, Is.syncOffset(e));
        A -= (A - F) % Wt, A < e.byteLength && !n1 && (this.remainderData = new Uint8Array(e.buffer, A, e.buffer.byteLength - A));
        let M = 0;
        for(let K = F; K < A; K += Wt)if (e[K] === 71) {
            const j = !!(e[K + 1] & 64), C = pc(e, K), k = (e[K + 3] & 48) >> 4;
            let $;
            if (k > 1) {
                if ($ = K + 5 + e[K + 4], $ === K + Wt) continue;
            } else $ = K + 4;
            switch(C){
                case u:
                    j && (d1 && (i = hn(d1, this.logger)) && (this.readyVideoParser(o.segmentCodec), this.videoParser !== null && this.videoParser.parsePES(o, c, i, !1)), d1 = {
                        data: [],
                        size: 0
                    }), d1 && (d1.data.push(e.subarray($, K + Wt)), d1.size += K + Wt - $);
                    break;
                case h:
                    if (j) {
                        if (p && (i = hn(p, this.logger))) switch(a.segmentCodec){
                            case "aac":
                                this.parseAACPES(a, i);
                                break;
                            case "mp3":
                                this.parseMPEGPES(a, i);
                                break;
                            case "ac3":
                                this.parseAC3PES(a, i);
                                break;
                        }
                        p = {
                            data: [],
                            size: 0
                        };
                    }
                    p && (p.data.push(e.subarray($, K + Wt)), p.size += K + Wt - $);
                    break;
                case f:
                    j && (y && (i = hn(y, this.logger)) && this.parseID3PES(l, i), y = {
                        data: [],
                        size: 0
                    }), y && (y.data.push(e.subarray($, K + Wt)), y.size += K + Wt - $);
                    break;
                case 0:
                    j && ($ += e[$] + 1), L = this._pmtId = jT(e, $);
                    break;
                case L:
                    {
                        j && ($ += e[$] + 1);
                        const W = KT(e, $, this.typeSupported, r, this.observer, this.logger);
                        u = W.videoPid, u > 0 && (o.pid = u, o.segmentCodec = W.segmentVideoCodec), h = W.audioPid, h > 0 && (a.pid = h, a.segmentCodec = W.segmentAudioCodec), f = W.id3Pid, f > 0 && (l.pid = f), E !== null && !b && (this.logger.warn(`MPEG-TS PMT found at ${K} after unknown PID '${E}'. Backtracking to sync byte @${F} to parse all TS packets.`), E = null, K = F - 188), b = this.pmtParsed = !0;
                        break;
                    }
                case 17:
                case 8191:
                    break;
                default:
                    E = C;
                    break;
            }
        } else M++;
        M > 0 && mc(this.observer, new Error(`Found ${M} TS packet/s that do not start with 0x47`), void 0, this.logger), o.pesData = d1, a.pesData = p, l.pesData = y;
        const H = {
            audioTrack: a,
            videoTrack: o,
            id3Track: l,
            textTrack: c
        };
        return n1 && this.extractRemainingSamples(H), H;
    }
    flush() {
        const { remainderData: e } = this;
        this.remainderData = null;
        let t;
        return e ? t = this.demux(e, -1, !1, !0) : t = {
            videoTrack: this._videoTrack,
            audioTrack: this._audioTrack,
            id3Track: this._id3Track,
            textTrack: this._txtTrack
        }, this.extractRemainingSamples(t), this.sampleAes ? this.decrypt(t, this.sampleAes) : t;
    }
    extractRemainingSamples(e) {
        const { audioTrack: t, videoTrack: r, id3Track: n1, textTrack: i } = e, o = r.pesData, a = t.pesData, l = n1.pesData;
        let c;
        if (o && (c = hn(o, this.logger)) ? (this.readyVideoParser(r.segmentCodec), this.videoParser !== null && (this.videoParser.parsePES(r, i, c, !0), r.pesData = null)) : r.pesData = o, a && (c = hn(a, this.logger))) {
            switch(t.segmentCodec){
                case "aac":
                    this.parseAACPES(t, c);
                    break;
                case "mp3":
                    this.parseMPEGPES(t, c);
                    break;
                case "ac3":
                    this.parseAC3PES(t, c);
                    break;
            }
            t.pesData = null;
        } else a != null && a.size && this.logger.log("last AAC PES packet truncated,might overlap between fragments"), t.pesData = a;
        l && (c = hn(l, this.logger)) ? (this.parseID3PES(n1, c), n1.pesData = null) : n1.pesData = l;
    }
    demuxSampleAes(e, t, r) {
        const n1 = this.demux(e, r, !0, !this.config.progressive), i = this.sampleAes = new $T(this.observer, this.config, t);
        return this.decrypt(n1, i);
    }
    readyVideoParser(e) {
        this.videoParser === null && (e === "avc" ? this.videoParser = new GT() : e === "hevc" && (this.videoParser = new VT()));
    }
    decrypt(e, t) {
        return new Promise((r)=>{
            const { audioTrack: n1, videoTrack: i } = e;
            n1.samples && n1.segmentCodec === "aac" ? t.decryptAacSamples(n1.samples, 0, ()=>{
                i.samples ? t.decryptAvcSamples(i.samples, 0, 0, ()=>{
                    r(e);
                }) : r(e);
            }) : i.samples && t.decryptAvcSamples(i.samples, 0, 0, ()=>{
                r(e);
            });
        });
    }
    destroy() {
        this.observer && this.observer.removeAllListeners(), this.config = this.logger = this.observer = null, this.aacOverFlow = this.videoParser = this.remainderData = this.sampleAes = null, this._videoTrack = this._audioTrack = this._id3Track = this._txtTrack = void 0;
    }
    parseAACPES(e, t) {
        let r = 0;
        const n1 = this.aacOverFlow;
        let i = t.data;
        if (n1) {
            this.aacOverFlow = null;
            const d1 = n1.missing, h = n1.sample.unit.byteLength;
            if (d1 === -1) i = _r(n1.sample.unit, i);
            else {
                const f = h - d1;
                n1.sample.unit.set(i.subarray(0, d1), f), e.samples.push(n1.sample), r = n1.missing;
            }
        }
        let o, a;
        for(o = r, a = i.length; o < a - 1 && !na(i, o); o++);
        if (o !== r) {
            let d1;
            const h = o < a - 1;
            if (h ? d1 = `AAC PES did not start with ADTS header,offset:${o}` : d1 = "No ADTS header found in AAC PES", mc(this.observer, new Error(d1), h, this.logger), !h) return;
        }
        cp(e, this.observer, i, o, this.audioCodec);
        let l;
        if (t.pts !== void 0) l = t.pts;
        else if (n1) {
            const d1 = up(e.samplerate);
            l = n1.sample.pts + d1;
        } else {
            this.logger.warn("[tsdemuxer]: AAC PES unknown PTS");
            return;
        }
        let c = 0, u;
        for(; o < a;)if (u = dp(e, i, o, l, c), o += u.length, u.missing) {
            this.aacOverFlow = u;
            break;
        } else for(c++; o < a - 1 && !na(i, o); o++);
    }
    parseMPEGPES(e, t) {
        const r = t.data, n1 = r.length;
        let i = 0, o = 0;
        const a = t.pts;
        if (a === void 0) {
            this.logger.warn("[tsdemuxer]: MPEG PES unknown PTS");
            return;
        }
        for(; o < n1;)if (mp(r, o)) {
            const l = gp(e, r, o, a, i);
            if (l) o += l.length, i++;
            else break;
        } else o++;
    }
    parseAC3PES(e, t) {
        {
            const r = t.data, n1 = t.pts;
            if (n1 === void 0) {
                this.logger.warn("[tsdemuxer]: AC3 PES unknown PTS");
                return;
            }
            const i = r.length;
            let o = 0, a = 0, l;
            for(; a < i && (l = Ep(e, r, a, n1, o++)) > 0;)a += l;
        }
    }
    parseID3PES(e, t) {
        if (t.pts === void 0) {
            this.logger.warn("[tsdemuxer]: ID3 PES unknown PTS");
            return;
        }
        const r = nt({}, t, {
            type: this._videoTrack ? br.emsg : br.audioId3,
            duration: Number.POSITIVE_INFINITY
        });
        e.samples.push(r);
    }
}
function pc(s, e) {
    return ((s[e + 1] & 31) << 8) + s[e + 2];
}
function jT(s, e) {
    return (s[e + 10] & 31) << 8 | s[e + 11];
}
function KT(s, e, t, r, n1, i) {
    const o = {
        audioPid: -1,
        videoPid: -1,
        id3Pid: -1,
        segmentVideoCodec: "avc",
        segmentAudioCodec: "aac"
    }, a = (s[e + 1] & 15) << 8 | s[e + 2], l = e + 3 + a - 4, c = (s[e + 10] & 15) << 8 | s[e + 11];
    for(e += 12 + c; e < l;){
        const u = pc(s, e), d1 = (s[e + 3] & 15) << 8 | s[e + 4];
        switch(s[e]){
            case 207:
                if (!r) {
                    vl("ADTS AAC", i);
                    break;
                }
            /* falls through */ case 15:
                o.audioPid === -1 && (o.audioPid = u);
                break;
            // Packetized metadata (ID3)
            case 21:
                o.id3Pid === -1 && (o.id3Pid = u);
                break;
            case 219:
                if (!r) {
                    vl("H.264", i);
                    break;
                }
            /* falls through */ case 27:
                o.videoPid === -1 && (o.videoPid = u);
                break;
            // ISO/IEC 11172-3 (MPEG-1 audio)
            // or ISO/IEC 13818-3 (MPEG-2 halved sample rate audio)
            case 3:
            case 4:
                !t.mpeg && !t.mp3 ? i.log("MPEG audio found, not supported in this browser") : o.audioPid === -1 && (o.audioPid = u, o.segmentAudioCodec = "mp3");
                break;
            case 193:
                if (!r) {
                    vl("AC-3", i);
                    break;
                }
            /* falls through */ case 129:
                t.ac3 ? o.audioPid === -1 && (o.audioPid = u, o.segmentAudioCodec = "ac3") : i.log("AC-3 audio found, not supported in this browser");
                break;
            case 6:
                if (o.audioPid === -1 && d1 > 0) {
                    let h = e + 5, f = d1;
                    for(; f > 2;){
                        switch(s[h]){
                            case 106:
                                t.ac3 !== !0 ? i.log("AC-3 audio found, not supported in this browser for now") : (o.audioPid = u, o.segmentAudioCodec = "ac3");
                                break;
                        }
                        const y = s[h + 1] + 2;
                        h += y, f -= y;
                    }
                }
                break;
            case 194:
            // SAMPLE-AES EC3
            /* falls through */ case 135:
                return mc(n1, new Error("Unsupported EC-3 in M2TS found"), void 0, i), o;
            case 36:
                o.videoPid === -1 && (o.videoPid = u, o.segmentVideoCodec = "hevc", i.log("HEVC in M2TS found"));
                break;
        }
        e += d1 + 5;
    }
    return o;
}
function mc(s, e, t, r) {
    r.warn(`parsing error: ${e.message}`), s.emit(I.ERROR, I.ERROR, {
        type: ve.MEDIA_ERROR,
        details: J.FRAG_PARSING_ERROR,
        fatal: !1,
        levelRetry: t,
        error: e,
        reason: e.message
    });
}
function vl(s, e) {
    e.log(`${s} with AES-128-CBC encryption found in unencrypted stream`);
}
function hn(s, e) {
    let t = 0, r, n1, i, o, a;
    const l = s.data;
    if (!s || s.size === 0) return null;
    for(; l[0].length < 19 && l.length > 1;)l[0] = _r(l[0], l[1]), l.splice(1, 1);
    if (r = l[0], (r[0] << 16) + (r[1] << 8) + r[2] === 1) {
        if (n1 = (r[4] << 8) + r[5], n1 && n1 > s.size - 6) return null;
        const u = r[7];
        u & 192 && (o = (r[9] & 14) * 536870912 + // 1 << 29
        (r[10] & 255) * 4194304 + // 1 << 22
        (r[11] & 254) * 16384 + // 1 << 14
        (r[12] & 255) * 128 + // 1 << 7
        (r[13] & 254) / 2, u & 64 ? (a = (r[14] & 14) * 536870912 + // 1 << 29
        (r[15] & 255) * 4194304 + // 1 << 22
        (r[16] & 254) * 16384 + // 1 << 14
        (r[17] & 255) * 128 + // 1 << 7
        (r[18] & 254) / 2, o - a > 60 * 9e4 && (e.warn(`${Math.round((o - a) / 9e4)}s delta between PTS and DTS, align them`), o = a)) : a = o), i = r[8];
        let d1 = i + 9;
        if (s.size <= d1) return null;
        s.size -= d1;
        const h = new Uint8Array(s.size);
        for(let f = 0, p = l.length; f < p; f++){
            r = l[f];
            let y = r.byteLength;
            if (d1) if (d1 > y) {
                d1 -= y;
                continue;
            } else r = r.subarray(d1), y -= d1, d1 = 0;
            h.set(r, t), t += y;
        }
        return n1 && (n1 -= i + 3), {
            data: h,
            pts: o,
            dts: a,
            len: n1
        };
    }
    return null;
}
class HT {
    static getSilentFrame(e, t) {
        switch(e){
            case "mp4a.40.2":
                if (t === 1) return new Uint8Array([
                    0,
                    200,
                    0,
                    128,
                    35,
                    128
                ]);
                if (t === 2) return new Uint8Array([
                    33,
                    0,
                    73,
                    144,
                    2,
                    25,
                    0,
                    35,
                    128
                ]);
                if (t === 3) return new Uint8Array([
                    0,
                    200,
                    0,
                    128,
                    32,
                    132,
                    1,
                    38,
                    64,
                    8,
                    100,
                    0,
                    142
                ]);
                if (t === 4) return new Uint8Array([
                    0,
                    200,
                    0,
                    128,
                    32,
                    132,
                    1,
                    38,
                    64,
                    8,
                    100,
                    0,
                    128,
                    44,
                    128,
                    8,
                    2,
                    56
                ]);
                if (t === 5) return new Uint8Array([
                    0,
                    200,
                    0,
                    128,
                    32,
                    132,
                    1,
                    38,
                    64,
                    8,
                    100,
                    0,
                    130,
                    48,
                    4,
                    153,
                    0,
                    33,
                    144,
                    2,
                    56
                ]);
                if (t === 6) return new Uint8Array([
                    0,
                    200,
                    0,
                    128,
                    32,
                    132,
                    1,
                    38,
                    64,
                    8,
                    100,
                    0,
                    130,
                    48,
                    4,
                    153,
                    0,
                    33,
                    144,
                    2,
                    0,
                    178,
                    0,
                    32,
                    8,
                    224
                ]);
                break;
            // handle HE-AAC below (mp4a.40.5 / mp4a.40.29)
            default:
                if (t === 1) return new Uint8Array([
                    1,
                    64,
                    34,
                    128,
                    163,
                    78,
                    230,
                    128,
                    186,
                    8,
                    0,
                    0,
                    0,
                    28,
                    6,
                    241,
                    193,
                    10,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    94
                ]);
                if (t === 2) return new Uint8Array([
                    1,
                    64,
                    34,
                    128,
                    163,
                    94,
                    230,
                    128,
                    186,
                    8,
                    0,
                    0,
                    0,
                    0,
                    149,
                    0,
                    6,
                    241,
                    161,
                    10,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    94
                ]);
                if (t === 3) return new Uint8Array([
                    1,
                    64,
                    34,
                    128,
                    163,
                    94,
                    230,
                    128,
                    186,
                    8,
                    0,
                    0,
                    0,
                    0,
                    149,
                    0,
                    6,
                    241,
                    161,
                    10,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    90,
                    94
                ]);
                break;
        }
    }
}
const Ss = Math.pow(2, 32) - 1;
class X {
    static init() {
        X.types = {
            avc1: [],
            // codingname
            avcC: [],
            hvc1: [],
            hvcC: [],
            btrt: [],
            dinf: [],
            dref: [],
            esds: [],
            ftyp: [],
            hdlr: [],
            mdat: [],
            mdhd: [],
            mdia: [],
            mfhd: [],
            minf: [],
            moof: [],
            moov: [],
            mp4a: [],
            ".mp3": [],
            dac3: [],
            "ac-3": [],
            mvex: [],
            mvhd: [],
            pasp: [],
            sdtp: [],
            stbl: [],
            stco: [],
            stsc: [],
            stsd: [],
            stsz: [],
            stts: [],
            tfdt: [],
            tfhd: [],
            traf: [],
            trak: [],
            trun: [],
            trex: [],
            tkhd: [],
            vmhd: [],
            smhd: []
        };
        let e;
        for(e in X.types)X.types.hasOwnProperty(e) && (X.types[e] = [
            e.charCodeAt(0),
            e.charCodeAt(1),
            e.charCodeAt(2),
            e.charCodeAt(3)
        ]);
        const t = new Uint8Array([
            0,
            // version 0
            0,
            0,
            0,
            // flags
            0,
            0,
            0,
            0,
            // pre_defined
            118,
            105,
            100,
            101,
            // handler_type: 'vide'
            0,
            0,
            0,
            0,
            // reserved
            0,
            0,
            0,
            0,
            // reserved
            0,
            0,
            0,
            0,
            // reserved
            86,
            105,
            100,
            101,
            111,
            72,
            97,
            110,
            100,
            108,
            101,
            114,
            0
        ]), r = new Uint8Array([
            0,
            // version 0
            0,
            0,
            0,
            // flags
            0,
            0,
            0,
            0,
            // pre_defined
            115,
            111,
            117,
            110,
            // handler_type: 'soun'
            0,
            0,
            0,
            0,
            // reserved
            0,
            0,
            0,
            0,
            // reserved
            0,
            0,
            0,
            0,
            // reserved
            83,
            111,
            117,
            110,
            100,
            72,
            97,
            110,
            100,
            108,
            101,
            114,
            0
        ]);
        X.HDLR_TYPES = {
            video: t,
            audio: r
        };
        const n1 = new Uint8Array([
            0,
            // version 0
            0,
            0,
            0,
            // flags
            0,
            0,
            0,
            1,
            // entry_count
            0,
            0,
            0,
            12,
            // entry_size
            117,
            114,
            108,
            32,
            // 'url' type
            0,
            // version 0
            0,
            0,
            1
        ]), i = new Uint8Array([
            0,
            // version
            0,
            0,
            0,
            // flags
            0,
            0,
            0,
            0
        ]);
        X.STTS = X.STSC = X.STCO = i, X.STSZ = new Uint8Array([
            0,
            // version
            0,
            0,
            0,
            // flags
            0,
            0,
            0,
            0,
            // sample_size
            0,
            0,
            0,
            0
        ]), X.VMHD = new Uint8Array([
            0,
            // version
            0,
            0,
            1,
            // flags
            0,
            0,
            // graphicsmode
            0,
            0,
            0,
            0,
            0,
            0
        ]), X.SMHD = new Uint8Array([
            0,
            // version
            0,
            0,
            0,
            // flags
            0,
            0,
            // balance
            0,
            0
        ]), X.STSD = new Uint8Array([
            0,
            // version 0
            0,
            0,
            0,
            // flags
            0,
            0,
            0,
            1
        ]);
        const o = new Uint8Array([
            105,
            115,
            111,
            109
        ]), a = new Uint8Array([
            97,
            118,
            99,
            49
        ]), l = new Uint8Array([
            0,
            0,
            0,
            1
        ]);
        X.FTYP = X.box(X.types.ftyp, o, l, o, a), X.DINF = X.box(X.types.dinf, X.box(X.types.dref, n1));
    }
    static box(e, ...t) {
        let r = 8, n1 = t.length;
        const i = n1;
        for(; n1--;)r += t[n1].byteLength;
        const o = new Uint8Array(r);
        for(o[0] = r >> 24 & 255, o[1] = r >> 16 & 255, o[2] = r >> 8 & 255, o[3] = r & 255, o.set(e, 4), n1 = 0, r = 8; n1 < i; n1++)o.set(t[n1], r), r += t[n1].byteLength;
        return o;
    }
    static hdlr(e) {
        return X.box(X.types.hdlr, X.HDLR_TYPES[e]);
    }
    static mdat(e) {
        return X.box(X.types.mdat, e);
    }
    static mdhd(e, t) {
        t *= e;
        const r = Math.floor(t / (Ss + 1)), n1 = Math.floor(t % (Ss + 1));
        return X.box(X.types.mdhd, new Uint8Array([
            1,
            // version 1
            0,
            0,
            0,
            // flags
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            // creation_time
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            3,
            // modification_time
            e >> 24 & 255,
            e >> 16 & 255,
            e >> 8 & 255,
            e & 255,
            // timescale
            r >> 24,
            r >> 16 & 255,
            r >> 8 & 255,
            r & 255,
            n1 >> 24,
            n1 >> 16 & 255,
            n1 >> 8 & 255,
            n1 & 255,
            85,
            196,
            // 'und' language (undetermined)
            0,
            0
        ]));
    }
    static mdia(e) {
        return X.box(X.types.mdia, X.mdhd(e.timescale || 0, e.duration || 0), X.hdlr(e.type), X.minf(e));
    }
    static mfhd(e) {
        return X.box(X.types.mfhd, new Uint8Array([
            0,
            0,
            0,
            0,
            // flags
            e >> 24,
            e >> 16 & 255,
            e >> 8 & 255,
            e & 255
        ]));
    }
    static minf(e) {
        return e.type === "audio" ? X.box(X.types.minf, X.box(X.types.smhd, X.SMHD), X.DINF, X.stbl(e)) : X.box(X.types.minf, X.box(X.types.vmhd, X.VMHD), X.DINF, X.stbl(e));
    }
    static moof(e, t, r) {
        return X.box(X.types.moof, X.mfhd(e), X.traf(r, t));
    }
    static moov(e) {
        let t = e.length;
        const r = [];
        for(; t--;)r[t] = X.trak(e[t]);
        return X.box.apply(null, [
            X.types.moov,
            X.mvhd(e[0].timescale || 0, e[0].duration || 0)
        ].concat(r).concat(X.mvex(e)));
    }
    static mvex(e) {
        let t = e.length;
        const r = [];
        for(; t--;)r[t] = X.trex(e[t]);
        return X.box.apply(null, [
            X.types.mvex,
            ...r
        ]);
    }
    static mvhd(e, t) {
        t *= e;
        const r = Math.floor(t / (Ss + 1)), n1 = Math.floor(t % (Ss + 1)), i = new Uint8Array([
            1,
            // version 1
            0,
            0,
            0,
            // flags
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            // creation_time
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            3,
            // modification_time
            e >> 24 & 255,
            e >> 16 & 255,
            e >> 8 & 255,
            e & 255,
            // timescale
            r >> 24,
            r >> 16 & 255,
            r >> 8 & 255,
            r & 255,
            n1 >> 24,
            n1 >> 16 & 255,
            n1 >> 8 & 255,
            n1 & 255,
            0,
            1,
            0,
            0,
            // 1.0 rate
            1,
            0,
            // 1.0 volume
            0,
            0,
            // reserved
            0,
            0,
            0,
            0,
            // reserved
            0,
            0,
            0,
            0,
            // reserved
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            64,
            0,
            0,
            0,
            // transformation: unity matrix
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            // pre_defined
            255,
            255,
            255,
            255
        ]);
        return X.box(X.types.mvhd, i);
    }
    static sdtp(e) {
        const t = e.samples || [], r = new Uint8Array(4 + t.length);
        let n1, i;
        for(n1 = 0; n1 < t.length; n1++)i = t[n1].flags, r[n1 + 4] = i.dependsOn << 4 | i.isDependedOn << 2 | i.hasRedundancy;
        return X.box(X.types.sdtp, r);
    }
    static stbl(e) {
        return X.box(X.types.stbl, X.stsd(e), X.box(X.types.stts, X.STTS), X.box(X.types.stsc, X.STSC), X.box(X.types.stsz, X.STSZ), X.box(X.types.stco, X.STCO));
    }
    static avc1(e) {
        let t = [], r = [], n1, i, o;
        for(n1 = 0; n1 < e.sps.length; n1++)i = e.sps[n1], o = i.byteLength, t.push(o >>> 8 & 255), t.push(o & 255), t = t.concat(Array.prototype.slice.call(i));
        for(n1 = 0; n1 < e.pps.length; n1++)i = e.pps[n1], o = i.byteLength, r.push(o >>> 8 & 255), r.push(o & 255), r = r.concat(Array.prototype.slice.call(i));
        const a = X.box(X.types.avcC, new Uint8Array([
            1,
            // version
            t[3],
            // profile
            t[4],
            // profile compat
            t[5],
            // level
            255,
            // lengthSizeMinusOne, hard-coded to 4 bytes
            224 | e.sps.length
        ].concat(t).concat([
            e.pps.length
        ]).concat(r))), l = e.width, c = e.height, u = e.pixelRatio[0], d1 = e.pixelRatio[1];
        return X.box(X.types.avc1, new Uint8Array([
            0,
            0,
            0,
            // reserved
            0,
            0,
            0,
            // reserved
            0,
            1,
            // data_reference_index
            0,
            0,
            // pre_defined
            0,
            0,
            // reserved
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            // pre_defined
            l >> 8 & 255,
            l & 255,
            // width
            c >> 8 & 255,
            c & 255,
            // height
            0,
            72,
            0,
            0,
            // horizresolution
            0,
            72,
            0,
            0,
            // vertresolution
            0,
            0,
            0,
            0,
            // reserved
            0,
            1,
            // frame_count
            18,
            100,
            97,
            105,
            108,
            // dailymotion/hls.js
            121,
            109,
            111,
            116,
            105,
            111,
            110,
            47,
            104,
            108,
            115,
            46,
            106,
            115,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            // compressorname
            0,
            24,
            // depth = 24
            17,
            17
        ]), // pre_defined = -1
        a, X.box(X.types.btrt, new Uint8Array([
            0,
            28,
            156,
            128,
            // bufferSizeDB
            0,
            45,
            198,
            192,
            // maxBitrate
            0,
            45,
            198,
            192
        ])), // avgBitrate
        X.box(X.types.pasp, new Uint8Array([
            u >> 24,
            // hSpacing
            u >> 16 & 255,
            u >> 8 & 255,
            u & 255,
            d1 >> 24,
            // vSpacing
            d1 >> 16 & 255,
            d1 >> 8 & 255,
            d1 & 255
        ])));
    }
    static esds(e) {
        const t = e.config;
        return new Uint8Array([
            0,
            // version 0
            0,
            0,
            0,
            // flags
            3,
            // descriptor_type
            25,
            // length
            0,
            1,
            // es_id
            0,
            // stream_priority
            4,
            // descriptor_type
            17,
            // length
            64,
            // codec : mpeg4_audio
            21,
            // stream_type
            0,
            0,
            0,
            // buffer_size
            0,
            0,
            0,
            0,
            // maxBitrate
            0,
            0,
            0,
            0,
            // avgBitrate
            5,
            // descriptor_type
            2,
            // length
            ...t,
            6,
            1,
            2
        ]);
    }
    static audioStsd(e) {
        const t = e.samplerate || 0;
        return new Uint8Array([
            0,
            0,
            0,
            // reserved
            0,
            0,
            0,
            // reserved
            0,
            1,
            // data_reference_index
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            // reserved
            0,
            e.channelCount || 0,
            // channelcount
            0,
            16,
            // sampleSize:16bits
            0,
            0,
            0,
            0,
            // reserved2
            t >> 8 & 255,
            t & 255,
            //
            0,
            0
        ]);
    }
    static mp4a(e) {
        return X.box(X.types.mp4a, X.audioStsd(e), X.box(X.types.esds, X.esds(e)));
    }
    static mp3(e) {
        return X.box(X.types[".mp3"], X.audioStsd(e));
    }
    static ac3(e) {
        return X.box(X.types["ac-3"], X.audioStsd(e), X.box(X.types.dac3, e.config));
    }
    static stsd(e) {
        const { segmentCodec: t } = e;
        if (e.type === "audio") {
            if (t === "aac") return X.box(X.types.stsd, X.STSD, X.mp4a(e));
            if (t === "ac3" && e.config) return X.box(X.types.stsd, X.STSD, X.ac3(e));
            if (t === "mp3" && e.codec === "mp3") return X.box(X.types.stsd, X.STSD, X.mp3(e));
        } else if (e.pps && e.sps) {
            if (t === "avc") return X.box(X.types.stsd, X.STSD, X.avc1(e));
            if (t === "hevc" && e.vps) return X.box(X.types.stsd, X.STSD, X.hvc1(e));
        } else throw new Error("video track missing pps or sps");
        throw new Error(`unsupported ${e.type} segment codec (${t}/${e.codec})`);
    }
    static tkhd(e) {
        const t = e.id, r = (e.duration || 0) * (e.timescale || 0), n1 = e.width || 0, i = e.height || 0, o = Math.floor(r / (Ss + 1)), a = Math.floor(r % (Ss + 1));
        return X.box(X.types.tkhd, new Uint8Array([
            1,
            // version 1
            0,
            0,
            7,
            // flags
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            // creation_time
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            3,
            // modification_time
            t >> 24 & 255,
            t >> 16 & 255,
            t >> 8 & 255,
            t & 255,
            // track_ID
            0,
            0,
            0,
            0,
            // reserved
            o >> 24,
            o >> 16 & 255,
            o >> 8 & 255,
            o & 255,
            a >> 24,
            a >> 16 & 255,
            a >> 8 & 255,
            a & 255,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            // reserved
            0,
            0,
            // layer
            0,
            0,
            // alternate_group
            0,
            0,
            // non-audio track volume
            0,
            0,
            // reserved
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            64,
            0,
            0,
            0,
            // transformation: unity matrix
            n1 >> 8 & 255,
            n1 & 255,
            0,
            0,
            // width
            i >> 8 & 255,
            i & 255,
            0,
            0
        ]));
    }
    static traf(e, t) {
        const r = X.sdtp(e), n1 = e.id, i = Math.floor(t / (Ss + 1)), o = Math.floor(t % (Ss + 1));
        return X.box(X.types.traf, X.box(X.types.tfhd, new Uint8Array([
            0,
            // version 0
            0,
            0,
            0,
            // flags
            n1 >> 24,
            n1 >> 16 & 255,
            n1 >> 8 & 255,
            n1 & 255
        ])), X.box(X.types.tfdt, new Uint8Array([
            1,
            // version 1
            0,
            0,
            0,
            // flags
            i >> 24,
            i >> 16 & 255,
            i >> 8 & 255,
            i & 255,
            o >> 24,
            o >> 16 & 255,
            o >> 8 & 255,
            o & 255
        ])), X.trun(e, r.length + 16 + // tfhd
        20 + // tfdt
        8 + // traf header
        16 + // mfhd
        8 + // moof header
        8), // mdat header
        r);
    }
    /**
   * Generate a track box.
   * @param track a track definition
   */ static trak(e) {
        return e.duration = e.duration || 4294967295, X.box(X.types.trak, X.tkhd(e), X.mdia(e));
    }
    static trex(e) {
        const t = e.id;
        return X.box(X.types.trex, new Uint8Array([
            0,
            // version 0
            0,
            0,
            0,
            // flags
            t >> 24,
            t >> 16 & 255,
            t >> 8 & 255,
            t & 255,
            // track_ID
            0,
            0,
            0,
            1,
            // default_sample_description_index
            0,
            0,
            0,
            0,
            // default_sample_duration
            0,
            0,
            0,
            0,
            // default_sample_size
            0,
            1,
            0,
            1
        ]));
    }
    static trun(e, t) {
        const r = e.samples || [], n1 = r.length, i = 12 + 16 * n1, o = new Uint8Array(i);
        let a, l, c, u, d1, h;
        for(t += 8 + i, o.set([
            e.type === "video" ? 1 : 0,
            // version 1 for video with signed-int sample_composition_time_offset
            0,
            15,
            1,
            // flags
            n1 >>> 24 & 255,
            n1 >>> 16 & 255,
            n1 >>> 8 & 255,
            n1 & 255,
            // sample_count
            t >>> 24 & 255,
            t >>> 16 & 255,
            t >>> 8 & 255,
            t & 255
        ], 0), a = 0; a < n1; a++)l = r[a], c = l.duration, u = l.size, d1 = l.flags, h = l.cts, o.set([
            c >>> 24 & 255,
            c >>> 16 & 255,
            c >>> 8 & 255,
            c & 255,
            // sample_duration
            u >>> 24 & 255,
            u >>> 16 & 255,
            u >>> 8 & 255,
            u & 255,
            // sample_size
            d1.isLeading << 2 | d1.dependsOn,
            d1.isDependedOn << 6 | d1.hasRedundancy << 4 | d1.paddingValue << 1 | d1.isNonSync,
            d1.degradPrio & 61440,
            d1.degradPrio & 15,
            // sample_flags
            h >>> 24 & 255,
            h >>> 16 & 255,
            h >>> 8 & 255,
            h & 255
        ], 12 + 16 * a);
        return X.box(X.types.trun, o);
    }
    static initSegment(e) {
        X.types || X.init();
        const t = X.moov(e);
        return _r(X.FTYP, t);
    }
    static hvc1(e) {
        const t = e.params, r = [
            e.vps,
            e.sps,
            e.pps
        ], n1 = 4, i = new Uint8Array([
            1,
            t.general_profile_space << 6 | (t.general_tier_flag ? 32 : 0) | t.general_profile_idc,
            t.general_profile_compatibility_flags[0],
            t.general_profile_compatibility_flags[1],
            t.general_profile_compatibility_flags[2],
            t.general_profile_compatibility_flags[3],
            t.general_constraint_indicator_flags[0],
            t.general_constraint_indicator_flags[1],
            t.general_constraint_indicator_flags[2],
            t.general_constraint_indicator_flags[3],
            t.general_constraint_indicator_flags[4],
            t.general_constraint_indicator_flags[5],
            t.general_level_idc,
            240 | t.min_spatial_segmentation_idc >> 8,
            255 & t.min_spatial_segmentation_idc,
            252 | t.parallelismType,
            252 | t.chroma_format_idc,
            248 | t.bit_depth_luma_minus8,
            248 | t.bit_depth_chroma_minus8,
            0,
            parseInt(t.frame_rate.fps),
            n1 - 1 | t.temporal_id_nested << 2 | t.num_temporal_layers << 3 | (t.frame_rate.fixed ? 64 : 0),
            r.length
        ]);
        let o = i.length;
        for(let p = 0; p < r.length; p += 1){
            o += 3;
            for(let y = 0; y < r[p].length; y += 1)o += 2 + r[p][y].length;
        }
        const a = new Uint8Array(o);
        a.set(i, 0), o = i.length;
        const l = r.length - 1;
        for(let p = 0; p < r.length; p += 1){
            a.set(new Uint8Array([
                32 + p | (p === l ? 128 : 0),
                0,
                r[p].length
            ]), o), o += 3;
            for(let y = 0; y < r[p].length; y += 1)a.set(new Uint8Array([
                r[p][y].length >> 8,
                r[p][y].length & 255
            ]), o), o += 2, a.set(r[p][y], o), o += r[p][y].length;
        }
        const c = X.box(X.types.hvcC, a), u = e.width, d1 = e.height, h = e.pixelRatio[0], f = e.pixelRatio[1];
        return X.box(X.types.hvc1, new Uint8Array([
            0,
            0,
            0,
            // reserved
            0,
            0,
            0,
            // reserved
            0,
            1,
            // data_reference_index
            0,
            0,
            // pre_defined
            0,
            0,
            // reserved
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            // pre_defined
            u >> 8 & 255,
            u & 255,
            // width
            d1 >> 8 & 255,
            d1 & 255,
            // height
            0,
            72,
            0,
            0,
            // horizresolution
            0,
            72,
            0,
            0,
            // vertresolution
            0,
            0,
            0,
            0,
            // reserved
            0,
            1,
            // frame_count
            18,
            100,
            97,
            105,
            108,
            // dailymotion/hls.js
            121,
            109,
            111,
            116,
            105,
            111,
            110,
            47,
            104,
            108,
            115,
            46,
            106,
            115,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            // compressorname
            0,
            24,
            // depth = 24
            17,
            17
        ]), // pre_defined = -1
        c, X.box(X.types.btrt, new Uint8Array([
            0,
            28,
            156,
            128,
            // bufferSizeDB
            0,
            45,
            198,
            192,
            // maxBitrate
            0,
            45,
            198,
            192
        ])), // avgBitrate
        X.box(X.types.pasp, new Uint8Array([
            h >> 24,
            // hSpacing
            h >> 16 & 255,
            h >> 8 & 255,
            h & 255,
            f >> 24,
            // vSpacing
            f >> 16 & 255,
            f >> 8 & 255,
            f & 255
        ])));
    }
}
X.types = void 0;
X.HDLR_TYPES = void 0;
X.STTS = void 0;
X.STSC = void 0;
X.STCO = void 0;
X.STSZ = void 0;
X.VMHD = void 0;
X.SMHD = void 0;
X.STSD = void 0;
X.FTYP = void 0;
X.DINF = void 0;
const Sp = 9e4;
function Cu(s, e, t = 1, r = !1) {
    const n1 = s * e * t;
    return r ? Math.round(n1) : n1;
}
function qT(s, e, t = 1, r = !1) {
    return Cu(s, e, 1 / t, r);
}
function qn(s, e = !1) {
    return Cu(s, 1e3, 1 / Sp, e);
}
function WT(s, e = 1) {
    return Cu(s, Sp, 1 / e);
}
const zT = 10 * 1e3, YT = 1024, ZT = 1152, XT = 1536;
let fn = null, El = null;
function Uh(s, e, t, r) {
    return {
        duration: e,
        size: t,
        cts: r,
        flags: {
            isLeading: 0,
            isDependedOn: 0,
            hasRedundancy: 0,
            degradPrio: 0,
            dependsOn: s ? 2 : 1,
            isNonSync: s ? 0 : 1
        }
    };
}
class mo extends Rr {
    constructor(e, t, r, n1){
        if (super("mp4-remuxer", n1), this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.ISGenerated = !1, this._initPTS = null, this._initDTS = null, this.nextVideoTs = null, this.nextAudioTs = null, this.videoSampleDuration = null, this.isAudioContiguous = !1, this.isVideoContiguous = !1, this.videoTrackConfig = void 0, this.observer = e, this.config = t, this.typeSupported = r, this.ISGenerated = !1, fn === null) {
            const o = (navigator.userAgent || "").match(/Chrome\/(\d+)/i);
            fn = o ? parseInt(o[1]) : 0;
        }
        if (El === null) {
            const i = navigator.userAgent.match(/Safari\/(\d+)/i);
            El = i ? parseInt(i[1]) : 0;
        }
    }
    destroy() {
        this.config = this.videoTrackConfig = this._initPTS = this._initDTS = null;
    }
    resetTimeStamp(e) {
        this.log("initPTS & initDTS reset"), this._initPTS = this._initDTS = e;
    }
    resetNextTimestamp() {
        this.log("reset next timestamp"), this.isVideoContiguous = !1, this.isAudioContiguous = !1;
    }
    resetInitSegment() {
        this.log("ISGenerated flag reset"), this.ISGenerated = !1, this.videoTrackConfig = void 0;
    }
    getVideoStartPts(e) {
        let t = !1;
        const r = e[0].pts, n1 = e.reduce((i, o)=>{
            let a = o.pts, l = a - i;
            return l < -4294967296 && (t = !0, a = Ar(a, r), l = a - i), l > 0 ? i : a;
        }, r);
        return t && this.debug("PTS rollover detected"), n1;
    }
    remux(e, t, r, n1, i, o, a, l) {
        let c, u, d1, h, f, p, y = i, E = i;
        const b = e.pid > -1, L = t.pid > -1, A = t.samples.length, F = e.samples.length > 0, M = a && A > 0 || A > 1;
        if ((!b || F) && (!L || M) || this.ISGenerated || a) {
            if (this.ISGenerated) {
                var K, j, C, k;
                const g = this.videoTrackConfig;
                (g && (t.width !== g.width || t.height !== g.height || ((K = t.pixelRatio) == null ? void 0 : K[0]) !== ((j = g.pixelRatio) == null ? void 0 : j[0]) || ((C = t.pixelRatio) == null ? void 0 : C[1]) !== ((k = g.pixelRatio) == null ? void 0 : k[1])) || !g && M || this.nextAudioTs === null && F) && this.resetInitSegment();
            }
            this.ISGenerated || (d1 = this.generateIS(e, t, i, o));
            const $ = this.isVideoContiguous;
            let W = -1, _;
            if (M && (W = JT(t.samples), !$ && this.config.forceKeyFrameOnDiscontinuity)) if (p = !0, W > 0) {
                this.warn(`Dropped ${W} out of ${A} video samples due to a missing keyframe`);
                const g = this.getVideoStartPts(t.samples);
                t.samples = t.samples.slice(W), t.dropped += W, E += (t.samples[0].pts - g) / t.inputTimeScale, _ = E;
            } else W === -1 && (this.warn(`No keyframe found out of ${A} video samples`), p = !1);
            if (this.ISGenerated) {
                if (F && M) {
                    const g = this.getVideoStartPts(t.samples), w = (Ar(e.samples[0].pts, g) - g) / t.inputTimeScale;
                    y += Math.max(0, w), E += Math.max(0, -w);
                }
                if (F) {
                    if (e.samplerate || (this.warn("regenerate InitSegment as audio detected"), d1 = this.generateIS(e, t, i, o)), u = this.remuxAudio(e, y, this.isAudioContiguous, o, L || M || l === pe.AUDIO ? E : void 0), M) {
                        const g = u ? u.endPTS - u.startPTS : 0;
                        t.inputTimeScale || (this.warn("regenerate InitSegment as video detected"), d1 = this.generateIS(e, t, i, o)), c = this.remuxVideo(t, E, $, g);
                    }
                } else M && (c = this.remuxVideo(t, E, $, 0));
                c && (c.firstKeyFrame = W, c.independent = W !== -1, c.firstKeyFramePTS = _);
            }
        }
        return this.ISGenerated && this._initPTS && this._initDTS && (r.samples.length && (f = bp(r, i, this._initPTS, this._initDTS)), n1.samples.length && (h = Tp(n1, i, this._initPTS))), {
            audio: u,
            video: c,
            initSegment: d1,
            independent: p,
            text: h,
            id3: f
        };
    }
    generateIS(e, t, r, n1) {
        const i = e.samples, o = t.samples, a = this.typeSupported, l = {}, c = this._initPTS;
        let u = !c || n1, d1 = "audio/mp4", h, f, p, y = -1;
        if (u && (h = f = 1 / 0), e.config && i.length) {
            switch(e.timescale = e.samplerate, e.segmentCodec){
                case "mp3":
                    a.mpeg ? (d1 = "audio/mpeg", e.codec = "") : a.mp3 && (e.codec = "mp3");
                    break;
                case "ac3":
                    e.codec = "ac-3";
                    break;
            }
            l.audio = {
                id: "audio",
                container: d1,
                codec: e.codec,
                initSegment: e.segmentCodec === "mp3" && a.mpeg ? new Uint8Array(0) : X.initSegment([
                    e
                ]),
                metadata: {
                    channelCount: e.channelCount
                }
            }, u && (y = e.id, p = e.inputTimeScale, !c || p !== c.timescale ? h = f = i[0].pts - Math.round(p * r) : u = !1);
        }
        if (t.sps && t.pps && o.length) {
            if (t.timescale = t.inputTimeScale, l.video = {
                id: "main",
                container: "video/mp4",
                codec: t.codec,
                initSegment: X.initSegment([
                    t
                ]),
                metadata: {
                    width: t.width,
                    height: t.height
                }
            }, u) if (y = t.id, p = t.inputTimeScale, !c || p !== c.timescale) {
                const E = this.getVideoStartPts(o), b = Math.round(p * r);
                f = Math.min(f, Ar(o[0].dts, E) - b), h = Math.min(h, E - b);
            } else u = !1;
            this.videoTrackConfig = {
                width: t.width,
                height: t.height,
                pixelRatio: t.pixelRatio
            };
        }
        if (Object.keys(l).length) return this.ISGenerated = !0, u ? (c && this.warn(`Timestamps at playlist time: ${n1 ? "" : "~"}${r} ${h / p} != initPTS: ${c.baseTime / c.timescale} (${c.baseTime}/${c.timescale}) trackId: ${c.trackId}`), this.log(`Found initPTS at playlist time: ${r} offset: ${h / p} (${h}/${p}) trackId: ${y}`), this._initPTS = {
            baseTime: h,
            timescale: p,
            trackId: y
        }, this._initDTS = {
            baseTime: f,
            timescale: p,
            trackId: y
        }) : h = p = void 0, {
            tracks: l,
            initPTS: h,
            timescale: p,
            trackId: y
        };
    }
    remuxVideo(e, t, r, n1) {
        const i = e.inputTimeScale, o = e.samples, a = [], l = o.length, c = this._initPTS, u = c.baseTime * i / c.timescale;
        let d1 = this.nextVideoTs, h = 8, f = this.videoSampleDuration, p, y, E = Number.POSITIVE_INFINITY, b = Number.NEGATIVE_INFINITY, L = !1;
        if (!r || d1 === null) {
            const R = u + t * i, m = o[0].pts - Ar(o[0].dts, o[0].pts);
            fn && d1 !== null && Math.abs(R - m - (d1 + u)) < 15e3 ? r = !0 : d1 = R - m - u;
        }
        const A = d1 + u;
        for(let R = 0; R < l; R++){
            const m = o[R];
            m.pts = Ar(m.pts, A), m.dts = Ar(m.dts, A), m.dts < o[R > 0 ? R - 1 : R].dts && (L = !0);
        }
        L && o.sort(function(R, m) {
            const v = R.dts - m.dts, P = R.pts - m.pts;
            return v || P;
        }), p = o[0].dts, y = o[o.length - 1].dts;
        const F = y - p, M = F ? Math.round(F / (l - 1)) : f || e.inputTimeScale / 30;
        if (r) {
            const R = p - A, m = R > M, v = R < -1;
            if ((m || v) && (m ? this.warn(`${(e.segmentCodec || "").toUpperCase()}: ${qn(R, !0)} ms (${R}dts) hole between fragments detected at ${t.toFixed(3)}`) : this.warn(`${(e.segmentCodec || "").toUpperCase()}: ${qn(-R, !0)} ms (${R}dts) overlapping between fragments detected at ${t.toFixed(3)}`), !v || A >= o[0].pts || fn)) {
                p = A;
                const P = o[0].pts - R;
                if (m) o[0].dts = p, o[0].pts = P;
                else {
                    let N = !0;
                    for(let Y = 0; Y < o.length && !(o[Y].dts > P && N); Y++){
                        const ee = o[Y].pts;
                        if (o[Y].dts -= R, o[Y].pts -= R, Y < o.length - 1) {
                            const ie = o[Y + 1].pts, le = o[Y].pts, Te = ie <= le, De = ie <= ee;
                            N = Te == De;
                        }
                    }
                }
                this.log(`Video: Initial PTS/DTS adjusted: ${qn(P, !0)}/${qn(p, !0)}, delta: ${qn(R, !0)} ms`);
            }
        }
        p = Math.max(0, p);
        let H = 0, K = 0, j = p;
        for(let R = 0; R < l; R++){
            const m = o[R], v = m.units, P = v.length;
            let N = 0;
            for(let Y = 0; Y < P; Y++)N += v[Y].data.length;
            K += N, H += P, m.length = N, m.dts < j ? (m.dts = j, j += M / 4 | 0 || 1) : j = m.dts, E = Math.min(m.pts, E), b = Math.max(m.pts, b);
        }
        y = o[l - 1].dts;
        const C = K + 4 * H + 8;
        let k;
        try {
            k = new Uint8Array(C);
        } catch (R) {
            this.observer.emit(I.ERROR, I.ERROR, {
                type: ve.MUX_ERROR,
                details: J.REMUX_ALLOC_ERROR,
                fatal: !1,
                error: R,
                bytes: C,
                reason: `fail allocating video mdat ${C}`
            });
            return;
        }
        const $ = new DataView(k.buffer);
        $.setUint32(0, C), k.set(X.types.mdat, 4);
        let W = !1, _ = Number.POSITIVE_INFINITY, g = Number.POSITIVE_INFINITY, x = Number.NEGATIVE_INFINITY, w = Number.NEGATIVE_INFINITY;
        for(let R = 0; R < l; R++){
            const m = o[R], v = m.units;
            let P = 0;
            for(let ee = 0, ie = v.length; ee < ie; ee++){
                const le = v[ee], Te = le.data, De = le.data.byteLength;
                $.setUint32(h, De), h += 4, k.set(Te, h), h += De, P += 4 + De;
            }
            let N;
            if (R < l - 1) f = o[R + 1].dts - m.dts, N = o[R + 1].pts - m.pts;
            else {
                const ee = this.config, ie = R > 0 ? m.dts - o[R - 1].dts : M;
                if (N = R > 0 ? m.pts - o[R - 1].pts : M, ee.stretchShortVideoTrack && this.nextAudioTs !== null) {
                    const le = Math.floor(ee.maxBufferHole * i), Te = (n1 ? E + n1 * i : this.nextAudioTs + u) - m.pts;
                    Te > le ? (f = Te - ie, f < 0 ? f = ie : W = !0, this.log(`It is approximately ${Te / 90} ms to the next segment; using duration ${f / 90} ms for the last video frame.`)) : f = ie;
                } else f = ie;
            }
            const Y = Math.round(m.pts - m.dts);
            _ = Math.min(_, f), x = Math.max(x, f), g = Math.min(g, N), w = Math.max(w, N), a.push(Uh(m.key, f, P, Y));
        }
        if (a.length) {
            if (fn) {
                if (fn < 70) {
                    const R = a[0].flags;
                    R.dependsOn = 2, R.isNonSync = 0;
                }
            } else if (El && w - g < x - _ && M / x < 0.025 && a[0].cts === 0) {
                this.warn("Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration.");
                let R = p;
                for(let m = 0, v = a.length; m < v; m++){
                    const P = R + a[m].duration, N = R + a[m].cts;
                    if (m < v - 1) {
                        const Y = P + a[m + 1].cts;
                        a[m].duration = Y - N;
                    } else a[m].duration = m ? a[m - 1].duration : M;
                    a[m].cts = 0, R = P;
                }
            }
        }
        f = W || !f ? M : f;
        const D = y + f;
        this.nextVideoTs = d1 = D - u, this.videoSampleDuration = f, this.isVideoContiguous = !0;
        const V = {
            data1: X.moof(e.sequenceNumber++, p, nt(e, {
                samples: a
            })),
            data2: k,
            startPTS: (E - u) / i,
            endPTS: (b + f - u) / i,
            startDTS: (p - u) / i,
            endDTS: d1 / i,
            type: "video",
            hasAudio: !1,
            hasVideo: !0,
            nb: a.length,
            dropped: e.dropped
        };
        return e.samples = [], e.dropped = 0, V;
    }
    getSamplesPerFrame(e) {
        switch(e.segmentCodec){
            case "mp3":
                return ZT;
            case "ac3":
                return XT;
            default:
                return YT;
        }
    }
    remuxAudio(e, t, r, n1, i) {
        const o = e.inputTimeScale, a = e.samplerate ? e.samplerate : o, l = o / a, c = this.getSamplesPerFrame(e), u = c * l, d1 = this._initPTS, h = e.segmentCodec === "mp3" && this.typeSupported.mpeg, f = [], p = i !== void 0;
        let y = e.samples, E = h ? 0 : 8, b = this.nextAudioTs || -1;
        const L = d1.baseTime * o / d1.timescale, A = L + t * o;
        if (this.isAudioContiguous = r = r || y.length && b > 0 && (n1 && Math.abs(A - (b + L)) < 9e3 || Math.abs(Ar(y[0].pts, A) - (b + L)) < 20 * u), y.forEach(function(w) {
            w.pts = Ar(w.pts, A);
        }), !r || b < 0) {
            if (y = y.filter((w)=>w.pts >= 0), !y.length) return;
            i === 0 ? b = 0 : n1 && !p ? b = Math.max(0, A - L) : b = y[0].pts - L;
        }
        if (e.segmentCodec === "aac") {
            const w = this.config.maxAudioFramesDrift;
            for(let D = 0, O = b + L; D < y.length; D++){
                const U = y[D], V = U.pts, R = V - O, m = Math.abs(1e3 * R / o);
                if (R <= -w * u && p) D === 0 && (this.warn(`Audio frame @ ${(V / o).toFixed(3)}s overlaps marker by ${Math.round(1e3 * R / o)} ms.`), this.nextAudioTs = b = V - L, O = V);
                else if (R >= w * u && m < zT && p) {
                    let v = Math.round(R / u);
                    for(O = V - v * u; O < 0 && v && u;)v--, O += u;
                    D === 0 && (this.nextAudioTs = b = O - L), this.warn(`Injecting ${v} audio frames @ ${((O - L) / o).toFixed(3)}s due to ${Math.round(1e3 * R / o)} ms gap.`);
                    for(let P = 0; P < v; P++){
                        let N = HT.getSilentFrame(e.parsedCodec || e.manifestCodec || e.codec, e.channelCount);
                        N || (this.log("Unable to get silent frame for given audio codec; duplicating last frame instead."), N = U.unit.subarray()), y.splice(D, 0, {
                            unit: N,
                            pts: O
                        }), O += u, D++;
                    }
                }
                U.pts = O, O += u;
            }
        }
        let F = null, M = null, H, K = 0, j = y.length;
        for(; j--;)K += y[j].unit.byteLength;
        for(let w = 0, D = y.length; w < D; w++){
            const O = y[w], U = O.unit;
            let V = O.pts;
            if (M !== null) {
                const m = f[w - 1];
                m.duration = Math.round((V - M) / l);
            } else if (r && e.segmentCodec === "aac" && (V = b + L), F = V, K > 0) {
                K += E;
                try {
                    H = new Uint8Array(K);
                } catch (m) {
                    this.observer.emit(I.ERROR, I.ERROR, {
                        type: ve.MUX_ERROR,
                        details: J.REMUX_ALLOC_ERROR,
                        fatal: !1,
                        error: m,
                        bytes: K,
                        reason: `fail allocating audio mdat ${K}`
                    });
                    return;
                }
                h || (new DataView(H.buffer).setUint32(0, K), H.set(X.types.mdat, 4));
            } else return;
            H.set(U, E);
            const R = U.byteLength;
            E += R, f.push(Uh(!0, c, R, 0)), M = V;
        }
        const C = f.length;
        if (!C) return;
        const k = f[f.length - 1];
        b = M - L, this.nextAudioTs = b + l * k.duration;
        const $ = h ? new Uint8Array(0) : X.moof(e.sequenceNumber++, F / l, nt({}, e, {
            samples: f
        }));
        e.samples = [];
        const W = (F - L) / o, _ = b / o, x = {
            data1: $,
            data2: H,
            startPTS: W,
            endPTS: _,
            startDTS: W,
            endDTS: _,
            type: "audio",
            hasAudio: !0,
            hasVideo: !1,
            nb: C
        };
        return this.isAudioContiguous = !0, x;
    }
}
function Ar(s, e) {
    let t;
    if (e === null) return s;
    for(e < s ? t = -8589934592 : t = 8589934592; Math.abs(s - e) > 4294967296;)s += t;
    return s;
}
function JT(s) {
    for(let e = 0; e < s.length; e++)if (s[e].key) return e;
    return -1;
}
function bp(s, e, t, r) {
    const n1 = s.samples.length;
    if (!n1) return;
    const i = s.inputTimeScale;
    for(let a = 0; a < n1; a++){
        const l = s.samples[a];
        l.pts = Ar(l.pts - t.baseTime * i / t.timescale, e * i) / i, l.dts = Ar(l.dts - r.baseTime * i / r.timescale, e * i) / i;
    }
    const o = s.samples;
    return s.samples = [], {
        samples: o
    };
}
function Tp(s, e, t) {
    const r = s.samples.length;
    if (!r) return;
    const n1 = s.inputTimeScale;
    for(let o = 0; o < r; o++){
        const a = s.samples[o];
        a.pts = Ar(a.pts - t.baseTime * n1 / t.timescale, e * n1) / n1;
    }
    s.samples.sort((o, a)=>o.pts - a.pts);
    const i = s.samples;
    return s.samples = [], {
        samples: i
    };
}
class QT extends Rr {
    constructor(e, t, r, n1){
        super("passthrough-remuxer", n1), this.emitInitSegment = !1, this.audioCodec = void 0, this.videoCodec = void 0, this.initData = void 0, this.initPTS = null, this.initTracks = void 0, this.lastEndTime = null, this.isVideoContiguous = !1;
    }
    destroy() {}
    resetTimeStamp(e) {
        this.lastEndTime = null;
        const t = this.initPTS;
        t && e && t.baseTime === e.baseTime && t.timescale === e.timescale || (this.initPTS = e);
    }
    resetNextTimestamp() {
        this.isVideoContiguous = !1, this.lastEndTime = null;
    }
    resetInitSegment(e, t, r, n1) {
        this.audioCodec = t, this.videoCodec = r, this.generateInitSegment(e, n1), this.emitInitSegment = !0;
    }
    generateInitSegment(e, t) {
        let { audioCodec: r, videoCodec: n1 } = this;
        if (!(e != null && e.byteLength)) {
            this.initTracks = void 0, this.initData = void 0;
            return;
        }
        const { audio: i, video: o } = this.initData = Dg(e);
        if (t) $S(e, t);
        else {
            const l = i || o;
            l != null && l.encrypted && this.warn(`Init segment with encrypted track with has no key ("${l.codec}")!`);
        }
        i && (r = $h(i, ot.AUDIO, this)), o && (n1 = $h(o, ot.VIDEO, this));
        const a = {};
        i && o ? a.audiovideo = {
            container: "video/mp4",
            codec: r + "," + n1,
            supplemental: o.supplemental,
            encrypted: o.encrypted,
            initSegment: e,
            id: "main"
        } : i ? a.audio = {
            container: "audio/mp4",
            codec: r,
            encrypted: i.encrypted,
            initSegment: e,
            id: "audio"
        } : o ? a.video = {
            container: "video/mp4",
            codec: n1,
            supplemental: o.supplemental,
            encrypted: o.encrypted,
            initSegment: e,
            id: "main"
        } : this.warn("initSegment does not contain moov or trak boxes."), this.initTracks = a;
    }
    remux(e, t, r, n1, i, o) {
        var a, l;
        let { initPTS: c, lastEndTime: u } = this;
        const d1 = {
            audio: void 0,
            video: void 0,
            text: n1,
            id3: r,
            initSegment: void 0
        };
        ue(u) || (u = this.lastEndTime = i || 0);
        const h = t.samples;
        if (!h.length) return d1;
        const f = {
            initPTS: void 0,
            timescale: void 0,
            trackId: void 0
        };
        let p = this.initData;
        if ((a = p) != null && a.length || (this.generateInitSegment(h), p = this.initData), !((l = p) != null && l.length)) return this.warn("Failed to generate initSegment."), d1;
        this.emitInitSegment && (f.tracks = this.initTracks, this.emitInitSegment = !1);
        const y = GS(h, p, this), E = p.audio ? y[p.audio.id] : null, b = p.video ? y[p.video.id] : null, L = Zi(b, 1 / 0), A = Zi(E, 1 / 0), F = Zi(b, 0, !0), M = Zi(E, 0, !0);
        let H = i, K = 0;
        const j = E && (!b || !c && A < L || c && c.trackId === p.audio.id), C = j ? E : b;
        if (C) {
            const O = C.timescale, U = C.start - i * O, V = j ? p.audio.id : p.video.id;
            H = C.start / O, K = j ? M - A : F - L, (o || !c) && (e2(c, H, i, K) || O !== c.timescale) && (c && this.warn(`Timestamps at playlist time: ${o ? "" : "~"}${i} ${U / O} != initPTS: ${c.baseTime / c.timescale} (${c.baseTime}/${c.timescale}) trackId: ${c.trackId}`), this.log(`Found initPTS at playlist time: ${i} offset: ${H - i} (${U}/${O}) trackId: ${V}`), c = null, f.initPTS = U, f.timescale = O, f.trackId = V);
        } else this.warn(`No audio or video samples found for initPTS at playlist time: ${i}`);
        c ? (f.initPTS = c.baseTime, f.timescale = c.timescale, f.trackId = c.trackId) : ((!f.timescale || f.trackId === void 0 || f.initPTS === void 0) && (this.warn("Could not set initPTS"), f.initPTS = H, f.timescale = 1, f.trackId = -1), this.initPTS = c = {
            baseTime: f.initPTS,
            timescale: f.timescale,
            trackId: f.trackId
        });
        const k = H - c.baseTime / c.timescale, $ = k + K;
        K > 0 ? this.lastEndTime = $ : (this.warn("Duration parsed from mp4 should be greater than zero"), this.resetNextTimestamp());
        const W = !!p.audio, _ = !!p.video;
        let g = "";
        W && (g += "audio"), _ && (g += "video");
        const x = (p.audio ? p.audio.encrypted : !1) || (p.video ? p.video.encrypted : !1), w = {
            data1: h,
            startPTS: k,
            startDTS: k,
            endPTS: $,
            endDTS: $,
            type: g,
            hasAudio: W,
            hasVideo: _,
            nb: 1,
            dropped: 0,
            encrypted: x
        };
        d1.audio = W && !_ ? w : void 0, d1.video = _ ? w : void 0;
        const D = b == null ? void 0 : b.sampleCount;
        if (D) {
            const O = b.keyFrameIndex, U = O !== -1;
            w.nb = D, w.dropped = O === 0 || this.isVideoContiguous ? 0 : U ? O : D, w.independent = U, w.firstKeyFrame = O, U && b.keyFrameStart && (w.firstKeyFramePTS = (b.keyFrameStart - c.baseTime) / c.timescale), this.isVideoContiguous || (d1.independent = U), this.isVideoContiguous || (this.isVideoContiguous = U), w.dropped && this.warn(`fmp4 does not start with IDR: firstIDR ${O}/${D} dropped: ${w.dropped} start: ${w.firstKeyFramePTS || "NA"}`);
        }
        return d1.initSegment = f, d1.id3 = bp(r, i, c, c), n1.samples.length && (d1.text = Tp(n1, i, c)), d1;
    }
}
function Zi(s, e, t = !1) {
    return (s == null ? void 0 : s.start) !== void 0 ? (s.start + (t ? s.duration : 0)) / s.timescale : e;
}
function e2(s, e, t, r) {
    if (s === null) return !0;
    const n1 = Math.max(r, 1), i = e - s.baseTime / s.timescale;
    return Math.abs(i - t) > n1;
}
function $h(s, e, t) {
    const r = s.codec;
    return r && r.length > 4 ? r : e === ot.AUDIO ? r === "ec-3" || r === "ac-3" || r === "alac" ? r : r === "fLaC" || r === "Opus" ? Xo(r, !1) : (t.warn(`Unhandled audio codec "${r}" in mp4 MAP`), r || "mp4a") : (t.warn(`Unhandled video codec "${r}" in mp4 MAP`), r || "avc1");
}
let ls;
try {
    ls = self.performance.now.bind(self.performance);
} catch  {
    ls = Date.now;
}
const yo = [
    {
        demux: UT,
        remux: QT
    },
    {
        demux: Is,
        remux: mo
    },
    {
        demux: OT,
        remux: mo
    },
    {
        demux: FT,
        remux: mo
    }
];
yo.splice(2, 0, {
    demux: BT,
    remux: mo
});
class Gh {
    constructor(e, t, r, n1, i, o){
        this.asyncResult = !1, this.logger = void 0, this.observer = void 0, this.typeSupported = void 0, this.config = void 0, this.id = void 0, this.demuxer = void 0, this.remuxer = void 0, this.decrypter = void 0, this.probe = void 0, this.decryptionPromise = null, this.transmuxConfig = void 0, this.currentTransmuxState = void 0, this.observer = e, this.typeSupported = t, this.config = r, this.id = i, this.logger = o;
    }
    configure(e) {
        this.transmuxConfig = e, this.decrypter && this.decrypter.reset();
    }
    push(e, t, r, n1) {
        const i = r.transmuxing;
        i.executeStart = ls();
        let o = new Uint8Array(e);
        const { currentTransmuxState: a, transmuxConfig: l } = this;
        n1 && (this.currentTransmuxState = n1);
        const { contiguous: c, discontinuity: u, trackSwitch: d1, accurateTimeOffset: h, timeOffset: f, initSegmentChange: p } = n1 || a, { audioCodec: y, videoCodec: E, defaultInitPts: b, duration: L, initSegmentData: A } = l, F = t2(o, t);
        if (F && wn(F.method)) {
            const j = this.getDecrypter(), C = Su(F.method);
            if (j.isSync()) {
                let k = j.softwareDecrypt(o, F.key.buffer, F.iv.buffer, C);
                if (r.part > -1) {
                    const W = j.flush();
                    k = W && W.buffer;
                }
                if (!k) return i.executeEnd = ls(), xl(r);
                o = new Uint8Array(k);
            } else return this.asyncResult = !0, this.decryptionPromise = j.webCryptoDecrypt(o, F.key.buffer, F.iv.buffer, C).then((k)=>{
                const $ = this.push(k, null, r);
                return this.decryptionPromise = null, $;
            }), this.decryptionPromise;
        }
        const M = this.needsProbing(u, d1);
        if (M) {
            const j = this.configureTransmuxer(o);
            if (j) return this.logger.warn(`[transmuxer] ${j.message}`), this.observer.emit(I.ERROR, I.ERROR, {
                type: ve.MEDIA_ERROR,
                details: J.FRAG_PARSING_ERROR,
                fatal: !1,
                error: j,
                reason: j.message
            }), i.executeEnd = ls(), xl(r);
        }
        (u || d1 || p || M) && this.resetInitSegment(A, y, E, L, t), (u || p || M) && this.resetInitialTimestamp(b), c || this.resetContiguity();
        const H = this.transmux(o, F, f, h, r);
        this.asyncResult = xi(H);
        const K = this.currentTransmuxState;
        return K.contiguous = !0, K.discontinuity = !1, K.trackSwitch = !1, i.executeEnd = ls(), H;
    }
    // Due to data caching, flush calls can produce more than one TransmuxerResult (hence the Array type)
    flush(e) {
        const t = e.transmuxing;
        t.executeStart = ls();
        const { decrypter: r, currentTransmuxState: n1, decryptionPromise: i } = this;
        if (i) return this.asyncResult = !0, i.then(()=>this.flush(e));
        const o = [], { timeOffset: a } = n1;
        if (r) {
            const d1 = r.flush();
            d1 && o.push(this.push(d1.buffer, null, e));
        }
        const { demuxer: l, remuxer: c } = this;
        if (!l || !c) {
            t.executeEnd = ls();
            const d1 = [
                xl(e)
            ];
            return this.asyncResult ? Promise.resolve(d1) : d1;
        }
        const u = l.flush(a);
        return xi(u) ? (this.asyncResult = !0, u.then((d1)=>(this.flushRemux(o, d1, e), o))) : (this.flushRemux(o, u, e), this.asyncResult ? Promise.resolve(o) : o);
    }
    flushRemux(e, t, r) {
        const { audioTrack: n1, videoTrack: i, id3Track: o, textTrack: a } = t, { accurateTimeOffset: l, timeOffset: c } = this.currentTransmuxState;
        this.logger.log(`[transmuxer.ts]: Flushed ${this.id} sn: ${r.sn}${r.part > -1 ? " part: " + r.part : ""} of ${this.id === pe.MAIN ? "level" : "track"} ${r.level}`);
        const u = this.remuxer.remux(n1, i, o, a, c, l, !0, this.id);
        e.push({
            remuxResult: u,
            chunkMeta: r
        }), r.transmuxing.executeEnd = ls();
    }
    resetInitialTimestamp(e) {
        const { demuxer: t, remuxer: r } = this;
        !t || !r || (t.resetTimeStamp(e), r.resetTimeStamp(e));
    }
    resetContiguity() {
        const { demuxer: e, remuxer: t } = this;
        !e || !t || (e.resetContiguity(), t.resetNextTimestamp());
    }
    resetInitSegment(e, t, r, n1, i) {
        const { demuxer: o, remuxer: a } = this;
        !o || !a || (o.resetInitSegment(e, t, r, n1), a.resetInitSegment(e, t, r, i));
    }
    destroy() {
        this.demuxer && (this.demuxer.destroy(), this.demuxer = void 0), this.remuxer && (this.remuxer.destroy(), this.remuxer = void 0);
    }
    transmux(e, t, r, n1, i) {
        let o;
        return t && t.method === "SAMPLE-AES" ? o = this.transmuxSampleAes(e, t, r, n1, i) : o = this.transmuxUnencrypted(e, r, n1, i), o;
    }
    transmuxUnencrypted(e, t, r, n1) {
        const { audioTrack: i, videoTrack: o, id3Track: a, textTrack: l } = this.demuxer.demux(e, t, !1, !this.config.progressive);
        return {
            remuxResult: this.remuxer.remux(i, o, a, l, t, r, !1, this.id),
            chunkMeta: n1
        };
    }
    transmuxSampleAes(e, t, r, n1, i) {
        return this.demuxer.demuxSampleAes(e, t, r).then((o)=>({
                remuxResult: this.remuxer.remux(o.audioTrack, o.videoTrack, o.id3Track, o.textTrack, r, n1, !1, this.id),
                chunkMeta: i
            }));
    }
    configureTransmuxer(e) {
        const { config: t, observer: r, typeSupported: n1 } = this;
        let i;
        for(let d1 = 0, h = yo.length; d1 < h; d1++){
            var o;
            if ((o = yo[d1].demux) != null && o.probe(e, this.logger)) {
                i = yo[d1];
                break;
            }
        }
        if (!i) return new Error("Failed to find demuxer by probing fragment data");
        const a = this.demuxer, l = this.remuxer, c = i.remux, u = i.demux;
        (!l || !(l instanceof c)) && (this.remuxer = new c(r, t, n1, this.logger)), (!a || !(a instanceof u)) && (this.demuxer = new u(r, t, n1, this.logger), this.probe = u.probe);
    }
    needsProbing(e, t) {
        return !this.demuxer || !this.remuxer || e || t;
    }
    getDecrypter() {
        let e = this.decrypter;
        return e || (e = this.decrypter = new vu(this.config)), e;
    }
}
function t2(s, e) {
    let t = null;
    return s.byteLength > 0 && (e == null ? void 0 : e.key) != null && e.iv !== null && e.method != null && (t = e), t;
}
const xl = (s)=>({
        remuxResult: {},
        chunkMeta: s
    });
function xi(s) {
    return "then" in s && s.then instanceof Function;
}
class r2 {
    constructor(e, t, r, n1, i){
        this.audioCodec = void 0, this.videoCodec = void 0, this.initSegmentData = void 0, this.duration = void 0, this.defaultInitPts = void 0, this.audioCodec = e, this.videoCodec = t, this.initSegmentData = r, this.duration = n1, this.defaultInitPts = i || null;
    }
}
class s2 {
    constructor(e, t, r, n1, i, o){
        this.discontinuity = void 0, this.contiguous = void 0, this.accurateTimeOffset = void 0, this.trackSwitch = void 0, this.timeOffset = void 0, this.initSegmentChange = void 0, this.discontinuity = e, this.contiguous = t, this.accurateTimeOffset = r, this.trackSwitch = n1, this.timeOffset = i, this.initSegmentChange = o;
    }
}
let Vh = 0;
class wp {
    constructor(e, t, r, n1){
        this.error = null, this.hls = void 0, this.id = void 0, this.instanceNo = Vh++, this.observer = void 0, this.frag = null, this.part = null, this.useWorker = void 0, this.workerContext = null, this.transmuxer = null, this.onTransmuxComplete = void 0, this.onFlush = void 0, this.onWorkerMessage = (l)=>{
            const c = l.data, u = this.hls;
            if (!(!u || !(c != null && c.event) || c.instanceNo !== this.instanceNo)) switch(c.event){
                case "init":
                    {
                        var d1;
                        const h = (d1 = this.workerContext) == null ? void 0 : d1.objectURL;
                        h && self.URL.revokeObjectURL(h);
                        break;
                    }
                case "transmuxComplete":
                    {
                        this.handleTransmuxComplete(c.data);
                        break;
                    }
                case "flush":
                    {
                        this.onFlush(c.data);
                        break;
                    }
                // pass logs from the worker thread to the main logger
                case "workerLog":
                    {
                        u.logger[c.data.logType] && u.logger[c.data.logType](c.data.message);
                        break;
                    }
                default:
                    {
                        c.data = c.data || {}, c.data.frag = this.frag, c.data.part = this.part, c.data.id = this.id, u.trigger(c.event, c.data);
                        break;
                    }
            }
        }, this.onWorkerError = (l)=>{
            if (!this.hls) return;
            const c = new Error(`${l.message}  (${l.filename}:${l.lineno})`);
            this.hls.config.enableWorker = !1, this.hls.logger.warn(`Error in "${this.id}" Web Worker, fallback to inline`), this.hls.trigger(I.ERROR, {
                type: ve.OTHER_ERROR,
                details: J.INTERNAL_EXCEPTION,
                fatal: !1,
                event: "demuxerWorker",
                error: c
            });
        };
        const i = e.config;
        this.hls = e, this.id = t, this.useWorker = !!i.enableWorker, this.onTransmuxComplete = r, this.onFlush = n1;
        const o = (l, c)=>{
            c = c || {}, c.frag = this.frag || void 0, l === I.ERROR && (c = c, c.parent = this.id, c.part = this.part, this.error = c.error), this.hls.trigger(l, c);
        };
        this.observer = new wu(), this.observer.on(I.FRAG_DECRYPTED, o), this.observer.on(I.ERROR, o);
        const a = ih(i.preferManagedMediaSource);
        if (this.useWorker && typeof Worker < "u") {
            const l = this.hls.logger;
            if (i.workerPath || aT()) {
                try {
                    i.workerPath ? (l.log(`loading Web Worker ${i.workerPath} for "${t}"`), this.workerContext = cT(i.workerPath)) : (l.log(`injecting Web Worker for "${t}"`), this.workerContext = lT());
                    const { worker: u } = this.workerContext;
                    u.addEventListener("message", this.onWorkerMessage), u.addEventListener("error", this.onWorkerError), u.postMessage({
                        instanceNo: this.instanceNo,
                        cmd: "init",
                        typeSupported: a,
                        id: t,
                        config: at(i)
                    });
                } catch (u) {
                    l.warn(`Error setting up "${t}" Web Worker, fallback to inline`, u), this.terminateWorker(), this.error = null, this.transmuxer = new Gh(this.observer, a, i, "", t, e.logger);
                }
                return;
            }
        }
        this.transmuxer = new Gh(this.observer, a, i, "", t, e.logger);
    }
    reset() {
        if (this.frag = null, this.part = null, this.workerContext) {
            const e = this.instanceNo;
            this.instanceNo = Vh++;
            const t = this.hls.config, r = ih(t.preferManagedMediaSource);
            this.workerContext.worker.postMessage({
                instanceNo: this.instanceNo,
                cmd: "reset",
                resetNo: e,
                typeSupported: r,
                id: this.id,
                config: at(t)
            });
        }
    }
    terminateWorker() {
        if (this.workerContext) {
            const { worker: e } = this.workerContext;
            this.workerContext = null, e.removeEventListener("message", this.onWorkerMessage), e.removeEventListener("error", this.onWorkerError), uT(this.hls.config.workerPath);
        }
    }
    destroy() {
        if (this.workerContext) this.terminateWorker(), this.onWorkerMessage = this.onWorkerError = null;
        else {
            const t = this.transmuxer;
            t && (t.destroy(), this.transmuxer = null);
        }
        const e = this.observer;
        e && e.removeAllListeners(), this.frag = null, this.part = null, this.observer = null, this.hls = null;
    }
    push(e, t, r, n1, i, o, a, l, c, u) {
        var d1, h;
        c.transmuxing.start = self.performance.now();
        const { instanceNo: f, transmuxer: p } = this, y = o ? o.start : i.start, E = i.decryptdata, b = this.frag, L = !(b && i.cc === b.cc), A = !(b && c.level === b.level), F = b ? c.sn - b.sn : -1, M = this.part ? c.part - this.part.index : -1, H = F === 0 && c.id > 1 && c.id === (b == null ? void 0 : b.stats.chunkCount), K = !A && (F === 1 || F === 0 && (M === 1 || H && M <= 0)), j = self.performance.now();
        (A || F || i.stats.parsing.start === 0) && (i.stats.parsing.start = j), o && (M || !K) && (o.stats.parsing.start = j);
        const C = !(b && ((d1 = i.initSegment) == null ? void 0 : d1.url) === ((h = b.initSegment) == null ? void 0 : h.url)), k = new s2(L, K, l, A, y, C);
        if (!K || L || C) {
            this.hls.logger.log(`[transmuxer-interface]: Starting new transmux session for ${i.type} sn: ${c.sn}${c.part > -1 ? " part: " + c.part : ""} ${this.id === pe.MAIN ? "level" : "track"}: ${c.level} id: ${c.id}
        discontinuity: ${L}
        trackSwitch: ${A}
        contiguous: ${K}
        accurateTimeOffset: ${l}
        timeOffset: ${y}
        initSegmentChange: ${C}`);
            const $ = new r2(r, n1, t, a, u);
            this.configureTransmuxer($);
        }
        if (this.frag = i, this.part = o, this.workerContext) this.workerContext.worker.postMessage({
            instanceNo: f,
            cmd: "demux",
            data: e,
            decryptdata: E,
            chunkMeta: c,
            state: k
        }, e instanceof ArrayBuffer ? [
            e
        ] : []);
        else if (p) {
            const $ = p.push(e, E, c, k);
            xi($) ? $.then((W)=>{
                this.handleTransmuxComplete(W);
            }).catch((W)=>{
                this.transmuxerError(W, c, "transmuxer-interface push error");
            }) : this.handleTransmuxComplete($);
        }
    }
    flush(e) {
        e.transmuxing.start = self.performance.now();
        const { instanceNo: t, transmuxer: r } = this;
        if (this.workerContext) this.workerContext.worker.postMessage({
            instanceNo: t,
            cmd: "flush",
            chunkMeta: e
        });
        else if (r) {
            const n1 = r.flush(e);
            xi(n1) ? n1.then((i)=>{
                this.handleFlushResult(i, e);
            }).catch((i)=>{
                this.transmuxerError(i, e, "transmuxer-interface flush error");
            }) : this.handleFlushResult(n1, e);
        }
    }
    transmuxerError(e, t, r) {
        this.hls && (this.error = e, this.hls.trigger(I.ERROR, {
            type: ve.MEDIA_ERROR,
            details: J.FRAG_PARSING_ERROR,
            chunkMeta: t,
            frag: this.frag || void 0,
            part: this.part || void 0,
            fatal: !1,
            error: e,
            err: e,
            reason: r
        }));
    }
    handleFlushResult(e, t) {
        e.forEach((r)=>{
            this.handleTransmuxComplete(r);
        }), this.onFlush(t);
    }
    configureTransmuxer(e) {
        const { instanceNo: t, transmuxer: r } = this;
        this.workerContext ? this.workerContext.worker.postMessage({
            instanceNo: t,
            cmd: "configure",
            config: e
        }) : r && r.configure(e);
    }
    handleTransmuxComplete(e) {
        e.chunkMeta.transmuxing.end = self.performance.now(), this.onTransmuxComplete(e);
    }
}
const jh = 100;
class n2 extends Tu {
    constructor(e, t, r){
        super(e, t, r, "audio-stream-controller", pe.AUDIO), this.mainAnchor = null, this.mainFragLoading = null, this.audioOnly = !1, this.bufferedTrack = null, this.switchingTrack = null, this.trackId = -1, this.waitingData = null, this.mainDetails = null, this.flushing = !1, this.bufferFlushed = !1, this.cachedTrackLoadedData = null, this.registerListeners();
    }
    onHandlerDestroying() {
        this.unregisterListeners(), super.onHandlerDestroying(), this.resetItem();
    }
    resetItem() {
        this.mainDetails = this.mainAnchor = this.mainFragLoading = this.bufferedTrack = this.switchingTrack = this.waitingData = this.cachedTrackLoadedData = null;
    }
    registerListeners() {
        super.registerListeners();
        const { hls: e } = this;
        e.on(I.LEVEL_LOADED, this.onLevelLoaded, this), e.on(I.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this), e.on(I.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.on(I.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.on(I.BUFFER_RESET, this.onBufferReset, this), e.on(I.BUFFER_CREATED, this.onBufferCreated, this), e.on(I.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(I.BUFFER_FLUSHED, this.onBufferFlushed, this), e.on(I.INIT_PTS_FOUND, this.onInitPtsFound, this), e.on(I.FRAG_LOADING, this.onFragLoading, this), e.on(I.FRAG_BUFFERED, this.onFragBuffered, this);
    }
    unregisterListeners() {
        const { hls: e } = this;
        e && (super.unregisterListeners(), e.off(I.LEVEL_LOADED, this.onLevelLoaded, this), e.off(I.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this), e.off(I.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.off(I.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.off(I.BUFFER_RESET, this.onBufferReset, this), e.off(I.BUFFER_CREATED, this.onBufferCreated, this), e.off(I.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(I.BUFFER_FLUSHED, this.onBufferFlushed, this), e.off(I.INIT_PTS_FOUND, this.onInitPtsFound, this), e.off(I.FRAG_LOADING, this.onFragLoading, this), e.off(I.FRAG_BUFFERED, this.onFragBuffered, this));
    }
    // INIT_PTS_FOUND is triggered when the video track parsed in the stream-controller has a new PTS value
    onInitPtsFound(e, { frag: t, id: r, initPTS: n1, timescale: i, trackId: o }) {
        if (r === pe.MAIN) {
            const a = t.cc, l = this.fragCurrent;
            if (this.initPTS[a] = {
                baseTime: n1,
                timescale: i,
                trackId: o
            }, this.log(`InitPTS for cc: ${a} found from main: ${n1 / i} (${n1}/${i}) trackId: ${o}`), this.mainAnchor = t, this.state === ne.WAITING_INIT_PTS) {
                const c = this.waitingData;
                (!c && !this.loadingParts || c && c.frag.cc !== a) && this.syncWithAnchor(t, c == null ? void 0 : c.frag);
            } else !this.hls.hasEnoughToStart && l && l.cc !== a ? (l.abortRequests(), this.syncWithAnchor(t, l)) : this.state === ne.IDLE && this.tick();
        }
    }
    getLoadPosition() {
        return !this.startFragRequested && this.nextLoadPosition >= 0 ? this.nextLoadPosition : super.getLoadPosition();
    }
    syncWithAnchor(e, t) {
        var r;
        const n1 = ((r = this.mainFragLoading) == null ? void 0 : r.frag) || null;
        if (t && (n1 == null ? void 0 : n1.cc) === t.cc) return;
        const i = (n1 || e).cc, o = this.getLevelDetails(), a = this.getLoadPosition(), l = Vg(o, i, a);
        l && (this.log(`Syncing with main frag at ${l.start} cc ${l.cc}`), this.startFragRequested = !1, this.nextLoadPosition = l.start, this.resetLoadingState(), this.state === ne.IDLE && this.doTickIdle());
    }
    startLoad(e, t) {
        if (!this.levels) {
            this.startPosition = e, this.state = ne.STOPPED;
            return;
        }
        const r = this.lastCurrentTime;
        this.stopLoad(), this.setInterval(jh), r > 0 && e === -1 ? (this.log(`Override startPosition with lastCurrentTime @${r.toFixed(3)}`), e = r, this.state = ne.IDLE) : this.state = ne.WAITING_TRACK, this.nextLoadPosition = this.lastCurrentTime = e + this.timelineOffset, this.startPosition = t ? -1 : e, this.tick();
    }
    doTick() {
        switch(this.state){
            case ne.IDLE:
                this.doTickIdle();
                break;
            case ne.WAITING_TRACK:
                {
                    const { levels: e, trackId: t } = this, r = e == null ? void 0 : e[t], n1 = r == null ? void 0 : r.details;
                    if (n1 && !this.waitForLive(r)) {
                        if (this.waitForCdnTuneIn(n1)) break;
                        this.state = ne.WAITING_INIT_PTS;
                    }
                    break;
                }
            case ne.FRAG_LOADING_WAITING_RETRY:
                {
                    this.checkRetryDate();
                    break;
                }
            case ne.WAITING_INIT_PTS:
                {
                    const e = this.waitingData;
                    if (e) {
                        const { frag: t, part: r, cache: n1, complete: i } = e, o = this.mainAnchor;
                        if (this.initPTS[t.cc] !== void 0) {
                            this.waitingData = null, this.state = ne.FRAG_LOADING;
                            const a = n1.flush().buffer, l = {
                                frag: t,
                                part: r,
                                payload: a,
                                networkDetails: null
                            };
                            this._handleFragmentLoadProgress(l), i && super._handleFragmentLoadComplete(l);
                        } else o && o.cc !== e.frag.cc && this.syncWithAnchor(o, e.frag);
                    } else this.state = ne.IDLE;
                }
        }
        this.onTickEnd();
    }
    resetLoadingState() {
        const e = this.waitingData;
        e && (this.fragmentTracker.removeFragment(e.frag), this.waitingData = null), super.resetLoadingState();
    }
    onTickEnd() {
        const { media: e } = this;
        e != null && e.readyState && (this.lastCurrentTime = e.currentTime);
    }
    doTickIdle() {
        var e;
        const { hls: t, levels: r, media: n1, trackId: i } = this, o = t.config;
        if (!this.buffering || !n1 && !this.primaryPrefetch && (this.startFragRequested || !o.startFragPrefetch) || !(r != null && r[i])) return;
        const a = r[i], l = a.details;
        if (!l || this.waitForLive(a) || this.waitForCdnTuneIn(l)) {
            this.state = ne.WAITING_TRACK, this.startFragRequested = !1;
            return;
        }
        const c = this.mediaBuffer ? this.mediaBuffer : this.media;
        this.bufferFlushed && c && (this.bufferFlushed = !1, this.afterBufferFlushed(c, ot.AUDIO, pe.AUDIO));
        const u = this.getFwdBufferInfo(c, pe.AUDIO);
        if (u === null) return;
        if (!this.switchingTrack && this._streamEnded(u, l)) {
            t.trigger(I.BUFFER_EOS, {
                type: "audio"
            }), this.state = ne.ENDED;
            return;
        }
        const d1 = u.len, h = t.maxBufferLength, f = l.fragments, p = f[0].start, y = this.getLoadPosition(), E = this.flushing ? y : u.end;
        if (this.switchingTrack && n1) {
            const A = y;
            l.PTSKnown && A < p && (u.end > p || u.nextStart) && (this.log("Alt audio track ahead of main track, seek to start of alt audio track"), n1.currentTime = p + 0.05);
        }
        if (d1 >= h && !this.switchingTrack && E < f[f.length - 1].start) return;
        let b = this.getNextFragment(E, l);
        if (b && this.isLoopLoading(b, E) && (b = this.getNextFragmentLoopLoading(b, l, u, pe.MAIN, h)), !b) {
            this.bufferFlushed = !0;
            return;
        }
        let L = ((e = this.mainFragLoading) == null ? void 0 : e.frag) || null;
        if (!this.audioOnly && this.startFragRequested && L && Vt(b) && !b.endList && (!l.live || !this.loadingParts && E < this.hls.liveSyncPosition) && (this.fragmentTracker.getState(L) === Ht.OK && (this.mainFragLoading = L = null), L && Vt(L))) {
            if (b.start > L.end) {
                const F = this.fragmentTracker.getFragAtPos(E, pe.MAIN);
                F && F.end > L.end && (L = F, this.mainFragLoading = {
                    frag: F,
                    targetBufferTime: null
                });
            }
            if (b.start > L.end) return;
        }
        this.loadFragment(b, a, E);
    }
    onMediaDetaching(e, t) {
        this.bufferFlushed = this.flushing = !1, super.onMediaDetaching(e, t);
    }
    onAudioTracksUpdated(e, { audioTracks: t }) {
        this.resetTransmuxer(), this.levels = t.map((r)=>new mi(r));
    }
    onAudioTrackSwitching(e, t) {
        const r = !!t.url;
        this.trackId = t.id;
        const { fragCurrent: n1 } = this;
        n1 && (n1.abortRequests(), this.removeUnbufferedFrags(n1.start)), this.resetLoadingState(), r ? (this.switchingTrack = t, this.flushAudioIfNeeded(t), this.state !== ne.STOPPED && (this.setInterval(jh), this.state = ne.IDLE, this.tick())) : (this.resetTransmuxer(), this.switchingTrack = null, this.bufferedTrack = t, this.clearInterval());
    }
    onManifestLoading() {
        super.onManifestLoading(), this.bufferFlushed = this.flushing = this.audioOnly = !1, this.resetItem(), this.trackId = -1;
    }
    onLevelLoaded(e, t) {
        this.mainDetails = t.details;
        const r = this.cachedTrackLoadedData;
        r && (this.cachedTrackLoadedData = null, this.onAudioTrackLoaded(I.AUDIO_TRACK_LOADED, r));
    }
    onAudioTrackLoaded(e, t) {
        var r;
        const { levels: n1 } = this, { details: i, id: o, groupId: a, track: l } = t;
        if (!n1) {
            this.warn(`Audio tracks reset while loading track ${o} "${l.name}" of "${a}"`);
            return;
        }
        const c = this.mainDetails;
        if (!c || i.endCC > c.endCC || c.expired) {
            this.cachedTrackLoadedData = t, this.state !== ne.STOPPED && (this.state = ne.WAITING_TRACK);
            return;
        }
        this.cachedTrackLoadedData = null, this.log(`Audio track ${o} "${l.name}" of "${a}" loaded [${i.startSN},${i.endSN}]${i.lastPartSn ? `[part-${i.lastPartSn}-${i.lastPartIndex}]` : ""},duration:${i.totalduration}`);
        const u = n1[o];
        let d1 = 0;
        if (i.live || (r = u.details) != null && r.live) {
            if (this.checkLiveUpdate(i), i.deltaUpdateFailed) return;
            if (u.details) {
                var h;
                d1 = this.alignPlaylists(i, u.details, (h = this.levelLastLoaded) == null ? void 0 : h.details);
            }
            i.alignedSliding || (np(i, c), i.alignedSliding || sa(i, c), d1 = i.fragmentStart);
        }
        u.details = i, this.levelLastLoaded = u, this.startFragRequested || this.setStartPosition(c, d1), this.hls.trigger(I.AUDIO_TRACK_UPDATED, {
            details: i,
            id: o,
            groupId: t.groupId
        }), this.state === ne.WAITING_TRACK && !this.waitForCdnTuneIn(i) && (this.state = ne.IDLE), this.tick();
    }
    _handleFragmentLoadProgress(e) {
        var t;
        const r = e.frag, { part: n1, payload: i } = e, { config: o, trackId: a, levels: l } = this;
        if (!l) {
            this.warn(`Audio tracks were reset while fragment load was in progress. Fragment ${r.sn} of level ${r.level} will not be buffered`);
            return;
        }
        const c = l[a];
        if (!c) {
            this.warn("Audio track is undefined on fragment load progress");
            return;
        }
        const u = c.details;
        if (!u) {
            this.warn("Audio track details undefined on fragment load progress"), this.removeUnbufferedFrags(r.start);
            return;
        }
        const d1 = o.defaultAudioCodec || c.audioCodec || "mp4a.40.2";
        let h = this.transmuxer;
        h || (h = this.transmuxer = new wp(this.hls, pe.AUDIO, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this)));
        const f = this.initPTS[r.cc], p = (t = r.initSegment) == null ? void 0 : t.data;
        if (f !== void 0) {
            const E = n1 ? n1.index : -1, b = E !== -1, L = new Eu(r.level, r.sn, r.stats.chunkCount, i.byteLength, E, b);
            h.push(i, p, d1, "", r, n1, u.totalduration, !1, L, f);
        } else {
            this.log(`Unknown video PTS for cc ${r.cc}, waiting for video PTS before demuxing audio frag ${r.sn} of [${u.startSN} ,${u.endSN}],track ${a}`);
            const { cache: y } = this.waitingData = this.waitingData || {
                frag: r,
                part: n1,
                cache: new ip(),
                complete: !1
            };
            y.push(new Uint8Array(i)), this.state !== ne.STOPPED && (this.state = ne.WAITING_INIT_PTS);
        }
    }
    _handleFragmentLoadComplete(e) {
        if (this.waitingData) {
            this.waitingData.complete = !0;
            return;
        }
        super._handleFragmentLoadComplete(e);
    }
    onBufferReset() {
        this.mediaBuffer = null;
    }
    onBufferCreated(e, t) {
        this.bufferFlushed = this.flushing = !1;
        const r = t.tracks.audio;
        r && (this.mediaBuffer = r.buffer || null);
    }
    onFragLoading(e, t) {
        !this.audioOnly && t.frag.type === pe.MAIN && Vt(t.frag) && (this.mainFragLoading = t, this.state === ne.IDLE && this.tick());
    }
    onFragBuffered(e, t) {
        const { frag: r, part: n1 } = t;
        if (r.type !== pe.AUDIO) {
            !this.audioOnly && r.type === pe.MAIN && !r.elementaryStreams.video && !r.elementaryStreams.audiovideo && (this.audioOnly = !0, this.mainFragLoading = null);
            return;
        }
        if (this.fragContextChanged(r)) {
            this.warn(`Fragment ${r.sn}${n1 ? " p: " + n1.index : ""} of level ${r.level} finished buffering, but was aborted. state: ${this.state}, audioSwitch: ${this.switchingTrack ? this.switchingTrack.name : "false"}`);
            return;
        }
        if (Vt(r)) {
            this.fragPrevious = r;
            const i = this.switchingTrack;
            i && (this.bufferedTrack = i, this.switchingTrack = null, this.hls.trigger(I.AUDIO_TRACK_SWITCHED, tt({}, i)));
        }
        this.fragBufferedComplete(r, n1), this.media && this.tick();
    }
    onError(e, t) {
        var r;
        if (t.fatal) {
            this.state = ne.ERROR;
            return;
        }
        switch(t.details){
            case J.FRAG_GAP:
            case J.FRAG_PARSING_ERROR:
            case J.FRAG_DECRYPT_ERROR:
            case J.FRAG_LOAD_ERROR:
            case J.FRAG_LOAD_TIMEOUT:
            case J.KEY_LOAD_ERROR:
            case J.KEY_LOAD_TIMEOUT:
                this.onFragmentOrKeyLoadError(pe.AUDIO, t);
                break;
            case J.AUDIO_TRACK_LOAD_ERROR:
            case J.AUDIO_TRACK_LOAD_TIMEOUT:
            case J.LEVEL_PARSING_ERROR:
                !t.levelRetry && this.state === ne.WAITING_TRACK && ((r = t.context) == null ? void 0 : r.type) === Ke.AUDIO_TRACK && (this.state = ne.IDLE);
                break;
            case J.BUFFER_ADD_CODEC_ERROR:
            case J.BUFFER_APPEND_ERROR:
                if (t.parent !== "audio") return;
                this.reduceLengthAndFlushBuffer(t) || this.resetLoadingState();
                break;
            case J.BUFFER_FULL_ERROR:
                if (t.parent !== "audio") return;
                this.reduceLengthAndFlushBuffer(t) && (this.bufferedTrack = null, super.flushMainBuffer(0, Number.POSITIVE_INFINITY, "audio"));
                break;
            case J.INTERNAL_EXCEPTION:
                this.recoverWorkerError(t);
                break;
        }
    }
    onBufferFlushing(e, { type: t }) {
        t !== ot.VIDEO && (this.flushing = !0);
    }
    onBufferFlushed(e, { type: t }) {
        if (t !== ot.VIDEO) {
            this.flushing = !1, this.bufferFlushed = !0, this.state === ne.ENDED && (this.state = ne.IDLE);
            const r = this.mediaBuffer || this.media;
            r && (this.afterBufferFlushed(r, t, pe.AUDIO), this.tick());
        }
    }
    _handleTransmuxComplete(e) {
        var t;
        const r = "audio", { hls: n1 } = this, { remuxResult: i, chunkMeta: o } = e, a = this.getCurrentContext(o);
        if (!a) {
            this.resetWhenMissingContext(o);
            return;
        }
        const { frag: l, part: c, level: u } = a, { details: d1 } = u, { audio: h, text: f, id3: p, initSegment: y } = i;
        if (this.fragContextChanged(l) || !d1) {
            this.fragmentTracker.removeFragment(l);
            return;
        }
        if (this.state = ne.PARSING, this.switchingTrack && h && this.completeAudioSwitch(this.switchingTrack), y != null && y.tracks) {
            const E = l.initSegment || l;
            if (this.unhandledEncryptionError(y, l)) return;
            this._bufferInitSegment(u, y.tracks, E, o), n1.trigger(I.FRAG_PARSING_INIT_SEGMENT, {
                frag: E,
                id: r,
                tracks: y.tracks
            });
        }
        if (h) {
            const { startPTS: E, endPTS: b, startDTS: L, endDTS: A } = h;
            c && (c.elementaryStreams[ot.AUDIO] = {
                startPTS: E,
                endPTS: b,
                startDTS: L,
                endDTS: A
            }), l.setElementaryStreamInfo(ot.AUDIO, E, b, L, A), this.bufferFragmentData(h, l, c, o);
        }
        if (p != null && (t = p.samples) != null && t.length) {
            const E = nt({
                id: r,
                frag: l,
                details: d1
            }, p);
            n1.trigger(I.FRAG_PARSING_METADATA, E);
        }
        if (f) {
            const E = nt({
                id: r,
                frag: l,
                details: d1
            }, f);
            n1.trigger(I.FRAG_PARSING_USERDATA, E);
        }
    }
    _bufferInitSegment(e, t, r, n1) {
        if (this.state !== ne.PARSING || (t.video && delete t.video, t.audiovideo && delete t.audiovideo, !t.audio)) return;
        const i = t.audio;
        i.id = pe.AUDIO;
        const o = e.audioCodec;
        this.log(`Init audio buffer, container:${i.container}, codecs[level/parsed]=[${o}/${i.codec}]`), o && o.split(",").length === 1 && (i.levelCodec = o), this.hls.trigger(I.BUFFER_CODECS, t);
        const a = i.initSegment;
        if (a != null && a.byteLength) {
            const l = {
                type: "audio",
                frag: r,
                part: null,
                chunkMeta: n1,
                parent: r.type,
                data: a
            };
            this.hls.trigger(I.BUFFER_APPENDING, l);
        }
        this.tickImmediate();
    }
    loadFragment(e, t, r) {
        const n1 = this.fragmentTracker.getState(e);
        if (this.switchingTrack || n1 === Ht.NOT_LOADED || n1 === Ht.PARTIAL) {
            var i;
            if (!Vt(e)) this._loadInitSegment(e, t);
            else if ((i = t.details) != null && i.live && !this.initPTS[e.cc]) {
                this.log(`Waiting for video PTS in continuity counter ${e.cc} of live stream before loading audio fragment ${e.sn} of level ${this.trackId}`), this.state = ne.WAITING_INIT_PTS;
                const o = this.mainDetails;
                o && o.fragmentStart !== t.details.fragmentStart && sa(t.details, o);
            } else super.loadFragment(e, t, r);
        } else this.clearTrackerIfNeeded(e);
    }
    flushAudioIfNeeded(e) {
        if (this.media && this.bufferedTrack) {
            const { name: t, lang: r, assocLang: n1, characteristics: i, audioCodec: o, channels: a } = this.bufferedTrack;
            qs({
                name: t,
                lang: r,
                assocLang: n1,
                characteristics: i,
                audioCodec: o,
                channels: a
            }, e, Us) || (Qo(e.url, this.hls) ? (this.log("Switching audio track : flushing all audio"), super.flushMainBuffer(0, Number.POSITIVE_INFINITY, "audio"), this.bufferedTrack = null) : this.bufferedTrack = e);
        }
    }
    completeAudioSwitch(e) {
        const { hls: t } = this;
        this.flushAudioIfNeeded(e), this.bufferedTrack = e, this.switchingTrack = null, t.trigger(I.AUDIO_TRACK_SWITCHED, tt({}, e));
    }
}
class ku extends Rr {
    constructor(e, t){
        super(t, e.logger), this.hls = void 0, this.canLoad = !1, this.timer = -1, this.hls = e;
    }
    destroy() {
        this.clearTimer(), this.hls = this.log = this.warn = null;
    }
    clearTimer() {
        this.timer !== -1 && (self.clearTimeout(this.timer), this.timer = -1);
    }
    startLoad() {
        this.canLoad = !0, this.loadPlaylist();
    }
    stopLoad() {
        this.canLoad = !1, this.clearTimer();
    }
    switchParams(e, t, r) {
        const n1 = t == null ? void 0 : t.renditionReports;
        if (n1) {
            let i = -1;
            for(let o = 0; o < n1.length; o++){
                const a = n1[o];
                let l;
                try {
                    l = new self.URL(a.URI, t.url).href;
                } catch (c) {
                    this.warn(`Could not construct new URL for Rendition Report: ${c}`), l = a.URI || "";
                }
                if (l === e) {
                    i = o;
                    break;
                } else l === e.substring(0, l.length) && (i = o);
            }
            if (i !== -1) {
                const o = n1[i], a = parseInt(o["LAST-MSN"]) || t.lastPartSn;
                let l = parseInt(o["LAST-PART"]) || t.lastPartIndex;
                if (this.hls.config.lowLatencyMode) {
                    const u = Math.min(t.age - t.partTarget, t.targetduration);
                    l >= 0 && u > t.partTarget && (l += 1);
                }
                const c = r && oh(r);
                return new ah(a, l >= 0 ? l : void 0, c);
            }
        }
    }
    loadPlaylist(e) {
        this.clearTimer();
    }
    loadingPlaylist(e, t) {
        this.clearTimer();
    }
    shouldLoadPlaylist(e) {
        return this.canLoad && !!e && !!e.url && (!e.details || e.details.live);
    }
    getUrlWithDirectives(e, t) {
        if (t) try {
            return t.addDirectives(e);
        } catch (r) {
            this.warn(`Could not construct new URL with HLS Delivery Directives: ${r}`);
        }
        return e;
    }
    playlistLoaded(e, t, r) {
        const { details: n1, stats: i } = t, o = self.performance.now(), a = i.loading.first ? Math.max(0, o - i.loading.first) : 0;
        n1.advancedDateTime = Date.now() - a;
        const l = this.hls.config.timelineOffset;
        if (l !== n1.appliedTimelineOffset) {
            const u = Math.max(l || 0, 0);
            n1.appliedTimelineOffset = u, n1.fragments.forEach((d1)=>{
                d1.setStart(d1.playlistOffset + u);
            });
        }
        if (n1.live || r != null && r.live) {
            const u = "levelInfo" in t ? t.levelInfo : t.track;
            if (n1.reloaded(r), r && n1.fragments.length > 0) {
                Zb(r, n1, this);
                const L = n1.playlistParsingError;
                if (L) {
                    this.warn(L);
                    const A = this.hls;
                    if (!A.config.ignorePlaylistParsingErrors) {
                        var c;
                        const { networkDetails: F } = t;
                        A.trigger(I.ERROR, {
                            type: ve.NETWORK_ERROR,
                            details: J.LEVEL_PARSING_ERROR,
                            fatal: !1,
                            url: n1.url,
                            error: L,
                            reason: L.message,
                            level: t.level || void 0,
                            parent: (c = n1.fragments[0]) == null ? void 0 : c.type,
                            networkDetails: F,
                            stats: i
                        });
                        return;
                    }
                    n1.playlistParsingError = null;
                }
            }
            n1.requestScheduled === -1 && (n1.requestScheduled = i.loading.start);
            const d1 = this.hls.mainForwardBufferInfo, h = d1 ? d1.end - d1.len : 0, f = (n1.edge - h) * 1e3, p = Qg(n1, f);
            if (n1.requestScheduled + p < o ? n1.requestScheduled = o : n1.requestScheduled += p, this.log(`live playlist ${e} ${n1.advanced ? "REFRESHED " + n1.lastPartSn + "-" + n1.lastPartIndex : n1.updated ? "UPDATED" : "MISSED"}`), !this.canLoad || !n1.live) return;
            let y, E, b;
            if (n1.canBlockReload && n1.endSN && n1.advanced) {
                const L = this.hls.config.lowLatencyMode, A = n1.lastPartSn, F = n1.endSN, M = n1.lastPartIndex, H = M !== -1, K = A === F;
                H ? K ? (E = F + 1, b = L ? 0 : M) : (E = A, b = L ? M + 1 : n1.maxPartIndex) : E = F + 1;
                const j = n1.age, C = j + n1.ageHeader;
                let k = Math.min(C - n1.partTarget, n1.targetduration * 1.5);
                if (k > 0) {
                    if (C > n1.targetduration * 3) this.log(`Playlist last advanced ${j.toFixed(2)}s ago. Omitting segment and part directives.`), E = void 0, b = void 0;
                    else if (r != null && r.tuneInGoal && C - n1.partTarget > r.tuneInGoal) this.warn(`CDN Tune-in goal increased from: ${r.tuneInGoal} to: ${k} with playlist age: ${n1.age}`), k = 0;
                    else {
                        const $ = Math.floor(k / n1.targetduration);
                        if (E += $, b !== void 0) {
                            const W = Math.round(k % n1.targetduration / n1.partTarget);
                            b += W;
                        }
                        this.log(`CDN Tune-in age: ${n1.ageHeader}s last advanced ${j.toFixed(2)}s goal: ${k} skip sn ${$} to part ${b}`);
                    }
                    n1.tuneInGoal = k;
                }
                if (y = this.getDeliveryDirectives(n1, t.deliveryDirectives, E, b), L || !K) {
                    n1.requestScheduled = o, this.loadingPlaylist(u, y);
                    return;
                }
            } else (n1.canBlockReload || n1.canSkipUntil) && (y = this.getDeliveryDirectives(n1, t.deliveryDirectives, E, b));
            y && E !== void 0 && n1.canBlockReload && (n1.requestScheduled = i.loading.first + Math.max(p - a * 2, p / 2)), this.scheduleLoading(u, y, n1);
        } else this.clearTimer();
    }
    scheduleLoading(e, t, r) {
        const n1 = r || e.details;
        if (!n1) {
            this.loadingPlaylist(e, t);
            return;
        }
        const i = self.performance.now(), o = n1.requestScheduled;
        if (i >= o) {
            this.loadingPlaylist(e, t);
            return;
        }
        const a = o - i;
        this.log(`reload live playlist ${e.name || e.bitrate + "bps"} in ${Math.round(a)} ms`), this.clearTimer(), this.timer = self.setTimeout(()=>this.loadingPlaylist(e, t), a);
    }
    getDeliveryDirectives(e, t, r, n1) {
        let i = oh(e);
        return t != null && t.skip && e.deltaUpdateFailed && (r = t.msn, n1 = t.part, i = go.No), new ah(r, n1, i);
    }
    checkRetry(e) {
        const t = e.details, r = ea(e), n1 = e.errorAction, { action: i, retryCount: o = 0, retryConfig: a } = n1 || {}, l = !!n1 && !!a && (i === Zt.RetryRequest || !n1.resolved && i === Zt.SendAlternateToPenaltyBox);
        if (l) {
            var c;
            if (o >= a.maxNumRetry) return !1;
            if (r && (c = e.context) != null && c.deliveryDirectives) this.warn(`Retrying playlist loading ${o + 1}/${a.maxNumRetry} after "${t}" without delivery-directives`), this.loadPlaylist();
            else {
                const u = yu(a, o);
                this.clearTimer(), this.timer = self.setTimeout(()=>this.loadPlaylist(), u), this.warn(`Retrying playlist loading ${o + 1}/${a.maxNumRetry} after "${t}" in ${u}ms`);
            }
            e.levelRetry = !0, n1.resolved = !0;
        }
        return l;
    }
}
function Ap(s, e) {
    if (s.length !== e.length) return !1;
    for(let t = 0; t < s.length; t++)if (!Si(s[t].attrs, e[t].attrs)) return !1;
    return !0;
}
function Si(s, e, t) {
    const r = s["STABLE-RENDITION-ID"];
    return r && !t ? r === e["STABLE-RENDITION-ID"] : !(t || [
        "LANGUAGE",
        "NAME",
        "CHARACTERISTICS",
        "AUTOSELECT",
        "DEFAULT",
        "FORCED",
        "ASSOC-LANGUAGE"
    ]).some((n1)=>s[n1] !== e[n1]);
}
function yc(s, e) {
    return e.label.toLowerCase() === s.name.toLowerCase() && (!e.language || e.language.toLowerCase() === (s.lang || "").toLowerCase());
}
class i2 extends ku {
    constructor(e){
        super(e, "audio-track-controller"), this.tracks = [], this.groupIds = null, this.tracksInGroup = [], this.trackId = -1, this.currentTrack = null, this.selectDefaultTrack = !0, this.registerListeners();
    }
    registerListeners() {
        const { hls: e } = this;
        e.on(I.MANIFEST_LOADING, this.onManifestLoading, this), e.on(I.MANIFEST_PARSED, this.onManifestParsed, this), e.on(I.LEVEL_LOADING, this.onLevelLoading, this), e.on(I.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on(I.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.on(I.ERROR, this.onError, this);
    }
    unregisterListeners() {
        const { hls: e } = this;
        e.off(I.MANIFEST_LOADING, this.onManifestLoading, this), e.off(I.MANIFEST_PARSED, this.onManifestParsed, this), e.off(I.LEVEL_LOADING, this.onLevelLoading, this), e.off(I.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off(I.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.off(I.ERROR, this.onError, this);
    }
    destroy() {
        this.unregisterListeners(), this.tracks.length = 0, this.tracksInGroup.length = 0, this.currentTrack = null, super.destroy();
    }
    onManifestLoading() {
        this.tracks = [], this.tracksInGroup = [], this.groupIds = null, this.currentTrack = null, this.trackId = -1, this.selectDefaultTrack = !0;
    }
    onManifestParsed(e, t) {
        this.tracks = t.audioTracks || [];
    }
    onAudioTrackLoaded(e, t) {
        const { id: r, groupId: n1, details: i } = t, o = this.tracksInGroup[r];
        if (!o || o.groupId !== n1) {
            this.warn(`Audio track with id:${r} and group:${n1} not found in active group ${o == null ? void 0 : o.groupId}`);
            return;
        }
        const a = o.details;
        o.details = t.details, this.log(`Audio track ${r} "${o.name}" lang:${o.lang} group:${n1} loaded [${i.startSN}-${i.endSN}]`), r === this.trackId && this.playlistLoaded(r, t, a);
    }
    onLevelLoading(e, t) {
        this.switchLevel(t.level);
    }
    onLevelSwitching(e, t) {
        this.switchLevel(t.level);
    }
    switchLevel(e) {
        const t = this.hls.levels[e];
        if (!t) return;
        const r = t.audioGroups || null, n1 = this.groupIds;
        let i = this.currentTrack;
        if (!r || (n1 == null ? void 0 : n1.length) !== (r == null ? void 0 : r.length) || r != null && r.some((a)=>(n1 == null ? void 0 : n1.indexOf(a)) === -1)) {
            this.groupIds = r, this.trackId = -1, this.currentTrack = null;
            const a = this.tracks.filter((h)=>!r || r.indexOf(h.groupId) !== -1);
            if (a.length) this.selectDefaultTrack && !a.some((h)=>h.default) && (this.selectDefaultTrack = !1), a.forEach((h, f)=>{
                h.id = f;
            });
            else if (!i && !this.tracksInGroup.length) return;
            this.tracksInGroup = a;
            const l = this.hls.config.audioPreference;
            if (!i && l) {
                const h = Wr(l, a, Us);
                if (h > -1) i = a[h];
                else {
                    const f = Wr(l, this.tracks);
                    i = this.tracks[f];
                }
            }
            let c = this.findTrackId(i);
            c === -1 && i && (c = this.findTrackId(null));
            const u = {
                audioTracks: a
            };
            this.log(`Updating audio tracks, ${a.length} track(s) found in group(s): ${r == null ? void 0 : r.join(",")}`), this.hls.trigger(I.AUDIO_TRACKS_UPDATED, u);
            const d1 = this.trackId;
            if (c !== -1 && d1 === -1) this.setAudioTrack(c);
            else if (a.length && d1 === -1) {
                var o;
                const h = new Error(`No audio track selected for current audio group-ID(s): ${(o = this.groupIds) == null ? void 0 : o.join(",")} track count: ${a.length}`);
                this.warn(h.message), this.hls.trigger(I.ERROR, {
                    type: ve.MEDIA_ERROR,
                    details: J.AUDIO_TRACK_LOAD_ERROR,
                    fatal: !0,
                    error: h
                });
            }
        }
    }
    onError(e, t) {
        t.fatal || !t.context || t.context.type === Ke.AUDIO_TRACK && t.context.id === this.trackId && (!this.groupIds || this.groupIds.indexOf(t.context.groupId) !== -1) && this.checkRetry(t);
    }
    get allAudioTracks() {
        return this.tracks;
    }
    get audioTracks() {
        return this.tracksInGroup;
    }
    get audioTrack() {
        return this.trackId;
    }
    set audioTrack(e) {
        this.selectDefaultTrack = !1, this.setAudioTrack(e);
    }
    setAudioOption(e) {
        const t = this.hls;
        if (t.config.audioPreference = e, e) {
            const r = this.allAudioTracks;
            if (this.selectDefaultTrack = !1, r.length) {
                const n1 = this.currentTrack;
                if (n1 && qs(e, n1, Us)) return n1;
                const i = Wr(e, this.tracksInGroup, Us);
                if (i > -1) {
                    const o = this.tracksInGroup[i];
                    return this.setAudioTrack(i), o;
                } else if (n1) {
                    let o = t.loadLevel;
                    o === -1 && (o = t.firstAutoLevel);
                    const a = mb(e, t.levels, r, o, Us);
                    if (a === -1) return null;
                    t.nextLoadLevel = a;
                }
                if (e.channels || e.audioCodec) {
                    const o = Wr(e, r);
                    if (o > -1) return r[o];
                }
            }
        }
        return null;
    }
    setAudioTrack(e) {
        const t = this.tracksInGroup;
        if (e < 0 || e >= t.length) {
            this.warn(`Invalid audio track id: ${e}`);
            return;
        }
        this.selectDefaultTrack = !1;
        const r = this.currentTrack, n1 = t[e], i = n1.details && !n1.details.live;
        if (e === this.trackId && n1 === r && i || (this.log(`Switching to audio-track ${e} "${n1.name}" lang:${n1.lang} group:${n1.groupId} channels:${n1.channels}`), this.trackId = e, this.currentTrack = n1, this.hls.trigger(I.AUDIO_TRACK_SWITCHING, tt({}, n1)), i)) return;
        const o = this.switchParams(n1.url, r == null ? void 0 : r.details, n1.details);
        this.loadPlaylist(o);
    }
    findTrackId(e) {
        const t = this.tracksInGroup;
        for(let r = 0; r < t.length; r++){
            const n1 = t[r];
            if (!(this.selectDefaultTrack && !n1.default) && (!e || qs(e, n1, Us))) return r;
        }
        if (e) {
            const { name: r, lang: n1, assocLang: i, characteristics: o, audioCodec: a, channels: l } = e;
            for(let c = 0; c < t.length; c++){
                const u = t[c];
                if (qs({
                    name: r,
                    lang: n1,
                    assocLang: i,
                    characteristics: o,
                    audioCodec: a,
                    channels: l
                }, u, Us)) return c;
            }
            for(let c = 0; c < t.length; c++){
                const u = t[c];
                if (Si(e.attrs, u.attrs, [
                    "LANGUAGE",
                    "ASSOC-LANGUAGE",
                    "CHARACTERISTICS"
                ])) return c;
            }
            for(let c = 0; c < t.length; c++){
                const u = t[c];
                if (Si(e.attrs, u.attrs, [
                    "LANGUAGE"
                ])) return c;
            }
        }
        return -1;
    }
    loadPlaylist(e) {
        super.loadPlaylist();
        const t = this.currentTrack;
        this.shouldLoadPlaylist(t) && Qo(t.url, this.hls) && this.scheduleLoading(t, e);
    }
    loadingPlaylist(e, t) {
        super.loadingPlaylist(e, t);
        const r = e.id, n1 = e.groupId, i = this.getUrlWithDirectives(e.url, t), o = e.details, a = o == null ? void 0 : o.age;
        this.log(`Loading audio-track ${r} "${e.name}" lang:${e.lang} group:${n1}${(t == null ? void 0 : t.msn) !== void 0 ? " at sn " + t.msn + " part " + t.part : ""}${a && o.live ? " age " + a.toFixed(1) + (o.type && " " + o.type || "") : ""} ${i}`), this.hls.trigger(I.AUDIO_TRACK_LOADING, {
            url: i,
            id: r,
            groupId: n1,
            deliveryDirectives: t || null,
            track: e
        });
    }
}
class o2 {
    constructor(e){
        this.tracks = void 0, this.queues = {
            video: [],
            audio: [],
            audiovideo: []
        }, this.tracks = e;
    }
    destroy() {
        this.tracks = this.queues = null;
    }
    append(e, t, r) {
        if (this.queues === null || this.tracks === null) return;
        const n1 = this.queues[t];
        n1.push(e), n1.length === 1 && !r && this.executeNext(t);
    }
    appendBlocker(e) {
        return new Promise((t)=>{
            const r = {
                label: "async-blocker",
                execute: t,
                onStart: ()=>{},
                onComplete: ()=>{},
                onError: ()=>{}
            };
            this.append(r, e);
        });
    }
    prependBlocker(e) {
        return new Promise((t)=>{
            if (this.queues) {
                const r = {
                    label: "async-blocker-prepend",
                    execute: t,
                    onStart: ()=>{},
                    onComplete: ()=>{},
                    onError: ()=>{}
                };
                this.queues[e].unshift(r);
            }
        });
    }
    removeBlockers() {
        this.queues !== null && [
            this.queues.video,
            this.queues.audio,
            this.queues.audiovideo
        ].forEach((e)=>{
            var t;
            const r = (t = e[0]) == null ? void 0 : t.label;
            (r === "async-blocker" || r === "async-blocker-prepend") && (e[0].execute(), e.splice(0, 1));
        });
    }
    unblockAudio(e) {
        if (this.queues === null) return;
        this.queues.audio[0] === e && this.shiftAndExecuteNext("audio");
    }
    executeNext(e) {
        if (this.queues === null || this.tracks === null) return;
        const t = this.queues[e];
        if (t.length) {
            const n1 = t[0];
            try {
                n1.execute();
            } catch (i) {
                var r;
                if (n1.onError(i), this.queues === null || this.tracks === null) return;
                const o = (r = this.tracks[e]) == null ? void 0 : r.buffer;
                o != null && o.updating || this.shiftAndExecuteNext(e);
            }
        }
    }
    shiftAndExecuteNext(e) {
        this.queues !== null && (this.queues[e].shift(), this.executeNext(e));
    }
    current(e) {
        var t;
        return ((t = this.queues) == null ? void 0 : t[e][0]) || null;
    }
    toString() {
        const { queues: e, tracks: t } = this;
        return e === null || t === null ? "<destroyed>" : `
${this.list("video")}
${this.list("audio")}
${this.list("audiovideo")}}`;
    }
    list(e) {
        var t, r;
        return (t = this.queues) != null && t[e] || (r = this.tracks) != null && r[e] ? `${e}: (${this.listSbInfo(e)}) ${this.listOps(e)}` : "";
    }
    listSbInfo(e) {
        var t;
        const r = (t = this.tracks) == null ? void 0 : t[e], n1 = r == null ? void 0 : r.buffer;
        return n1 ? `SourceBuffer${n1.updating ? " updating" : ""}${r.ended ? " ended" : ""}${r.ending ? " ending" : ""}` : "none";
    }
    listOps(e) {
        var t;
        return ((t = this.queues) == null ? void 0 : t[e].map((r)=>r.label).join(", ")) || "";
    }
}
const Kh = /(avc[1234]|hvc1|hev1|dvh[1e]|vp09|av01)(?:\.[^.,]+)+/, Ip = "HlsJsTrackRemovedError";
class a2 extends Error {
    constructor(e){
        super(e), this.name = Ip;
    }
}
class l2 extends Rr {
    constructor(e, t){
        super("buffer-controller", e.logger), this.hls = void 0, this.fragmentTracker = void 0, this.details = null, this._objectUrl = null, this.operationQueue = null, this.bufferCodecEventsTotal = 0, this.media = null, this.mediaSource = null, this.lastMpegAudioChunk = null, this.blockedAudioAppend = null, this.lastVideoAppendEnd = 0, this.appendSource = void 0, this.transferData = void 0, this.overrides = void 0, this.appendErrors = {
            audio: 0,
            video: 0,
            audiovideo: 0
        }, this.tracks = {}, this.sourceBuffers = [
            [
                null,
                null
            ],
            [
                null,
                null
            ]
        ], this._onEndStreaming = (r)=>{
            var n1;
            this.hls && ((n1 = this.mediaSource) == null ? void 0 : n1.readyState) === "open" && this.hls.pauseBuffering();
        }, this._onStartStreaming = (r)=>{
            this.hls && this.hls.resumeBuffering();
        }, this._onMediaSourceOpen = (r)=>{
            const { media: n1, mediaSource: i } = this;
            r && this.log("Media source opened"), !(!n1 || !i) && (i.removeEventListener("sourceopen", this._onMediaSourceOpen), n1.removeEventListener("emptied", this._onMediaEmptied), this.updateDuration(), this.hls.trigger(I.MEDIA_ATTACHED, {
                media: n1,
                mediaSource: i
            }), this.mediaSource !== null && this.checkPendingTracks());
        }, this._onMediaSourceClose = ()=>{
            this.log("Media source closed");
        }, this._onMediaSourceEnded = ()=>{
            this.log("Media source ended");
        }, this._onMediaEmptied = ()=>{
            const { mediaSrc: r, _objectUrl: n1 } = this;
            r !== n1 && this.error(`Media element src was set while attaching MediaSource (${n1} > ${r})`);
        }, this.hls = e, this.fragmentTracker = t, this.appendSource = CS(Ms(e.config.preferManagedMediaSource)), this.initTracks(), this.registerListeners();
    }
    hasSourceTypes() {
        return Object.keys(this.tracks).length > 0;
    }
    destroy() {
        this.unregisterListeners(), this.details = null, this.lastMpegAudioChunk = this.blockedAudioAppend = null, this.transferData = this.overrides = void 0, this.operationQueue && (this.operationQueue.destroy(), this.operationQueue = null), this.hls = this.fragmentTracker = null, this._onMediaSourceOpen = this._onMediaSourceClose = null, this._onMediaSourceEnded = null, this._onStartStreaming = this._onEndStreaming = null;
    }
    registerListeners() {
        const { hls: e } = this;
        e.on(I.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(I.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(I.MANIFEST_LOADING, this.onManifestLoading, this), e.on(I.MANIFEST_PARSED, this.onManifestParsed, this), e.on(I.BUFFER_RESET, this.onBufferReset, this), e.on(I.BUFFER_APPENDING, this.onBufferAppending, this), e.on(I.BUFFER_CODECS, this.onBufferCodecs, this), e.on(I.BUFFER_EOS, this.onBufferEos, this), e.on(I.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(I.LEVEL_UPDATED, this.onLevelUpdated, this), e.on(I.FRAG_PARSED, this.onFragParsed, this), e.on(I.FRAG_CHANGED, this.onFragChanged, this), e.on(I.ERROR, this.onError, this);
    }
    unregisterListeners() {
        const { hls: e } = this;
        e.off(I.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(I.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(I.MANIFEST_LOADING, this.onManifestLoading, this), e.off(I.MANIFEST_PARSED, this.onManifestParsed, this), e.off(I.BUFFER_RESET, this.onBufferReset, this), e.off(I.BUFFER_APPENDING, this.onBufferAppending, this), e.off(I.BUFFER_CODECS, this.onBufferCodecs, this), e.off(I.BUFFER_EOS, this.onBufferEos, this), e.off(I.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(I.LEVEL_UPDATED, this.onLevelUpdated, this), e.off(I.FRAG_PARSED, this.onFragParsed, this), e.off(I.FRAG_CHANGED, this.onFragChanged, this), e.off(I.ERROR, this.onError, this);
    }
    transferMedia() {
        const { media: e, mediaSource: t } = this;
        if (!e) return null;
        const r = {};
        if (this.operationQueue) {
            const i = this.isUpdating();
            i || this.operationQueue.removeBlockers();
            const o = this.isQueued();
            (i || o) && this.warn(`Transfering MediaSource with${o ? " operations in queue" : ""}${i ? " updating SourceBuffer(s)" : ""} ${this.operationQueue}`), this.operationQueue.destroy();
        }
        const n1 = this.transferData;
        return !this.sourceBufferCount && n1 && n1.mediaSource === t ? nt(r, n1.tracks) : this.sourceBuffers.forEach((i)=>{
            const [o] = i;
            o && (r[o] = nt({}, this.tracks[o]), this.removeBuffer(o)), i[0] = i[1] = null;
        }), {
            media: e,
            mediaSource: t,
            tracks: r
        };
    }
    initTracks() {
        const e = {};
        this.sourceBuffers = [
            [
                null,
                null
            ],
            [
                null,
                null
            ]
        ], this.tracks = e, this.resetQueue(), this.resetAppendErrors(), this.lastMpegAudioChunk = this.blockedAudioAppend = null, this.lastVideoAppendEnd = 0;
    }
    onManifestLoading() {
        this.bufferCodecEventsTotal = 0, this.details = null;
    }
    onManifestParsed(e, t) {
        var r;
        let n1 = 2;
        (t.audio && !t.video || !t.altAudio) && (n1 = 1), this.bufferCodecEventsTotal = n1, this.log(`${n1} bufferCodec event(s) expected.`), (r = this.transferData) != null && r.mediaSource && this.sourceBufferCount && n1 && this.bufferCreated();
    }
    onMediaAttaching(e, t) {
        const r = this.media = t.media;
        this.transferData = this.overrides = void 0;
        const n1 = Ms(this.appendSource);
        if (n1) {
            const i = !!t.mediaSource;
            (i || t.overrides) && (this.transferData = t, this.overrides = t.overrides);
            const o = this.mediaSource = t.mediaSource || new n1();
            if (this.assignMediaSource(o), i) this._objectUrl = r.src, this.attachTransferred();
            else {
                const a = this._objectUrl = self.URL.createObjectURL(o);
                if (this.appendSource) try {
                    r.removeAttribute("src");
                    const l = self.ManagedMediaSource;
                    r.disableRemotePlayback = r.disableRemotePlayback || l && o instanceof l, Hh(r), c2(r, a), r.load();
                } catch  {
                    r.src = a;
                }
                else r.src = a;
            }
            r.addEventListener("emptied", this._onMediaEmptied);
        }
    }
    assignMediaSource(e) {
        var t, r;
        this.log(`${((t = this.transferData) == null ? void 0 : t.mediaSource) === e ? "transferred" : "created"} media source: ${(r = e.constructor) == null ? void 0 : r.name}`), e.addEventListener("sourceopen", this._onMediaSourceOpen), e.addEventListener("sourceended", this._onMediaSourceEnded), e.addEventListener("sourceclose", this._onMediaSourceClose), this.appendSource && (e.addEventListener("startstreaming", this._onStartStreaming), e.addEventListener("endstreaming", this._onEndStreaming));
    }
    attachTransferred() {
        const e = this.media, t = this.transferData;
        if (!t || !e) return;
        const r = this.tracks, n1 = t.tracks, i = n1 ? Object.keys(n1) : null, o = i ? i.length : 0, a = ()=>{
            Promise.resolve().then(()=>{
                this.media && this.mediaSourceOpenOrEnded && this._onMediaSourceOpen();
            });
        };
        if (n1 && i && o) {
            if (!this.tracksReady) {
                this.hls.config.startFragPrefetch = !0, this.log("attachTransferred: waiting for SourceBuffer track info");
                return;
            }
            if (this.log(`attachTransferred: (bufferCodecEventsTotal ${this.bufferCodecEventsTotal})
required tracks: ${at(r, (l, c)=>l === "initSegment" ? void 0 : c)};
transfer tracks: ${at(n1, (l, c)=>l === "initSegment" ? void 0 : c)}}`), !Ag(n1, r)) {
                t.mediaSource = null, t.tracks = void 0;
                const l = e.currentTime, c = this.details, u = Math.max(l, (c == null ? void 0 : c.fragments[0].start) || 0);
                if (u - l > 1) {
                    this.log(`attachTransferred: waiting for playback to reach new tracks start time ${l} -> ${u}`);
                    return;
                }
                this.warn(`attachTransferred: resetting MediaSource for incompatible tracks ("${Object.keys(n1)}"->"${Object.keys(r)}") start time: ${u} currentTime: ${l}`), this.onMediaDetaching(I.MEDIA_DETACHING, {}), this.onMediaAttaching(I.MEDIA_ATTACHING, t), e.currentTime = u;
                return;
            }
            this.transferData = void 0, i.forEach((l)=>{
                const c = l, u = n1[c];
                if (u) {
                    const d1 = u.buffer;
                    if (d1) {
                        const h = this.fragmentTracker, f = u.id;
                        if (h.hasFragments(f) || h.hasParts(f)) {
                            const E = Ce.getBuffered(d1);
                            h.detectEvictedFragments(c, E, f, null, !0);
                        }
                        const p = Sl(c), y = [
                            c,
                            d1
                        ];
                        this.sourceBuffers[p] = y, d1.updating && this.operationQueue && this.operationQueue.prependBlocker(c), this.trackSourceBuffer(c, u);
                    }
                }
            }), a(), this.bufferCreated();
        } else this.log("attachTransferred: MediaSource w/o SourceBuffers"), a();
    }
    get mediaSourceOpenOrEnded() {
        var e;
        const t = (e = this.mediaSource) == null ? void 0 : e.readyState;
        return t === "open" || t === "ended";
    }
    onMediaDetaching(e, t) {
        const r = !!t.transferMedia;
        this.transferData = this.overrides = void 0;
        const { media: n1, mediaSource: i, _objectUrl: o } = this;
        if (i) {
            if (this.log(`media source ${r ? "transferring" : "detaching"}`), r) this.sourceBuffers.forEach(([a])=>{
                a && this.removeBuffer(a);
            }), this.resetQueue();
            else {
                if (this.mediaSourceOpenOrEnded) {
                    const a = i.readyState === "open";
                    try {
                        const l = i.sourceBuffers;
                        for(let c = l.length; c--;)a && l[c].abort(), i.removeSourceBuffer(l[c]);
                        a && i.endOfStream();
                    } catch (l) {
                        this.warn(`onMediaDetaching: ${l.message} while calling endOfStream`);
                    }
                }
                this.sourceBufferCount && this.onBufferReset();
            }
            i.removeEventListener("sourceopen", this._onMediaSourceOpen), i.removeEventListener("sourceended", this._onMediaSourceEnded), i.removeEventListener("sourceclose", this._onMediaSourceClose), this.appendSource && (i.removeEventListener("startstreaming", this._onStartStreaming), i.removeEventListener("endstreaming", this._onEndStreaming)), this.mediaSource = null, this._objectUrl = null;
        }
        n1 && (n1.removeEventListener("emptied", this._onMediaEmptied), r || (o && self.URL.revokeObjectURL(o), this.mediaSrc === o ? (n1.removeAttribute("src"), this.appendSource && Hh(n1), n1.load()) : this.warn("media|source.src was changed by a third party - skip cleanup")), this.media = null), this.hls.trigger(I.MEDIA_DETACHED, t);
    }
    onBufferReset() {
        this.sourceBuffers.forEach(([e])=>{
            e && this.resetBuffer(e);
        }), this.initTracks();
    }
    resetBuffer(e) {
        var t;
        const r = (t = this.tracks[e]) == null ? void 0 : t.buffer;
        if (this.removeBuffer(e), r) try {
            var n1;
            (n1 = this.mediaSource) != null && n1.sourceBuffers.length && this.mediaSource.removeSourceBuffer(r);
        } catch (i) {
            this.warn(`onBufferReset ${e}`, i);
        }
        delete this.tracks[e];
    }
    removeBuffer(e) {
        this.removeBufferListeners(e), this.sourceBuffers[Sl(e)] = [
            null,
            null
        ];
        const t = this.tracks[e];
        t && (t.buffer = void 0);
    }
    resetQueue() {
        this.operationQueue && this.operationQueue.destroy(), this.operationQueue = new o2(this.tracks);
    }
    onBufferCodecs(e, t) {
        var r;
        const n1 = this.tracks, i = Object.keys(t);
        this.log(`BUFFER_CODECS: "${i}" (current SB count ${this.sourceBufferCount})`);
        const o = "audiovideo" in t && (n1.audio || n1.video) || n1.audiovideo && ("audio" in t || "video" in t), a = !o && this.sourceBufferCount && this.media && i.some((l)=>!n1[l]);
        if (o || a) {
            this.warn(`Unsupported transition between "${Object.keys(n1)}" and "${i}" SourceBuffers`);
            return;
        }
        i.forEach((l)=>{
            var c, u;
            const d1 = t[l], { id: h, codec: f, levelCodec: p, container: y, metadata: E, supplemental: b } = d1;
            let L = n1[l];
            const A = (c = this.transferData) == null || (c = c.tracks) == null ? void 0 : c[l], F = A != null && A.buffer ? A : L, M = (F == null ? void 0 : F.pendingCodec) || (F == null ? void 0 : F.codec), H = F == null ? void 0 : F.levelCodec;
            L || (L = n1[l] = {
                buffer: void 0,
                listeners: [],
                codec: f,
                supplemental: b,
                container: y,
                levelCodec: p,
                metadata: E,
                id: h
            });
            const K = fo(M, H), j = K == null ? void 0 : K.replace(Kh, "$1");
            let C = fo(f, p);
            const k = (u = C) == null ? void 0 : u.replace(Kh, "$1");
            C && K && j !== k && (l.slice(0, 5) === "audio" && (C = Xo(C, this.appendSource)), this.log(`switching codec ${M} to ${C}`), C !== (L.pendingCodec || L.codec) && (L.pendingCodec = C), L.container = y, this.appendChangeType(l, y, C));
        }), (this.tracksReady || this.sourceBufferCount) && (t.tracks = this.sourceBufferTracks), !this.sourceBufferCount && (this.bufferCodecEventsTotal > 1 && !this.tracks.video && !t.video && ((r = t.audio) == null ? void 0 : r.id) === "main" && (this.log("Main audio-only"), this.bufferCodecEventsTotal = 1), this.mediaSourceOpenOrEnded && this.checkPendingTracks());
    }
    get sourceBufferTracks() {
        return Object.keys(this.tracks).reduce((e, t)=>{
            const r = this.tracks[t];
            return e[t] = {
                id: r.id,
                container: r.container,
                codec: r.codec,
                levelCodec: r.levelCodec
            }, e;
        }, {});
    }
    appendChangeType(e, t, r) {
        const n1 = `${t};codecs=${r}`, i = {
            label: `change-type=${n1}`,
            execute: ()=>{
                const o = this.tracks[e];
                if (o) {
                    const a = o.buffer;
                    a != null && a.changeType && (this.log(`changing ${e} sourceBuffer type to ${n1}`), a.changeType(n1), o.codec = r, o.container = t);
                }
                this.shiftAndExecuteNext(e);
            },
            onStart: ()=>{},
            onComplete: ()=>{},
            onError: (o)=>{
                this.warn(`Failed to change ${e} SourceBuffer type`, o);
            }
        };
        this.append(i, e, this.isPending(this.tracks[e]));
    }
    blockAudio(e) {
        var t;
        const r = e.start, n1 = r + e.duration * 0.05;
        if (((t = this.fragmentTracker.getAppendedFrag(r, pe.MAIN)) == null ? void 0 : t.gap) === !0) return;
        const o = {
            label: "block-audio",
            execute: ()=>{
                var a;
                const l = this.tracks.video;
                (this.lastVideoAppendEnd > n1 || l != null && l.buffer && Ce.isBuffered(l.buffer, n1) || ((a = this.fragmentTracker.getAppendedFrag(n1, pe.MAIN)) == null ? void 0 : a.gap) === !0) && (this.blockedAudioAppend = null, this.shiftAndExecuteNext("audio"));
            },
            onStart: ()=>{},
            onComplete: ()=>{},
            onError: (a)=>{
                this.warn("Error executing block-audio operation", a);
            }
        };
        this.blockedAudioAppend = {
            op: o,
            frag: e
        }, this.append(o, "audio", !0);
    }
    unblockAudio() {
        const { blockedAudioAppend: e, operationQueue: t } = this;
        e && t && (this.blockedAudioAppend = null, t.unblockAudio(e.op));
    }
    onBufferAppending(e, t) {
        const { tracks: r } = this, { data: n1, type: i, parent: o, frag: a, part: l, chunkMeta: c, offset: u } = t, d1 = c.buffering[i], { sn: h, cc: f } = a, p = self.performance.now();
        d1.start = p;
        const y = a.stats.buffering, E = l ? l.stats.buffering : null;
        y.start === 0 && (y.start = p), E && E.start === 0 && (E.start = p);
        const b = r.audio;
        let L = !1;
        i === "audio" && (b == null ? void 0 : b.container) === "audio/mpeg" && (L = !this.lastMpegAudioChunk || c.id === 1 || this.lastMpegAudioChunk.sn !== c.sn, this.lastMpegAudioChunk = c);
        const A = r.video, F = A == null ? void 0 : A.buffer;
        if (F && h !== "initSegment") {
            const K = l || a, j = this.blockedAudioAppend;
            if (i === "audio" && o !== "main" && !this.blockedAudioAppend && !(A.ending || A.ended)) {
                const k = K.start + K.duration * 0.05, $ = F.buffered, W = this.currentOp("video");
                !$.length && !W ? this.blockAudio(K) : !W && !Ce.isBuffered(F, k) && this.lastVideoAppendEnd < k && this.blockAudio(K);
            } else if (i === "video") {
                const C = K.end;
                if (j) {
                    const k = j.frag.start;
                    (C > k || C < this.lastVideoAppendEnd || Ce.isBuffered(F, k)) && this.unblockAudio();
                }
                this.lastVideoAppendEnd = C;
            }
        }
        const M = (l || a).start, H = {
            label: `append-${i}`,
            execute: ()=>{
                var K;
                d1.executeStart = self.performance.now();
                const j = (K = this.tracks[i]) == null ? void 0 : K.buffer;
                j && (L ? this.updateTimestampOffset(j, M, 0.1, i, h, f) : u !== void 0 && ue(u) && this.updateTimestampOffset(j, u, 1e-6, i, h, f)), this.appendExecutor(n1, i);
            },
            onStart: ()=>{},
            onComplete: ()=>{
                const K = self.performance.now();
                d1.executeEnd = d1.end = K, y.first === 0 && (y.first = K), E && E.first === 0 && (E.first = K);
                const j = {};
                this.sourceBuffers.forEach(([C, k])=>{
                    C && (j[C] = Ce.getBuffered(k));
                }), this.appendErrors[i] = 0, i === "audio" || i === "video" ? this.appendErrors.audiovideo = 0 : (this.appendErrors.audio = 0, this.appendErrors.video = 0), this.hls.trigger(I.BUFFER_APPENDED, {
                    type: i,
                    frag: a,
                    part: l,
                    chunkMeta: c,
                    parent: a.type,
                    timeRanges: j
                });
            },
            onError: (K)=>{
                var j;
                const C = {
                    type: ve.MEDIA_ERROR,
                    parent: a.type,
                    details: J.BUFFER_APPEND_ERROR,
                    sourceBufferName: i,
                    frag: a,
                    part: l,
                    chunkMeta: c,
                    error: K,
                    err: K,
                    fatal: !1
                }, k = (j = this.media) == null ? void 0 : j.error;
                if (K.code === DOMException.QUOTA_EXCEEDED_ERR || K.name == "QuotaExceededError" || "quota" in K) C.details = J.BUFFER_FULL_ERROR;
                else if (K.code === DOMException.INVALID_STATE_ERR && this.mediaSourceOpenOrEnded && !k) C.errorAction = Tn(!0);
                else if (K.name === Ip && this.sourceBufferCount === 0) C.errorAction = Tn(!0);
                else {
                    const $ = ++this.appendErrors[i];
                    this.warn(`Failed ${$}/${this.hls.config.appendErrorMaxRetry} times to append segment in "${i}" sourceBuffer (${k || "no media error"})`), ($ >= this.hls.config.appendErrorMaxRetry || k) && (C.fatal = !0);
                }
                this.hls.trigger(I.ERROR, C);
            }
        };
        this.log(`queuing "${i}" append sn: ${h}${l ? " p: " + l.index : ""} of ${a.type === pe.MAIN ? "level" : "track"} ${a.level} cc: ${f}`), this.append(H, i, this.isPending(this.tracks[i]));
    }
    getFlushOp(e, t, r) {
        return this.log(`queuing "${e}" remove ${t}-${r}`), {
            label: "remove",
            execute: ()=>{
                this.removeExecutor(e, t, r);
            },
            onStart: ()=>{},
            onComplete: ()=>{
                this.hls.trigger(I.BUFFER_FLUSHED, {
                    type: e
                });
            },
            onError: (n1)=>{
                this.warn(`Failed to remove ${t}-${r} from "${e}" SourceBuffer`, n1);
            }
        };
    }
    onBufferFlushing(e, t) {
        const { type: r, startOffset: n1, endOffset: i } = t;
        r ? this.append(this.getFlushOp(r, n1, i), r) : this.sourceBuffers.forEach(([o])=>{
            o && this.append(this.getFlushOp(o, n1, i), o);
        });
    }
    onFragParsed(e, t) {
        const { frag: r, part: n1 } = t, i = [], o = n1 ? n1.elementaryStreams : r.elementaryStreams;
        o[ot.AUDIOVIDEO] ? i.push("audiovideo") : (o[ot.AUDIO] && i.push("audio"), o[ot.VIDEO] && i.push("video"));
        const a = ()=>{
            const l = self.performance.now();
            r.stats.buffering.end = l, n1 && (n1.stats.buffering.end = l);
            const c = n1 ? n1.stats : r.stats;
            this.hls.trigger(I.FRAG_BUFFERED, {
                frag: r,
                part: n1,
                stats: c,
                id: r.type
            });
        };
        i.length === 0 && this.warn(`Fragments must have at least one ElementaryStreamType set. type: ${r.type} level: ${r.level} sn: ${r.sn}`), this.blockBuffers(a, i).catch((l)=>{
            this.warn(`Fragment buffered callback ${l}`), this.stepOperationQueue(this.sourceBufferTypes);
        });
    }
    onFragChanged(e, t) {
        this.trimBuffers();
    }
    get bufferedToEnd() {
        return this.sourceBufferCount > 0 && !this.sourceBuffers.some(([e])=>{
            if (e) {
                const t = this.tracks[e];
                if (t) return !t.ended || t.ending;
            }
            return !1;
        });
    }
    // on BUFFER_EOS mark matching sourcebuffer(s) as "ending" and "ended" and queue endOfStream after remaining operations(s)
    // an undefined data.type will mark all buffers as EOS.
    onBufferEos(e, t) {
        var r;
        this.sourceBuffers.forEach(([o])=>{
            if (o) {
                const a = this.tracks[o];
                (!t.type || t.type === o) && (a.ending = !0, a.ended || (a.ended = !0, this.log(`${o} buffer reached EOS`)));
            }
        });
        const n1 = ((r = this.overrides) == null ? void 0 : r.endOfStream) !== !1;
        this.sourceBufferCount > 0 && !this.sourceBuffers.some(([o])=>{
            var a;
            return o && !((a = this.tracks[o]) != null && a.ended);
        }) ? n1 ? (this.log("Queueing EOS"), this.blockUntilOpen(()=>{
            this.tracksEnded();
            const { mediaSource: o } = this;
            if (!o || o.readyState !== "open") {
                o && this.log(`Could not call mediaSource.endOfStream(). mediaSource.readyState: ${o.readyState}`);
                return;
            }
            this.log("Calling mediaSource.endOfStream()"), o.endOfStream(), this.hls.trigger(I.BUFFERED_TO_END, void 0);
        })) : (this.tracksEnded(), this.hls.trigger(I.BUFFERED_TO_END, void 0)) : t.type === "video" && this.unblockAudio();
    }
    tracksEnded() {
        this.sourceBuffers.forEach(([e])=>{
            if (e !== null) {
                const t = this.tracks[e];
                t && (t.ending = !1);
            }
        });
    }
    onLevelUpdated(e, { details: t }) {
        t.fragments.length && (this.details = t, this.updateDuration());
    }
    updateDuration() {
        this.blockUntilOpen(()=>{
            const e = this.getDurationAndRange();
            e && this.updateMediaSource(e);
        });
    }
    onError(e, t) {
        if (t.details === J.BUFFER_APPEND_ERROR && t.frag) {
            var r;
            const n1 = (r = t.errorAction) == null ? void 0 : r.nextAutoLevel;
            ue(n1) && n1 !== t.frag.level && this.resetAppendErrors();
        }
    }
    resetAppendErrors() {
        this.appendErrors = {
            audio: 0,
            video: 0,
            audiovideo: 0
        };
    }
    trimBuffers() {
        const { hls: e, details: t, media: r } = this;
        if (!r || t === null || !this.sourceBufferCount) return;
        const n1 = e.config, i = r.currentTime, o = t.levelTargetDuration, a = t.live && n1.liveBackBufferLength !== null ? n1.liveBackBufferLength : n1.backBufferLength;
        if (ue(a) && a >= 0) {
            const c = Math.max(a, o), u = Math.floor(i / o) * o - c;
            this.flushBackBuffer(i, o, u);
        }
        const l = n1.frontBufferFlushThreshold;
        if (ue(l) && l > 0) {
            const c = Math.max(n1.maxBufferLength, l), u = Math.max(c, o), d1 = Math.floor(i / o) * o + u;
            this.flushFrontBuffer(i, o, d1);
        }
    }
    flushBackBuffer(e, t, r) {
        this.sourceBuffers.forEach(([n1, i])=>{
            if (i) {
                const a = Ce.getBuffered(i);
                if (a.length > 0 && r > a.start(0)) {
                    var o;
                    this.hls.trigger(I.BACK_BUFFER_REACHED, {
                        bufferEnd: r
                    });
                    const l = this.tracks[n1];
                    if ((o = this.details) != null && o.live) this.hls.trigger(I.LIVE_BACK_BUFFER_REACHED, {
                        bufferEnd: r
                    });
                    else if (l != null && l.ended) {
                        this.log(`Cannot flush ${n1} back buffer while SourceBuffer is in ended state`);
                        return;
                    }
                    this.hls.trigger(I.BUFFER_FLUSHING, {
                        startOffset: 0,
                        endOffset: r,
                        type: n1
                    });
                }
            }
        });
    }
    flushFrontBuffer(e, t, r) {
        this.sourceBuffers.forEach(([n1, i])=>{
            if (i) {
                const o = Ce.getBuffered(i), a = o.length;
                if (a < 2) return;
                const l = o.start(a - 1), c = o.end(a - 1);
                if (r > l || e >= l && e <= c) return;
                this.hls.trigger(I.BUFFER_FLUSHING, {
                    startOffset: l,
                    endOffset: 1 / 0,
                    type: n1
                });
            }
        });
    }
    /**
   * Update Media Source duration to current level duration or override to Infinity if configuration parameter
   * 'liveDurationInfinity` is set to `true`
   * More details: https://github.com/video-dev/hls.js/issues/355
   */ getDurationAndRange() {
        var e;
        const { details: t, mediaSource: r } = this;
        if (!t || !this.media || (r == null ? void 0 : r.readyState) !== "open") return null;
        const n1 = t.edge;
        if (t.live && this.hls.config.liveDurationInfinity) {
            if (t.fragments.length && r.setLiveSeekableRange) {
                const c = Math.max(0, t.fragmentStart), u = Math.max(c, n1);
                return {
                    duration: 1 / 0,
                    start: c,
                    end: u
                };
            }
            return {
                duration: 1 / 0
            };
        }
        const i = (e = this.overrides) == null ? void 0 : e.duration;
        if (i) return ue(i) ? {
            duration: i
        } : null;
        const o = this.media.duration, a = ue(r.duration) ? r.duration : 0;
        return n1 > a && n1 > o || !ue(o) ? {
            duration: n1
        } : null;
    }
    updateMediaSource({ duration: e, start: t, end: r }) {
        const n1 = this.mediaSource;
        !this.media || !n1 || n1.readyState !== "open" || (n1.duration !== e && (ue(e) && this.log(`Updating MediaSource duration to ${e.toFixed(3)}`), n1.duration = e), t !== void 0 && r !== void 0 && (this.log(`MediaSource duration is set to ${n1.duration}. Setting seekable range to ${t}-${r}.`), n1.setLiveSeekableRange(t, r)));
    }
    get tracksReady() {
        const e = this.pendingTrackCount;
        return e > 0 && (e >= this.bufferCodecEventsTotal || this.isPending(this.tracks.audiovideo));
    }
    checkPendingTracks() {
        const { bufferCodecEventsTotal: e, pendingTrackCount: t, tracks: r } = this;
        if (this.log(`checkPendingTracks (pending: ${t} codec events expected: ${e}) ${at(r)}`), this.tracksReady) {
            var n1;
            const i = (n1 = this.transferData) == null ? void 0 : n1.tracks;
            i && Object.keys(i).length ? this.attachTransferred() : this.createSourceBuffers();
        }
    }
    bufferCreated() {
        if (this.sourceBufferCount) {
            const e = {};
            this.sourceBuffers.forEach(([t, r])=>{
                if (t) {
                    const n1 = this.tracks[t];
                    e[t] = {
                        buffer: r,
                        container: n1.container,
                        codec: n1.codec,
                        supplemental: n1.supplemental,
                        levelCodec: n1.levelCodec,
                        id: n1.id,
                        metadata: n1.metadata
                    };
                }
            }), this.hls.trigger(I.BUFFER_CREATED, {
                tracks: e
            }), this.log(`SourceBuffers created. Running queue: ${this.operationQueue}`), this.sourceBuffers.forEach(([t])=>{
                this.executeNext(t);
            });
        } else {
            const e = new Error("could not create source buffer for media codec(s)");
            this.hls.trigger(I.ERROR, {
                type: ve.MEDIA_ERROR,
                details: J.BUFFER_INCOMPATIBLE_CODECS_ERROR,
                fatal: !0,
                error: e,
                reason: e.message
            });
        }
    }
    createSourceBuffers() {
        const { tracks: e, sourceBuffers: t, mediaSource: r } = this;
        if (!r) throw new Error("createSourceBuffers called when mediaSource was null");
        for(const i in e){
            const o = i, a = e[o];
            if (this.isPending(a)) {
                const l = this.getTrackCodec(a, o), c = `${a.container};codecs=${l}`;
                a.codec = l, this.log(`creating sourceBuffer(${c})${this.currentOp(o) ? " Queued" : ""} ${at(a)}`);
                try {
                    const u = r.addSourceBuffer(c), d1 = Sl(o), h = [
                        o,
                        u
                    ];
                    t[d1] = h, a.buffer = u;
                } catch (u) {
                    var n1;
                    this.error(`error while trying to add sourceBuffer: ${u.message}`), this.shiftAndExecuteNext(o), (n1 = this.operationQueue) == null || n1.removeBlockers(), delete this.tracks[o], this.hls.trigger(I.ERROR, {
                        type: ve.MEDIA_ERROR,
                        details: J.BUFFER_ADD_CODEC_ERROR,
                        fatal: !1,
                        error: u,
                        sourceBufferName: o,
                        mimeType: c,
                        parent: a.id
                    });
                    return;
                }
                this.trackSourceBuffer(o, a);
            }
        }
        this.bufferCreated();
    }
    getTrackCodec(e, t) {
        const r = e.supplemental;
        let n1 = e.codec;
        r && (t === "video" || t === "audiovideo") && gi(r, "video") && (n1 = XS(n1, r));
        const i = fo(n1, e.levelCodec);
        return i ? t.slice(0, 5) === "audio" ? Xo(i, this.appendSource) : i : "";
    }
    trackSourceBuffer(e, t) {
        const r = t.buffer;
        if (!r) return;
        const n1 = this.getTrackCodec(t, e);
        this.tracks[e] = {
            buffer: r,
            codec: n1,
            container: t.container,
            levelCodec: t.levelCodec,
            supplemental: t.supplemental,
            metadata: t.metadata,
            id: t.id,
            listeners: []
        }, this.removeBufferListeners(e), this.addBufferListener(e, "updatestart", this.onSBUpdateStart), this.addBufferListener(e, "updateend", this.onSBUpdateEnd), this.addBufferListener(e, "error", this.onSBUpdateError), this.appendSource && this.addBufferListener(e, "bufferedchange", (i, o)=>{
            const a = o.removedRanges;
            a != null && a.length && this.hls.trigger(I.BUFFER_FLUSHED, {
                type: i
            });
        });
    }
    get mediaSrc() {
        var e, t;
        const r = ((e = this.media) == null || (t = e.querySelector) == null ? void 0 : t.call(e, "source")) || this.media;
        return r == null ? void 0 : r.src;
    }
    onSBUpdateStart(e) {
        const t = this.currentOp(e);
        t && t.onStart();
    }
    onSBUpdateEnd(e) {
        var t;
        if (((t = this.mediaSource) == null ? void 0 : t.readyState) === "closed") {
            this.resetBuffer(e);
            return;
        }
        const r = this.currentOp(e);
        r && (r.onComplete(), this.shiftAndExecuteNext(e));
    }
    onSBUpdateError(e, t) {
        var r;
        const n1 = new Error(`${e} SourceBuffer error. MediaSource readyState: ${(r = this.mediaSource) == null ? void 0 : r.readyState}`);
        this.error(`${n1}`, t), this.hls.trigger(I.ERROR, {
            type: ve.MEDIA_ERROR,
            details: J.BUFFER_APPENDING_ERROR,
            sourceBufferName: e,
            error: n1,
            fatal: !1
        });
        const i = this.currentOp(e);
        i && i.onError(n1);
    }
    updateTimestampOffset(e, t, r, n1, i, o) {
        const a = t - e.timestampOffset;
        Math.abs(a) >= r && (this.log(`Updating ${n1} SourceBuffer timestampOffset to ${t} (sn: ${i} cc: ${o})`), e.timestampOffset = t);
    }
    // This method must result in an updateend event; if remove is not called, onSBUpdateEnd must be called manually
    removeExecutor(e, t, r) {
        const { media: n1, mediaSource: i } = this, o = this.tracks[e], a = o == null ? void 0 : o.buffer;
        if (!n1 || !i || !a) {
            this.warn(`Attempting to remove from the ${e} SourceBuffer, but it does not exist`), this.shiftAndExecuteNext(e);
            return;
        }
        const l = ue(n1.duration) ? n1.duration : 1 / 0, c = ue(i.duration) ? i.duration : 1 / 0, u = Math.max(0, t), d1 = Math.min(r, l, c);
        d1 > u && (!o.ending || o.ended) ? (o.ended = !1, this.log(`Removing [${u},${d1}] from the ${e} SourceBuffer`), a.remove(u, d1)) : this.shiftAndExecuteNext(e);
    }
    // This method must result in an updateend event; if append is not called, onSBUpdateEnd must be called manually
    appendExecutor(e, t) {
        const r = this.tracks[t], n1 = r == null ? void 0 : r.buffer;
        if (!n1) throw new a2(`Attempting to append to the ${t} SourceBuffer, but it does not exist`);
        r.ending = !1, r.ended = !1, n1.appendBuffer(e);
    }
    blockUntilOpen(e) {
        if (this.isUpdating() || this.isQueued()) this.blockBuffers(e).catch((t)=>{
            this.warn(`SourceBuffer blocked callback ${t}`), this.stepOperationQueue(this.sourceBufferTypes);
        });
        else try {
            e();
        } catch (t) {
            this.warn(`Callback run without blocking ${this.operationQueue} ${t}`);
        }
    }
    isUpdating() {
        return this.sourceBuffers.some(([e, t])=>e && t.updating);
    }
    isQueued() {
        return this.sourceBuffers.some(([e])=>e && !!this.currentOp(e));
    }
    isPending(e) {
        return !!e && !e.buffer;
    }
    // Enqueues an operation to each SourceBuffer queue which, upon execution, resolves a promise. When all promises
    // resolve, the onUnblocked function is executed. Functions calling this method do not need to unblock the queue
    // upon completion, since we already do it here
    blockBuffers(e, t = this.sourceBufferTypes) {
        if (!t.length) return this.log("Blocking operation requested, but no SourceBuffers exist"), Promise.resolve().then(e);
        const { operationQueue: r } = this, n1 = t.map((o)=>this.appendBlocker(o));
        return t.length > 1 && !!this.blockedAudioAppend && this.unblockAudio(), Promise.all(n1).then((o)=>{
            r === this.operationQueue && (e(), this.stepOperationQueue(this.sourceBufferTypes));
        });
    }
    stepOperationQueue(e) {
        e.forEach((t)=>{
            var r;
            const n1 = (r = this.tracks[t]) == null ? void 0 : r.buffer;
            !n1 || n1.updating || this.shiftAndExecuteNext(t);
        });
    }
    append(e, t, r) {
        this.operationQueue && this.operationQueue.append(e, t, r);
    }
    appendBlocker(e) {
        if (this.operationQueue) return this.operationQueue.appendBlocker(e);
    }
    currentOp(e) {
        return this.operationQueue ? this.operationQueue.current(e) : null;
    }
    executeNext(e) {
        e && this.operationQueue && this.operationQueue.executeNext(e);
    }
    shiftAndExecuteNext(e) {
        this.operationQueue && this.operationQueue.shiftAndExecuteNext(e);
    }
    get pendingTrackCount() {
        return Object.keys(this.tracks).reduce((e, t)=>e + (this.isPending(this.tracks[t]) ? 1 : 0), 0);
    }
    get sourceBufferCount() {
        return this.sourceBuffers.reduce((e, [t])=>e + (t ? 1 : 0), 0);
    }
    get sourceBufferTypes() {
        return this.sourceBuffers.map(([e])=>e).filter((e)=>!!e);
    }
    addBufferListener(e, t, r) {
        const n1 = this.tracks[e];
        if (!n1) return;
        const i = n1.buffer;
        if (!i) return;
        const o = r.bind(this, e);
        n1.listeners.push({
            event: t,
            listener: o
        }), i.addEventListener(t, o);
    }
    removeBufferListeners(e) {
        const t = this.tracks[e];
        if (!t) return;
        const r = t.buffer;
        r && (t.listeners.forEach((n1)=>{
            r.removeEventListener(n1.event, n1.listener);
        }), t.listeners.length = 0);
    }
}
function Hh(s) {
    const e = s.querySelectorAll("source");
    [].slice.call(e).forEach((t)=>{
        s.removeChild(t);
    });
}
function c2(s, e) {
    const t = self.document.createElement("source");
    t.type = "video/mp4", t.src = e, s.appendChild(t);
}
function Sl(s) {
    return s === "audio" ? 1 : 0;
}
class Du {
    constructor(e){
        this.hls = void 0, this.autoLevelCapping = void 0, this.firstLevel = void 0, this.media = void 0, this.restrictedLevels = void 0, this.timer = void 0, this.clientRect = void 0, this.streamController = void 0, this.hls = e, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.firstLevel = -1, this.media = null, this.restrictedLevels = [], this.timer = void 0, this.clientRect = null, this.registerListeners();
    }
    setStreamController(e) {
        this.streamController = e;
    }
    destroy() {
        this.hls && this.unregisterListener(), this.timer && this.stopCapping(), this.media = null, this.clientRect = null, this.hls = this.streamController = null;
    }
    registerListeners() {
        const { hls: e } = this;
        e.on(I.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), e.on(I.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(I.MANIFEST_PARSED, this.onManifestParsed, this), e.on(I.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(I.BUFFER_CODECS, this.onBufferCodecs, this), e.on(I.MEDIA_DETACHING, this.onMediaDetaching, this);
    }
    unregisterListener() {
        const { hls: e } = this;
        e.off(I.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), e.off(I.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(I.MANIFEST_PARSED, this.onManifestParsed, this), e.off(I.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(I.BUFFER_CODECS, this.onBufferCodecs, this), e.off(I.MEDIA_DETACHING, this.onMediaDetaching, this);
    }
    onFpsDropLevelCapping(e, t) {
        const r = this.hls.levels[t.droppedLevel];
        this.isLevelAllowed(r) && this.restrictedLevels.push({
            bitrate: r.bitrate,
            height: r.height,
            width: r.width
        });
    }
    onMediaAttaching(e, t) {
        this.media = t.media instanceof HTMLVideoElement ? t.media : null, this.clientRect = null, this.timer && this.hls.levels.length && this.detectPlayerSize();
    }
    onManifestParsed(e, t) {
        const r = this.hls;
        this.restrictedLevels = [], this.firstLevel = t.firstLevel, r.config.capLevelToPlayerSize && t.video && this.startCapping();
    }
    onLevelsUpdated(e, t) {
        this.timer && ue(this.autoLevelCapping) && this.detectPlayerSize();
    }
    // Only activate capping when playing a video stream; otherwise, multi-bitrate audio-only streams will be restricted
    // to the first level
    onBufferCodecs(e, t) {
        this.hls.config.capLevelToPlayerSize && t.video && this.startCapping();
    }
    onMediaDetaching() {
        this.stopCapping(), this.media = null;
    }
    detectPlayerSize() {
        if (this.media) {
            if (this.mediaHeight <= 0 || this.mediaWidth <= 0) {
                this.clientRect = null;
                return;
            }
            const e = this.hls.levels;
            if (e.length) {
                const t = this.hls, r = this.getMaxLevel(e.length - 1);
                r !== this.autoLevelCapping && t.logger.log(`Setting autoLevelCapping to ${r}: ${e[r].height}p@${e[r].bitrate} for media ${this.mediaWidth}x${this.mediaHeight}`), t.autoLevelCapping = r, t.autoLevelEnabled && t.autoLevelCapping > this.autoLevelCapping && this.streamController && this.streamController.nextLevelSwitch(), this.autoLevelCapping = t.autoLevelCapping;
            }
        }
    }
    /*
   * returns level should be the one with the dimensions equal or greater than the media (player) dimensions (so the video will be downscaled)
   */ getMaxLevel(e) {
        const t = this.hls.levels;
        if (!t.length) return -1;
        const r = t.filter((n1, i)=>this.isLevelAllowed(n1) && i <= e);
        return this.clientRect = null, Du.getMaxLevelByMediaSize(r, this.mediaWidth, this.mediaHeight);
    }
    startCapping() {
        this.timer || (this.autoLevelCapping = Number.POSITIVE_INFINITY, self.clearInterval(this.timer), this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1e3), this.detectPlayerSize());
    }
    stopCapping() {
        this.restrictedLevels = [], this.firstLevel = -1, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.timer && (self.clearInterval(this.timer), this.timer = void 0);
    }
    getDimensions() {
        if (this.clientRect) return this.clientRect;
        const e = this.media, t = {
            width: 0,
            height: 0
        };
        if (e) {
            const r = e.getBoundingClientRect();
            t.width = r.width, t.height = r.height, !t.width && !t.height && (t.width = r.right - r.left || e.width || 0, t.height = r.bottom - r.top || e.height || 0);
        }
        return this.clientRect = t, t;
    }
    get mediaWidth() {
        return this.getDimensions().width * this.contentScaleFactor;
    }
    get mediaHeight() {
        return this.getDimensions().height * this.contentScaleFactor;
    }
    get contentScaleFactor() {
        let e = 1;
        if (!this.hls.config.ignoreDevicePixelRatio) try {
            e = self.devicePixelRatio;
        } catch  {}
        return Math.min(e, this.hls.config.maxDevicePixelRatio);
    }
    isLevelAllowed(e) {
        return !this.restrictedLevels.some((r)=>e.bitrate === r.bitrate && e.width === r.width && e.height === r.height);
    }
    static getMaxLevelByMediaSize(e, t, r) {
        if (!(e != null && e.length)) return -1;
        const n1 = (a, l)=>l ? a.width !== l.width || a.height !== l.height : !0;
        let i = e.length - 1;
        const o = Math.max(t, r);
        for(let a = 0; a < e.length; a += 1){
            const l = e[a];
            if ((l.width >= o || l.height >= o) && n1(l, e[a + 1])) {
                i = a;
                break;
            }
        }
        return i;
    }
}
const u2 = {
    /**
   * text file, such as a manifest or playlist
   */ MANIFEST: "m",
    /**
   * audio only
   */ AUDIO: "a",
    /**
   * video only
   */ VIDEO: "v",
    /**
   * muxed audio and video
   */ MUXED: "av",
    /**
   * init segment
   */ INIT: "i",
    /**
   * caption or subtitle
   */ CAPTION: "c",
    /**
   * ISOBMFF timed text track
   */ TIMED_TEXT: "tt",
    /**
   * cryptographic key, license or certificate.
   */ KEY: "k",
    /**
   * other
   */ OTHER: "o"
}, hr = u2, d2 = {
    /**
   * HTTP Live Streaming (HLS)
   */ HLS: "h"
}, h2 = d2;
class Jr {
    constructor(e, t){
        Array.isArray(e) && (e = e.map((r)=>r instanceof Jr ? r : new Jr(r))), this.value = e, this.params = t;
    }
}
const f2 = "Dict";
function g2(s) {
    return Array.isArray(s) ? JSON.stringify(s) : s instanceof Map ? "Map{}" : s instanceof Set ? "Set{}" : typeof s == "object" ? JSON.stringify(s) : String(s);
}
function p2(s, e, t, r) {
    return new Error(`failed to ${s} "${g2(e)}" as ${t}`, {
        cause: r
    });
}
function Qr(s, e, t) {
    return p2("serialize", s, e, t);
}
class _p {
    constructor(e){
        this.description = e;
    }
}
const qh = "Bare Item", m2 = "Boolean";
function y2(s) {
    if (typeof s != "boolean") throw Qr(s, m2);
    return s ? "?1" : "?0";
}
function v2(s) {
    return btoa(String.fromCharCode(...s));
}
const E2 = "Byte Sequence";
function x2(s) {
    if (ArrayBuffer.isView(s) === !1) throw Qr(s, E2);
    return `:${v2(s)}:`;
}
const S2 = "Integer";
function b2(s) {
    return s < -999999999999999 || 999999999999999 < s;
}
function Lp(s) {
    if (b2(s)) throw Qr(s, S2);
    return s.toString();
}
function T2(s) {
    return `@${Lp(s.getTime() / 1e3)}`;
}
function Rp(s, e) {
    if (s < 0) return -Rp(-s, e);
    const t = Math.pow(10, e);
    if (Math.abs(s * t % 1 - 0.5) < Number.EPSILON) {
        const n1 = Math.floor(s * t);
        return (n1 % 2 === 0 ? n1 : n1 + 1) / t;
    } else return Math.round(s * t) / t;
}
const w2 = "Decimal";
function A2(s) {
    const e = Rp(s, 3);
    if (Math.floor(Math.abs(e)).toString().length > 12) throw Qr(s, w2);
    const t = e.toString();
    return t.includes(".") ? t : `${t}.0`;
}
const I2 = "String", _2 = /[\x00-\x1f\x7f]+/;
function L2(s) {
    if (_2.test(s)) throw Qr(s, I2);
    return `"${s.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"`;
}
function R2(s) {
    return s.description || s.toString().slice(7, -1);
}
const C2 = "Token";
function Wh(s) {
    const e = R2(s);
    if (/^([a-zA-Z*])([!#$%&'*+\-.^_`|~\w:/]*)$/.test(e) === !1) throw Qr(e, C2);
    return e;
}
function vc(s) {
    switch(typeof s){
        case "number":
            if (!ue(s)) throw Qr(s, qh);
            return Number.isInteger(s) ? Lp(s) : A2(s);
        case "string":
            return L2(s);
        case "symbol":
            return Wh(s);
        case "boolean":
            return y2(s);
        case "object":
            if (s instanceof Date) return T2(s);
            if (s instanceof Uint8Array) return x2(s);
            if (s instanceof _p) return Wh(s);
        default:
            throw Qr(s, qh);
    }
}
const k2 = "Key";
function Ec(s) {
    if (/^[a-z*][a-z0-9\-_.*]*$/.test(s) === !1) throw Qr(s, k2);
    return s;
}
function Pu(s) {
    return s == null ? "" : Object.entries(s).map(([e, t])=>t === !0 ? `;${Ec(e)}` : `;${Ec(e)}=${vc(t)}`).join("");
}
function Cp(s) {
    return s instanceof Jr ? `${vc(s.value)}${Pu(s.params)}` : vc(s);
}
function D2(s) {
    return `(${s.value.map(Cp).join(" ")})${Pu(s.params)}`;
}
function P2(s, e = {
    whitespace: !0
}) {
    if (typeof s != "object" || s == null) throw Qr(s, f2);
    const t = s instanceof Map ? s.entries() : Object.entries(s), r = e != null && e.whitespace ? " " : "";
    return Array.from(t).map(([n1, i])=>{
        i instanceof Jr || (i = new Jr(i));
        let o = Ec(n1);
        return i.value === !0 ? o += Pu(i.params) : (o += "=", Array.isArray(i.value) ? o += D2(i) : o += Cp(i)), o;
    }).join(`,${r}`);
}
function kp(s, e) {
    return P2(s, e);
}
const $r = "CMCD-Object", yt = "CMCD-Request", Fs = "CMCD-Session", bs = "CMCD-Status", M2 = {
    // Object
    br: $r,
    ab: $r,
    d: $r,
    ot: $r,
    tb: $r,
    tpb: $r,
    lb: $r,
    tab: $r,
    lab: $r,
    url: $r,
    // Request
    pb: yt,
    bl: yt,
    tbl: yt,
    dl: yt,
    ltc: yt,
    mtp: yt,
    nor: yt,
    nrr: yt,
    rc: yt,
    sn: yt,
    sta: yt,
    su: yt,
    ttfb: yt,
    ttfbb: yt,
    ttlb: yt,
    cmsdd: yt,
    cmsds: yt,
    smrt: yt,
    df: yt,
    cs: yt,
    // TODO: Which header to put the `ts` field is not defined yet.
    ts: yt,
    // Session
    cid: Fs,
    pr: Fs,
    sf: Fs,
    sid: Fs,
    st: Fs,
    v: Fs,
    msd: Fs,
    // Status
    bs,
    bsd: bs,
    cdn: bs,
    rtp: bs,
    bg: bs,
    pt: bs,
    ec: bs,
    e: bs
}, O2 = {
    /**
   * keys whose values vary with each request.
   */ REQUEST: yt
};
function B2(s) {
    return Object.keys(s).reduce((e, t)=>{
        var r;
        return (r = s[t]) === null || r === void 0 || r.forEach((n1)=>e[n1] = t), e;
    }, {});
}
function F2(s, e) {
    const t = {};
    if (!s) return t;
    const r = Object.keys(s), n1 = e ? B2(e) : {};
    return r.reduce((i, o)=>{
        var a;
        const l = M2[o] || n1[o] || O2.REQUEST, c = (a = i[l]) !== null && a !== void 0 ? a : i[l] = {};
        return c[o] = s[o], i;
    }, t);
}
function N2(s) {
    return [
        "ot",
        "sf",
        "st",
        "e",
        "sta"
    ].includes(s);
}
function U2(s) {
    return typeof s == "number" ? ue(s) : s != null && s !== "" && s !== !1;
}
const Dp = "event";
function $2(s, e) {
    const t = new URL(s), r = new URL(e);
    if (t.origin !== r.origin) return s;
    const n1 = t.pathname.split("/").slice(1), i = r.pathname.split("/").slice(1, -1);
    for(; n1[0] === i[0];)n1.shift(), i.shift();
    for(; i.length;)i.shift(), n1.unshift("..");
    return n1.join("/") + t.search + t.hash;
}
const vo = (s)=>Math.round(s), xc = (s, e)=>Array.isArray(s) ? s.map((t)=>xc(t, e)) : s instanceof Jr && typeof s.value == "string" ? new Jr(xc(s.value, e), s.params) : (e.baseUrl && (s = $2(s, e.baseUrl)), e.version === 1 ? encodeURIComponent(s) : s), Xi = (s)=>vo(s / 100) * 100, G2 = (s, e)=>{
    let t = s;
    return e.version >= 2 && (s instanceof Jr && typeof s.value == "string" ? t = new Jr([
        s
    ]) : typeof s == "string" && (t = [
        s
    ])), xc(t, e);
}, V2 = {
    /**
   * Bitrate (kbps) rounded integer
   */ br: vo,
    /**
   * Duration (milliseconds) rounded integer
   */ d: vo,
    /**
   * Buffer Length (milliseconds) rounded nearest 100ms
   */ bl: Xi,
    /**
   * Deadline (milliseconds) rounded nearest 100ms
   */ dl: Xi,
    /**
   * Measured Throughput (kbps) rounded nearest 100kbps
   */ mtp: Xi,
    /**
   * Next Object Request URL encoded
   */ nor: G2,
    /**
   * Requested maximum throughput (kbps) rounded nearest 100kbps
   */ rtp: Xi,
    /**
   * Top Bitrate (kbps) rounded integer
   */ tb: vo
}, Pp = "request", Mp = "response", Mu = [
    "ab",
    "bg",
    "bl",
    "br",
    "bs",
    "bsd",
    "cdn",
    "cid",
    "cs",
    "df",
    "ec",
    "lab",
    "lb",
    "ltc",
    "msd",
    "mtp",
    "pb",
    "pr",
    "pt",
    "sf",
    "sid",
    "sn",
    "st",
    "sta",
    "tab",
    "tb",
    "tbl",
    "tpb",
    "ts",
    "v"
], j2 = [
    "e"
], K2 = /^[a-zA-Z0-9-.]+-[a-zA-Z0-9-.]+$/;
function Ea(s) {
    return K2.test(s);
}
function H2(s) {
    return Mu.includes(s) || j2.includes(s) || Ea(s);
}
const Op = [
    "d",
    "dl",
    "nor",
    "ot",
    "rtp",
    "su"
];
function q2(s) {
    return Mu.includes(s) || Op.includes(s) || Ea(s);
}
const W2 = [
    "cmsdd",
    "cmsds",
    "rc",
    "smrt",
    "ttfb",
    "ttfbb",
    "ttlb",
    "url"
];
function z2(s) {
    return Mu.includes(s) || Op.includes(s) || W2.includes(s) || Ea(s);
}
const Y2 = [
    "bl",
    "br",
    "bs",
    "cid",
    "d",
    "dl",
    "mtp",
    "nor",
    "nrr",
    "ot",
    "pr",
    "rtp",
    "sf",
    "sid",
    "st",
    "su",
    "tb",
    "v"
];
function Z2(s) {
    return Y2.includes(s) || Ea(s);
}
const X2 = {
    [Mp]: z2,
    [Dp]: H2,
    [Pp]: q2
};
function Bp(s, e = {}) {
    const t = {};
    if (s == null || typeof s != "object") return t;
    const r = e.version || s.v || 1, n1 = e.reportingMode || Pp, i = r === 1 ? Z2 : X2[n1];
    let o = Object.keys(s).filter(i);
    const a = e.filter;
    typeof a == "function" && (o = o.filter(a));
    const l = n1 === Mp || n1 === Dp;
    l && !o.includes("ts") && o.push("ts"), r > 1 && !o.includes("v") && o.push("v");
    const c = nt({}, V2, e.formatters), u = {
        version: r,
        reportingMode: n1,
        baseUrl: e.baseUrl
    };
    return o.sort().forEach((d1)=>{
        let h = s[d1];
        const f = c[d1];
        if (typeof f == "function" && (h = f(h, u)), d1 === "v") {
            if (r === 1) return;
            h = r;
        }
        d1 == "pr" && h === 1 || (l && d1 === "ts" && !ue(h) && (h = Date.now()), U2(h) && (N2(d1) && typeof h == "string" && (h = new _p(h)), t[d1] = h));
    }), t;
}
function J2(s, e = {}) {
    const t = {};
    if (!s) return t;
    const r = Bp(s, e), n1 = F2(r, e == null ? void 0 : e.customHeaderMap);
    return Object.entries(n1).reduce((i, [o, a])=>{
        const l = kp(a, {
            whitespace: !1
        });
        return l && (i[o] = l), i;
    }, t);
}
function Q2(s, e, t) {
    return nt(s, J2(e, t));
}
const ew = "CMCD";
function tw(s, e = {}) {
    return s ? kp(Bp(s, e), {
        whitespace: !1
    }) : "";
}
function rw(s, e = {}) {
    if (!s) return "";
    const t = tw(s, e);
    return encodeURIComponent(t);
}
function sw(s, e = {}) {
    if (!s) return "";
    const t = rw(s, e);
    return `${ew}=${t}`;
}
const zh = /CMCD=[^&#]+/;
function nw(s, e, t) {
    const r = sw(e, t);
    if (!r) return s;
    if (zh.test(s)) return s.replace(zh, r);
    const n1 = s.includes("?") ? "&" : "?";
    return `${s}${n1}${r}`;
}
class iw {
    constructor(e){
        this.hls = void 0, this.config = void 0, this.media = void 0, this.sid = void 0, this.cid = void 0, this.useHeaders = !1, this.includeKeys = void 0, this.initialized = !1, this.starved = !1, this.buffering = !0, this.audioBuffer = void 0, this.videoBuffer = void 0, this.onWaiting = ()=>{
            this.initialized && (this.starved = !0), this.buffering = !0;
        }, this.onPlaying = ()=>{
            this.initialized || (this.initialized = !0), this.buffering = !1;
        }, this.applyPlaylistData = (n1)=>{
            try {
                this.apply(n1, {
                    ot: hr.MANIFEST,
                    su: !this.initialized
                });
            } catch (i) {
                this.hls.logger.warn("Could not generate manifest CMCD data.", i);
            }
        }, this.applyFragmentData = (n1)=>{
            try {
                const { frag: i, part: o } = n1, a = this.hls.levels[i.level], l = this.getObjectType(i), c = {
                    d: (o || i).duration * 1e3,
                    ot: l
                };
                (l === hr.VIDEO || l === hr.AUDIO || l == hr.MUXED) && (c.br = a.bitrate / 1e3, c.tb = this.getTopBandwidth(l) / 1e3, c.bl = this.getBufferLength(l));
                const u = o ? this.getNextPart(o) : this.getNextFrag(i);
                u != null && u.url && u.url !== i.url && (c.nor = u.url), this.apply(n1, c);
            } catch (i) {
                this.hls.logger.warn("Could not generate segment CMCD data.", i);
            }
        }, this.hls = e;
        const t = this.config = e.config, { cmcd: r } = t;
        r != null && (t.pLoader = this.createPlaylistLoader(), t.fLoader = this.createFragmentLoader(), this.sid = r.sessionId || e.sessionId, this.cid = r.contentId, this.useHeaders = r.useHeaders === !0, this.includeKeys = r.includeKeys, this.registerListeners());
    }
    registerListeners() {
        const e = this.hls;
        e.on(I.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(I.MEDIA_DETACHED, this.onMediaDetached, this), e.on(I.BUFFER_CREATED, this.onBufferCreated, this);
    }
    unregisterListeners() {
        const e = this.hls;
        e.off(I.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(I.MEDIA_DETACHED, this.onMediaDetached, this), e.off(I.BUFFER_CREATED, this.onBufferCreated, this);
    }
    destroy() {
        this.unregisterListeners(), this.onMediaDetached(), this.hls = this.config = this.audioBuffer = this.videoBuffer = null, this.onWaiting = this.onPlaying = this.media = null;
    }
    onMediaAttached(e, t) {
        this.media = t.media, this.media.addEventListener("waiting", this.onWaiting), this.media.addEventListener("playing", this.onPlaying);
    }
    onMediaDetached() {
        this.media && (this.media.removeEventListener("waiting", this.onWaiting), this.media.removeEventListener("playing", this.onPlaying), this.media = null);
    }
    onBufferCreated(e, t) {
        var r, n1;
        this.audioBuffer = (r = t.tracks.audio) == null ? void 0 : r.buffer, this.videoBuffer = (n1 = t.tracks.video) == null ? void 0 : n1.buffer;
    }
    /**
   * Create baseline CMCD data
   */ createData() {
        var e;
        return {
            v: 1,
            sf: h2.HLS,
            sid: this.sid,
            cid: this.cid,
            pr: (e = this.media) == null ? void 0 : e.playbackRate,
            mtp: this.hls.bandwidthEstimate / 1e3
        };
    }
    /**
   * Apply CMCD data to a request.
   */ apply(e, t = {}) {
        nt(t, this.createData());
        const r = t.ot === hr.INIT || t.ot === hr.VIDEO || t.ot === hr.MUXED;
        this.starved && r && (t.bs = !0, t.su = !0, this.starved = !1), t.su == null && (t.su = this.buffering);
        const { includeKeys: n1 } = this;
        n1 && (t = Object.keys(t).reduce((o, a)=>(n1.includes(a) && (o[a] = t[a]), o), {}));
        const i = {
            baseUrl: e.url
        };
        this.useHeaders ? (e.headers || (e.headers = {}), Q2(e.headers, t, i)) : e.url = nw(e.url, t, i);
    }
    getNextFrag(e) {
        var t;
        const r = (t = this.hls.levels[e.level]) == null ? void 0 : t.details;
        if (r) {
            const n1 = e.sn - r.startSN;
            return r.fragments[n1 + 1];
        }
    }
    getNextPart(e) {
        var t;
        const { index: r, fragment: n1 } = e, i = (t = this.hls.levels[n1.level]) == null || (t = t.details) == null ? void 0 : t.partList;
        if (i) {
            const { sn: o } = n1;
            for(let a = i.length - 1; a >= 0; a--){
                const l = i[a];
                if (l.index === r && l.fragment.sn === o) return i[a + 1];
            }
        }
    }
    /**
   * The CMCD object type.
   */ getObjectType(e) {
        const { type: t } = e;
        if (t === "subtitle") return hr.TIMED_TEXT;
        if (e.sn === "initSegment") return hr.INIT;
        if (t === "audio") return hr.AUDIO;
        if (t === "main") return this.hls.audioTracks.length ? hr.VIDEO : hr.MUXED;
    }
    /**
   * Get the highest bitrate.
   */ getTopBandwidth(e) {
        let t = 0, r;
        const n1 = this.hls;
        if (e === hr.AUDIO) r = n1.audioTracks;
        else {
            const i = n1.maxAutoLevel, o = i > -1 ? i + 1 : n1.levels.length;
            r = n1.levels.slice(0, o);
        }
        return r.forEach((i)=>{
            i.bitrate > t && (t = i.bitrate);
        }), t > 0 ? t : NaN;
    }
    /**
   * Get the buffer length for a media type in milliseconds
   */ getBufferLength(e) {
        const t = this.media, r = e === hr.AUDIO ? this.audioBuffer : this.videoBuffer;
        return !r || !t ? NaN : Ce.bufferInfo(r, t.currentTime, this.config.maxBufferHole).len * 1e3;
    }
    /**
   * Create a playlist loader
   */ createPlaylistLoader() {
        const { pLoader: e } = this.config, t = this.applyPlaylistData, r = e || this.config.loader;
        return class {
            constructor(i){
                this.loader = void 0, this.loader = new r(i);
            }
            get stats() {
                return this.loader.stats;
            }
            get context() {
                return this.loader.context;
            }
            destroy() {
                this.loader.destroy();
            }
            abort() {
                this.loader.abort();
            }
            load(i, o, a) {
                t(i), this.loader.load(i, o, a);
            }
        };
    }
    /**
   * Create a playlist loader
   */ createFragmentLoader() {
        const { fLoader: e } = this.config, t = this.applyFragmentData, r = e || this.config.loader;
        return class {
            constructor(i){
                this.loader = void 0, this.loader = new r(i);
            }
            get stats() {
                return this.loader.stats;
            }
            get context() {
                return this.loader.context;
            }
            destroy() {
                this.loader.destroy();
            }
            abort() {
                this.loader.abort();
            }
            load(i, o, a) {
                t(i), this.loader.load(i, o, a);
            }
        };
    }
}
const ow = 3e5;
class aw extends Rr {
    constructor(e){
        super("content-steering", e.logger), this.hls = void 0, this.loader = null, this.uri = null, this.pathwayId = ".", this._pathwayPriority = null, this.timeToLoad = 300, this.reloadTimer = -1, this.updated = 0, this.started = !1, this.enabled = !0, this.levels = null, this.audioTracks = null, this.subtitleTracks = null, this.penalizedPathways = {}, this.hls = e, this.registerListeners();
    }
    registerListeners() {
        const e = this.hls;
        e.on(I.MANIFEST_LOADING, this.onManifestLoading, this), e.on(I.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(I.MANIFEST_PARSED, this.onManifestParsed, this), e.on(I.ERROR, this.onError, this);
    }
    unregisterListeners() {
        const e = this.hls;
        e && (e.off(I.MANIFEST_LOADING, this.onManifestLoading, this), e.off(I.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(I.MANIFEST_PARSED, this.onManifestParsed, this), e.off(I.ERROR, this.onError, this));
    }
    pathways() {
        return (this.levels || []).reduce((e, t)=>(e.indexOf(t.pathwayId) === -1 && e.push(t.pathwayId), e), []);
    }
    get pathwayPriority() {
        return this._pathwayPriority;
    }
    set pathwayPriority(e) {
        this.updatePathwayPriority(e);
    }
    startLoad() {
        if (this.started = !0, this.clearTimeout(), this.enabled && this.uri) {
            if (this.updated) {
                const e = this.timeToLoad * 1e3 - (performance.now() - this.updated);
                if (e > 0) {
                    this.scheduleRefresh(this.uri, e);
                    return;
                }
            }
            this.loadSteeringManifest(this.uri);
        }
    }
    stopLoad() {
        this.started = !1, this.loader && (this.loader.destroy(), this.loader = null), this.clearTimeout();
    }
    clearTimeout() {
        this.reloadTimer !== -1 && (self.clearTimeout(this.reloadTimer), this.reloadTimer = -1);
    }
    destroy() {
        this.unregisterListeners(), this.stopLoad(), this.hls = null, this.levels = this.audioTracks = this.subtitleTracks = null;
    }
    removeLevel(e) {
        const t = this.levels;
        t && (this.levels = t.filter((r)=>r !== e));
    }
    onManifestLoading() {
        this.stopLoad(), this.enabled = !0, this.timeToLoad = 300, this.updated = 0, this.uri = null, this.pathwayId = ".", this.levels = this.audioTracks = this.subtitleTracks = null;
    }
    onManifestLoaded(e, t) {
        const { contentSteering: r } = t;
        r !== null && (this.pathwayId = r.pathwayId, this.uri = r.uri, this.started && this.startLoad());
    }
    onManifestParsed(e, t) {
        this.audioTracks = t.audioTracks, this.subtitleTracks = t.subtitleTracks;
    }
    onError(e, t) {
        const { errorAction: r } = t;
        if ((r == null ? void 0 : r.action) === Zt.SendAlternateToPenaltyBox && r.flags === vr.MoveAllAlternatesMatchingHost) {
            const n1 = this.levels;
            let i = this._pathwayPriority, o = this.pathwayId;
            if (t.context) {
                const { groupId: a, pathwayId: l, type: c } = t.context;
                a && n1 ? o = this.getPathwayForGroupId(a, c, o) : l && (o = l);
            }
            o in this.penalizedPathways || (this.penalizedPathways[o] = performance.now()), !i && n1 && (i = this.pathways()), i && i.length > 1 && (this.updatePathwayPriority(i), r.resolved = this.pathwayId !== o), t.details === J.BUFFER_APPEND_ERROR && !t.fatal ? r.resolved = !0 : r.resolved || this.warn(`Could not resolve ${t.details} ("${t.error.message}") with content-steering for Pathway: ${o} levels: ${n1 && n1.length} priorities: ${at(i)} penalized: ${at(this.penalizedPathways)}`);
        }
    }
    filterParsedLevels(e) {
        this.levels = e;
        let t = this.getLevelsForPathway(this.pathwayId);
        if (t.length === 0) {
            const r = e[0].pathwayId;
            this.log(`No levels found in Pathway ${this.pathwayId}. Setting initial Pathway to "${r}"`), t = this.getLevelsForPathway(r), this.pathwayId = r;
        }
        return t.length !== e.length && this.log(`Found ${t.length}/${e.length} levels in Pathway "${this.pathwayId}"`), t;
    }
    getLevelsForPathway(e) {
        return this.levels === null ? [] : this.levels.filter((t)=>e === t.pathwayId);
    }
    updatePathwayPriority(e) {
        this._pathwayPriority = e;
        let t;
        const r = this.penalizedPathways, n1 = performance.now();
        Object.keys(r).forEach((i)=>{
            n1 - r[i] > ow && delete r[i];
        });
        for(let i = 0; i < e.length; i++){
            const o = e[i];
            if (o in r) continue;
            if (o === this.pathwayId) return;
            const a = this.hls.nextLoadLevel, l = this.hls.levels[a];
            if (t = this.getLevelsForPathway(o), t.length > 0) {
                this.log(`Setting Pathway to "${o}"`), this.pathwayId = o, rp(t), this.hls.trigger(I.LEVELS_UPDATED, {
                    levels: t
                });
                const c = this.hls.levels[a];
                l && c && this.levels && (c.attrs["STABLE-VARIANT-ID"] !== l.attrs["STABLE-VARIANT-ID"] && c.bitrate !== l.bitrate && this.log(`Unstable Pathways change from bitrate ${l.bitrate} to ${c.bitrate}`), this.hls.nextLoadLevel = a);
                break;
            }
        }
    }
    getPathwayForGroupId(e, t, r) {
        const n1 = this.getLevelsForPathway(r).concat(this.levels || []);
        for(let i = 0; i < n1.length; i++)if (t === Ke.AUDIO_TRACK && n1[i].hasAudioGroup(e) || t === Ke.SUBTITLE_TRACK && n1[i].hasSubtitleGroup(e)) return n1[i].pathwayId;
        return r;
    }
    clonePathways(e) {
        const t = this.levels;
        if (!t) return;
        const r = {}, n1 = {};
        e.forEach((i)=>{
            const { ID: o, "BASE-ID": a, "URI-REPLACEMENT": l } = i;
            if (t.some((u)=>u.pathwayId === o)) return;
            const c = this.getLevelsForPathway(a).map((u)=>{
                const d1 = new ft(u.attrs);
                d1["PATHWAY-ID"] = o;
                const h = d1.AUDIO && `${d1.AUDIO}_clone_${o}`, f = d1.SUBTITLES && `${d1.SUBTITLES}_clone_${o}`;
                h && (r[d1.AUDIO] = h, d1.AUDIO = h), f && (n1[d1.SUBTITLES] = f, d1.SUBTITLES = f);
                const p = Fp(u.uri, d1["STABLE-VARIANT-ID"], "PER-VARIANT-URIS", l), y = new mi({
                    attrs: d1,
                    audioCodec: u.audioCodec,
                    bitrate: u.bitrate,
                    height: u.height,
                    name: u.name,
                    url: p,
                    videoCodec: u.videoCodec,
                    width: u.width
                });
                if (u.audioGroups) for(let E = 1; E < u.audioGroups.length; E++)y.addGroupId("audio", `${u.audioGroups[E]}_clone_${o}`);
                if (u.subtitleGroups) for(let E = 1; E < u.subtitleGroups.length; E++)y.addGroupId("text", `${u.subtitleGroups[E]}_clone_${o}`);
                return y;
            });
            t.push(...c), Yh(this.audioTracks, r, l, o), Yh(this.subtitleTracks, n1, l, o);
        });
    }
    loadSteeringManifest(e) {
        const t = this.hls.config, r = t.loader;
        this.loader && this.loader.destroy(), this.loader = new r(t);
        let n1;
        try {
            n1 = new self.URL(e);
        } catch  {
            this.enabled = !1, this.log(`Failed to parse Steering Manifest URI: ${e}`);
            return;
        }
        if (n1.protocol !== "data:") {
            const u = (this.hls.bandwidthEstimate || t.abrEwmaDefaultEstimate) | 0;
            n1.searchParams.set("_HLS_pathway", this.pathwayId), n1.searchParams.set("_HLS_throughput", "" + u);
        }
        const i = {
            responseType: "json",
            url: n1.href
        }, o = t.steeringManifestLoadPolicy.default, a = o.errorRetry || o.timeoutRetry || {}, l = {
            loadPolicy: o,
            timeout: o.maxLoadTimeMs,
            maxRetry: a.maxNumRetry || 0,
            retryDelay: a.retryDelayMs || 0,
            maxRetryDelay: a.maxRetryDelayMs || 0
        }, c = {
            onSuccess: (u, d1, h, f)=>{
                this.log(`Loaded steering manifest: "${n1}"`);
                const p = u.data;
                if ((p == null ? void 0 : p.VERSION) !== 1) {
                    this.log(`Steering VERSION ${p.VERSION} not supported!`);
                    return;
                }
                this.updated = performance.now(), this.timeToLoad = p.TTL;
                const { "RELOAD-URI": y, "PATHWAY-CLONES": E, "PATHWAY-PRIORITY": b } = p;
                if (y) try {
                    this.uri = new self.URL(y, n1).href;
                } catch  {
                    this.enabled = !1, this.log(`Failed to parse Steering Manifest RELOAD-URI: ${y}`);
                    return;
                }
                this.scheduleRefresh(this.uri || h.url), E && this.clonePathways(E);
                const L = {
                    steeringManifest: p,
                    url: n1.toString()
                };
                this.hls.trigger(I.STEERING_MANIFEST_LOADED, L), b && this.updatePathwayPriority(b);
            },
            onError: (u, d1, h, f)=>{
                if (this.log(`Error loading steering manifest: ${u.code} ${u.text} (${d1.url})`), this.stopLoad(), u.code === 410) {
                    this.enabled = !1, this.log(`Steering manifest ${d1.url} no longer available`);
                    return;
                }
                let p = this.timeToLoad * 1e3;
                if (u.code === 429) {
                    const y = this.loader;
                    if (typeof (y == null ? void 0 : y.getResponseHeader) == "function") {
                        const E = y.getResponseHeader("Retry-After");
                        E && (p = parseFloat(E) * 1e3);
                    }
                    this.log(`Steering manifest ${d1.url} rate limited`);
                    return;
                }
                this.scheduleRefresh(this.uri || d1.url, p);
            },
            onTimeout: (u, d1, h)=>{
                this.log(`Timeout loading steering manifest (${d1.url})`), this.scheduleRefresh(this.uri || d1.url);
            }
        };
        this.log(`Requesting steering manifest: ${n1}`), this.loader.load(i, l, c);
    }
    scheduleRefresh(e, t = this.timeToLoad * 1e3) {
        this.clearTimeout(), this.reloadTimer = self.setTimeout(()=>{
            var r;
            const n1 = (r = this.hls) == null ? void 0 : r.media;
            if (n1 && !n1.ended) {
                this.loadSteeringManifest(e);
                return;
            }
            this.scheduleRefresh(e, this.timeToLoad * 1e3);
        }, t);
    }
}
function Yh(s, e, t, r) {
    s && Object.keys(e).forEach((n1)=>{
        const i = s.filter((o)=>o.groupId === n1).map((o)=>{
            const a = nt({}, o);
            return a.details = void 0, a.attrs = new ft(a.attrs), a.url = a.attrs.URI = Fp(o.url, o.attrs["STABLE-RENDITION-ID"], "PER-RENDITION-URIS", t), a.groupId = a.attrs["GROUP-ID"] = e[n1], a.attrs["PATHWAY-ID"] = r, a;
        });
        s.push(...i);
    });
}
function Fp(s, e, t, r) {
    const { HOST: n1, PARAMS: i, [t]: o } = r;
    let a;
    e && (a = o == null ? void 0 : o[e], a && (s = a));
    const l = new self.URL(s);
    return n1 && !a && (l.host = n1), i && Object.keys(i).sort().forEach((c)=>{
        c && l.searchParams.set(c, i[c]);
    }), l.href;
}
class An extends Rr {
    constructor(e){
        super("eme", e.logger), this.hls = void 0, this.config = void 0, this.media = null, this.keyFormatPromise = null, this.keySystemAccessPromises = {}, this._requestLicenseFailureCount = 0, this.mediaKeySessions = [], this.keyIdToKeySessionPromise = {}, this.mediaKeys = null, this.setMediaKeysQueue = An.CDMCleanupPromise ? [
            An.CDMCleanupPromise
        ] : [], this.bannedKeyIds = {}, this.onMediaEncrypted = (t)=>{
            const { initDataType: r, initData: n1 } = t, i = `"${t.type}" event: init data type: "${r}"`;
            if (this.debug(i), n1 !== null) {
                if (!this.keyFormatPromise) {
                    let o = Object.keys(this.keySystemAccessPromises);
                    o.length || (o = zn(this.config));
                    const a = o.map(fl).filter((l)=>!!l);
                    this.keyFormatPromise = this.getKeyFormatPromise(a);
                }
                this.keyFormatPromise.then((o)=>{
                    const a = po(o);
                    if (r !== "sinf" || a !== pt.FAIRPLAY) {
                        this.log(`Ignoring "${t.type}" event with init data type: "${r}" for selected key-system ${a}`);
                        return;
                    }
                    let l;
                    try {
                        const f = jt(new Uint8Array(n1)), p = bu(JSON.parse(f).sinf), y = Pg(p);
                        if (!y) throw new Error("'schm' box missing or not cbcs/cenc with schi > tenc");
                        l = new Uint8Array(y.subarray(8, 24));
                    } catch (f) {
                        this.warn(`${i} Failed to parse sinf: ${f}`);
                        return;
                    }
                    const c = fr(l), { keyIdToKeySessionPromise: u, mediaKeySessions: d1 } = this;
                    let h = u[c];
                    for(let f = 0; f < d1.length; f++){
                        const p = d1[f], y = p.decryptdata;
                        if (!y.keyId) continue;
                        const E = fr(y.keyId);
                        if (xu(l, y.keyId) || y.uri.replace(/-/g, "").indexOf(c) !== -1) {
                            if (h = u[E], !h) continue;
                            if (y.pssh) break;
                            delete u[E], y.pssh = new Uint8Array(n1), y.keyId = l, h = u[c] = h.then(()=>this.generateRequestWithPreferredKeySession(p, r, n1, "encrypted-event-key-match")), h.catch((b)=>this.handleError(b));
                            break;
                        }
                    }
                    h || this.handleError(new Error(`Key ID ${c} not encountered in playlist. Key-system sessions ${d1.length}.`));
                }).catch((o)=>this.handleError(o));
            }
        }, this.onWaitingForKey = (t)=>{
            this.log(`"${t.type}" event`);
        }, this.hls = e, this.config = e.config, this.registerListeners();
    }
    destroy() {
        this.onDestroying(), this.onMediaDetached();
        const e = this.config;
        e.requestMediaKeySystemAccessFunc = null, e.licenseXhrSetup = e.licenseResponseCallback = void 0, e.drmSystems = e.drmSystemOptions = {}, this.hls = this.config = this.keyIdToKeySessionPromise = null, this.onMediaEncrypted = this.onWaitingForKey = null;
    }
    registerListeners() {
        this.hls.on(I.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.on(I.MEDIA_DETACHED, this.onMediaDetached, this), this.hls.on(I.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.on(I.MANIFEST_LOADED, this.onManifestLoaded, this), this.hls.on(I.DESTROYING, this.onDestroying, this);
    }
    unregisterListeners() {
        this.hls.off(I.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.off(I.MEDIA_DETACHED, this.onMediaDetached, this), this.hls.off(I.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.off(I.MANIFEST_LOADED, this.onManifestLoaded, this), this.hls.off(I.DESTROYING, this.onDestroying, this);
    }
    getLicenseServerUrl(e) {
        const { drmSystems: t, widevineLicenseUrl: r } = this.config, n1 = t == null ? void 0 : t[e];
        if (n1) return n1.licenseUrl;
        if (e === pt.WIDEVINE && r) return r;
    }
    getLicenseServerUrlOrThrow(e) {
        const t = this.getLicenseServerUrl(e);
        if (t === void 0) throw new Error(`no license server URL configured for key-system "${e}"`);
        return t;
    }
    getServerCertificateUrl(e) {
        const { drmSystems: t } = this.config, r = t == null ? void 0 : t[e];
        if (r) return r.serverCertificateUrl;
        this.log(`No Server Certificate in config.drmSystems["${e}"]`);
    }
    attemptKeySystemAccess(e) {
        const t = this.hls.levels, r = (o, a, l)=>!!o && l.indexOf(o) === a, n1 = t.map((o)=>o.audioCodec).filter(r), i = t.map((o)=>o.videoCodec).filter(r);
        return n1.length + i.length === 0 && i.push("avc1.42e01e"), new Promise((o, a)=>{
            const l = (c)=>{
                const u = c.shift();
                this.getMediaKeysPromise(u, n1, i).then((d1)=>o({
                        keySystem: u,
                        mediaKeys: d1
                    })).catch((d1)=>{
                    c.length ? l(c) : d1 instanceof yr ? a(d1) : a(new yr({
                        type: ve.KEY_SYSTEM_ERROR,
                        details: J.KEY_SYSTEM_NO_ACCESS,
                        error: d1,
                        fatal: !0
                    }, d1.message));
                });
            };
            l(e);
        });
    }
    requestMediaKeySystemAccess(e, t) {
        const { requestMediaKeySystemAccessFunc: r } = this.config;
        if (typeof r != "function") {
            let n1 = `Configured requestMediaKeySystemAccess is not a function ${r}`;
            return Yg === null && self.location.protocol === "http:" && (n1 = `navigator.requestMediaKeySystemAccess is not available over insecure protocol ${location.protocol}`), Promise.reject(new Error(n1));
        }
        return r(e, t);
    }
    getMediaKeysPromise(e, t, r) {
        var n1;
        const i = Gb(e, t, r, this.config.drmSystemOptions || {});
        let o = this.keySystemAccessPromises[e], a = (n1 = o) == null ? void 0 : n1.keySystemAccess;
        if (!a) {
            this.log(`Requesting encrypted media "${e}" key-system access with config: ${at(i)}`), a = this.requestMediaKeySystemAccess(e, i);
            const l = o = this.keySystemAccessPromises[e] = {
                keySystemAccess: a
            };
            return a.catch((c)=>{
                this.log(`Failed to obtain access to key-system "${e}": ${c}`);
            }), a.then((c)=>{
                this.log(`Access for key-system "${c.keySystem}" obtained`);
                const u = this.fetchServerCertificate(e);
                this.log(`Create media-keys for "${e}"`);
                const d1 = l.mediaKeys = c.createMediaKeys().then((h)=>(this.log(`Media-keys created for "${e}"`), l.hasMediaKeys = !0, u.then((f)=>f ? this.setMediaKeysServerCertificate(h, e, f) : h)));
                return d1.catch((h)=>{
                    this.error(`Failed to create media-keys for "${e}"}: ${h}`);
                }), d1;
            });
        }
        return a.then(()=>o.mediaKeys);
    }
    createMediaKeySessionContext({ decryptdata: e, keySystem: t, mediaKeys: r }) {
        this.log(`Creating key-system session "${t}" keyId: ${fr(e.keyId || [])} keyUri: ${e.uri}`);
        const n1 = r.createSession(), i = {
            decryptdata: e,
            keySystem: t,
            mediaKeys: r,
            mediaKeysSession: n1,
            keyStatus: "status-pending"
        };
        return this.mediaKeySessions.push(i), i;
    }
    renewKeySession(e) {
        const t = e.decryptdata;
        if (t.pssh) {
            const r = this.createMediaKeySessionContext(e), n1 = Ji(t), i = "cenc";
            this.keyIdToKeySessionPromise[n1] = this.generateRequestWithPreferredKeySession(r, i, t.pssh.buffer, "expired");
        } else this.warn("Could not renew expired session. Missing pssh initData.");
        this.removeSession(e);
    }
    updateKeySession(e, t) {
        const r = e.mediaKeysSession;
        return this.log(`Updating key-session "${r.sessionId}" for keyId ${fr(e.decryptdata.keyId || [])}
      } (data length: ${t.byteLength})`), r.update(t);
    }
    getSelectedKeySystemFormats() {
        return Object.keys(this.keySystemAccessPromises).map((e)=>({
                keySystem: e,
                hasMediaKeys: this.keySystemAccessPromises[e].hasMediaKeys
            })).filter(({ hasMediaKeys: e })=>!!e).map(({ keySystem: e })=>fl(e)).filter((e)=>!!e);
    }
    getKeySystemAccess(e) {
        return this.getKeySystemSelectionPromise(e).then(({ keySystem: t, mediaKeys: r })=>this.attemptSetMediaKeys(t, r));
    }
    selectKeySystem(e) {
        return new Promise((t, r)=>{
            this.getKeySystemSelectionPromise(e).then(({ keySystem: n1 })=>{
                const i = fl(n1);
                i ? t(i) : r(new Error(`Unable to find format for key-system "${n1}"`));
            }).catch(r);
        });
    }
    selectKeySystemFormat(e) {
        const t = Object.keys(e.levelkeys || {});
        return this.keyFormatPromise || (this.log(`Selecting key-system from fragment (sn: ${e.sn} ${e.type}: ${e.level}) key formats ${t.join(", ")}`), this.keyFormatPromise = this.getKeyFormatPromise(t)), this.keyFormatPromise;
    }
    getKeyFormatPromise(e) {
        const t = zn(this.config), r = e.map(po).filter((n1)=>!!n1 && t.indexOf(n1) !== -1);
        return this.selectKeySystem(r);
    }
    getKeyStatus(e) {
        const { mediaKeySessions: t } = this;
        for(let r = 0; r < t.length; r++){
            const n1 = lw(e, t[r]);
            if (n1) return n1;
        }
    }
    loadKey(e) {
        const t = e.keyInfo.decryptdata, r = Ji(t), n1 = this.bannedKeyIds[r];
        if (n1 || this.getKeyStatus(t) === "internal-error") {
            const a = Zh(n1 || "internal-error", t);
            return this.handleError(a, e.frag), Promise.reject(a);
        }
        const i = `(keyId: ${r} format: "${t.keyFormat}" method: ${t.method} uri: ${t.uri})`;
        this.log(`Starting session for key ${i}`);
        const o = this.keyIdToKeySessionPromise[r];
        if (!o) {
            const a = this.getKeySystemForKeyPromise(t).then(({ keySystem: l, mediaKeys: c })=>(this.throwIfDestroyed(), this.log(`Handle encrypted media sn: ${e.frag.sn} ${e.frag.type}: ${e.frag.level} using key ${i}`), this.attemptSetMediaKeys(l, c).then(()=>(this.throwIfDestroyed(), this.createMediaKeySessionContext({
                        keySystem: l,
                        mediaKeys: c,
                        decryptdata: t
                    }))))).then((l)=>{
                const c = "cenc", u = t.pssh ? t.pssh.buffer : null;
                return this.generateRequestWithPreferredKeySession(l, c, u, "playlist-key");
            });
            return a.catch((l)=>this.handleError(l, e.frag)), this.keyIdToKeySessionPromise[r] = a, a;
        }
        return o.catch((a)=>{
            if (a instanceof yr) {
                const l = tt({}, a.data);
                this.getKeyStatus(t) === "internal-error" && (l.decryptdata = t);
                const c = new yr(l, a.message);
                this.handleError(c, e.frag);
            }
        }), o;
    }
    throwIfDestroyed(e = "Invalid state") {
        if (!this.hls) throw new Error("invalid state");
    }
    handleError(e, t) {
        if (this.hls) if (e instanceof yr) {
            t && (e.data.frag = t);
            const r = e.data.decryptdata;
            this.error(`${e.message}${r ? ` (${fr(r.keyId || [])})` : ""}`), this.hls.trigger(I.ERROR, e.data);
        } else this.error(e.message), this.hls.trigger(I.ERROR, {
            type: ve.KEY_SYSTEM_ERROR,
            details: J.KEY_SYSTEM_NO_KEYS,
            error: e,
            fatal: !0
        });
    }
    getKeySystemForKeyPromise(e) {
        const t = Ji(e), r = this.keyIdToKeySessionPromise[t];
        if (!r) {
            const n1 = po(e.keyFormat), i = n1 ? [
                n1
            ] : zn(this.config);
            return this.attemptKeySystemAccess(i);
        }
        return r;
    }
    getKeySystemSelectionPromise(e) {
        if (e.length || (e = zn(this.config)), e.length === 0) throw new yr({
            type: ve.KEY_SYSTEM_ERROR,
            details: J.KEY_SYSTEM_NO_CONFIGURED_LICENSE,
            fatal: !0
        }, `Missing key-system license configuration options ${at({
            drmSystems: this.config.drmSystems
        })}`);
        return this.attemptKeySystemAccess(e);
    }
    attemptSetMediaKeys(e, t) {
        if (this.mediaKeys === t) return Promise.resolve();
        const r = this.setMediaKeysQueue.slice();
        this.log(`Setting media-keys for "${e}"`);
        const n1 = Promise.all(r).then(()=>{
            if (!this.media) throw this.mediaKeys = null, new Error("Attempted to set mediaKeys without media element attached");
            return this.media.setMediaKeys(t);
        });
        return this.mediaKeys = t, this.setMediaKeysQueue.push(n1), n1.then(()=>{
            this.log(`Media-keys set for "${e}"`), r.push(n1), this.setMediaKeysQueue = this.setMediaKeysQueue.filter((i)=>r.indexOf(i) === -1);
        });
    }
    generateRequestWithPreferredKeySession(e, t, r, n1) {
        var i;
        const o = (i = this.config.drmSystems) == null || (i = i[e.keySystem]) == null ? void 0 : i.generateRequest;
        if (o) try {
            const p = o.call(this.hls, t, r, e);
            if (!p) throw new Error("Invalid response from configured generateRequest filter");
            t = p.initDataType, r = p.initData ? p.initData : null, e.decryptdata.pssh = r ? new Uint8Array(r) : null;
        } catch (p) {
            if (this.warn(p.message), this.hls && this.hls.config.debug) throw p;
        }
        if (r === null) return this.log(`Skipping key-session request for "${n1}" (no initData)`), Promise.resolve(e);
        const a = Ji(e.decryptdata), l = e.decryptdata.uri;
        this.log(`Generating key-session request for "${n1}" keyId: ${a} URI: ${l} (init data type: ${t} length: ${r.byteLength})`);
        const c = new wu(), u = e._onmessage = (p)=>{
            const y = e.mediaKeysSession;
            if (!y) {
                c.emit("error", new Error("invalid state"));
                return;
            }
            const { messageType: E, message: b } = p;
            this.log(`"${E}" message event for session "${y.sessionId}" message size: ${b.byteLength}`), E === "license-request" || E === "license-renewal" ? this.renewLicense(e, b).catch((L)=>{
                c.eventNames().length ? c.emit("error", L) : this.handleError(L);
            }) : E === "license-release" ? e.keySystem === pt.FAIRPLAY && this.updateKeySession(e, hc("acknowledged")).then(()=>this.removeSession(e)).catch((L)=>this.handleError(L)) : this.warn(`unhandled media key message type "${E}"`);
        }, d1 = (p, y)=>{
            y.keyStatus = p;
            let E;
            p.startsWith("usable") ? c.emit("resolved") : p === "internal-error" || p === "output-restricted" || p === "output-downscaled" ? E = Zh(p, y.decryptdata) : p === "expired" ? E = new Error(`key expired (keyId: ${a})`) : p === "released" ? E = new Error("key released") : p === "status-pending" || this.warn(`unhandled key status change "${p}" (keyId: ${a})`), E && (c.eventNames().length ? c.emit("error", E) : this.handleError(E));
        }, h = e._onkeystatuseschange = (p)=>{
            if (!e.mediaKeysSession) {
                c.emit("error", new Error("invalid state"));
                return;
            }
            const E = this.getKeyStatuses(e);
            if (!Object.keys(E).some((F)=>E[F] !== "status-pending")) return;
            if (E[a] === "expired") {
                this.log(`Expired key ${at(E)} in key-session "${e.mediaKeysSession.sessionId}"`), this.renewKeySession(e);
                return;
            }
            let L = E[a];
            if (L) d1(L, e);
            else {
                var A;
                e.keyStatusTimeouts || (e.keyStatusTimeouts = {}), (A = e.keyStatusTimeouts)[a] || (A[a] = self.setTimeout(()=>{
                    if (!e.mediaKeysSession || !this.mediaKeys) return;
                    const M = this.getKeyStatus(e.decryptdata);
                    if (M && M !== "status-pending") return this.log(`No status for keyId ${a} in key-session "${e.mediaKeysSession.sessionId}". Using session key-status ${M} from other session.`), d1(M, e);
                    this.log(`key status for ${a} in key-session "${e.mediaKeysSession.sessionId}" timed out after 0ms`), L = "internal-error", d1(L, e);
                }, 0)), this.log(`No status for keyId ${a} (${at(E)}).`);
            }
        };
        cr(e.mediaKeysSession, "message", u), cr(e.mediaKeysSession, "keystatuseschange", h);
        const f = new Promise((p, y)=>{
            c.on("error", y), c.on("resolved", p);
        });
        return e.mediaKeysSession.generateRequest(t, r).then(()=>{
            this.log(`Request generated for key-session "${e.mediaKeysSession.sessionId}" keyId: ${a} URI: ${l}`);
        }).catch((p)=>{
            throw new yr({
                type: ve.KEY_SYSTEM_ERROR,
                details: J.KEY_SYSTEM_NO_SESSION,
                error: p,
                decryptdata: e.decryptdata,
                fatal: !1
            }, `Error generating key-session request: ${p}`);
        }).then(()=>f).catch((p)=>(c.removeAllListeners(), this.removeSession(e).then(()=>{
                throw p;
            }))).then(()=>(c.removeAllListeners(), e));
    }
    getKeyStatuses(e) {
        const t = {};
        return e.mediaKeysSession.keyStatuses.forEach((r, n1)=>{
            if (typeof n1 == "string" && typeof r == "object") {
                const a = n1;
                n1 = r, r = a;
            }
            const i = "buffer" in n1 ? new Uint8Array(n1.buffer, n1.byteOffset, n1.byteLength) : new Uint8Array(n1);
            e.keySystem === pt.PLAYREADY && i.length === 16 && zg(i);
            const o = fr(i);
            r === "internal-error" && (this.bannedKeyIds[o] = r), this.log(`key status change "${r}" for keyStatuses keyId: ${o} key-session "${e.mediaKeysSession.sessionId}"`), t[o] = r;
        }), t;
    }
    fetchServerCertificate(e) {
        const t = this.config, r = t.loader, n1 = new r(t), i = this.getServerCertificateUrl(e);
        return i ? (this.log(`Fetching server certificate for "${e}"`), new Promise((o, a)=>{
            const l = {
                responseType: "arraybuffer",
                url: i
            }, c = t.certLoadPolicy.default, u = {
                loadPolicy: c,
                timeout: c.maxLoadTimeMs,
                maxRetry: 0,
                retryDelay: 0,
                maxRetryDelay: 0
            }, d1 = {
                onSuccess: (h, f, p, y)=>{
                    o(h.data);
                },
                onError: (h, f, p, y)=>{
                    a(new yr({
                        type: ve.KEY_SYSTEM_ERROR,
                        details: J.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
                        fatal: !0,
                        networkDetails: p,
                        response: tt({
                            url: l.url,
                            data: void 0
                        }, h)
                    }, `"${e}" certificate request failed (${i}). Status: ${h.code} (${h.text})`));
                },
                onTimeout: (h, f, p)=>{
                    a(new yr({
                        type: ve.KEY_SYSTEM_ERROR,
                        details: J.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
                        fatal: !0,
                        networkDetails: p,
                        response: {
                            url: l.url,
                            data: void 0
                        }
                    }, `"${e}" certificate request timed out (${i})`));
                },
                onAbort: (h, f, p)=>{
                    a(new Error("aborted"));
                }
            };
            n1.load(l, u, d1);
        })) : Promise.resolve();
    }
    setMediaKeysServerCertificate(e, t, r) {
        return new Promise((n1, i)=>{
            e.setServerCertificate(r).then((o)=>{
                this.log(`setServerCertificate ${o ? "success" : "not supported by CDM"} (${r.byteLength}) on "${t}"`), n1(e);
            }).catch((o)=>{
                i(new yr({
                    type: ve.KEY_SYSTEM_ERROR,
                    details: J.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED,
                    error: o,
                    fatal: !0
                }, o.message));
            });
        });
    }
    renewLicense(e, t) {
        return this.requestLicense(e, new Uint8Array(t)).then((r)=>this.updateKeySession(e, new Uint8Array(r)).catch((n1)=>{
                throw new yr({
                    type: ve.KEY_SYSTEM_ERROR,
                    details: J.KEY_SYSTEM_SESSION_UPDATE_FAILED,
                    decryptdata: e.decryptdata,
                    error: n1,
                    fatal: !1
                }, n1.message);
            }));
    }
    unpackPlayReadyKeyMessage(e, t) {
        const r = String.fromCharCode.apply(null, new Uint16Array(t.buffer));
        if (!r.includes("PlayReadyKeyMessage")) return e.setRequestHeader("Content-Type", "text/xml; charset=utf-8"), t;
        const n1 = new DOMParser().parseFromString(r, "application/xml"), i = n1.querySelectorAll("HttpHeader");
        if (i.length > 0) {
            let u;
            for(let d1 = 0, h = i.length; d1 < h; d1++){
                var o, a;
                u = i[d1];
                const f = (o = u.querySelector("name")) == null ? void 0 : o.textContent, p = (a = u.querySelector("value")) == null ? void 0 : a.textContent;
                f && p && e.setRequestHeader(f, p);
            }
        }
        const l = n1.querySelector("Challenge"), c = l == null ? void 0 : l.textContent;
        if (!c) throw new Error("Cannot find <Challenge> in key message");
        return hc(atob(c));
    }
    setupLicenseXHR(e, t, r, n1) {
        const i = this.config.licenseXhrSetup;
        return i ? Promise.resolve().then(()=>{
            if (!r.decryptdata) throw new Error("Key removed");
            return i.call(this.hls, e, t, r, n1);
        }).catch((o)=>{
            if (!r.decryptdata) throw o;
            return e.open("POST", t, !0), i.call(this.hls, e, t, r, n1);
        }).then((o)=>(e.readyState || e.open("POST", t, !0), {
                xhr: e,
                licenseChallenge: o || n1
            })) : (e.open("POST", t, !0), Promise.resolve({
            xhr: e,
            licenseChallenge: n1
        }));
    }
    requestLicense(e, t) {
        const r = this.config.keyLoadPolicy.default;
        return new Promise((n1, i)=>{
            const o = this.getLicenseServerUrlOrThrow(e.keySystem);
            this.log(`Sending license request to URL: ${o}`);
            const a = new XMLHttpRequest();
            a.responseType = "arraybuffer", a.onreadystatechange = ()=>{
                if (!this.hls || !e.mediaKeysSession) return i(new Error("invalid state"));
                if (a.readyState === 4) if (a.status === 200) {
                    this._requestLicenseFailureCount = 0;
                    let l = a.response;
                    this.log(`License received ${l instanceof ArrayBuffer ? l.byteLength : l}`);
                    const c = this.config.licenseResponseCallback;
                    if (c) try {
                        l = c.call(this.hls, a, o, e);
                    } catch (u) {
                        this.error(u);
                    }
                    n1(l);
                } else {
                    const l = r.errorRetry, c = l ? l.maxNumRetry : 0;
                    if (this._requestLicenseFailureCount++, this._requestLicenseFailureCount > c || a.status >= 400 && a.status < 500) i(new yr({
                        type: ve.KEY_SYSTEM_ERROR,
                        details: J.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
                        decryptdata: e.decryptdata,
                        fatal: !0,
                        networkDetails: a,
                        response: {
                            url: o,
                            data: void 0,
                            code: a.status,
                            text: a.statusText
                        }
                    }, `License Request XHR failed (${o}). Status: ${a.status} (${a.statusText})`));
                    else {
                        const u = c - this._requestLicenseFailureCount + 1;
                        this.warn(`Retrying license request, ${u} attempts left`), this.requestLicense(e, t).then(n1, i);
                    }
                }
            }, e.licenseXhr && e.licenseXhr.readyState !== XMLHttpRequest.DONE && e.licenseXhr.abort(), e.licenseXhr = a, this.setupLicenseXHR(a, o, e, t).then(({ xhr: l, licenseChallenge: c })=>{
                e.keySystem == pt.PLAYREADY && (c = this.unpackPlayReadyKeyMessage(l, c)), l.send(c);
            }).catch(i);
        });
    }
    onDestroying() {
        this.unregisterListeners(), this._clear();
    }
    onMediaAttached(e, t) {
        if (!this.config.emeEnabled) return;
        const r = t.media;
        this.media = r, cr(r, "encrypted", this.onMediaEncrypted), cr(r, "waitingforkey", this.onWaitingForKey);
    }
    onMediaDetached() {
        const e = this.media;
        e && (pr(e, "encrypted", this.onMediaEncrypted), pr(e, "waitingforkey", this.onWaitingForKey), this.media = null, this.mediaKeys = null);
    }
    _clear() {
        var e;
        if (this._requestLicenseFailureCount = 0, this.keyIdToKeySessionPromise = {}, this.bannedKeyIds = {}, !this.mediaKeys && !this.mediaKeySessions.length) return;
        const t = this.media, r = this.mediaKeySessions.slice();
        this.mediaKeySessions = [], this.mediaKeys = null, yi.clearKeyUriToKeyIdMap();
        const n1 = r.length;
        An.CDMCleanupPromise = Promise.all(r.map((i)=>this.removeSession(i)).concat((t == null || (e = t.setMediaKeys(null)) == null ? void 0 : e.catch((i)=>{
            this.log(`Could not clear media keys: ${i}`), this.hls && this.hls.trigger(I.ERROR, {
                type: ve.OTHER_ERROR,
                details: J.KEY_SYSTEM_DESTROY_MEDIA_KEYS_ERROR,
                fatal: !1,
                error: new Error(`Could not clear media keys: ${i}`)
            });
        })) || Promise.resolve())).catch((i)=>{
            this.log(`Could not close sessions and clear media keys: ${i}`), this.hls && this.hls.trigger(I.ERROR, {
                type: ve.OTHER_ERROR,
                details: J.KEY_SYSTEM_DESTROY_CLOSE_SESSION_ERROR,
                fatal: !1,
                error: new Error(`Could not close sessions and clear media keys: ${i}`)
            });
        }).then(()=>{
            n1 && this.log("finished closing key sessions and clearing media keys");
        });
    }
    onManifestLoading() {
        this.keyFormatPromise = null, this.bannedKeyIds = {};
    }
    onManifestLoaded(e, { sessionKeys: t }) {
        if (!(!t || !this.config.emeEnabled) && !this.keyFormatPromise) {
            const r = t.reduce((n1, i)=>(n1.indexOf(i.keyFormat) === -1 && n1.push(i.keyFormat), n1), []);
            this.log(`Selecting key-system from session-keys ${r.join(", ")}`), this.keyFormatPromise = this.getKeyFormatPromise(r);
        }
    }
    removeSession(e) {
        const { mediaKeysSession: t, licenseXhr: r, decryptdata: n1 } = e;
        if (t) {
            this.log(`Remove licenses and keys and close session "${t.sessionId}" keyId: ${fr((n1 == null ? void 0 : n1.keyId) || [])}`), e._onmessage && (t.removeEventListener("message", e._onmessage), e._onmessage = void 0), e._onkeystatuseschange && (t.removeEventListener("keystatuseschange", e._onkeystatuseschange), e._onkeystatuseschange = void 0), r && r.readyState !== XMLHttpRequest.DONE && r.abort(), e.mediaKeysSession = e.decryptdata = e.licenseXhr = void 0;
            const i = this.mediaKeySessions.indexOf(e);
            i > -1 && this.mediaKeySessions.splice(i, 1);
            const { keyStatusTimeouts: o } = e;
            o && Object.keys(o).forEach((c)=>self.clearTimeout(o[c]));
            const { drmSystemOptions: a } = this.config;
            return (jb(a) ? new Promise((c, u)=>{
                self.setTimeout(()=>u(new Error("MediaKeySession.remove() timeout")), 8e3), t.remove().then(c).catch(u);
            }) : Promise.resolve()).catch((c)=>{
                this.log(`Could not remove session: ${c}`), this.hls && this.hls.trigger(I.ERROR, {
                    type: ve.OTHER_ERROR,
                    details: J.KEY_SYSTEM_DESTROY_REMOVE_SESSION_ERROR,
                    fatal: !1,
                    error: new Error(`Could not remove session: ${c}`)
                });
            }).then(()=>t.close()).catch((c)=>{
                this.log(`Could not close session: ${c}`), this.hls && this.hls.trigger(I.ERROR, {
                    type: ve.OTHER_ERROR,
                    details: J.KEY_SYSTEM_DESTROY_CLOSE_SESSION_ERROR,
                    fatal: !1,
                    error: new Error(`Could not close session: ${c}`)
                });
            });
        }
        return Promise.resolve();
    }
}
An.CDMCleanupPromise = void 0;
function Ji(s) {
    if (!s) throw new Error("Could not read keyId of undefined decryptdata");
    if (s.keyId === null) throw new Error("keyId is null");
    return fr(s.keyId);
}
function lw(s, e) {
    if (s.keyId && e.mediaKeysSession.keyStatuses.has(s.keyId)) return e.mediaKeysSession.keyStatuses.get(s.keyId);
    if (s.matches(e.decryptdata)) return e.keyStatus;
}
class yr extends Error {
    constructor(e, t){
        super(t), this.data = void 0, e.error || (e.error = new Error(t)), this.data = e, e.err = e.error;
    }
}
function Zh(s, e) {
    const t = s === "output-restricted", r = t ? J.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED : J.KEY_SYSTEM_STATUS_INTERNAL_ERROR;
    return new yr({
        type: ve.KEY_SYSTEM_ERROR,
        details: r,
        fatal: !1,
        decryptdata: e
    }, t ? "HDCP level output restricted" : `key status changed to "${s}"`);
}
class cw {
    constructor(e){
        this.hls = void 0, this.isVideoPlaybackQualityAvailable = !1, this.timer = void 0, this.media = null, this.lastTime = void 0, this.lastDroppedFrames = 0, this.lastDecodedFrames = 0, this.streamController = void 0, this.hls = e, this.registerListeners();
    }
    setStreamController(e) {
        this.streamController = e;
    }
    registerListeners() {
        this.hls.on(I.MEDIA_ATTACHING, this.onMediaAttaching, this), this.hls.on(I.MEDIA_DETACHING, this.onMediaDetaching, this);
    }
    unregisterListeners() {
        this.hls.off(I.MEDIA_ATTACHING, this.onMediaAttaching, this), this.hls.off(I.MEDIA_DETACHING, this.onMediaDetaching, this);
    }
    destroy() {
        this.timer && clearInterval(this.timer), this.unregisterListeners(), this.isVideoPlaybackQualityAvailable = !1, this.media = null;
    }
    onMediaAttaching(e, t) {
        const r = this.hls.config;
        if (r.capLevelOnFPSDrop) {
            const n1 = t.media instanceof self.HTMLVideoElement ? t.media : null;
            this.media = n1, n1 && typeof n1.getVideoPlaybackQuality == "function" && (this.isVideoPlaybackQualityAvailable = !0), self.clearInterval(this.timer), this.timer = self.setInterval(this.checkFPSInterval.bind(this), r.fpsDroppedMonitoringPeriod);
        }
    }
    onMediaDetaching() {
        this.media = null;
    }
    checkFPS(e, t, r) {
        const n1 = performance.now();
        if (t) {
            if (this.lastTime) {
                const i = n1 - this.lastTime, o = r - this.lastDroppedFrames, a = t - this.lastDecodedFrames, l = 1e3 * o / i, c = this.hls;
                if (c.trigger(I.FPS_DROP, {
                    currentDropped: o,
                    currentDecoded: a,
                    totalDroppedFrames: r
                }), l > 0 && o > c.config.fpsDroppedMonitoringThreshold * a) {
                    let u = c.currentLevel;
                    c.logger.warn("drop FPS ratio greater than max allowed value for currentLevel: " + u), u > 0 && (c.autoLevelCapping === -1 || c.autoLevelCapping >= u) && (u = u - 1, c.trigger(I.FPS_DROP_LEVEL_CAPPING, {
                        level: u,
                        droppedLevel: c.currentLevel
                    }), c.autoLevelCapping = u, this.streamController.nextLevelSwitch());
                }
            }
            this.lastTime = n1, this.lastDroppedFrames = r, this.lastDecodedFrames = t;
        }
    }
    checkFPSInterval() {
        const e = this.media;
        if (e) if (this.isVideoPlaybackQualityAvailable) {
            const t = e.getVideoPlaybackQuality();
            this.checkFPS(e, t.totalVideoFrames, t.droppedVideoFrames);
        } else this.checkFPS(e, e.webkitDecodedFrameCount, e.webkitDroppedFrameCount);
    }
}
function Np(s, e) {
    let t;
    try {
        t = new Event("addtrack");
    } catch  {
        t = document.createEvent("Event"), t.initEvent("addtrack", !1, !1);
    }
    t.track = s, e.dispatchEvent(t);
}
function Up(s, e) {
    const t = s.mode;
    if (t === "disabled" && (s.mode = "hidden"), s.cues && !s.cues.getCueById(e.id)) try {
        if (s.addCue(e), !s.cues.getCueById(e.id)) throw new Error(`addCue is failed for: ${e}`);
    } catch (r) {
        rt.debug(`[texttrack-utils]: ${r}`);
        try {
            const n1 = new self.TextTrackCue(e.startTime, e.endTime, e.text);
            n1.id = e.id, s.addCue(n1);
        } catch (n1) {
            rt.debug(`[texttrack-utils]: Legacy TextTrackCue fallback failed: ${n1}`);
        }
    }
    t === "disabled" && (s.mode = t);
}
function En(s, e) {
    const t = s.mode;
    if (t === "disabled" && (s.mode = "hidden"), s.cues) for(let r = s.cues.length; r--;)e && s.cues[r].removeEventListener("enter", e), s.removeCue(s.cues[r]);
    t === "disabled" && (s.mode = t);
}
function Sc(s, e, t, r) {
    const n1 = s.mode;
    if (n1 === "disabled" && (s.mode = "hidden"), s.cues && s.cues.length > 0) {
        const i = dw(s.cues, e, t);
        for(let o = 0; o < i.length; o++)(!r || r(i[o])) && s.removeCue(i[o]);
    }
    n1 === "disabled" && (s.mode = n1);
}
function uw(s, e) {
    if (e <= s[0].startTime) return 0;
    const t = s.length - 1;
    if (e > s[t].endTime) return -1;
    let r = 0, n1 = t, i;
    for(; r <= n1;)if (i = Math.floor((n1 + r) / 2), e < s[i].startTime) n1 = i - 1;
    else if (e > s[i].startTime && r < t) r = i + 1;
    else return i;
    return s[r].startTime - e < e - s[n1].startTime ? r : n1;
}
function dw(s, e, t) {
    const r = [], n1 = uw(s, e);
    if (n1 > -1) for(let i = n1, o = s.length; i < o; i++){
        const a = s[i];
        if (a.startTime >= e && a.endTime <= t) r.push(a);
        else if (a.startTime > t) return r;
    }
    return r;
}
function Eo(s) {
    const e = [];
    for(let t = 0; t < s.length; t++){
        const r = s[t];
        (r.kind === "subtitles" || r.kind === "captions") && r.label && e.push(s[t]);
    }
    return e;
}
class hw extends ku {
    constructor(e){
        super(e, "subtitle-track-controller"), this.media = null, this.tracks = [], this.groupIds = null, this.tracksInGroup = [], this.trackId = -1, this.currentTrack = null, this.selectDefaultTrack = !0, this.queuedDefaultTrack = -1, this.useTextTrackPolling = !1, this.subtitlePollingInterval = -1, this._subtitleDisplay = !0, this.asyncPollTrackChange = ()=>this.pollTrackChange(0), this.onTextTracksChanged = ()=>{
            if (this.useTextTrackPolling || self.clearInterval(this.subtitlePollingInterval), !this.media || !this.hls.config.renderTextTracksNatively) return;
            let t = null;
            const r = Eo(this.media.textTracks);
            for(let i = 0; i < r.length; i++)if (r[i].mode === "hidden") t = r[i];
            else if (r[i].mode === "showing") {
                t = r[i];
                break;
            }
            const n1 = this.findTrackForTextTrack(t);
            this.subtitleTrack !== n1 && this.setSubtitleTrack(n1);
        }, this.registerListeners();
    }
    destroy() {
        this.unregisterListeners(), this.tracks.length = 0, this.tracksInGroup.length = 0, this.currentTrack = null, this.onTextTracksChanged = this.asyncPollTrackChange = null, super.destroy();
    }
    get subtitleDisplay() {
        return this._subtitleDisplay;
    }
    set subtitleDisplay(e) {
        this._subtitleDisplay = e, this.trackId > -1 && this.toggleTrackModes();
    }
    registerListeners() {
        const { hls: e } = this;
        e.on(I.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(I.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(I.MANIFEST_LOADING, this.onManifestLoading, this), e.on(I.MANIFEST_PARSED, this.onManifestParsed, this), e.on(I.LEVEL_LOADING, this.onLevelLoading, this), e.on(I.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on(I.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.on(I.ERROR, this.onError, this);
    }
    unregisterListeners() {
        const { hls: e } = this;
        e.off(I.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(I.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(I.MANIFEST_LOADING, this.onManifestLoading, this), e.off(I.MANIFEST_PARSED, this.onManifestParsed, this), e.off(I.LEVEL_LOADING, this.onLevelLoading, this), e.off(I.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off(I.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.off(I.ERROR, this.onError, this);
    }
    // Listen for subtitle track change, then extract the current track ID.
    onMediaAttached(e, t) {
        this.media = t.media, this.media && (this.queuedDefaultTrack > -1 && (this.subtitleTrack = this.queuedDefaultTrack, this.queuedDefaultTrack = -1), this.useTextTrackPolling = !(this.media.textTracks && "onchange" in this.media.textTracks), this.useTextTrackPolling ? this.pollTrackChange(500) : this.media.textTracks.addEventListener("change", this.asyncPollTrackChange));
    }
    pollTrackChange(e) {
        self.clearInterval(this.subtitlePollingInterval), this.subtitlePollingInterval = self.setInterval(this.onTextTracksChanged, e);
    }
    onMediaDetaching(e, t) {
        const r = this.media;
        if (!r) return;
        const n1 = !!t.transferMedia;
        if (self.clearInterval(this.subtitlePollingInterval), this.useTextTrackPolling || r.textTracks.removeEventListener("change", this.asyncPollTrackChange), this.trackId > -1 && (this.queuedDefaultTrack = this.trackId), this.subtitleTrack = -1, this.media = null, n1) return;
        Eo(r.textTracks).forEach((o)=>{
            En(o);
        });
    }
    onManifestLoading() {
        this.tracks = [], this.groupIds = null, this.tracksInGroup = [], this.trackId = -1, this.currentTrack = null, this.selectDefaultTrack = !0;
    }
    // Fired whenever a new manifest is loaded.
    onManifestParsed(e, t) {
        this.tracks = t.subtitleTracks;
    }
    onSubtitleTrackLoaded(e, t) {
        const { id: r, groupId: n1, details: i } = t, o = this.tracksInGroup[r];
        if (!o || o.groupId !== n1) {
            this.warn(`Subtitle track with id:${r} and group:${n1} not found in active group ${o == null ? void 0 : o.groupId}`);
            return;
        }
        const a = o.details;
        o.details = t.details, this.log(`Subtitle track ${r} "${o.name}" lang:${o.lang} group:${n1} loaded [${i.startSN}-${i.endSN}]`), r === this.trackId && this.playlistLoaded(r, t, a);
    }
    onLevelLoading(e, t) {
        this.switchLevel(t.level);
    }
    onLevelSwitching(e, t) {
        this.switchLevel(t.level);
    }
    switchLevel(e) {
        const t = this.hls.levels[e];
        if (!t) return;
        const r = t.subtitleGroups || null, n1 = this.groupIds;
        let i = this.currentTrack;
        if (!r || (n1 == null ? void 0 : n1.length) !== (r == null ? void 0 : r.length) || r != null && r.some((o)=>(n1 == null ? void 0 : n1.indexOf(o)) === -1)) {
            this.groupIds = r, this.trackId = -1, this.currentTrack = null;
            const o = this.tracks.filter((u)=>!r || r.indexOf(u.groupId) !== -1);
            if (o.length) this.selectDefaultTrack && !o.some((u)=>u.default) && (this.selectDefaultTrack = !1), o.forEach((u, d1)=>{
                u.id = d1;
            });
            else if (!i && !this.tracksInGroup.length) return;
            this.tracksInGroup = o;
            const a = this.hls.config.subtitlePreference;
            if (!i && a) {
                this.selectDefaultTrack = !1;
                const u = Wr(a, o);
                if (u > -1) i = o[u];
                else {
                    const d1 = Wr(a, this.tracks);
                    i = this.tracks[d1];
                }
            }
            let l = this.findTrackId(i);
            l === -1 && i && (l = this.findTrackId(null));
            const c = {
                subtitleTracks: o
            };
            this.log(`Updating subtitle tracks, ${o.length} track(s) found in "${r == null ? void 0 : r.join(",")}" group-id`), this.hls.trigger(I.SUBTITLE_TRACKS_UPDATED, c), l !== -1 && this.trackId === -1 && this.setSubtitleTrack(l);
        }
    }
    findTrackId(e) {
        const t = this.tracksInGroup, r = this.selectDefaultTrack;
        for(let n1 = 0; n1 < t.length; n1++){
            const i = t[n1];
            if (!(r && !i.default || !r && !e) && (!e || qs(i, e))) return n1;
        }
        if (e) {
            for(let n1 = 0; n1 < t.length; n1++){
                const i = t[n1];
                if (Si(e.attrs, i.attrs, [
                    "LANGUAGE",
                    "ASSOC-LANGUAGE",
                    "CHARACTERISTICS"
                ])) return n1;
            }
            for(let n1 = 0; n1 < t.length; n1++){
                const i = t[n1];
                if (Si(e.attrs, i.attrs, [
                    "LANGUAGE"
                ])) return n1;
            }
        }
        return -1;
    }
    findTrackForTextTrack(e) {
        if (e) {
            const t = this.tracksInGroup;
            for(let r = 0; r < t.length; r++){
                const n1 = t[r];
                if (yc(n1, e)) return r;
            }
        }
        return -1;
    }
    onError(e, t) {
        t.fatal || !t.context || t.context.type === Ke.SUBTITLE_TRACK && t.context.id === this.trackId && (!this.groupIds || this.groupIds.indexOf(t.context.groupId) !== -1) && this.checkRetry(t);
    }
    get allSubtitleTracks() {
        return this.tracks;
    }
    /** get alternate subtitle tracks list from playlist **/ get subtitleTracks() {
        return this.tracksInGroup;
    }
    /** get/set index of the selected subtitle track (based on index in subtitle track lists) **/ get subtitleTrack() {
        return this.trackId;
    }
    set subtitleTrack(e) {
        this.selectDefaultTrack = !1, this.setSubtitleTrack(e);
    }
    setSubtitleOption(e) {
        if (this.hls.config.subtitlePreference = e, e) {
            if (e.id === -1) return this.setSubtitleTrack(-1), null;
            const t = this.allSubtitleTracks;
            if (this.selectDefaultTrack = !1, t.length) {
                const r = this.currentTrack;
                if (r && qs(e, r)) return r;
                const n1 = Wr(e, this.tracksInGroup);
                if (n1 > -1) {
                    const i = this.tracksInGroup[n1];
                    return this.setSubtitleTrack(n1), i;
                } else {
                    if (r) return null;
                    {
                        const i = Wr(e, t);
                        if (i > -1) return t[i];
                    }
                }
            }
        }
        return null;
    }
    loadPlaylist(e) {
        super.loadPlaylist(), this.shouldLoadPlaylist(this.currentTrack) && this.scheduleLoading(this.currentTrack, e);
    }
    loadingPlaylist(e, t) {
        super.loadingPlaylist(e, t);
        const r = e.id, n1 = e.groupId, i = this.getUrlWithDirectives(e.url, t), o = e.details, a = o == null ? void 0 : o.age;
        this.log(`Loading subtitle ${r} "${e.name}" lang:${e.lang} group:${n1}${(t == null ? void 0 : t.msn) !== void 0 ? " at sn " + t.msn + " part " + t.part : ""}${a && o.live ? " age " + a.toFixed(1) + (o.type && " " + o.type || "") : ""} ${i}`), this.hls.trigger(I.SUBTITLE_TRACK_LOADING, {
            url: i,
            id: r,
            groupId: n1,
            deliveryDirectives: t || null,
            track: e
        });
    }
    /**
   * Disables the old subtitleTrack and sets current mode on the next subtitleTrack.
   * This operates on the DOM textTracks.
   * A value of -1 will disable all subtitle tracks.
   */ toggleTrackModes() {
        const { media: e } = this;
        if (!e) return;
        const t = Eo(e.textTracks), r = this.currentTrack;
        let n1;
        if (r && (n1 = t.filter((i)=>yc(r, i))[0], n1 || this.warn(`Unable to find subtitle TextTrack with name "${r.name}" and language "${r.lang}"`)), [].slice.call(t).forEach((i)=>{
            i.mode !== "disabled" && i !== n1 && (i.mode = "disabled");
        }), n1) {
            const i = this.subtitleDisplay ? "showing" : "hidden";
            n1.mode !== i && (n1.mode = i);
        }
    }
    /**
   * This method is responsible for validating the subtitle index and periodically reloading if live.
   * Dispatches the SUBTITLE_TRACK_SWITCH event, which instructs the subtitle-stream-controller to load the selected track.
   */ setSubtitleTrack(e) {
        const t = this.tracksInGroup;
        if (!this.media) {
            this.queuedDefaultTrack = e;
            return;
        }
        if (e < -1 || e >= t.length || !ue(e)) {
            this.warn(`Invalid subtitle track id: ${e}`);
            return;
        }
        this.selectDefaultTrack = !1;
        const r = this.currentTrack, n1 = t[e] || null;
        if (this.trackId = e, this.currentTrack = n1, this.toggleTrackModes(), !n1) {
            this.hls.trigger(I.SUBTITLE_TRACK_SWITCH, {
                id: e
            });
            return;
        }
        const i = !!n1.details && !n1.details.live;
        if (e === this.trackId && n1 === r && i) return;
        this.log(`Switching to subtitle-track ${e}` + (n1 ? ` "${n1.name}" lang:${n1.lang} group:${n1.groupId}` : ""));
        const { id: o, groupId: a = "", name: l, type: c, url: u } = n1;
        this.hls.trigger(I.SUBTITLE_TRACK_SWITCH, {
            id: o,
            groupId: a,
            name: l,
            type: c,
            url: u
        });
        const d1 = this.switchParams(n1.url, r == null ? void 0 : r.details, n1.details);
        this.loadPlaylist(d1);
    }
}
function fw() {
    try {
        return crypto.randomUUID();
    } catch  {
        try {
            const e = URL.createObjectURL(new Blob()), t = e.toString();
            return URL.revokeObjectURL(e), t.slice(t.lastIndexOf("/") + 1);
        } catch  {
            let t = /* @__PURE__ */ new Date().getTime();
            return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (n1)=>{
                const i = (t + Math.random() * 16) % 16 | 0;
                return t = Math.floor(t / 16), (n1 == "x" ? i : i & 3 | 8).toString(16);
            });
        }
    }
}
function Xn(s) {
    let e = 5381, t = s.length;
    for(; t;)e = e * 33 ^ s.charCodeAt(--t);
    return (e >>> 0).toString();
}
const In = 0.025;
let ia = /* @__PURE__ */ function(s) {
    return s[s.Point = 0] = "Point", s[s.Range = 1] = "Range", s;
}({});
function gw(s, e, t) {
    return `${s.identifier}-${t + 1}-${Xn(e)}`;
}
class pw {
    constructor(e, t){
        this.base = void 0, this._duration = null, this._timelineStart = null, this.appendInPlaceDisabled = void 0, this.appendInPlaceStarted = void 0, this.dateRange = void 0, this.hasPlayed = !1, this.cumulativeDuration = 0, this.resumeOffset = NaN, this.playoutLimit = NaN, this.restrictions = {
            skip: !1,
            jump: !1
        }, this.snapOptions = {
            out: !1,
            in: !1
        }, this.assetList = [], this.assetListLoader = void 0, this.assetListResponse = null, this.resumeAnchor = void 0, this.error = void 0, this.resetOnResume = void 0, this.base = t, this.dateRange = e, this.setDateRange(e);
    }
    setDateRange(e) {
        this.dateRange = e, this.resumeOffset = e.attr.optionalFloat("X-RESUME-OFFSET", this.resumeOffset), this.playoutLimit = e.attr.optionalFloat("X-PLAYOUT-LIMIT", this.playoutLimit), this.restrictions = e.attr.enumeratedStringList("X-RESTRICT", this.restrictions), this.snapOptions = e.attr.enumeratedStringList("X-SNAP", this.snapOptions);
    }
    reset() {
        var e;
        this.appendInPlaceStarted = !1, (e = this.assetListLoader) == null || e.destroy(), this.assetListLoader = void 0, this.supplementsPrimary || (this.assetListResponse = null, this.assetList = [], this._duration = null);
    }
    isAssetPastPlayoutLimit(e) {
        var t;
        if (e > 0 && e >= this.assetList.length) return !0;
        const r = this.playoutLimit;
        return e <= 0 || isNaN(r) ? !1 : r === 0 ? !0 : (((t = this.assetList[e]) == null ? void 0 : t.startOffset) || 0) > r;
    }
    findAssetIndex(e) {
        return this.assetList.indexOf(e);
    }
    get identifier() {
        return this.dateRange.id;
    }
    get startDate() {
        return this.dateRange.startDate;
    }
    get startTime() {
        const e = this.dateRange.startTime;
        if (this.snapOptions.out) {
            const t = this.dateRange.tagAnchor;
            if (t) return bl(e, t);
        }
        return e;
    }
    get startOffset() {
        return this.cue.pre ? 0 : this.startTime;
    }
    get startIsAligned() {
        if (this.startTime === 0 || this.snapOptions.out) return !0;
        const e = this.dateRange.tagAnchor;
        if (e) {
            const t = this.dateRange.startTime, r = bl(t, e);
            return t - r < 0.1;
        }
        return !1;
    }
    get resumptionOffset() {
        const e = this.resumeOffset, t = ue(e) ? e : this.duration;
        return this.cumulativeDuration + t;
    }
    get resumeTime() {
        const e = this.startOffset + this.resumptionOffset;
        if (this.snapOptions.in) {
            const t = this.resumeAnchor;
            if (t) return bl(e, t);
        }
        return e;
    }
    get appendInPlace() {
        return this.appendInPlaceStarted ? !0 : this.appendInPlaceDisabled ? !1 : !!(!this.cue.once && !this.cue.pre && // preroll starts at startPosition before startPosition is known (live)
        this.startIsAligned && (isNaN(this.playoutLimit) && isNaN(this.resumeOffset) || this.resumeOffset && this.duration && Math.abs(this.resumeOffset - this.duration) < In));
    }
    set appendInPlace(e) {
        if (this.appendInPlaceStarted) {
            this.resetOnResume = !e;
            return;
        }
        this.appendInPlaceDisabled = !e;
    }
    // Extended timeline start time
    get timelineStart() {
        return this._timelineStart !== null ? this._timelineStart : this.startTime;
    }
    set timelineStart(e) {
        this._timelineStart = e;
    }
    get duration() {
        const e = this.playoutLimit;
        let t;
        return this._duration !== null ? t = this._duration : this.dateRange.duration ? t = this.dateRange.duration : t = this.dateRange.plannedDuration || 0, !isNaN(e) && e < t && (t = e), t;
    }
    set duration(e) {
        this._duration = e;
    }
    get cue() {
        return this.dateRange.cue;
    }
    get timelineOccupancy() {
        return this.dateRange.attr["X-TIMELINE-OCCUPIES"] === "RANGE" ? ia.Range : ia.Point;
    }
    get supplementsPrimary() {
        return this.dateRange.attr["X-TIMELINE-STYLE"] === "PRIMARY";
    }
    get contentMayVary() {
        return this.dateRange.attr["X-CONTENT-MAY-VARY"] !== "NO";
    }
    get assetUrl() {
        return this.dateRange.attr["X-ASSET-URI"];
    }
    get assetListUrl() {
        return this.dateRange.attr["X-ASSET-LIST"];
    }
    get baseUrl() {
        return this.base.url;
    }
    get assetListLoaded() {
        return this.assetList.length > 0 || this.assetListResponse !== null;
    }
    toString() {
        return mw(this);
    }
}
function bl(s, e) {
    return s - e.start < e.duration / 2 && !(Math.abs(s - (e.start + e.duration)) < In) ? e.start : e.start + e.duration;
}
function $p(s, e, t) {
    const r = new self.URL(s, t);
    return r.protocol !== "data:" && r.searchParams.set("_HLS_primary_id", e), r;
}
function Tl(s, e) {
    for(; (t = s.assetList[++e]) != null && t.error;)var t;
    return e;
}
function mw(s) {
    return `["${s.identifier}" ${s.cue.pre ? "<pre>" : s.cue.post ? "<post>" : ""}${s.timelineStart.toFixed(2)}-${s.resumeTime.toFixed(2)}]`;
}
function mn(s) {
    const e = s.timelineStart, t = s.duration || 0;
    return `["${s.identifier}" ${e.toFixed(2)}-${(e + t).toFixed(2)}]`;
}
class yw {
    constructor(e, t, r, n1){
        this.hls = void 0, this.interstitial = void 0, this.assetItem = void 0, this.tracks = null, this.hasDetails = !1, this.mediaAttached = null, this._currentTime = void 0, this._bufferedEosTime = void 0, this.checkPlayout = ()=>{
            this.reachedPlayout(this.currentTime) && this.hls && this.hls.trigger(I.PLAYOUT_LIMIT_REACHED, {});
        };
        const i = this.hls = new e(t);
        this.interstitial = r, this.assetItem = n1;
        const o = ()=>{
            this.hasDetails = !0;
        };
        i.once(I.LEVEL_LOADED, o), i.once(I.AUDIO_TRACK_LOADED, o), i.once(I.SUBTITLE_TRACK_LOADED, o), i.on(I.MEDIA_ATTACHING, (a, { media: l })=>{
            this.removeMediaListeners(), this.mediaAttached = l, this.interstitial.playoutLimit && (l.addEventListener("timeupdate", this.checkPlayout), this.appendInPlace && i.on(I.BUFFER_APPENDED, ()=>{
                const u = this.bufferedEnd;
                this.reachedPlayout(u) && (this._bufferedEosTime = u, i.trigger(I.BUFFERED_TO_END, void 0));
            }));
        });
    }
    get appendInPlace() {
        return this.interstitial.appendInPlace;
    }
    loadSource() {
        const e = this.hls;
        if (e) if (e.url) e.levels.length && !e.started && e.startLoad(-1, !0);
        else {
            let t = this.assetItem.uri;
            try {
                t = $p(t, e.config.primarySessionId || "").href;
            } catch  {}
            e.loadSource(t);
        }
    }
    bufferedInPlaceToEnd(e) {
        var t;
        if (!this.appendInPlace) return !1;
        if ((t = this.hls) != null && t.bufferedToEnd) return !0;
        if (!e) return !1;
        const r = Math.min(this._bufferedEosTime || 1 / 0, this.duration), n1 = this.timelineOffset, i = Ce.bufferInfo(e, n1, 0);
        return this.getAssetTime(i.end) >= r - 0.02;
    }
    reachedPlayout(e) {
        const r = this.interstitial.playoutLimit;
        return this.startOffset + e >= r;
    }
    get destroyed() {
        var e;
        return !((e = this.hls) != null && e.userConfig);
    }
    get assetId() {
        return this.assetItem.identifier;
    }
    get interstitialId() {
        return this.assetItem.parentIdentifier;
    }
    get media() {
        var e;
        return ((e = this.hls) == null ? void 0 : e.media) || null;
    }
    get bufferedEnd() {
        const e = this.media || this.mediaAttached;
        if (!e) return this._bufferedEosTime ? this._bufferedEosTime : this.currentTime;
        const t = Ce.bufferInfo(e, e.currentTime, 1e-3);
        return this.getAssetTime(t.end);
    }
    get currentTime() {
        const e = this.media || this.mediaAttached;
        return e ? this.getAssetTime(e.currentTime) : this._currentTime || 0;
    }
    get duration() {
        const e = this.assetItem.duration;
        if (!e) return 0;
        const t = this.interstitial.playoutLimit;
        if (t) {
            const r = t - this.startOffset;
            if (r > 0 && r < e) return r;
        }
        return e;
    }
    get remaining() {
        const e = this.duration;
        return e ? Math.max(0, e - this.currentTime) : 0;
    }
    get startOffset() {
        return this.assetItem.startOffset;
    }
    get timelineOffset() {
        var e;
        return ((e = this.hls) == null ? void 0 : e.config.timelineOffset) || 0;
    }
    set timelineOffset(e) {
        const t = this.timelineOffset;
        if (e !== t) {
            const r = e - t;
            if (Math.abs(r) > 1 / 9e4 && this.hls) {
                if (this.hasDetails) throw new Error("Cannot set timelineOffset after playlists are loaded");
                this.hls.config.timelineOffset = e;
            }
        }
    }
    getAssetTime(e) {
        const t = this.timelineOffset, r = this.duration;
        return Math.min(Math.max(0, e - t), r);
    }
    removeMediaListeners() {
        const e = this.mediaAttached;
        e && (this._currentTime = e.currentTime, this.bufferSnapShot(), e.removeEventListener("timeupdate", this.checkPlayout));
    }
    bufferSnapShot() {
        if (this.mediaAttached) {
            var e;
            (e = this.hls) != null && e.bufferedToEnd && (this._bufferedEosTime = this.bufferedEnd);
        }
    }
    destroy() {
        this.removeMediaListeners(), this.hls && this.hls.destroy(), this.hls = null, this.tracks = this.mediaAttached = this.checkPlayout = null;
    }
    attachMedia(e) {
        var t;
        this.loadSource(), (t = this.hls) == null || t.attachMedia(e);
    }
    detachMedia() {
        var e;
        this.removeMediaListeners(), this.mediaAttached = null, (e = this.hls) == null || e.detachMedia();
    }
    resumeBuffering() {
        var e;
        (e = this.hls) == null || e.resumeBuffering();
    }
    pauseBuffering() {
        var e;
        (e = this.hls) == null || e.pauseBuffering();
    }
    transferMedia() {
        var e;
        return this.bufferSnapShot(), ((e = this.hls) == null ? void 0 : e.transferMedia()) || null;
    }
    resetDetails() {
        const e = this.hls;
        if (e && this.hasDetails) {
            e.stopLoad();
            const t = (r)=>delete r.details;
            e.levels.forEach(t), e.allAudioTracks.forEach(t), e.allSubtitleTracks.forEach(t), this.hasDetails = !1;
        }
    }
    on(e, t, r) {
        var n1;
        (n1 = this.hls) == null || n1.on(e, t);
    }
    once(e, t, r) {
        var n1;
        (n1 = this.hls) == null || n1.once(e, t);
    }
    off(e, t, r) {
        var n1;
        (n1 = this.hls) == null || n1.off(e, t);
    }
    toString() {
        var e;
        return `HlsAssetPlayer: ${mn(this.assetItem)} ${(e = this.hls) == null ? void 0 : e.sessionId} ${this.appendInPlace ? "append-in-place" : ""}`;
    }
}
const Xh = 0.033;
class vw extends Rr {
    constructor(e, t){
        super("interstitials-sched", t), this.onScheduleUpdate = void 0, this.eventMap = {}, this.events = null, this.items = null, this.durations = {
            primary: 0,
            playout: 0,
            integrated: 0
        }, this.onScheduleUpdate = e;
    }
    destroy() {
        this.reset(), this.onScheduleUpdate = null;
    }
    reset() {
        this.eventMap = {}, this.setDurations(0, 0, 0), this.events && this.events.forEach((e)=>e.reset()), this.events = this.items = null;
    }
    resetErrorsInRange(e, t) {
        return this.events ? this.events.reduce((r, n1)=>e <= n1.startOffset && t > n1.startOffset ? (delete n1.error, r + 1) : r, 0) : 0;
    }
    get duration() {
        const e = this.items;
        return e ? e[e.length - 1].end : 0;
    }
    get length() {
        return this.items ? this.items.length : 0;
    }
    getEvent(e) {
        return e && this.eventMap[e] || null;
    }
    hasEvent(e) {
        return e in this.eventMap;
    }
    findItemIndex(e, t) {
        if (e.event) return this.findEventIndex(e.event.identifier);
        let r = -1;
        e.nextEvent ? r = this.findEventIndex(e.nextEvent.identifier) - 1 : e.previousEvent && (r = this.findEventIndex(e.previousEvent.identifier) + 1);
        const n1 = this.items;
        if (n1) for(n1[r] || (t === void 0 && (t = e.start), r = this.findItemIndexAtTime(t)); r >= 0 && (i = n1[r]) != null && i.event;){
            var i;
            r--;
        }
        return r;
    }
    findItemIndexAtTime(e, t) {
        const r = this.items;
        if (r) for(let n1 = 0; n1 < r.length; n1++){
            let i = r[n1];
            if (t && t !== "primary" && (i = i[t]), e === i.start || e > i.start && e < i.end) return n1;
        }
        return -1;
    }
    findJumpRestrictedIndex(e, t) {
        const r = this.items;
        if (r) for(let n1 = e; n1 <= t && r[n1]; n1++){
            const i = r[n1].event;
            if (i != null && i.restrictions.jump && !i.appendInPlace) return n1;
        }
        return -1;
    }
    findEventIndex(e) {
        const t = this.items;
        if (t) for(let n1 = t.length; n1--;){
            var r;
            if (((r = t[n1].event) == null ? void 0 : r.identifier) === e) return n1;
        }
        return -1;
    }
    findAssetIndex(e, t) {
        const r = e.assetList, n1 = r.length;
        if (n1 > 1) for(let i = 0; i < n1; i++){
            const o = r[i];
            if (!o.error) {
                const a = o.timelineStart;
                if (t === a || t > a && (t < a + (o.duration || 0) || i === n1 - 1)) return i;
            }
        }
        return 0;
    }
    get assetIdAtEnd() {
        var e;
        const t = (e = this.items) == null || (e = e[this.length - 1]) == null ? void 0 : e.event;
        if (t) {
            const r = t.assetList, n1 = r[r.length - 1];
            if (n1) return n1.identifier;
        }
        return null;
    }
    parseInterstitialDateRanges(e, t) {
        const r = e.main.details, { dateRanges: n1 } = r, i = this.events, o = this.parseDateRanges(n1, {
            url: r.url
        }, t), a = Object.keys(n1), l = i ? i.filter((c)=>!a.includes(c.identifier)) : [];
        o.length && o.sort((c, u)=>{
            const d1 = c.cue.pre, h = c.cue.post, f = u.cue.pre, p = u.cue.post;
            if (d1 && !f) return -1;
            if (f && !d1 || h && !p) return 1;
            if (p && !h) return -1;
            if (!d1 && !f && !h && !p) {
                const y = c.startTime, E = u.startTime;
                if (y !== E) return y - E;
            }
            return c.dateRange.tagOrder - u.dateRange.tagOrder;
        }), this.events = o, l.forEach((c)=>{
            this.removeEvent(c);
        }), this.updateSchedule(e, l);
    }
    updateSchedule(e, t = [], r = !1) {
        const n1 = this.events || [];
        if (n1.length || t.length || this.length < 2) {
            const i = this.items, o = this.parseSchedule(n1, e);
            (r || t.length || (i == null ? void 0 : i.length) !== o.length || o.some((l, c)=>Math.abs(l.playout.start - i[c].playout.start) > 5e-3 || Math.abs(l.playout.end - i[c].playout.end) > 5e-3)) && (this.items = o, this.onScheduleUpdate(t, i));
        }
    }
    parseDateRanges(e, t, r) {
        const n1 = [], i = Object.keys(e);
        for(let o = 0; o < i.length; o++){
            const a = i[o], l = e[a];
            if (l.isInterstitial) {
                let c = this.eventMap[a];
                c ? c.setDateRange(l) : (c = new pw(l, t), this.eventMap[a] = c, r === !1 && (c.appendInPlace = r)), n1.push(c);
            }
        }
        return n1;
    }
    parseSchedule(e, t) {
        const r = [], n1 = t.main.details, i = n1.live ? 1 / 0 : n1.edge;
        let o = 0;
        if (e = e.filter((l)=>!l.error && !(l.cue.once && l.hasPlayed)), e.length) {
            this.resolveOffsets(e, t);
            let l = 0, c = 0;
            if (e.forEach((u, d1)=>{
                const h = u.cue.pre, f = u.cue.post, p = e[d1 - 1] || null, y = u.appendInPlace, E = f ? i : u.startOffset, b = u.duration, L = u.timelineOccupancy === ia.Range ? b : 0, A = u.resumptionOffset, F = (p == null ? void 0 : p.startTime) === E, M = E + u.cumulativeDuration;
                let H = y ? M + b : E + A;
                if (h || !f && E <= 0) {
                    const j = c;
                    c += L, u.timelineStart = M;
                    const C = o;
                    o += b, r.push({
                        event: u,
                        start: M,
                        end: H,
                        playout: {
                            start: C,
                            end: o
                        },
                        integrated: {
                            start: j,
                            end: c
                        }
                    });
                } else if (E <= i) {
                    if (!F) {
                        const k = E - l;
                        if (k > Xh) {
                            const $ = l, W = c;
                            c += k;
                            const _ = o;
                            o += k;
                            const g = {
                                previousEvent: e[d1 - 1] || null,
                                nextEvent: u,
                                start: $,
                                end: $ + k,
                                playout: {
                                    start: _,
                                    end: o
                                },
                                integrated: {
                                    start: W,
                                    end: c
                                }
                            };
                            r.push(g);
                        } else k > 0 && p && (p.cumulativeDuration += k, r[r.length - 1].end = E);
                    }
                    f && (H = M), u.timelineStart = M;
                    const j = c;
                    c += L;
                    const C = o;
                    o += b, r.push({
                        event: u,
                        start: M,
                        end: H,
                        playout: {
                            start: C,
                            end: o
                        },
                        integrated: {
                            start: j,
                            end: c
                        }
                    });
                } else return;
                const K = u.resumeTime;
                f || K > i ? l = i : l = K;
            }), l < i) {
                var a;
                const u = l, d1 = c, h = i - l;
                c += h;
                const f = o;
                o += h, r.push({
                    previousEvent: ((a = r[r.length - 1]) == null ? void 0 : a.event) || null,
                    nextEvent: null,
                    start: l,
                    end: u + h,
                    playout: {
                        start: f,
                        end: o
                    },
                    integrated: {
                        start: d1,
                        end: c
                    }
                });
            }
            this.setDurations(i, o, c);
        } else r.push({
            previousEvent: null,
            nextEvent: null,
            start: 0,
            end: i,
            playout: {
                start: 0,
                end: i
            },
            integrated: {
                start: 0,
                end: i
            }
        }), this.setDurations(i, i, i);
        return r;
    }
    setDurations(e, t, r) {
        this.durations = {
            primary: e,
            playout: t,
            integrated: r
        };
    }
    resolveOffsets(e, t) {
        const r = t.main.details, n1 = r.live ? 1 / 0 : r.edge;
        let i = 0, o = -1;
        e.forEach((a, l)=>{
            const c = a.cue.pre, u = a.cue.post, d1 = c ? 0 : u ? n1 : a.startTime;
            this.updateAssetDurations(a), o === d1 ? a.cumulativeDuration = i : (i = 0, o = d1), !u && a.snapOptions.in && (a.resumeAnchor = Js(null, r.fragments, a.startOffset + a.resumptionOffset, 0, 0) || void 0), a.appendInPlace && !a.appendInPlaceStarted && (this.primaryCanResumeInPlaceAt(a, t) || (a.appendInPlace = !1)), !a.appendInPlace && l + 1 < e.length && e[l + 1].startTime - e[l].resumeTime < Xh && (e[l + 1].appendInPlace = !1, e[l + 1].appendInPlace && this.warn(`Could not change append strategy for abutting event ${a}`));
            const f = ue(a.resumeOffset) ? a.resumeOffset : a.duration;
            i += f;
        });
    }
    primaryCanResumeInPlaceAt(e, t) {
        const r = e.resumeTime, n1 = e.startTime + e.resumptionOffset;
        return Math.abs(r - n1) > In ? (this.log(`"${e.identifier}" resumption ${r} not aligned with estimated timeline end ${n1}`), !1) : !Object.keys(t).some((o)=>{
            const a = t[o].details, l = a.edge;
            if (r >= l) return this.log(`"${e.identifier}" resumption ${r} past ${o} playlist end ${l}`), !1;
            const c = Js(null, a.fragments, r);
            if (!c) return this.log(`"${e.identifier}" resumption ${r} does not align with any fragments in ${o} playlist (${a.fragStart}-${a.fragmentEnd})`), !0;
            const u = o === "audio" ? 0.175 : 0;
            return Math.abs(c.start - r) < In + u || Math.abs(c.end - r) < In + u ? !1 : (this.log(`"${e.identifier}" resumption ${r} not aligned with ${o} fragment bounds (${c.start}-${c.end} sn: ${c.sn} cc: ${c.cc})`), !0);
        });
    }
    updateAssetDurations(e) {
        if (!e.assetListLoaded) return;
        const t = e.timelineStart;
        let r = 0, n1 = !1, i = !1;
        for(let o = 0; o < e.assetList.length; o++){
            const a = e.assetList[o], l = t + r;
            a.startOffset = r, a.timelineStart = l, n1 || (n1 = a.duration === null), i || (i = !!a.error);
            const c = a.error ? 0 : a.duration || 0;
            r += c;
        }
        n1 && !i ? e.duration = Math.max(r, e.duration) : e.duration = r;
    }
    removeEvent(e) {
        e.reset(), delete this.eventMap[e.identifier];
    }
}
function kr(s) {
    return `[${s.event ? '"' + s.event.identifier + '"' : "primary"}: ${s.start.toFixed(2)}-${s.end.toFixed(2)}]`;
}
class Ew {
    constructor(e){
        this.hls = void 0, this.hls = e;
    }
    destroy() {
        this.hls = null;
    }
    loadAssetList(e, t) {
        const r = e.assetListUrl;
        let n1;
        try {
            n1 = $p(r, this.hls.sessionId, e.baseUrl);
        } catch (h) {
            const f = this.assignAssetListError(e, J.ASSET_LIST_LOAD_ERROR, h, r);
            this.hls.trigger(I.ERROR, f);
            return;
        }
        t && n1.protocol !== "data:" && n1.searchParams.set("_HLS_start_offset", "" + t);
        const i = this.hls.config, o = i.loader, a = new o(i), l = {
            responseType: "json",
            url: n1.href
        }, c = i.interstitialAssetListLoadPolicy.default, u = {
            loadPolicy: c,
            timeout: c.maxLoadTimeMs,
            maxRetry: 0,
            retryDelay: 0,
            maxRetryDelay: 0
        }, d1 = {
            onSuccess: (h, f, p, y)=>{
                const E = h.data, b = E == null ? void 0 : E.ASSETS;
                if (!Array.isArray(b)) {
                    const L = this.assignAssetListError(e, J.ASSET_LIST_PARSING_ERROR, new Error("Invalid interstitial asset list"), p.url, f, y);
                    this.hls.trigger(I.ERROR, L);
                    return;
                }
                e.assetListResponse = E, this.hls.trigger(I.ASSET_LIST_LOADED, {
                    event: e,
                    assetListResponse: E,
                    networkDetails: y
                });
            },
            onError: (h, f, p, y)=>{
                const E = this.assignAssetListError(e, J.ASSET_LIST_LOAD_ERROR, new Error(`Error loading X-ASSET-LIST: HTTP status ${h.code} ${h.text} (${f.url})`), f.url, y, p);
                this.hls.trigger(I.ERROR, E);
            },
            onTimeout: (h, f, p)=>{
                const y = this.assignAssetListError(e, J.ASSET_LIST_LOAD_TIMEOUT, new Error(`Timeout loading X-ASSET-LIST (${f.url})`), f.url, h, p);
                this.hls.trigger(I.ERROR, y);
            }
        };
        return a.load(l, u, d1), this.hls.trigger(I.ASSET_LIST_LOADING, {
            event: e
        }), a;
    }
    assignAssetListError(e, t, r, n1, i, o) {
        return e.error = r, {
            type: ve.NETWORK_ERROR,
            details: t,
            fatal: !1,
            interstitial: e,
            url: n1,
            error: r,
            networkDetails: o,
            stats: i
        };
    }
}
function Jh(s) {
    s == null || s.play().catch(()=>{});
}
function Qi(s, e) {
    return `[${s}] Advancing timeline position to ${e}`;
}
class xw extends Rr {
    constructor(e, t){
        super("interstitials", e.logger), this.HlsPlayerClass = void 0, this.hls = void 0, this.assetListLoader = void 0, this.mediaSelection = null, this.altSelection = null, this.media = null, this.detachedData = null, this.requiredTracks = null, this.manager = null, this.playerQueue = [], this.bufferedPos = -1, this.timelinePos = -1, this.schedule = void 0, this.playingItem = null, this.bufferingItem = null, this.waitingItem = null, this.endedItem = null, this.playingAsset = null, this.endedAsset = null, this.bufferingAsset = null, this.shouldPlay = !1, this.onPlay = ()=>{
            this.shouldPlay = !0;
        }, this.onPause = ()=>{
            this.shouldPlay = !1;
        }, this.onSeeking = ()=>{
            const r = this.currentTime;
            if (r === void 0 || this.playbackDisabled || !this.schedule) return;
            const n1 = r - this.timelinePos;
            if (Math.abs(n1) < 1 / 7056e5) return;
            const o = n1 <= -0.01;
            this.timelinePos = r, this.bufferedPos = r;
            const a = this.playingItem;
            if (!a) {
                this.checkBuffer();
                return;
            }
            if (o && this.schedule.resetErrorsInRange(r, r - n1) && this.updateSchedule(!0), this.checkBuffer(), o && r < a.start || r >= a.end) {
                var l;
                const f = this.findItemIndex(a);
                let p = this.schedule.findItemIndexAtTime(r);
                if (p === -1 && (p = f + (o ? -1 : 1), this.log(`seeked ${o ? "back " : ""}to position not covered by schedule ${r} (resolving from ${f} to ${p})`)), !this.isInterstitial(a) && (l = this.media) != null && l.paused && (this.shouldPlay = !1), !o && p > f) {
                    const y = this.schedule.findJumpRestrictedIndex(f + 1, p);
                    if (y > f) {
                        this.setSchedulePosition(y);
                        return;
                    }
                }
                this.setSchedulePosition(p);
                return;
            }
            const c = this.playingAsset;
            if (!c) {
                if (this.playingLastItem && this.isInterstitial(a)) {
                    const f = a.event.assetList[0];
                    f && (this.endedItem = this.playingItem, this.playingItem = null, this.setScheduleToAssetAtTime(r, f));
                }
                return;
            }
            const u = c.timelineStart, d1 = c.duration || 0;
            if (o && r < u || r >= u + d1) {
                var h;
                (h = a.event) != null && h.appendInPlace && (this.clearInterstitial(a.event, a), this.flushFrontBuffer(r)), this.setScheduleToAssetAtTime(r, c);
            }
        }, this.onTimeupdate = ()=>{
            const r = this.currentTime;
            if (r === void 0 || this.playbackDisabled) return;
            if (r > this.timelinePos) this.timelinePos = r, r > this.bufferedPos && this.checkBuffer();
            else return;
            const n1 = this.playingItem;
            if (!n1 || this.playingLastItem) return;
            if (r >= n1.end) {
                this.timelinePos = n1.end;
                const a = this.findItemIndex(n1);
                this.setSchedulePosition(a + 1);
            }
            const i = this.playingAsset;
            if (!i) return;
            const o = i.timelineStart + (i.duration || 0);
            r >= o && this.setScheduleToAssetAtTime(r, i);
        }, this.onScheduleUpdate = (r, n1)=>{
            const i = this.schedule;
            if (!i) return;
            const o = this.playingItem, a = i.events || [], l = i.items || [], c = i.durations, u = r.map((y)=>y.identifier), d1 = !!(a.length || u.length);
            (d1 || n1) && this.log(`INTERSTITIALS_UPDATED (${a.length}): ${a}
Schedule: ${l.map((y)=>kr(y))} pos: ${this.timelinePos}`), u.length && this.log(`Removed events ${u}`);
            let h = null, f = null;
            o && (h = this.updateItem(o, this.timelinePos), this.itemsMatch(o, h) ? this.playingItem = h : this.waitingItem = this.endedItem = null), this.waitingItem = this.updateItem(this.waitingItem), this.endedItem = this.updateItem(this.endedItem);
            const p = this.bufferingItem;
            if (p && (f = this.updateItem(p, this.bufferedPos), this.itemsMatch(p, f) ? this.bufferingItem = f : p.event && (this.bufferingItem = this.playingItem, this.clearInterstitial(p.event, null))), r.forEach((y)=>{
                y.assetList.forEach((E)=>{
                    this.clearAssetPlayer(E.identifier, null);
                });
            }), this.playerQueue.forEach((y)=>{
                if (y.interstitial.appendInPlace) {
                    const E = y.assetItem.timelineStart, b = y.timelineOffset - E;
                    if (b) try {
                        y.timelineOffset = E;
                    } catch (L) {
                        Math.abs(b) > In && this.warn(`${L} ("${y.assetId}" ${y.timelineOffset}->${E})`);
                    }
                }
            }), d1 || n1) {
                if (this.hls.trigger(I.INTERSTITIALS_UPDATED, {
                    events: a.slice(0),
                    schedule: l.slice(0),
                    durations: c,
                    removedIds: u
                }), this.isInterstitial(o) && u.includes(o.event.identifier)) {
                    this.warn(`Interstitial "${o.event.identifier}" removed while playing`), this.primaryFallback(o.event);
                    return;
                }
                o && this.trimInPlace(h, o), p && f !== h && this.trimInPlace(f, p), this.checkBuffer();
            }
        }, this.hls = e, this.HlsPlayerClass = t, this.assetListLoader = new Ew(e), this.schedule = new vw(this.onScheduleUpdate, e.logger), this.registerListeners();
    }
    registerListeners() {
        const e = this.hls;
        e && (e.on(I.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(I.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(I.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(I.MANIFEST_LOADING, this.onManifestLoading, this), e.on(I.LEVEL_UPDATED, this.onLevelUpdated, this), e.on(I.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.on(I.AUDIO_TRACK_UPDATED, this.onAudioTrackUpdated, this), e.on(I.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e.on(I.SUBTITLE_TRACK_UPDATED, this.onSubtitleTrackUpdated, this), e.on(I.EVENT_CUE_ENTER, this.onInterstitialCueEnter, this), e.on(I.ASSET_LIST_LOADED, this.onAssetListLoaded, this), e.on(I.BUFFER_APPENDED, this.onBufferAppended, this), e.on(I.BUFFER_FLUSHED, this.onBufferFlushed, this), e.on(I.BUFFERED_TO_END, this.onBufferedToEnd, this), e.on(I.MEDIA_ENDED, this.onMediaEnded, this), e.on(I.ERROR, this.onError, this), e.on(I.DESTROYING, this.onDestroying, this));
    }
    unregisterListeners() {
        const e = this.hls;
        e && (e.off(I.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(I.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(I.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(I.MANIFEST_LOADING, this.onManifestLoading, this), e.off(I.LEVEL_UPDATED, this.onLevelUpdated, this), e.off(I.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.off(I.AUDIO_TRACK_UPDATED, this.onAudioTrackUpdated, this), e.off(I.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e.off(I.SUBTITLE_TRACK_UPDATED, this.onSubtitleTrackUpdated, this), e.off(I.EVENT_CUE_ENTER, this.onInterstitialCueEnter, this), e.off(I.ASSET_LIST_LOADED, this.onAssetListLoaded, this), e.off(I.BUFFER_CODECS, this.onBufferCodecs, this), e.off(I.BUFFER_APPENDED, this.onBufferAppended, this), e.off(I.BUFFER_FLUSHED, this.onBufferFlushed, this), e.off(I.BUFFERED_TO_END, this.onBufferedToEnd, this), e.off(I.MEDIA_ENDED, this.onMediaEnded, this), e.off(I.ERROR, this.onError, this), e.off(I.DESTROYING, this.onDestroying, this));
    }
    startLoad() {
        this.resumeBuffering();
    }
    stopLoad() {
        this.pauseBuffering();
    }
    resumeBuffering() {
        var e;
        (e = this.getBufferingPlayer()) == null || e.resumeBuffering();
    }
    pauseBuffering() {
        var e;
        (e = this.getBufferingPlayer()) == null || e.pauseBuffering();
    }
    destroy() {
        this.unregisterListeners(), this.stopLoad(), this.assetListLoader && this.assetListLoader.destroy(), this.emptyPlayerQueue(), this.clearScheduleState(), this.schedule && this.schedule.destroy(), this.media = this.detachedData = this.mediaSelection = this.requiredTracks = this.altSelection = this.schedule = this.manager = null, this.hls = this.HlsPlayerClass = this.log = null, this.assetListLoader = null, this.onPlay = this.onPause = this.onSeeking = this.onTimeupdate = null, this.onScheduleUpdate = null;
    }
    onDestroying() {
        const e = this.primaryMedia || this.media;
        e && this.removeMediaListeners(e);
    }
    removeMediaListeners(e) {
        pr(e, "play", this.onPlay), pr(e, "pause", this.onPause), pr(e, "seeking", this.onSeeking), pr(e, "timeupdate", this.onTimeupdate);
    }
    onMediaAttaching(e, t) {
        const r = this.media = t.media;
        cr(r, "seeking", this.onSeeking), cr(r, "timeupdate", this.onTimeupdate), cr(r, "play", this.onPlay), cr(r, "pause", this.onPause);
    }
    onMediaAttached(e, t) {
        const r = this.effectivePlayingItem, n1 = this.detachedData;
        if (this.detachedData = null, r === null) this.checkStart();
        else if (!n1) {
            this.clearScheduleState();
            const i = this.findItemIndex(r);
            this.setSchedulePosition(i);
        }
    }
    clearScheduleState() {
        this.log("clear schedule state"), this.playingItem = this.bufferingItem = this.waitingItem = this.endedItem = this.playingAsset = this.endedAsset = this.bufferingAsset = null;
    }
    onMediaDetaching(e, t) {
        const r = !!t.transferMedia, n1 = this.media;
        if (this.media = null, !r && (n1 && this.removeMediaListeners(n1), this.detachedData)) {
            const i = this.getBufferingPlayer();
            i && (this.log(`Removing schedule state for detachedData and ${i}`), this.playingAsset = this.endedAsset = this.bufferingAsset = this.bufferingItem = this.waitingItem = this.detachedData = null, i.detachMedia()), this.shouldPlay = !1;
        }
    }
    get interstitialsManager() {
        if (!this.hls) return null;
        if (this.manager) return this.manager;
        const e = this, t = ()=>e.bufferingItem || e.waitingItem, r = (d1)=>d1 && e.getAssetPlayer(d1.identifier), n1 = (d1, h, f, p, y)=>{
            if (d1) {
                let E = d1[h].start;
                const b = d1.event;
                if (b) {
                    if (h === "playout" || b.timelineOccupancy !== ia.Point) {
                        const L = r(f);
                        (L == null ? void 0 : L.interstitial) === b && (E += L.assetItem.startOffset + L[y]);
                    }
                } else {
                    const L = p === "bufferedPos" ? o() : e[p];
                    E += L - d1.start;
                }
                return E;
            }
            return 0;
        }, i = (d1, h)=>{
            var f;
            if (d1 !== 0 && h !== "primary" && (f = e.schedule) != null && f.length) {
                var p;
                const y = e.schedule.findItemIndexAtTime(d1), E = (p = e.schedule.items) == null ? void 0 : p[y];
                if (E) {
                    const b = E[h].start - E.start;
                    return d1 + b;
                }
            }
            return d1;
        }, o = ()=>{
            const d1 = e.bufferedPos;
            return d1 === Number.MAX_VALUE ? a("primary") : Math.max(d1, 0);
        }, a = (d1)=>{
            var h, f;
            return (h = e.primaryDetails) != null && h.live ? e.primaryDetails.edge : ((f = e.schedule) == null ? void 0 : f.durations[d1]) || 0;
        }, l = (d1, h)=>{
            var f, p;
            const y = e.effectivePlayingItem;
            if (y != null && (f = y.event) != null && f.restrictions.skip || !e.schedule) return;
            e.log(`seek to ${d1} "${h}"`);
            const E = e.effectivePlayingItem, b = e.schedule.findItemIndexAtTime(d1, h), L = (p = e.schedule.items) == null ? void 0 : p[b], A = e.getBufferingPlayer(), F = A == null ? void 0 : A.interstitial, M = F == null ? void 0 : F.appendInPlace, H = E && e.itemsMatch(E, L);
            if (E && (M || H)) {
                const K = r(e.playingAsset), j = (K == null ? void 0 : K.media) || e.primaryMedia;
                if (j) {
                    const C = h === "primary" ? j.currentTime : n1(E, h, e.playingAsset, "timelinePos", "currentTime"), k = d1 - C, $ = (M ? C : j.currentTime) + k;
                    if ($ >= 0 && (!K || M || $ <= K.duration)) {
                        j.currentTime = $;
                        return;
                    }
                }
            }
            if (L) {
                let K = d1;
                if (h !== "primary") {
                    const C = L[h].start, k = d1 - C;
                    K = L.start + k;
                }
                const j = !e.isInterstitial(L);
                if ((!e.isInterstitial(E) || E.event.appendInPlace) && (j || L.event.appendInPlace)) {
                    const C = e.media || (M ? A == null ? void 0 : A.media : null);
                    C && (C.currentTime = K);
                } else if (E) {
                    const C = e.findItemIndex(E);
                    if (b > C) {
                        const $ = e.schedule.findJumpRestrictedIndex(C + 1, b);
                        if ($ > C) {
                            e.setSchedulePosition($);
                            return;
                        }
                    }
                    let k = 0;
                    if (j) e.timelinePos = K, e.checkBuffer();
                    else {
                        const $ = L.event.assetList, W = d1 - (L[h] || L).start;
                        for(let _ = $.length; _--;){
                            const g = $[_];
                            if (g.duration && W >= g.startOffset && W < g.startOffset + g.duration) {
                                k = _;
                                break;
                            }
                        }
                    }
                    e.setSchedulePosition(b, k);
                }
            }
        }, c = ()=>{
            const d1 = e.effectivePlayingItem;
            if (e.isInterstitial(d1)) return d1;
            const h = t();
            return e.isInterstitial(h) ? h : null;
        }, u = {
            get bufferedEnd () {
                const d1 = t(), h = e.bufferingItem;
                if (h && h === d1) {
                    var f;
                    return n1(h, "playout", e.bufferingAsset, "bufferedPos", "bufferedEnd") - h.playout.start || ((f = e.bufferingAsset) == null ? void 0 : f.startOffset) || 0;
                }
                return 0;
            },
            get currentTime () {
                const d1 = c(), h = e.effectivePlayingItem;
                return h && h === d1 ? n1(h, "playout", e.effectivePlayingAsset, "timelinePos", "currentTime") - h.playout.start : 0;
            },
            set currentTime (d){
                const h = c(), f = e.effectivePlayingItem;
                f && f === h && l(d + f.playout.start, "playout");
            },
            get duration () {
                const d1 = c();
                return d1 ? d1.playout.end - d1.playout.start : 0;
            },
            get assetPlayers () {
                var d1;
                const h = (d1 = c()) == null ? void 0 : d1.event.assetList;
                return h ? h.map((f)=>e.getAssetPlayer(f.identifier)) : [];
            },
            get playingIndex () {
                var d2;
                const h = (d2 = c()) == null ? void 0 : d2.event;
                return h && e.effectivePlayingAsset ? h.findAssetIndex(e.effectivePlayingAsset) : -1;
            },
            get scheduleItem () {
                return c();
            }
        };
        return this.manager = {
            get events () {
                var d3;
                return ((d3 = e.schedule) == null || (d3 = d3.events) == null ? void 0 : d3.slice(0)) || [];
            },
            get schedule () {
                var d4;
                return ((d4 = e.schedule) == null || (d4 = d4.items) == null ? void 0 : d4.slice(0)) || [];
            },
            get interstitialPlayer () {
                return c() ? u : null;
            },
            get playerQueue () {
                return e.playerQueue.slice(0);
            },
            get bufferingAsset () {
                return e.bufferingAsset;
            },
            get bufferingItem () {
                return t();
            },
            get bufferingIndex () {
                const d1 = t();
                return e.findItemIndex(d1);
            },
            get playingAsset () {
                return e.effectivePlayingAsset;
            },
            get playingItem () {
                return e.effectivePlayingItem;
            },
            get playingIndex () {
                const d1 = e.effectivePlayingItem;
                return e.findItemIndex(d1);
            },
            primary: {
                get bufferedEnd () {
                    return o();
                },
                get currentTime () {
                    const d1 = e.timelinePos;
                    return d1 > 0 ? d1 : 0;
                },
                set currentTime (d){
                    l(d, "primary");
                },
                get duration () {
                    return a("primary");
                },
                get seekableStart () {
                    var d5;
                    return ((d5 = e.primaryDetails) == null ? void 0 : d5.fragmentStart) || 0;
                }
            },
            integrated: {
                get bufferedEnd () {
                    return n1(t(), "integrated", e.bufferingAsset, "bufferedPos", "bufferedEnd");
                },
                get currentTime () {
                    return n1(e.effectivePlayingItem, "integrated", e.effectivePlayingAsset, "timelinePos", "currentTime");
                },
                set currentTime (d){
                    l(d, "integrated");
                },
                get duration () {
                    return a("integrated");
                },
                get seekableStart () {
                    var d6;
                    return i(((d6 = e.primaryDetails) == null ? void 0 : d6.fragmentStart) || 0, "integrated");
                }
            },
            skip: ()=>{
                const d1 = e.effectivePlayingItem, h = d1 == null ? void 0 : d1.event;
                if (h && !h.restrictions.skip) {
                    const f = e.findItemIndex(d1);
                    if (h.appendInPlace) {
                        const p = d1.playout.start + d1.event.duration;
                        l(p + 1e-3, "playout");
                    } else e.advanceAfterAssetEnded(h, f, 1 / 0);
                }
            }
        };
    }
    // Schedule getters
    get effectivePlayingItem() {
        return this.waitingItem || this.playingItem || this.endedItem;
    }
    get effectivePlayingAsset() {
        return this.playingAsset || this.endedAsset;
    }
    get playingLastItem() {
        var e;
        const t = this.playingItem, r = (e = this.schedule) == null ? void 0 : e.items;
        return !this.playbackStarted || !t || !r ? !1 : this.findItemIndex(t) === r.length - 1;
    }
    get playbackStarted() {
        return this.effectivePlayingItem !== null;
    }
    // Media getters and event callbacks
    get currentTime() {
        var e, t;
        if (this.mediaSelection === null) return;
        const r = this.waitingItem || this.playingItem;
        if (this.isInterstitial(r) && !r.event.appendInPlace) return;
        let n1 = this.media;
        !n1 && (e = this.bufferingItem) != null && (e = e.event) != null && e.appendInPlace && (n1 = this.primaryMedia);
        const i = (t = n1) == null ? void 0 : t.currentTime;
        if (!(i === void 0 || !ue(i))) return i;
    }
    get primaryMedia() {
        var e;
        return this.media || ((e = this.detachedData) == null ? void 0 : e.media) || null;
    }
    isInterstitial(e) {
        return !!(e != null && e.event);
    }
    retreiveMediaSource(e, t) {
        const r = this.getAssetPlayer(e);
        r && this.transferMediaFromPlayer(r, t);
    }
    transferMediaFromPlayer(e, t) {
        const r = e.interstitial.appendInPlace, n1 = e.media;
        if (r && n1 === this.primaryMedia) {
            if (this.bufferingAsset = null, (!t || this.isInterstitial(t) && !t.event.appendInPlace) && t && n1) {
                this.detachedData = {
                    media: n1
                };
                return;
            }
            const i = e.transferMedia();
            this.log(`transfer MediaSource from ${e} ${at(i)}`), this.detachedData = i;
        } else t && n1 && (this.shouldPlay || (this.shouldPlay = !n1.paused));
    }
    transferMediaTo(e, t) {
        var r, n1;
        if (e.media === t) return;
        let i = null;
        const o = this.hls, a = e !== o, l = a && e.interstitial.appendInPlace, c = (r = this.detachedData) == null ? void 0 : r.mediaSource;
        let u;
        if (o.media) l && (i = o.transferMedia(), this.detachedData = i), u = "Primary";
        else if (c) {
            const p = this.getBufferingPlayer();
            p ? (i = p.transferMedia(), u = `${p}`) : u = "detached MediaSource";
        } else u = "detached media";
        if (!i) {
            if (c) i = this.detachedData, this.log(`using detachedData: MediaSource ${at(i)}`);
            else if (!this.detachedData || o.media === t) {
                const p = this.playerQueue;
                p.length > 1 && p.forEach((y)=>{
                    if (a && y.interstitial.appendInPlace !== l) {
                        const E = y.interstitial;
                        this.clearInterstitial(y.interstitial, null), E.appendInPlace = !1, E.appendInPlace && this.warn(`Could not change append strategy for queued assets ${E}`);
                    }
                }), this.hls.detachMedia(), this.detachedData = {
                    media: t
                };
            }
        }
        const d1 = i && "mediaSource" in i && ((n1 = i.mediaSource) == null ? void 0 : n1.readyState) !== "closed", h = d1 && i ? i : t;
        this.log(`${d1 ? "transfering MediaSource" : "attaching media"} to ${a ? e : "Primary"} from ${u} (media.currentTime: ${t.currentTime})`);
        const f = this.schedule;
        if (h === i && f) {
            const p = a && e.assetId === f.assetIdAtEnd;
            h.overrides = {
                duration: f.duration,
                endOfStream: !a || p,
                cueRemoval: !a
            };
        }
        e.attachMedia(h);
    }
    onInterstitialCueEnter() {
        this.onTimeupdate();
    }
    // Scheduling methods
    checkStart() {
        const e = this.schedule, t = e == null ? void 0 : e.events;
        if (!t || this.playbackDisabled || !this.media) return;
        this.bufferedPos === -1 && (this.bufferedPos = 0);
        const r = this.timelinePos, n1 = this.effectivePlayingItem;
        if (r === -1) {
            const i = this.hls.startPosition;
            if (this.log(Qi("checkStart", i)), this.timelinePos = i, t.length && t[0].cue.pre) {
                const o = e.findEventIndex(t[0].identifier);
                this.setSchedulePosition(o);
            } else if (i >= 0 || !this.primaryLive) {
                const o = this.timelinePos = i > 0 ? i : 0, a = e.findItemIndexAtTime(o);
                this.setSchedulePosition(a);
            }
        } else if (n1 && !this.playingItem) {
            const i = e.findItemIndex(n1);
            this.setSchedulePosition(i);
        }
    }
    advanceAssetBuffering(e, t) {
        const r = e.event, n1 = r.findAssetIndex(t), i = Tl(r, n1);
        if (!r.isAssetPastPlayoutLimit(i)) this.bufferedToEvent(e, i);
        else if (this.schedule) {
            var o;
            const a = (o = this.schedule.items) == null ? void 0 : o[this.findItemIndex(e) + 1];
            a && this.bufferedToItem(a);
        }
    }
    advanceAfterAssetEnded(e, t, r) {
        const n1 = Tl(e, r);
        if (e.isAssetPastPlayoutLimit(n1)) {
            if (this.schedule) {
                const i = this.schedule.items;
                if (i) {
                    const o = t + 1, a = i.length;
                    if (o >= a) {
                        this.setSchedulePosition(-1);
                        return;
                    }
                    const l = e.resumeTime;
                    this.timelinePos < l && (this.log(Qi("advanceAfterAssetEnded", l)), this.timelinePos = l, e.appendInPlace && this.advanceInPlace(l), this.checkBuffer(this.bufferedPos < l)), this.setSchedulePosition(o);
                }
            }
        } else {
            if (e.appendInPlace) {
                const i = e.assetList[n1];
                i && this.advanceInPlace(i.timelineStart);
            }
            this.setSchedulePosition(t, n1);
        }
    }
    setScheduleToAssetAtTime(e, t) {
        const r = this.schedule;
        if (!r) return;
        const n1 = t.parentIdentifier, i = r.getEvent(n1);
        if (i) {
            const o = r.findEventIndex(n1), a = r.findAssetIndex(i, e);
            this.advanceAfterAssetEnded(i, o, a - 1);
        }
    }
    setSchedulePosition(e, t) {
        var r;
        const n1 = (r = this.schedule) == null ? void 0 : r.items;
        if (!n1 || this.playbackDisabled) return;
        const i = e >= 0 ? n1[e] : null;
        this.log(`setSchedulePosition ${e}, ${t} (${i && kr(i)}) pos: ${this.timelinePos}`);
        const o = this.waitingItem || this.playingItem, a = this.playingLastItem;
        if (this.isInterstitial(o)) {
            const u = o.event, d1 = this.playingAsset, h = d1 == null ? void 0 : d1.identifier, f = h ? this.getAssetPlayer(h) : null;
            if (f && h && (!this.eventItemsMatch(o, i) || t !== void 0 && h !== u.assetList[t].identifier)) {
                var l;
                const p = u.findAssetIndex(d1);
                if (this.log(`INTERSTITIAL_ASSET_ENDED ${p + 1}/${u.assetList.length} ${mn(d1)}`), this.endedAsset = d1, this.playingAsset = null, this.hls.trigger(I.INTERSTITIAL_ASSET_ENDED, {
                    asset: d1,
                    assetListIndex: p,
                    event: u,
                    schedule: n1.slice(0),
                    scheduleIndex: e,
                    player: f
                }), o !== this.playingItem) {
                    this.itemsMatch(o, this.playingItem) && // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                    !this.playingAsset && this.advanceAfterAssetEnded(u, this.findItemIndex(this.playingItem), p);
                    return;
                }
                this.retreiveMediaSource(h, i), f.media && !((l = this.detachedData) != null && l.mediaSource) && f.detachMedia();
            }
            if (!this.eventItemsMatch(o, i) && (this.endedItem = o, this.playingItem = null, this.log(`INTERSTITIAL_ENDED ${u} ${kr(o)}`), u.hasPlayed = !0, this.hls.trigger(I.INTERSTITIAL_ENDED, {
                event: u,
                schedule: n1.slice(0),
                scheduleIndex: e
            }), u.cue.once)) {
                var c;
                this.updateSchedule();
                const p = (c = this.schedule) == null ? void 0 : c.items;
                if (i && p) {
                    const y = this.findItemIndex(i);
                    this.advanceSchedule(y, p, t, o, a);
                }
                return;
            }
        }
        this.advanceSchedule(e, n1, t, o, a);
    }
    advanceSchedule(e, t, r, n1, i) {
        const o = this.schedule;
        if (!o) return;
        const a = t[e] || null, l = this.primaryMedia, c = this.playerQueue;
        if (c.length && c.forEach((u)=>{
            const d1 = u.interstitial, h = o.findEventIndex(d1.identifier);
            (h < e || h > e + 1) && this.clearInterstitial(d1, a);
        }), this.isInterstitial(a)) {
            this.timelinePos = Math.min(Math.max(this.timelinePos, a.start), a.end);
            const u = a.event;
            if (r === void 0) {
                r = o.findAssetIndex(u, this.timelinePos);
                const p = Tl(u, r - 1);
                if (u.isAssetPastPlayoutLimit(p) || u.appendInPlace && this.timelinePos === a.end) {
                    this.advanceAfterAssetEnded(u, e, r);
                    return;
                }
                r = p;
            }
            const d1 = this.waitingItem;
            this.assetsBuffered(a, l) || this.setBufferingItem(a);
            let h = this.preloadAssets(u, r);
            if (this.eventItemsMatch(a, d1 || n1) || (this.waitingItem = a, this.log(`INTERSTITIAL_STARTED ${kr(a)} ${u.appendInPlace ? "append in place" : ""}`), this.hls.trigger(I.INTERSTITIAL_STARTED, {
                event: u,
                schedule: t.slice(0),
                scheduleIndex: e
            })), !u.assetListLoaded) {
                this.log(`Waiting for ASSET-LIST to complete loading ${u}`);
                return;
            }
            if (u.assetListLoader && (u.assetListLoader.destroy(), u.assetListLoader = void 0), !l) {
                this.log(`Waiting for attachMedia to start Interstitial ${u}`);
                return;
            }
            this.waitingItem = this.endedItem = null, this.playingItem = a;
            const f = u.assetList[r];
            if (!f) {
                this.advanceAfterAssetEnded(u, e, r || 0);
                return;
            }
            if (h || (h = this.getAssetPlayer(f.identifier)), h === null || h.destroyed) {
                const p = u.assetList.length;
                this.warn(`asset ${r + 1}/${p} player destroyed ${u}`), h = this.createAssetPlayer(u, f, r), h.loadSource();
            }
            if (!this.eventItemsMatch(a, this.bufferingItem) && u.appendInPlace && this.isAssetBuffered(f)) return;
            this.startAssetPlayer(h, r, t, e, l), this.shouldPlay && Jh(h.media);
        } else a ? (this.resumePrimary(a, e, n1), this.shouldPlay && Jh(this.hls.media)) : i && this.isInterstitial(n1) && (this.endedItem = null, this.playingItem = n1, n1.event.appendInPlace || this.attachPrimary(o.durations.primary, null));
    }
    get playbackDisabled() {
        return this.hls.config.enableInterstitialPlayback === !1;
    }
    get primaryDetails() {
        var e;
        return (e = this.mediaSelection) == null ? void 0 : e.main.details;
    }
    get primaryLive() {
        var e;
        return !!((e = this.primaryDetails) != null && e.live);
    }
    resumePrimary(e, t, r) {
        var n1, i;
        if (this.playingItem = e, this.playingAsset = this.endedAsset = null, this.waitingItem = this.endedItem = null, this.bufferedToItem(e), this.log(`resuming ${kr(e)}`), !((n1 = this.detachedData) != null && n1.mediaSource)) {
            let a = this.timelinePos;
            (a < e.start || a >= e.end) && (a = this.getPrimaryResumption(e, t), this.log(Qi("resumePrimary", a)), this.timelinePos = a), this.attachPrimary(a, e);
        }
        if (!r) return;
        const o = (i = this.schedule) == null ? void 0 : i.items;
        o && (this.log(`INTERSTITIALS_PRIMARY_RESUMED ${kr(e)}`), this.hls.trigger(I.INTERSTITIALS_PRIMARY_RESUMED, {
            schedule: o.slice(0),
            scheduleIndex: t
        }), this.checkBuffer());
    }
    getPrimaryResumption(e, t) {
        const r = e.start;
        if (this.primaryLive) {
            const n1 = this.primaryDetails;
            if (t === 0) return this.hls.startPosition;
            if (n1 && (r < n1.fragmentStart || r > n1.edge)) return this.hls.liveSyncPosition || -1;
        }
        return r;
    }
    isAssetBuffered(e) {
        const t = this.getAssetPlayer(e.identifier);
        return t != null && t.hls ? t.hls.bufferedToEnd : Ce.bufferInfo(this.primaryMedia, this.timelinePos, 0).end + 1 >= e.timelineStart + (e.duration || 0);
    }
    attachPrimary(e, t, r) {
        t ? this.setBufferingItem(t) : this.bufferingItem = this.playingItem, this.bufferingAsset = null;
        const n1 = this.primaryMedia;
        if (!n1) return;
        const i = this.hls;
        i.media ? this.checkBuffer() : (this.transferMediaTo(i, n1), r && this.startLoadingPrimaryAt(e, r)), r || (this.log(Qi("attachPrimary", e)), this.timelinePos = e, this.startLoadingPrimaryAt(e, r));
    }
    startLoadingPrimaryAt(e, t) {
        var r;
        const n1 = this.hls;
        !n1.loadingEnabled || !n1.media || Math.abs((((r = n1.mainForwardBufferInfo) == null ? void 0 : r.start) || n1.media.currentTime) - e) > 0.5 ? n1.startLoad(e, t) : n1.bufferingEnabled || n1.resumeBuffering();
    }
    // HLS.js event callbacks
    onManifestLoading() {
        var e;
        this.stopLoad(), (e = this.schedule) == null || e.reset(), this.emptyPlayerQueue(), this.clearScheduleState(), this.shouldPlay = !1, this.bufferedPos = this.timelinePos = -1, this.mediaSelection = this.altSelection = this.manager = this.requiredTracks = null, this.hls.off(I.BUFFER_CODECS, this.onBufferCodecs, this), this.hls.on(I.BUFFER_CODECS, this.onBufferCodecs, this);
    }
    onLevelUpdated(e, t) {
        if (t.level === -1 || !this.schedule) return;
        const r = this.hls.levels[t.level];
        if (!r.details) return;
        const n1 = tt(tt({}, this.mediaSelection || this.altSelection), {}, {
            main: r
        });
        this.mediaSelection = n1, this.schedule.parseInterstitialDateRanges(n1, this.hls.config.interstitialAppendInPlace), !this.effectivePlayingItem && this.schedule.items && this.checkStart();
    }
    onAudioTrackUpdated(e, t) {
        const r = this.hls.audioTracks[t.id], n1 = this.mediaSelection;
        if (!n1) {
            this.altSelection = tt(tt({}, this.altSelection), {}, {
                audio: r
            });
            return;
        }
        const i = tt(tt({}, n1), {}, {
            audio: r
        });
        this.mediaSelection = i;
    }
    onSubtitleTrackUpdated(e, t) {
        const r = this.hls.subtitleTracks[t.id], n1 = this.mediaSelection;
        if (!n1) {
            this.altSelection = tt(tt({}, this.altSelection), {}, {
                subtitles: r
            });
            return;
        }
        const i = tt(tt({}, n1), {}, {
            subtitles: r
        });
        this.mediaSelection = i;
    }
    onAudioTrackSwitching(e, t) {
        const r = ch(t);
        this.playerQueue.forEach(({ hls: n1 })=>n1 && (n1.setAudioOption(t) || n1.setAudioOption(r)));
    }
    onSubtitleTrackSwitch(e, t) {
        const r = ch(t);
        this.playerQueue.forEach(({ hls: n1 })=>n1 && (n1.setSubtitleOption(t) || t.id !== -1 && n1.setSubtitleOption(r)));
    }
    onBufferCodecs(e, t) {
        const r = t.tracks;
        r && (this.requiredTracks = r);
    }
    onBufferAppended(e, t) {
        this.checkBuffer();
    }
    onBufferFlushed(e, t) {
        const r = this.playingItem;
        if (r && !this.itemsMatch(r, this.bufferingItem) && !this.isInterstitial(r)) {
            const n1 = this.timelinePos;
            this.bufferedPos = n1, this.checkBuffer();
        }
    }
    onBufferedToEnd(e) {
        if (!this.schedule) return;
        const t = this.schedule.events;
        if (this.bufferedPos < Number.MAX_VALUE && t) {
            for(let n1 = 0; n1 < t.length; n1++){
                const i = t[n1];
                if (i.cue.post) {
                    var r;
                    const o = this.schedule.findEventIndex(i.identifier), a = (r = this.schedule.items) == null ? void 0 : r[o];
                    this.isInterstitial(a) && this.eventItemsMatch(a, this.bufferingItem) && this.bufferedToItem(a, 0);
                    break;
                }
            }
            this.bufferedPos = Number.MAX_VALUE;
        }
    }
    onMediaEnded(e) {
        const t = this.playingItem;
        if (!this.playingLastItem && t) {
            const r = this.findItemIndex(t);
            this.setSchedulePosition(r + 1);
        } else this.shouldPlay = !1;
    }
    updateItem(e, t) {
        var r;
        const n1 = (r = this.schedule) == null ? void 0 : r.items;
        if (e && n1) {
            const i = this.findItemIndex(e, t);
            return n1[i] || null;
        }
        return null;
    }
    trimInPlace(e, t) {
        if (this.isInterstitial(e) && e.event.appendInPlace && t.end - e.end > 0.25) {
            e.event.assetList.forEach((i, o)=>{
                e.event.isAssetPastPlayoutLimit(o) && this.clearAssetPlayer(i.identifier, null);
            });
            const r = e.end + 0.25, n1 = Ce.bufferInfo(this.primaryMedia, r, 0);
            (n1.end > r || (n1.nextStart || 0) > r) && (this.log(`trim buffered interstitial ${kr(e)} (was ${kr(t)})`), this.attachPrimary(r, null, !0), this.flushFrontBuffer(r));
        }
    }
    itemsMatch(e, t) {
        return !!t && (e === t || e.event && t.event && this.eventItemsMatch(e, t) || !e.event && !t.event && this.findItemIndex(e) === this.findItemIndex(t));
    }
    eventItemsMatch(e, t) {
        var r;
        return !!t && (e === t || e.event.identifier === ((r = t.event) == null ? void 0 : r.identifier));
    }
    findItemIndex(e, t) {
        return e && this.schedule ? this.schedule.findItemIndex(e, t) : -1;
    }
    updateSchedule(e = !1) {
        var t;
        const r = this.mediaSelection;
        r && ((t = this.schedule) == null || t.updateSchedule(r, [], e));
    }
    // Schedule buffer control
    checkBuffer(e) {
        var t;
        const r = (t = this.schedule) == null ? void 0 : t.items;
        if (!r) return;
        const n1 = Ce.bufferInfo(this.primaryMedia, this.timelinePos, 0);
        e && (this.bufferedPos = this.timelinePos), e || (e = n1.len < 1), this.updateBufferedPos(n1.end, r, e);
    }
    updateBufferedPos(e, t, r) {
        const n1 = this.schedule, i = this.bufferingItem;
        if (this.bufferedPos > e || !n1) return;
        if (t.length === 1 && this.itemsMatch(t[0], i)) {
            this.bufferedPos = e;
            return;
        }
        const o = this.playingItem, a = this.findItemIndex(o);
        let l = n1.findItemIndexAtTime(e);
        if (this.bufferedPos < e) {
            var c;
            const u = this.findItemIndex(i), d1 = Math.min(u + 1, t.length - 1), h = t[d1];
            if ((l === -1 && i && e >= i.end || (c = h.event) != null && c.appendInPlace && e + 0.01 >= h.start) && (l = d1), this.isInterstitial(i)) {
                const f = i.event;
                if (d1 - a > 1 && f.appendInPlace === !1 || f.assetList.length === 0 && f.assetListLoader) return;
            }
            if (this.bufferedPos = e, l > u && l > a) this.bufferedToItem(h);
            else {
                const f = this.primaryDetails;
                this.primaryLive && f && e > f.edge - f.targetduration && h.start < f.edge + this.hls.config.interstitialLiveLookAhead && this.isInterstitial(h) && this.preloadAssets(h.event, 0);
            }
        } else r && o && !this.itemsMatch(o, i) && (l === a ? this.bufferedToItem(o) : l === a + 1 && this.bufferedToItem(t[l]));
    }
    assetsBuffered(e, t) {
        return e.event.assetList.length === 0 ? !1 : !e.event.assetList.some((n1)=>{
            const i = this.getAssetPlayer(n1.identifier);
            return !(i != null && i.bufferedInPlaceToEnd(t));
        });
    }
    setBufferingItem(e) {
        const t = this.bufferingItem, r = this.schedule;
        if (!this.itemsMatch(e, t) && r) {
            const { items: n1, events: i } = r;
            if (!n1 || !i) return t;
            const o = this.isInterstitial(e), a = this.getBufferingPlayer();
            this.bufferingItem = e, this.bufferedPos = Math.max(e.start, Math.min(e.end, this.timelinePos));
            const l = a ? a.remaining : t ? t.end - this.timelinePos : 0;
            if (this.log(`INTERSTITIALS_BUFFERED_TO_BOUNDARY ${kr(e)}` + (t ? ` (${l.toFixed(2)} remaining)` : "")), !this.playbackDisabled) if (o) {
                const c = r.findAssetIndex(e.event, this.bufferedPos);
                e.event.assetList.forEach((u, d1)=>{
                    const h = this.getAssetPlayer(u.identifier);
                    h && (d1 === c && h.loadSource(), h.resumeBuffering());
                });
            } else this.hls.resumeBuffering(), this.playerQueue.forEach((c)=>c.pauseBuffering());
            this.hls.trigger(I.INTERSTITIALS_BUFFERED_TO_BOUNDARY, {
                events: i.slice(0),
                schedule: n1.slice(0),
                bufferingIndex: this.findItemIndex(e),
                playingIndex: this.findItemIndex(this.playingItem)
            });
        } else this.bufferingItem !== e && (this.bufferingItem = e);
        return t;
    }
    bufferedToItem(e, t = 0) {
        const r = this.setBufferingItem(e);
        if (!this.playbackDisabled) {
            if (this.isInterstitial(e)) this.bufferedToEvent(e, t);
            else if (r !== null) {
                this.bufferingAsset = null;
                const n1 = this.detachedData;
                n1 ? n1.mediaSource ? this.attachPrimary(e.start, e, !0) : this.preloadPrimary(e) : this.preloadPrimary(e);
            }
        }
    }
    preloadPrimary(e) {
        const t = this.findItemIndex(e), r = this.getPrimaryResumption(e, t);
        this.startLoadingPrimaryAt(r);
    }
    bufferedToEvent(e, t) {
        const r = e.event, n1 = r.assetList.length === 0 && !r.assetListLoader, i = r.cue.once;
        if (n1 || !i) {
            const o = this.preloadAssets(r, t);
            if (o != null && o.interstitial.appendInPlace) {
                const a = this.primaryMedia;
                a && this.bufferAssetPlayer(o, a);
            }
        }
    }
    preloadAssets(e, t) {
        const r = e.assetUrl, n1 = e.assetList.length, i = n1 === 0 && !e.assetListLoader, o = e.cue.once;
        if (i) {
            const l = e.timelineStart;
            if (e.appendInPlace) {
                var a;
                const h = this.playingItem;
                !this.isInterstitial(h) && (h == null || (a = h.nextEvent) == null ? void 0 : a.identifier) === e.identifier && this.flushFrontBuffer(l + 0.25);
            }
            let c, u = 0;
            if (!this.playingItem && this.primaryLive && (u = this.hls.startPosition, u === -1 && (u = this.hls.liveSyncPosition || 0)), u && !(e.cue.pre || e.cue.post)) {
                const h = u - l;
                h > 0 && (c = Math.round(h * 1e3) / 1e3);
            }
            if (this.log(`Load interstitial asset ${t + 1}/${r ? 1 : n1} ${e}${c ? ` live-start: ${u} start-offset: ${c}` : ""}`), r) return this.createAsset(e, 0, 0, l, e.duration, r);
            const d1 = this.assetListLoader.loadAssetList(e, c);
            d1 && (e.assetListLoader = d1);
        } else if (!o && n1) {
            for(let c = t; c < n1; c++){
                const u = e.assetList[c], d1 = this.getAssetPlayerQueueIndex(u.identifier);
                (d1 === -1 || this.playerQueue[d1].destroyed) && !u.error && this.createAssetPlayer(e, u, c);
            }
            const l = e.assetList[t];
            if (l) {
                const c = this.getAssetPlayer(l.identifier);
                return c && c.loadSource(), c;
            }
        }
        return null;
    }
    flushFrontBuffer(e) {
        const t = this.requiredTracks;
        if (!t) return;
        this.log(`Removing front buffer starting at ${e}`), Object.keys(t).forEach((n1)=>{
            this.hls.trigger(I.BUFFER_FLUSHING, {
                startOffset: e,
                endOffset: 1 / 0,
                type: n1
            });
        });
    }
    // Interstitial Asset Player control
    getAssetPlayerQueueIndex(e) {
        const t = this.playerQueue;
        for(let r = 0; r < t.length; r++)if (e === t[r].assetId) return r;
        return -1;
    }
    getAssetPlayer(e) {
        const t = this.getAssetPlayerQueueIndex(e);
        return this.playerQueue[t] || null;
    }
    getBufferingPlayer() {
        const { playerQueue: e, primaryMedia: t } = this;
        if (t) {
            for(let r = 0; r < e.length; r++)if (e[r].media === t) return e[r];
        }
        return null;
    }
    createAsset(e, t, r, n1, i, o) {
        const a = {
            parentIdentifier: e.identifier,
            identifier: gw(e, o, t),
            duration: i,
            startOffset: r,
            timelineStart: n1,
            uri: o
        };
        return this.createAssetPlayer(e, a, t);
    }
    createAssetPlayer(e, t, r) {
        const n1 = this.hls, i = n1.userConfig;
        let o = i.videoPreference;
        const a = n1.loadLevelObj || n1.levels[n1.currentLevel];
        (o || a) && (o = nt({}, o), a.videoCodec && (o.videoCodec = a.videoCodec), a.videoRange && (o.allowedVideoRanges = [
            a.videoRange
        ]));
        const l = n1.audioTracks[n1.audioTrack], c = n1.subtitleTracks[n1.subtitleTrack];
        let u = 0;
        if (this.primaryLive || e.appendInPlace) {
            const F = this.timelinePos - t.timelineStart;
            if (F > 1) {
                const M = t.duration;
                M && F < M && (u = F);
            }
        }
        const d1 = t.identifier, h = tt(tt({}, i), {}, {
            maxMaxBufferLength: Math.min(180, n1.config.maxMaxBufferLength),
            autoStartLoad: !0,
            startFragPrefetch: !0,
            primarySessionId: n1.sessionId,
            assetPlayerId: d1,
            abrEwmaDefaultEstimate: n1.bandwidthEstimate,
            interstitialsController: void 0,
            startPosition: u,
            liveDurationInfinity: !1,
            testBandwidth: !1,
            videoPreference: o,
            audioPreference: l || i.audioPreference,
            subtitlePreference: c || i.subtitlePreference
        });
        e.appendInPlace && (e.appendInPlaceStarted = !0, t.timelineStart && (h.timelineOffset = t.timelineStart));
        const f = h.cmcd;
        f != null && f.sessionId && f.contentId && (h.cmcd = nt({}, f, {
            contentId: Xn(t.uri)
        })), this.getAssetPlayer(d1) && this.warn(`Duplicate date range identifier ${e} and asset ${d1}`);
        const p = new yw(this.HlsPlayerClass, h, e, t);
        this.playerQueue.push(p), e.assetList[r] = t;
        let y = !0;
        const E = (F)=>{
            if (F.live) {
                var M;
                const j = new Error(`Interstitials MUST be VOD assets ${e}`), C = {
                    fatal: !0,
                    type: ve.OTHER_ERROR,
                    details: J.INTERSTITIAL_ASSET_ITEM_ERROR,
                    error: j
                }, k = ((M = this.schedule) == null ? void 0 : M.findEventIndex(e.identifier)) || -1;
                this.handleAssetItemError(C, e, k, r, j.message);
                return;
            }
            const H = F.edge - F.fragmentStart, K = t.duration;
            (y || K === null || H > K) && (y = !1, this.log(`Interstitial asset "${d1}" duration change ${K} > ${H}`), t.duration = H, this.updateSchedule());
        };
        p.on(I.LEVEL_UPDATED, (F, { details: M })=>E(M)), p.on(I.LEVEL_PTS_UPDATED, (F, { details: M })=>E(M)), p.on(I.EVENT_CUE_ENTER, ()=>this.onInterstitialCueEnter());
        const b = (F, M)=>{
            const H = this.getAssetPlayer(d1);
            if (H && M.tracks) {
                H.off(I.BUFFER_CODECS, b), H.tracks = M.tracks;
                const K = this.primaryMedia;
                this.bufferingAsset === H.assetItem && K && !H.media && this.bufferAssetPlayer(H, K);
            }
        };
        p.on(I.BUFFER_CODECS, b);
        const L = ()=>{
            var F;
            const M = this.getAssetPlayer(d1);
            if (this.log(`buffered to end of asset ${M}`), !M || !this.schedule) return;
            const H = this.schedule.findEventIndex(e.identifier), K = (F = this.schedule.items) == null ? void 0 : F[H];
            this.isInterstitial(K) && this.advanceAssetBuffering(K, t);
        };
        p.on(I.BUFFERED_TO_END, L);
        const A = (F)=>()=>{
                if (!this.getAssetPlayer(d1) || !this.schedule) return;
                this.shouldPlay = !0;
                const H = this.schedule.findEventIndex(e.identifier);
                this.advanceAfterAssetEnded(e, H, F);
            };
        return p.once(I.MEDIA_ENDED, A(r)), p.once(I.PLAYOUT_LIMIT_REACHED, A(1 / 0)), p.on(I.ERROR, (F, M)=>{
            if (!this.schedule) return;
            const H = this.getAssetPlayer(d1);
            if (M.details === J.BUFFER_STALLED_ERROR) {
                if (H != null && H.appendInPlace) {
                    this.handleInPlaceStall(e);
                    return;
                }
                this.onTimeupdate(), this.checkBuffer(!0);
                return;
            }
            this.handleAssetItemError(M, e, this.schedule.findEventIndex(e.identifier), r, `Asset player error ${M.error} ${e}`);
        }), p.on(I.DESTROYING, ()=>{
            if (!this.getAssetPlayer(d1) || !this.schedule) return;
            const M = new Error(`Asset player destroyed unexpectedly ${d1}`), H = {
                fatal: !0,
                type: ve.OTHER_ERROR,
                details: J.INTERSTITIAL_ASSET_ITEM_ERROR,
                error: M
            };
            this.handleAssetItemError(H, e, this.schedule.findEventIndex(e.identifier), r, M.message);
        }), this.log(`INTERSTITIAL_ASSET_PLAYER_CREATED ${mn(t)}`), this.hls.trigger(I.INTERSTITIAL_ASSET_PLAYER_CREATED, {
            asset: t,
            assetListIndex: r,
            event: e,
            player: p
        }), p;
    }
    clearInterstitial(e, t) {
        e.assetList.forEach((r)=>{
            this.clearAssetPlayer(r.identifier, t);
        }), e.reset();
    }
    resetAssetPlayer(e) {
        const t = this.getAssetPlayerQueueIndex(e);
        if (t !== -1) {
            this.log(`reset asset player "${e}" after error`);
            const r = this.playerQueue[t];
            this.transferMediaFromPlayer(r, null), r.resetDetails();
        }
    }
    clearAssetPlayer(e, t) {
        const r = this.getAssetPlayerQueueIndex(e);
        if (r !== -1) {
            const n1 = this.playerQueue[r];
            this.log(`clear ${n1} toSegment: ${t && kr(t)}`), this.transferMediaFromPlayer(n1, t), this.playerQueue.splice(r, 1), n1.destroy();
        }
    }
    emptyPlayerQueue() {
        let e;
        for(; e = this.playerQueue.pop();)e.destroy();
        this.playerQueue = [];
    }
    startAssetPlayer(e, t, r, n1, i) {
        const { interstitial: o, assetItem: a, assetId: l } = e, c = o.assetList.length, u = this.playingAsset;
        this.endedAsset = null, this.playingAsset = a, (!u || u.identifier !== l) && (u && (this.clearAssetPlayer(u.identifier, r[n1]), delete u.error), this.log(`INTERSTITIAL_ASSET_STARTED ${t + 1}/${c} ${mn(a)}`), this.hls.trigger(I.INTERSTITIAL_ASSET_STARTED, {
            asset: a,
            assetListIndex: t,
            event: o,
            schedule: r.slice(0),
            scheduleIndex: n1,
            player: e
        })), this.bufferAssetPlayer(e, i);
    }
    bufferAssetPlayer(e, t) {
        var r, n1;
        if (!this.schedule) return;
        const { interstitial: i, assetItem: o } = e, a = this.schedule.findEventIndex(i.identifier), l = (r = this.schedule.items) == null ? void 0 : r[a];
        if (!l) return;
        e.loadSource(), this.setBufferingItem(l), this.bufferingAsset = o;
        const c = this.getBufferingPlayer();
        if (c === e) return;
        const u = i.appendInPlace;
        if (u && (c == null ? void 0 : c.interstitial.appendInPlace) === !1) return;
        const d1 = (c == null ? void 0 : c.tracks) || ((n1 = this.detachedData) == null ? void 0 : n1.tracks) || this.requiredTracks;
        if (u && o !== this.playingAsset) {
            if (!e.tracks) {
                this.log(`Waiting for track info before buffering ${e}`);
                return;
            }
            if (d1 && !Ag(d1, e.tracks)) {
                const h = new Error(`Asset ${mn(o)} SourceBuffer tracks ('${Object.keys(e.tracks)}') are not compatible with primary content tracks ('${Object.keys(d1)}')`), f = {
                    fatal: !0,
                    type: ve.OTHER_ERROR,
                    details: J.INTERSTITIAL_ASSET_ITEM_ERROR,
                    error: h
                }, p = i.findAssetIndex(o);
                this.handleAssetItemError(f, i, a, p, h.message);
                return;
            }
        }
        this.transferMediaTo(e, t);
    }
    handleInPlaceStall(e) {
        const t = this.schedule, r = this.primaryMedia;
        if (!t || !r) return;
        const n1 = r.currentTime, i = t.findAssetIndex(e, n1), o = e.assetList[i];
        if (o) {
            const a = this.getAssetPlayer(o.identifier);
            if (a) {
                const l = a.currentTime || n1 - o.timelineStart, c = a.duration - l;
                if (this.warn(`Stalled at ${l} of ${l + c} in ${a} ${e} (media.currentTime: ${n1})`), l && (c / r.playbackRate < 0.5 || a.bufferedInPlaceToEnd(r)) && a.hls) {
                    const u = t.findEventIndex(e.identifier);
                    this.advanceAfterAssetEnded(e, u, i);
                }
            }
        }
    }
    advanceInPlace(e) {
        const t = this.primaryMedia;
        t && t.currentTime < e && (t.currentTime = e);
    }
    handleAssetItemError(e, t, r, n1, i) {
        if (e.details === J.BUFFER_STALLED_ERROR) return;
        const o = t.assetList[n1] || null;
        if (this.warn(`INTERSTITIAL_ASSET_ERROR ${o && mn(o)} ${e.error}`), !this.schedule) return;
        const a = (o == null ? void 0 : o.identifier) || "", l = this.getAssetPlayerQueueIndex(a), c = this.playerQueue[l] || null, u = this.schedule.items, d1 = nt({}, e, {
            fatal: !1,
            errorAction: Tn(!0),
            asset: o,
            assetListIndex: n1,
            event: t,
            schedule: u,
            scheduleIndex: r,
            player: c
        });
        if (this.hls.trigger(I.INTERSTITIAL_ASSET_ERROR, d1), !e.fatal) return;
        const h = this.playingAsset, f = this.bufferingAsset, p = new Error(i);
        if (o && (this.clearAssetPlayer(a, null), o.error = p), !t.assetList.some((y)=>!y.error)) t.error = p;
        else for(let y = n1; y < t.assetList.length; y++)this.resetAssetPlayer(t.assetList[y].identifier);
        this.updateSchedule(!0), t.error ? this.primaryFallback(t) : h && h.identifier === a ? this.advanceAfterAssetEnded(t, r, n1) : f && f.identifier === a && this.isInterstitial(this.bufferingItem) && this.advanceAssetBuffering(this.bufferingItem, f);
    }
    primaryFallback(e) {
        const t = e.timelineStart, r = this.effectivePlayingItem;
        if (r) {
            this.log(`Fallback to primary from event "${e.identifier}" start: ${t} pos: ${this.timelinePos} playing: ${kr(r)} error: ${e.error}`);
            let n1 = this.timelinePos;
            n1 === -1 && (n1 = this.hls.startPosition);
            const i = this.updateItem(r, n1);
            if (this.itemsMatch(r, i) && this.clearInterstitial(e, null), e.appendInPlace && (this.attachPrimary(t, null), this.flushFrontBuffer(t)), !this.schedule) return;
            const o = this.schedule.findItemIndexAtTime(n1);
            this.setSchedulePosition(o);
        } else this.checkStart();
    }
    // Asset List loading
    onAssetListLoaded(e, t) {
        var r, n1;
        const i = t.event, o = i.identifier, a = t.assetListResponse.ASSETS;
        if (!((r = this.schedule) != null && r.hasEvent(o))) return;
        const l = i.timelineStart, c = i.duration;
        let u = 0;
        a.forEach((y, E)=>{
            const b = parseFloat(y.DURATION);
            this.createAsset(i, E, u, l + u, b, y.URI), u += b;
        }), i.duration = u, this.log(`Loaded asset-list with duration: ${u} (was: ${c}) ${i}`);
        const d1 = this.waitingItem, h = (d1 == null ? void 0 : d1.event.identifier) === o;
        this.updateSchedule();
        const f = (n1 = this.bufferingItem) == null ? void 0 : n1.event;
        if (h) {
            var p;
            const y = this.schedule.findEventIndex(o), E = (p = this.schedule.items) == null ? void 0 : p[y];
            if (E) {
                if (!this.playingItem && this.timelinePos > E.end && this.schedule.findItemIndexAtTime(this.timelinePos) !== y) {
                    i.error = new Error(`Interstitial no longer within playback range ${this.timelinePos} ${i}`), this.updateSchedule(!0), this.primaryFallback(i);
                    return;
                }
                this.setBufferingItem(E);
            }
            this.setSchedulePosition(y);
        } else if ((f == null ? void 0 : f.identifier) === o) {
            const y = i.assetList[0];
            if (y) {
                const E = this.getAssetPlayer(y.identifier);
                if (f.appendInPlace) {
                    const b = this.primaryMedia;
                    E && b && this.bufferAssetPlayer(E, b);
                } else E && E.loadSource();
            }
        }
    }
    onError(e, t) {
        if (this.schedule) switch(t.details){
            case J.ASSET_LIST_PARSING_ERROR:
            case J.ASSET_LIST_LOAD_ERROR:
            case J.ASSET_LIST_LOAD_TIMEOUT:
                {
                    const r = t.interstitial;
                    r && (this.updateSchedule(!0), this.primaryFallback(r));
                    break;
                }
            case J.BUFFER_STALLED_ERROR:
                {
                    const r = this.endedItem || this.waitingItem || this.playingItem;
                    if (this.isInterstitial(r) && r.event.appendInPlace) {
                        this.handleInPlaceStall(r.event);
                        return;
                    }
                    this.log(`Primary player stall @${this.timelinePos} bufferedPos: ${this.bufferedPos}`), this.onTimeupdate(), this.checkBuffer(!0);
                    break;
                }
        }
    }
}
const Qh = 500;
class Sw extends Tu {
    constructor(e, t, r){
        super(e, t, r, "subtitle-stream-controller", pe.SUBTITLE), this.currentTrackId = -1, this.tracksBuffered = [], this.mainDetails = null, this.registerListeners();
    }
    onHandlerDestroying() {
        this.unregisterListeners(), super.onHandlerDestroying(), this.mainDetails = null;
    }
    registerListeners() {
        super.registerListeners();
        const { hls: e } = this;
        e.on(I.LEVEL_LOADED, this.onLevelLoaded, this), e.on(I.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.on(I.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e.on(I.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.on(I.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this), e.on(I.BUFFER_FLUSHING, this.onBufferFlushing, this);
    }
    unregisterListeners() {
        super.unregisterListeners();
        const { hls: e } = this;
        e.off(I.LEVEL_LOADED, this.onLevelLoaded, this), e.off(I.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.off(I.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e.off(I.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.off(I.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this), e.off(I.BUFFER_FLUSHING, this.onBufferFlushing, this);
    }
    startLoad(e, t) {
        this.stopLoad(), this.state = ne.IDLE, this.setInterval(Qh), this.nextLoadPosition = this.lastCurrentTime = e + this.timelineOffset, this.startPosition = t ? -1 : e, this.tick();
    }
    onManifestLoading() {
        super.onManifestLoading(), this.mainDetails = null;
    }
    onMediaDetaching(e, t) {
        this.tracksBuffered = [], super.onMediaDetaching(e, t);
    }
    onLevelLoaded(e, t) {
        this.mainDetails = t.details;
    }
    onSubtitleFragProcessed(e, t) {
        const { frag: r, success: n1 } = t;
        if (this.fragContextChanged(r) || (Vt(r) && (this.fragPrevious = r), this.state = ne.IDLE), !n1) return;
        const i = this.tracksBuffered[this.currentTrackId];
        if (!i) return;
        let o;
        const a = r.start;
        for(let c = 0; c < i.length; c++)if (a >= i[c].start && a <= i[c].end) {
            o = i[c];
            break;
        }
        const l = r.start + r.duration;
        o ? o.end = l : (o = {
            start: a,
            end: l
        }, i.push(o)), this.fragmentTracker.fragBuffered(r), this.fragBufferedComplete(r, null), this.media && this.tick();
    }
    onBufferFlushing(e, t) {
        const { startOffset: r, endOffset: n1 } = t;
        if (r === 0 && n1 !== Number.POSITIVE_INFINITY) {
            const i = n1 - 1;
            if (i <= 0) return;
            t.endOffsetSubtitles = Math.max(0, i), this.tracksBuffered.forEach((o)=>{
                for(let a = 0; a < o.length;){
                    if (o[a].end <= i) {
                        o.shift();
                        continue;
                    } else if (o[a].start < i) o[a].start = i;
                    else break;
                    a++;
                }
            }), this.fragmentTracker.removeFragmentsInRange(r, i, pe.SUBTITLE);
        }
    }
    // If something goes wrong, proceed to next frag, if we were processing one.
    onError(e, t) {
        const r = t.frag;
        (r == null ? void 0 : r.type) === pe.SUBTITLE && (t.details === J.FRAG_GAP && this.fragmentTracker.fragBuffered(r, !0), this.fragCurrent && this.fragCurrent.abortRequests(), this.state !== ne.STOPPED && (this.state = ne.IDLE));
    }
    // Got all new subtitle levels.
    onSubtitleTracksUpdated(e, { subtitleTracks: t }) {
        if (this.levels && Ap(this.levels, t)) {
            this.levels = t.map((r)=>new mi(r));
            return;
        }
        this.tracksBuffered = [], this.levels = t.map((r)=>{
            const n1 = new mi(r);
            return this.tracksBuffered[n1.id] = [], n1;
        }), this.fragmentTracker.removeFragmentsInRange(0, Number.POSITIVE_INFINITY, pe.SUBTITLE), this.fragPrevious = null, this.mediaBuffer = null;
    }
    onSubtitleTrackSwitch(e, t) {
        var r;
        if (this.currentTrackId = t.id, !((r = this.levels) != null && r.length) || this.currentTrackId === -1) {
            this.clearInterval();
            return;
        }
        const n1 = this.levels[this.currentTrackId];
        n1 != null && n1.details ? this.mediaBuffer = this.mediaBufferTimeRanges : this.mediaBuffer = null, n1 && this.state !== ne.STOPPED && this.setInterval(Qh);
    }
    // Got a new set of subtitle fragments.
    onSubtitleTrackLoaded(e, t) {
        var r;
        const { currentTrackId: n1, levels: i } = this, { details: o, id: a } = t;
        if (!i) {
            this.warn(`Subtitle tracks were reset while loading level ${a}`);
            return;
        }
        const l = i[a];
        if (a >= i.length || !l) return;
        this.log(`Subtitle track ${a} loaded [${o.startSN},${o.endSN}]${o.lastPartSn ? `[part-${o.lastPartSn}-${o.lastPartIndex}]` : ""},duration:${o.totalduration}`), this.mediaBuffer = this.mediaBufferTimeRanges;
        let c = 0;
        if (o.live || (r = l.details) != null && r.live) {
            if (o.deltaUpdateFailed) return;
            const d1 = this.mainDetails;
            if (!d1) {
                this.startFragRequested = !1;
                return;
            }
            const h = d1.fragments[0];
            if (!l.details) o.hasProgramDateTime && d1.hasProgramDateTime ? (sa(o, d1), c = o.fragmentStart) : h && (c = h.start, gc(o, c));
            else {
                var u;
                c = this.alignPlaylists(o, l.details, (u = this.levelLastLoaded) == null ? void 0 : u.details), c === 0 && h && (c = h.start, gc(o, c));
            }
            d1 && !this.startFragRequested && this.setStartPosition(d1, c);
        }
        l.details = o, this.levelLastLoaded = l, a === n1 && (this.hls.trigger(I.SUBTITLE_TRACK_UPDATED, {
            details: o,
            id: a,
            groupId: t.groupId
        }), this.tick(), o.live && !this.fragCurrent && this.media && this.state === ne.IDLE && (Js(null, o.fragments, this.media.currentTime, 0) || (this.warn("Subtitle playlist not aligned with playback"), l.details = void 0)));
    }
    _handleFragmentLoadComplete(e) {
        const { frag: t, payload: r } = e, n1 = t.decryptdata, i = this.hls;
        if (!this.fragContextChanged(t) && r && r.byteLength > 0 && n1 != null && n1.key && n1.iv && wn(n1.method)) {
            const o = performance.now();
            this.decrypter.decrypt(new Uint8Array(r), n1.key.buffer, n1.iv.buffer, Su(n1.method)).catch((a)=>{
                throw i.trigger(I.ERROR, {
                    type: ve.MEDIA_ERROR,
                    details: J.FRAG_DECRYPT_ERROR,
                    fatal: !1,
                    error: a,
                    reason: a.message,
                    frag: t
                }), a;
            }).then((a)=>{
                const l = performance.now();
                i.trigger(I.FRAG_DECRYPTED, {
                    frag: t,
                    payload: a,
                    stats: {
                        tstart: o,
                        tdecrypt: l
                    }
                });
            }).catch((a)=>{
                this.warn(`${a.name}: ${a.message}`), this.state = ne.IDLE;
            });
        }
    }
    doTick() {
        if (!this.media) {
            this.state = ne.IDLE;
            return;
        }
        if (this.state === ne.IDLE) {
            const { currentTrackId: e, levels: t } = this, r = t == null ? void 0 : t[e];
            if (!r || !t.length || !r.details || this.waitForLive(r)) return;
            const { config: n1 } = this, i = this.getLoadPosition(), o = Ce.bufferedInfo(this.tracksBuffered[this.currentTrackId] || [], i, n1.maxBufferHole), { end: a, len: l } = o, c = r.details, u = this.hls.maxBufferLength + c.levelTargetDuration;
            if (l > u) return;
            const d1 = c.fragments, h = d1.length, f = c.edge;
            let p = null;
            const y = this.fragPrevious;
            if (a < f) {
                const L = n1.maxFragLookUpTolerance, A = a > f - L ? 0 : L;
                p = Js(y, d1, Math.max(d1[0].start, a), A), !p && y && y.start < d1[0].start && (p = d1[0]);
            } else p = d1[h - 1];
            if (p = this.filterReplacedPrimary(p, r.details), !p) return;
            const E = p.sn - c.startSN, b = d1[E - 1];
            if (b && b.cc === p.cc && this.fragmentTracker.getState(b) === Ht.NOT_LOADED && (p = b), this.fragmentTracker.getState(p) === Ht.NOT_LOADED) {
                const L = this.mapToInitFragWhenRequired(p);
                L && this.loadFragment(L, r, a);
            }
        }
    }
    loadFragment(e, t, r) {
        Vt(e) ? super.loadFragment(e, t, r) : this._loadInitSegment(e, t);
    }
    get mediaBufferTimeRanges() {
        return new bw(this.tracksBuffered[this.currentTrackId] || []);
    }
}
class bw {
    constructor(e){
        this.buffered = void 0;
        const t = (r, n1, i)=>{
            if (n1 = n1 >>> 0, n1 > i - 1) throw new DOMException(`Failed to execute '${r}' on 'TimeRanges': The index provided (${n1}) is greater than the maximum bound (${i})`);
            return e[n1][r];
        };
        this.buffered = {
            get length () {
                return e.length;
            },
            end (r) {
                return t("end", r, e.length);
            },
            start (r) {
                return t("start", r, e.length);
            }
        };
    }
}
const Tw = {
    42: 225,
    // lowercase a, acute accent
    92: 233,
    // lowercase e, acute accent
    94: 237,
    // lowercase i, acute accent
    95: 243,
    // lowercase o, acute accent
    96: 250,
    // lowercase u, acute accent
    123: 231,
    // lowercase c with cedilla
    124: 247,
    // division symbol
    125: 209,
    // uppercase N tilde
    126: 241,
    // lowercase n tilde
    127: 9608,
    // Full block
    // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
    // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F
    // THIS MEANS THAT \x50 MUST BE ADDED TO THE VALUES
    128: 174,
    // Registered symbol (R)
    129: 176,
    // degree sign
    130: 189,
    // 1/2 symbol
    131: 191,
    // Inverted (open) question mark
    132: 8482,
    // Trademark symbol (TM)
    133: 162,
    // Cents symbol
    134: 163,
    // Pounds sterling
    135: 9834,
    // Music 8'th note
    136: 224,
    // lowercase a, grave accent
    137: 32,
    // transparent space (regular)
    138: 232,
    // lowercase e, grave accent
    139: 226,
    // lowercase a, circumflex accent
    140: 234,
    // lowercase e, circumflex accent
    141: 238,
    // lowercase i, circumflex accent
    142: 244,
    // lowercase o, circumflex accent
    143: 251,
    // lowercase u, circumflex accent
    // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
    // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F
    144: 193,
    // capital letter A with acute
    145: 201,
    // capital letter E with acute
    146: 211,
    // capital letter O with acute
    147: 218,
    // capital letter U with acute
    148: 220,
    // capital letter U with diaresis
    149: 252,
    // lowercase letter U with diaeresis
    150: 8216,
    // opening single quote
    151: 161,
    // inverted exclamation mark
    152: 42,
    // asterisk
    153: 8217,
    // closing single quote
    154: 9473,
    // box drawings heavy horizontal
    155: 169,
    // copyright sign
    156: 8480,
    // Service mark
    157: 8226,
    // (round) bullet
    158: 8220,
    // Left double quotation mark
    159: 8221,
    // Right double quotation mark
    160: 192,
    // uppercase A, grave accent
    161: 194,
    // uppercase A, circumflex
    162: 199,
    // uppercase C with cedilla
    163: 200,
    // uppercase E, grave accent
    164: 202,
    // uppercase E, circumflex
    165: 203,
    // capital letter E with diaresis
    166: 235,
    // lowercase letter e with diaresis
    167: 206,
    // uppercase I, circumflex
    168: 207,
    // uppercase I, with diaresis
    169: 239,
    // lowercase i, with diaresis
    170: 212,
    // uppercase O, circumflex
    171: 217,
    // uppercase U, grave accent
    172: 249,
    // lowercase u, grave accent
    173: 219,
    // uppercase U, circumflex
    174: 171,
    // left-pointing double angle quotation mark
    175: 187,
    // right-pointing double angle quotation mark
    // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
    // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F
    176: 195,
    // Uppercase A, tilde
    177: 227,
    // Lowercase a, tilde
    178: 205,
    // Uppercase I, acute accent
    179: 204,
    // Uppercase I, grave accent
    180: 236,
    // Lowercase i, grave accent
    181: 210,
    // Uppercase O, grave accent
    182: 242,
    // Lowercase o, grave accent
    183: 213,
    // Uppercase O, tilde
    184: 245,
    // Lowercase o, tilde
    185: 123,
    // Open curly brace
    186: 125,
    // Closing curly brace
    187: 92,
    // Backslash
    188: 94,
    // Caret
    189: 95,
    // Underscore
    190: 124,
    // Pipe (vertical line)
    191: 8764,
    // Tilde operator
    192: 196,
    // Uppercase A, umlaut
    193: 228,
    // Lowercase A, umlaut
    194: 214,
    // Uppercase O, umlaut
    195: 246,
    // Lowercase o, umlaut
    196: 223,
    // Esszett (sharp S)
    197: 165,
    // Yen symbol
    198: 164,
    // Generic currency sign
    199: 9475,
    // Box drawings heavy vertical
    200: 197,
    // Uppercase A, ring
    201: 229,
    // Lowercase A, ring
    202: 216,
    // Uppercase O, stroke
    203: 248,
    // Lowercase o, strok
    204: 9487,
    // Box drawings heavy down and right
    205: 9491,
    // Box drawings heavy down and left
    206: 9495,
    // Box drawings heavy up and right
    207: 9499
}, Gp = (s)=>String.fromCharCode(Tw[s] || s), Dr = 15, is = 100, ww = {
    17: 1,
    18: 3,
    21: 5,
    22: 7,
    23: 9,
    16: 11,
    19: 12,
    20: 14
}, Aw = {
    17: 2,
    18: 4,
    21: 6,
    22: 8,
    23: 10,
    19: 13,
    20: 15
}, Iw = {
    25: 1,
    26: 3,
    29: 5,
    30: 7,
    31: 9,
    24: 11,
    27: 12,
    28: 14
}, _w = {
    25: 2,
    26: 4,
    29: 6,
    30: 8,
    31: 10,
    27: 13,
    28: 15
}, Lw = [
    "white",
    "green",
    "blue",
    "cyan",
    "red",
    "yellow",
    "magenta",
    "black",
    "transparent"
];
class Rw {
    constructor(){
        this.time = null, this.verboseLevel = 0;
    }
    log(e, t) {
        if (this.verboseLevel >= e) {
            const r = typeof t == "function" ? t() : t;
            rt.log(`${this.time} [${e}] ${r}`);
        }
    }
}
const Ns = function(e) {
    const t = [];
    for(let r = 0; r < e.length; r++)t.push(e[r].toString(16));
    return t;
};
class Vp {
    constructor(){
        this.foreground = "white", this.underline = !1, this.italics = !1, this.background = "black", this.flash = !1;
    }
    reset() {
        this.foreground = "white", this.underline = !1, this.italics = !1, this.background = "black", this.flash = !1;
    }
    setStyles(e) {
        const t = [
            "foreground",
            "underline",
            "italics",
            "background",
            "flash"
        ];
        for(let r = 0; r < t.length; r++){
            const n1 = t[r];
            e.hasOwnProperty(n1) && (this[n1] = e[n1]);
        }
    }
    isDefault() {
        return this.foreground === "white" && !this.underline && !this.italics && this.background === "black" && !this.flash;
    }
    equals(e) {
        return this.foreground === e.foreground && this.underline === e.underline && this.italics === e.italics && this.background === e.background && this.flash === e.flash;
    }
    copy(e) {
        this.foreground = e.foreground, this.underline = e.underline, this.italics = e.italics, this.background = e.background, this.flash = e.flash;
    }
    toString() {
        return "color=" + this.foreground + ", underline=" + this.underline + ", italics=" + this.italics + ", background=" + this.background + ", flash=" + this.flash;
    }
}
class Cw {
    constructor(){
        this.uchar = " ", this.penState = new Vp();
    }
    reset() {
        this.uchar = " ", this.penState.reset();
    }
    setChar(e, t) {
        this.uchar = e, this.penState.copy(t);
    }
    setPenState(e) {
        this.penState.copy(e);
    }
    equals(e) {
        return this.uchar === e.uchar && this.penState.equals(e.penState);
    }
    copy(e) {
        this.uchar = e.uchar, this.penState.copy(e.penState);
    }
    isEmpty() {
        return this.uchar === " " && this.penState.isDefault();
    }
}
class kw {
    constructor(e){
        this.chars = [], this.pos = 0, this.currPenState = new Vp(), this.cueStartTime = null, this.logger = void 0;
        for(let t = 0; t < is; t++)this.chars.push(new Cw());
        this.logger = e;
    }
    equals(e) {
        for(let t = 0; t < is; t++)if (!this.chars[t].equals(e.chars[t])) return !1;
        return !0;
    }
    copy(e) {
        for(let t = 0; t < is; t++)this.chars[t].copy(e.chars[t]);
    }
    isEmpty() {
        let e = !0;
        for(let t = 0; t < is; t++)if (!this.chars[t].isEmpty()) {
            e = !1;
            break;
        }
        return e;
    }
    /**
   *  Set the cursor to a valid column.
   */ setCursor(e) {
        this.pos !== e && (this.pos = e), this.pos < 0 ? (this.logger.log(3, "Negative cursor position " + this.pos), this.pos = 0) : this.pos > is && (this.logger.log(3, "Too large cursor position " + this.pos), this.pos = is);
    }
    /**
   * Move the cursor relative to current position.
   */ moveCursor(e) {
        const t = this.pos + e;
        if (e > 1) for(let r = this.pos + 1; r < t + 1; r++)this.chars[r].setPenState(this.currPenState);
        this.setCursor(t);
    }
    /**
   * Backspace, move one step back and clear character.
   */ backSpace() {
        this.moveCursor(-1), this.chars[this.pos].setChar(" ", this.currPenState);
    }
    insertChar(e) {
        e >= 144 && this.backSpace();
        const t = Gp(e);
        if (this.pos >= is) {
            this.logger.log(0, ()=>"Cannot insert " + e.toString(16) + " (" + t + ") at position " + this.pos + ". Skipping it!");
            return;
        }
        this.chars[this.pos].setChar(t, this.currPenState), this.moveCursor(1);
    }
    clearFromPos(e) {
        let t;
        for(t = e; t < is; t++)this.chars[t].reset();
    }
    clear() {
        this.clearFromPos(0), this.pos = 0, this.currPenState.reset();
    }
    clearToEndOfRow() {
        this.clearFromPos(this.pos);
    }
    getTextString() {
        const e = [];
        let t = !0;
        for(let r = 0; r < is; r++){
            const n1 = this.chars[r].uchar;
            n1 !== " " && (t = !1), e.push(n1);
        }
        return t ? "" : e.join("");
    }
    setPenStyles(e) {
        this.currPenState.setStyles(e), this.chars[this.pos].setPenState(this.currPenState);
    }
}
class wl {
    constructor(e){
        this.rows = [], this.currRow = Dr - 1, this.nrRollUpRows = null, this.lastOutputScreen = null, this.logger = void 0;
        for(let t = 0; t < Dr; t++)this.rows.push(new kw(e));
        this.logger = e;
    }
    reset() {
        for(let e = 0; e < Dr; e++)this.rows[e].clear();
        this.currRow = Dr - 1;
    }
    equals(e) {
        let t = !0;
        for(let r = 0; r < Dr; r++)if (!this.rows[r].equals(e.rows[r])) {
            t = !1;
            break;
        }
        return t;
    }
    copy(e) {
        for(let t = 0; t < Dr; t++)this.rows[t].copy(e.rows[t]);
    }
    isEmpty() {
        let e = !0;
        for(let t = 0; t < Dr; t++)if (!this.rows[t].isEmpty()) {
            e = !1;
            break;
        }
        return e;
    }
    backSpace() {
        this.rows[this.currRow].backSpace();
    }
    clearToEndOfRow() {
        this.rows[this.currRow].clearToEndOfRow();
    }
    /**
   * Insert a character (without styling) in the current row.
   */ insertChar(e) {
        this.rows[this.currRow].insertChar(e);
    }
    setPen(e) {
        this.rows[this.currRow].setPenStyles(e);
    }
    moveCursor(e) {
        this.rows[this.currRow].moveCursor(e);
    }
    setCursor(e) {
        this.logger.log(2, "setCursor: " + e), this.rows[this.currRow].setCursor(e);
    }
    setPAC(e) {
        this.logger.log(2, ()=>"pacData = " + at(e));
        let t = e.row - 1;
        if (this.nrRollUpRows && t < this.nrRollUpRows - 1 && (t = this.nrRollUpRows - 1), this.nrRollUpRows && this.currRow !== t) {
            for(let a = 0; a < Dr; a++)this.rows[a].clear();
            const i = this.currRow + 1 - this.nrRollUpRows, o = this.lastOutputScreen;
            if (o) {
                const a = o.rows[i].cueStartTime, l = this.logger.time;
                if (a !== null && l !== null && a < l) for(let c = 0; c < this.nrRollUpRows; c++)this.rows[t - this.nrRollUpRows + c + 1].copy(o.rows[i + c]);
            }
        }
        this.currRow = t;
        const r = this.rows[this.currRow];
        if (e.indent !== null) {
            const i = e.indent, o = Math.max(i - 1, 0);
            r.setCursor(e.indent), e.color = r.chars[o].penState.foreground;
        }
        const n1 = {
            foreground: e.color,
            underline: e.underline,
            italics: e.italics,
            background: "black",
            flash: !1
        };
        this.setPen(n1);
    }
    /**
   * Set background/extra foreground, but first do back_space, and then insert space (backwards compatibility).
   */ setBkgData(e) {
        this.logger.log(2, ()=>"bkgData = " + at(e)), this.backSpace(), this.setPen(e), this.insertChar(32);
    }
    setRollUpRows(e) {
        this.nrRollUpRows = e;
    }
    rollUp() {
        if (this.nrRollUpRows === null) {
            this.logger.log(3, "roll_up but nrRollUpRows not set yet");
            return;
        }
        this.logger.log(1, ()=>this.getDisplayText());
        const e = this.currRow + 1 - this.nrRollUpRows, t = this.rows.splice(e, 1)[0];
        t.clear(), this.rows.splice(this.currRow, 0, t), this.logger.log(2, "Rolling up");
    }
    /**
   * Get all non-empty rows with as unicode text.
   */ getDisplayText(e) {
        e = e || !1;
        const t = [];
        let r = "", n1 = -1;
        for(let i = 0; i < Dr; i++){
            const o = this.rows[i].getTextString();
            o && (n1 = i + 1, e ? t.push("Row " + n1 + ": '" + o + "'") : t.push(o.trim()));
        }
        return t.length > 0 && (e ? r = "[" + t.join(" | ") + "]" : r = t.join(`
`)), r;
    }
    getTextAndFormat() {
        return this.rows;
    }
}
class ef {
    constructor(e, t, r){
        this.chNr = void 0, this.outputFilter = void 0, this.mode = void 0, this.verbose = void 0, this.displayedMemory = void 0, this.nonDisplayedMemory = void 0, this.lastOutputScreen = void 0, this.currRollUpRow = void 0, this.writeScreen = void 0, this.cueStartTime = void 0, this.logger = void 0, this.chNr = e, this.outputFilter = t, this.mode = null, this.verbose = 0, this.displayedMemory = new wl(r), this.nonDisplayedMemory = new wl(r), this.lastOutputScreen = new wl(r), this.currRollUpRow = this.displayedMemory.rows[Dr - 1], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null, this.logger = r;
    }
    reset() {
        this.mode = null, this.displayedMemory.reset(), this.nonDisplayedMemory.reset(), this.lastOutputScreen.reset(), this.outputFilter.reset(), this.currRollUpRow = this.displayedMemory.rows[Dr - 1], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null;
    }
    getHandler() {
        return this.outputFilter;
    }
    setHandler(e) {
        this.outputFilter = e;
    }
    setPAC(e) {
        this.writeScreen.setPAC(e);
    }
    setBkgData(e) {
        this.writeScreen.setBkgData(e);
    }
    setMode(e) {
        e !== this.mode && (this.mode = e, this.logger.log(2, ()=>"MODE=" + e), this.mode === "MODE_POP-ON" ? this.writeScreen = this.nonDisplayedMemory : (this.writeScreen = this.displayedMemory, this.writeScreen.reset()), this.mode !== "MODE_ROLL-UP" && (this.displayedMemory.nrRollUpRows = null, this.nonDisplayedMemory.nrRollUpRows = null), this.mode = e);
    }
    insertChars(e) {
        for(let r = 0; r < e.length; r++)this.writeScreen.insertChar(e[r]);
        const t = this.writeScreen === this.displayedMemory ? "DISP" : "NON_DISP";
        this.logger.log(2, ()=>t + ": " + this.writeScreen.getDisplayText(!0)), (this.mode === "MODE_PAINT-ON" || this.mode === "MODE_ROLL-UP") && (this.logger.log(1, ()=>"DISPLAYED: " + this.displayedMemory.getDisplayText(!0)), this.outputDataUpdate());
    }
    ccRCL() {
        this.logger.log(2, "RCL - Resume Caption Loading"), this.setMode("MODE_POP-ON");
    }
    ccBS() {
        this.logger.log(2, "BS - BackSpace"), this.mode !== "MODE_TEXT" && (this.writeScreen.backSpace(), this.writeScreen === this.displayedMemory && this.outputDataUpdate());
    }
    ccAOF() {}
    ccAON() {}
    ccDER() {
        this.logger.log(2, "DER- Delete to End of Row"), this.writeScreen.clearToEndOfRow(), this.outputDataUpdate();
    }
    ccRU(e) {
        this.logger.log(2, "RU(" + e + ") - Roll Up"), this.writeScreen = this.displayedMemory, this.setMode("MODE_ROLL-UP"), this.writeScreen.setRollUpRows(e);
    }
    ccFON() {
        this.logger.log(2, "FON - Flash On"), this.writeScreen.setPen({
            flash: !0
        });
    }
    ccRDC() {
        this.logger.log(2, "RDC - Resume Direct Captioning"), this.setMode("MODE_PAINT-ON");
    }
    ccTR() {
        this.logger.log(2, "TR"), this.setMode("MODE_TEXT");
    }
    ccRTD() {
        this.logger.log(2, "RTD"), this.setMode("MODE_TEXT");
    }
    ccEDM() {
        this.logger.log(2, "EDM - Erase Displayed Memory"), this.displayedMemory.reset(), this.outputDataUpdate(!0);
    }
    ccCR() {
        this.logger.log(2, "CR - Carriage Return"), this.writeScreen.rollUp(), this.outputDataUpdate(!0);
    }
    ccENM() {
        this.logger.log(2, "ENM - Erase Non-displayed Memory"), this.nonDisplayedMemory.reset();
    }
    ccEOC() {
        if (this.logger.log(2, "EOC - End Of Caption"), this.mode === "MODE_POP-ON") {
            const e = this.displayedMemory;
            this.displayedMemory = this.nonDisplayedMemory, this.nonDisplayedMemory = e, this.writeScreen = this.nonDisplayedMemory, this.logger.log(1, ()=>"DISP: " + this.displayedMemory.getDisplayText());
        }
        this.outputDataUpdate(!0);
    }
    ccTO(e) {
        this.logger.log(2, "TO(" + e + ") - Tab Offset"), this.writeScreen.moveCursor(e);
    }
    ccMIDROW(e) {
        const t = {
            flash: !1
        };
        if (t.underline = e % 2 === 1, t.italics = e >= 46, t.italics) t.foreground = "white";
        else {
            const r = Math.floor(e / 2) - 16, n1 = [
                "white",
                "green",
                "blue",
                "cyan",
                "red",
                "yellow",
                "magenta"
            ];
            t.foreground = n1[r];
        }
        this.logger.log(2, "MIDROW: " + at(t)), this.writeScreen.setPen(t);
    }
    outputDataUpdate(e = !1) {
        const t = this.logger.time;
        t !== null && this.outputFilter && (this.cueStartTime === null && !this.displayedMemory.isEmpty() ? this.cueStartTime = t : this.displayedMemory.equals(this.lastOutputScreen) || (this.outputFilter.newCue(this.cueStartTime, t, this.lastOutputScreen), e && this.outputFilter.dispatchCue && this.outputFilter.dispatchCue(), this.cueStartTime = this.displayedMemory.isEmpty() ? null : t), this.lastOutputScreen.copy(this.displayedMemory));
    }
    cueSplitAtTime(e) {
        this.outputFilter && (this.displayedMemory.isEmpty() || (this.outputFilter.newCue && this.outputFilter.newCue(this.cueStartTime, e, this.displayedMemory), this.cueStartTime = e));
    }
}
class tf {
    constructor(e, t, r){
        this.channels = void 0, this.currentChannel = 0, this.cmdHistory = Pw(), this.logger = void 0;
        const n1 = this.logger = new Rw();
        this.channels = [
            null,
            new ef(e, t, n1),
            new ef(e + 1, r, n1)
        ];
    }
    getHandler(e) {
        return this.channels[e].getHandler();
    }
    setHandler(e, t) {
        this.channels[e].setHandler(t);
    }
    /**
   * Add data for time t in forms of list of bytes (unsigned ints). The bytes are treated as pairs.
   */ addData(e, t) {
        this.logger.time = e;
        for(let r = 0; r < t.length; r += 2){
            const n1 = t[r] & 127, i = t[r + 1] & 127;
            let o = !1, a = null;
            if (n1 === 0 && i === 0) continue;
            this.logger.log(3, ()=>"[" + Ns([
                    t[r],
                    t[r + 1]
                ]) + "] -> (" + Ns([
                    n1,
                    i
                ]) + ")");
            const l = this.cmdHistory;
            if (n1 >= 16 && n1 <= 31) {
                if (Dw(n1, i, l)) {
                    eo(null, null, l), this.logger.log(3, ()=>"Repeated command (" + Ns([
                            n1,
                            i
                        ]) + ") is dropped");
                    continue;
                }
                eo(n1, i, this.cmdHistory), o = this.parseCmd(n1, i), o || (o = this.parseMidrow(n1, i)), o || (o = this.parsePAC(n1, i)), o || (o = this.parseBackgroundAttributes(n1, i));
            } else eo(null, null, l);
            if (!o && (a = this.parseChars(n1, i), a)) {
                const u = this.currentChannel;
                u && u > 0 ? this.channels[u].insertChars(a) : this.logger.log(2, "No channel found yet. TEXT-MODE?");
            }
            !o && !a && this.logger.log(2, ()=>"Couldn't parse cleaned data " + Ns([
                    n1,
                    i
                ]) + " orig: " + Ns([
                    t[r],
                    t[r + 1]
                ]));
        }
    }
    /**
   * Parse Command.
   * @returns True if a command was found
   */ parseCmd(e, t) {
        const r = (e === 20 || e === 28 || e === 21 || e === 29) && t >= 32 && t <= 47, n1 = (e === 23 || e === 31) && t >= 33 && t <= 35;
        if (!(r || n1)) return !1;
        const i = e === 20 || e === 21 || e === 23 ? 1 : 2, o = this.channels[i];
        return e === 20 || e === 21 || e === 28 || e === 29 ? t === 32 ? o.ccRCL() : t === 33 ? o.ccBS() : t === 34 ? o.ccAOF() : t === 35 ? o.ccAON() : t === 36 ? o.ccDER() : t === 37 ? o.ccRU(2) : t === 38 ? o.ccRU(3) : t === 39 ? o.ccRU(4) : t === 40 ? o.ccFON() : t === 41 ? o.ccRDC() : t === 42 ? o.ccTR() : t === 43 ? o.ccRTD() : t === 44 ? o.ccEDM() : t === 45 ? o.ccCR() : t === 46 ? o.ccENM() : t === 47 && o.ccEOC() : o.ccTO(t - 32), this.currentChannel = i, !0;
    }
    /**
   * Parse midrow styling command
   */ parseMidrow(e, t) {
        let r = 0;
        if ((e === 17 || e === 25) && t >= 32 && t <= 47) {
            if (e === 17 ? r = 1 : r = 2, r !== this.currentChannel) return this.logger.log(0, "Mismatch channel in midrow parsing"), !1;
            const n1 = this.channels[r];
            return n1 ? (n1.ccMIDROW(t), this.logger.log(3, ()=>"MIDROW (" + Ns([
                    e,
                    t
                ]) + ")"), !0) : !1;
        }
        return !1;
    }
    /**
   * Parse Preable Access Codes (Table 53).
   * @returns {Boolean} Tells if PAC found
   */ parsePAC(e, t) {
        let r;
        const n1 = (e >= 17 && e <= 23 || e >= 25 && e <= 31) && t >= 64 && t <= 127, i = (e === 16 || e === 24) && t >= 64 && t <= 95;
        if (!(n1 || i)) return !1;
        const o = e <= 23 ? 1 : 2;
        t >= 64 && t <= 95 ? r = o === 1 ? ww[e] : Iw[e] : r = o === 1 ? Aw[e] : _w[e];
        const a = this.channels[o];
        return a ? (a.setPAC(this.interpretPAC(r, t)), this.currentChannel = o, !0) : !1;
    }
    /**
   * Interpret the second byte of the pac, and return the information.
   * @returns pacData with style parameters
   */ interpretPAC(e, t) {
        let r;
        const n1 = {
            color: null,
            italics: !1,
            indent: null,
            underline: !1,
            row: e
        };
        return t > 95 ? r = t - 96 : r = t - 64, n1.underline = (r & 1) === 1, r <= 13 ? n1.color = [
            "white",
            "green",
            "blue",
            "cyan",
            "red",
            "yellow",
            "magenta",
            "white"
        ][Math.floor(r / 2)] : r <= 15 ? (n1.italics = !0, n1.color = "white") : n1.indent = Math.floor((r - 16) / 2) * 4, n1;
    }
    /**
   * Parse characters.
   * @returns An array with 1 to 2 codes corresponding to chars, if found. null otherwise.
   */ parseChars(e, t) {
        let r, n1 = null, i = null;
        if (e >= 25 ? (r = 2, i = e - 8) : (r = 1, i = e), i >= 17 && i <= 19) {
            let o;
            i === 17 ? o = t + 80 : i === 18 ? o = t + 112 : o = t + 144, this.logger.log(2, ()=>"Special char '" + Gp(o) + "' in channel " + r), n1 = [
                o
            ];
        } else e >= 32 && e <= 127 && (n1 = t === 0 ? [
            e
        ] : [
            e,
            t
        ]);
        return n1 && this.logger.log(3, ()=>"Char codes =  " + Ns(n1).join(",")), n1;
    }
    /**
   * Parse extended background attributes as well as new foreground color black.
   * @returns True if background attributes are found
   */ parseBackgroundAttributes(e, t) {
        const r = (e === 16 || e === 24) && t >= 32 && t <= 47, n1 = (e === 23 || e === 31) && t >= 45 && t <= 47;
        if (!(r || n1)) return !1;
        let i;
        const o = {};
        e === 16 || e === 24 ? (i = Math.floor((t - 32) / 2), o.background = Lw[i], t % 2 === 1 && (o.background = o.background + "_semi")) : t === 45 ? o.background = "transparent" : (o.foreground = "black", t === 47 && (o.underline = !0));
        const a = e <= 23 ? 1 : 2;
        return this.channels[a].setBkgData(o), !0;
    }
    /**
   * Reset state of parser and its channels.
   */ reset() {
        for(let e = 0; e < Object.keys(this.channels).length; e++){
            const t = this.channels[e];
            t && t.reset();
        }
        eo(null, null, this.cmdHistory);
    }
    /**
   * Trigger the generation of a cue, and the start of a new one if displayScreens are not empty.
   */ cueSplitAtTime(e) {
        for(let t = 0; t < this.channels.length; t++){
            const r = this.channels[t];
            r && r.cueSplitAtTime(e);
        }
    }
}
function eo(s, e, t) {
    t.a = s, t.b = e;
}
function Dw(s, e, t) {
    return t.a === s && t.b === e;
}
function Pw() {
    return {
        a: null,
        b: null
    };
}
var Ou = function() {
    if (ra != null && ra.VTTCue) return self.VTTCue;
    const s = [
        "",
        "lr",
        "rl"
    ], e = [
        "start",
        "middle",
        "end",
        "left",
        "right"
    ];
    function t(a, l) {
        if (typeof l != "string" || !Array.isArray(a)) return !1;
        const c = l.toLowerCase();
        return ~a.indexOf(c) ? c : !1;
    }
    function r(a) {
        return t(s, a);
    }
    function n1(a) {
        return t(e, a);
    }
    function i(a, ...l) {
        let c = 1;
        for(; c < arguments.length; c++){
            const u = arguments[c];
            for(const d1 in u)a[d1] = u[d1];
        }
        return a;
    }
    function o(a, l, c) {
        const u = this, d1 = {
            enumerable: !0
        };
        u.hasBeenReset = !1;
        let h = "", f = !1, p = a, y = l, E = c, b = null, L = "", A = !0, F = "auto", M = "start", H = 50, K = "middle", j = 50, C = "middle";
        Object.defineProperty(u, "id", i({}, d1, {
            get: function() {
                return h;
            },
            set: function(k) {
                h = "" + k;
            }
        })), Object.defineProperty(u, "pauseOnExit", i({}, d1, {
            get: function() {
                return f;
            },
            set: function(k) {
                f = !!k;
            }
        })), Object.defineProperty(u, "startTime", i({}, d1, {
            get: function() {
                return p;
            },
            set: function(k) {
                if (typeof k != "number") throw new TypeError("Start time must be set to a number.");
                p = k, this.hasBeenReset = !0;
            }
        })), Object.defineProperty(u, "endTime", i({}, d1, {
            get: function() {
                return y;
            },
            set: function(k) {
                if (typeof k != "number") throw new TypeError("End time must be set to a number.");
                y = k, this.hasBeenReset = !0;
            }
        })), Object.defineProperty(u, "text", i({}, d1, {
            get: function() {
                return E;
            },
            set: function(k) {
                E = "" + k, this.hasBeenReset = !0;
            }
        })), Object.defineProperty(u, "region", i({}, d1, {
            get: function() {
                return b;
            },
            set: function(k) {
                b = k, this.hasBeenReset = !0;
            }
        })), Object.defineProperty(u, "vertical", i({}, d1, {
            get: function() {
                return L;
            },
            set: function(k) {
                const $ = r(k);
                if ($ === !1) throw new SyntaxError("An invalid or illegal string was specified.");
                L = $, this.hasBeenReset = !0;
            }
        })), Object.defineProperty(u, "snapToLines", i({}, d1, {
            get: function() {
                return A;
            },
            set: function(k) {
                A = !!k, this.hasBeenReset = !0;
            }
        })), Object.defineProperty(u, "line", i({}, d1, {
            get: function() {
                return F;
            },
            set: function(k) {
                if (typeof k != "number" && k !== "auto") throw new SyntaxError("An invalid number or illegal string was specified.");
                F = k, this.hasBeenReset = !0;
            }
        })), Object.defineProperty(u, "lineAlign", i({}, d1, {
            get: function() {
                return M;
            },
            set: function(k) {
                const $ = n1(k);
                if (!$) throw new SyntaxError("An invalid or illegal string was specified.");
                M = $, this.hasBeenReset = !0;
            }
        })), Object.defineProperty(u, "position", i({}, d1, {
            get: function() {
                return H;
            },
            set: function(k) {
                if (k < 0 || k > 100) throw new Error("Position must be between 0 and 100.");
                H = k, this.hasBeenReset = !0;
            }
        })), Object.defineProperty(u, "positionAlign", i({}, d1, {
            get: function() {
                return K;
            },
            set: function(k) {
                const $ = n1(k);
                if (!$) throw new SyntaxError("An invalid or illegal string was specified.");
                K = $, this.hasBeenReset = !0;
            }
        })), Object.defineProperty(u, "size", i({}, d1, {
            get: function() {
                return j;
            },
            set: function(k) {
                if (k < 0 || k > 100) throw new Error("Size must be between 0 and 100.");
                j = k, this.hasBeenReset = !0;
            }
        })), Object.defineProperty(u, "align", i({}, d1, {
            get: function() {
                return C;
            },
            set: function(k) {
                const $ = n1(k);
                if (!$) throw new SyntaxError("An invalid or illegal string was specified.");
                C = $, this.hasBeenReset = !0;
            }
        })), u.displayState = void 0;
    }
    return o.prototype.getCueAsHTML = function() {
        return self.WebVTT.convertCueToDOMTree(self, this.text);
    }, o;
}();
class Mw {
    decode(e, t) {
        if (!e) return "";
        if (typeof e != "string") throw new Error("Error - expected string data.");
        return decodeURIComponent(encodeURIComponent(e));
    }
}
function jp(s) {
    function e(r, n1, i, o) {
        return (r | 0) * 3600 + (n1 | 0) * 60 + (i | 0) + parseFloat(o || 0);
    }
    const t = s.match(/^(?:(\d+):)?(\d{2}):(\d{2})(\.\d+)?/);
    return t ? parseFloat(t[2]) > 59 ? e(t[2], t[3], 0, t[4]) : e(t[1], t[2], t[3], t[4]) : null;
}
class Ow {
    constructor(){
        this.values = /* @__PURE__ */ Object.create(null);
    }
    // Only accept the first assignment to any key.
    set(e, t) {
        !this.get(e) && t !== "" && (this.values[e] = t);
    }
    // Return the value for a key, or a default value.
    // If 'defaultKey' is passed then 'dflt' is assumed to be an object with
    // a number of possible default values as properties where 'defaultKey' is
    // the key of the property that will be chosen; otherwise it's assumed to be
    // a single value.
    get(e, t, r) {
        return r ? this.has(e) ? this.values[e] : t[r] : this.has(e) ? this.values[e] : t;
    }
    // Check whether we have a value for a key.
    has(e) {
        return e in this.values;
    }
    // Accept a setting if its one of the given alternatives.
    alt(e, t, r) {
        for(let n1 = 0; n1 < r.length; ++n1)if (t === r[n1]) {
            this.set(e, t);
            break;
        }
    }
    // Accept a setting if its a valid (signed) integer.
    integer(e, t) {
        /^-?\d+$/.test(t) && this.set(e, parseInt(t, 10));
    }
    // Accept a setting if its a valid percentage.
    percent(e, t) {
        if (/^([\d]{1,3})(\.[\d]*)?%$/.test(t)) {
            const r = parseFloat(t);
            if (r >= 0 && r <= 100) return this.set(e, r), !0;
        }
        return !1;
    }
}
function Kp(s, e, t, r) {
    const n1 = r ? s.split(r) : [
        s
    ];
    for(const i in n1){
        if (typeof n1[i] != "string") continue;
        const o = n1[i].split(t);
        if (o.length !== 2) continue;
        const a = o[0], l = o[1];
        e(a, l);
    }
}
const bc = new Ou(0, 0, ""), to = bc.align === "middle" ? "middle" : "center";
function Bw(s, e, t) {
    const r = s;
    function n1() {
        const a = jp(s);
        if (a === null) throw new Error("Malformed timestamp: " + r);
        return s = s.replace(/^[^\sa-zA-Z-]+/, ""), a;
    }
    function i(a, l) {
        const c = new Ow();
        Kp(a, function(h, f) {
            let p;
            switch(h){
                case "region":
                    for(let y = t.length - 1; y >= 0; y--)if (t[y].id === f) {
                        c.set(h, t[y].region);
                        break;
                    }
                    break;
                case "vertical":
                    c.alt(h, f, [
                        "rl",
                        "lr"
                    ]);
                    break;
                case "line":
                    p = f.split(","), c.integer(h, p[0]), c.percent(h, p[0]) && c.set("snapToLines", !1), c.alt(h, p[0], [
                        "auto"
                    ]), p.length === 2 && c.alt("lineAlign", p[1], [
                        "start",
                        to,
                        "end"
                    ]);
                    break;
                case "position":
                    p = f.split(","), c.percent(h, p[0]), p.length === 2 && c.alt("positionAlign", p[1], [
                        "start",
                        to,
                        "end",
                        "line-left",
                        "line-right",
                        "auto"
                    ]);
                    break;
                case "size":
                    c.percent(h, f);
                    break;
                case "align":
                    c.alt(h, f, [
                        "start",
                        to,
                        "end",
                        "left",
                        "right"
                    ]);
                    break;
            }
        }, /:/, /\s/), l.region = c.get("region", null), l.vertical = c.get("vertical", "");
        let u = c.get("line", "auto");
        u === "auto" && bc.line === -1 && (u = -1), l.line = u, l.lineAlign = c.get("lineAlign", "start"), l.snapToLines = c.get("snapToLines", !0), l.size = c.get("size", 100), l.align = c.get("align", to);
        let d1 = c.get("position", "auto");
        d1 === "auto" && bc.position === 50 && (d1 = l.align === "start" || l.align === "left" ? 0 : l.align === "end" || l.align === "right" ? 100 : 50), l.position = d1;
    }
    function o() {
        s = s.replace(/^\s+/, "");
    }
    if (o(), e.startTime = n1(), o(), s.slice(0, 3) !== "-->") throw new Error("Malformed time stamp (time stamps must be separated by '-->'): " + r);
    s = s.slice(3), o(), e.endTime = n1(), o(), i(s, e);
}
function Hp(s) {
    return s.replace(/<br(?: \/)?>/gi, `
`);
}
class Fw {
    constructor(){
        this.state = "INITIAL", this.buffer = "", this.decoder = new Mw(), this.regionList = [], this.cue = null, this.oncue = void 0, this.onparsingerror = void 0, this.onflush = void 0;
    }
    parse(e) {
        const t = this;
        e && (t.buffer += t.decoder.decode(e, {
            stream: !0
        }));
        function r() {
            let i = t.buffer, o = 0;
            for(i = Hp(i); o < i.length && i[o] !== "\r" && i[o] !== `
`;)++o;
            const a = i.slice(0, o);
            return i[o] === "\r" && ++o, i[o] === `
` && ++o, t.buffer = i.slice(o), a;
        }
        function n1(i) {
            Kp(i, function(o, a) {}, /:/);
        }
        try {
            let i = "";
            if (t.state === "INITIAL") {
                if (!/\r\n|\n/.test(t.buffer)) return this;
                i = r();
                const a = i.match(/^()?WEBVTT([ \t].*)?$/);
                if (!(a != null && a[0])) throw new Error("Malformed WebVTT signature.");
                t.state = "HEADER";
            }
            let o = !1;
            for(; t.buffer;){
                if (!/\r\n|\n/.test(t.buffer)) return this;
                switch(o ? o = !1 : i = r(), t.state){
                    case "HEADER":
                        /:/.test(i) ? n1(i) : i || (t.state = "ID");
                        continue;
                    case "NOTE":
                        i || (t.state = "ID");
                        continue;
                    case "ID":
                        if (/^NOTE($|[ \t])/.test(i)) {
                            t.state = "NOTE";
                            break;
                        }
                        if (!i) continue;
                        if (t.cue = new Ou(0, 0, ""), t.state = "CUE", i.indexOf("-->") === -1) {
                            t.cue.id = i;
                            continue;
                        }
                    // Process line as start of a cue.
                    /* falls through */ case "CUE":
                        if (!t.cue) {
                            t.state = "BADCUE";
                            continue;
                        }
                        try {
                            Bw(i, t.cue, t.regionList);
                        } catch  {
                            t.cue = null, t.state = "BADCUE";
                            continue;
                        }
                        t.state = "CUETEXT";
                        continue;
                    case "CUETEXT":
                        {
                            const a = i.indexOf("-->") !== -1;
                            if (!i || a && (o = !0)) {
                                t.oncue && t.cue && t.oncue(t.cue), t.cue = null, t.state = "ID";
                                continue;
                            }
                            if (t.cue === null) continue;
                            t.cue.text && (t.cue.text += `
`), t.cue.text += i;
                        }
                        continue;
                    case "BADCUE":
                        i || (t.state = "ID");
                }
            }
        } catch  {
            t.state === "CUETEXT" && t.cue && t.oncue && t.oncue(t.cue), t.cue = null, t.state = t.state === "INITIAL" ? "BADWEBVTT" : "BADCUE";
        }
        return this;
    }
    flush() {
        const e = this;
        try {
            if ((e.cue || e.state === "HEADER") && (e.buffer += `

`, e.parse()), e.state === "INITIAL" || e.state === "BADWEBVTT") throw new Error("Malformed WebVTT signature.");
        } catch (t) {
            e.onparsingerror && e.onparsingerror(t);
        }
        return e.onflush && e.onflush(), this;
    }
}
const Nw = /\r\n|\n\r|\n|\r/g, Al = function(e, t, r = 0) {
    return e.slice(r, r + t.length) === t;
}, Uw = function(e) {
    let t = parseInt(e.slice(-3));
    const r = parseInt(e.slice(-6, -4)), n1 = parseInt(e.slice(-9, -7)), i = e.length > 9 ? parseInt(e.substring(0, e.indexOf(":"))) : 0;
    if (!ue(t) || !ue(r) || !ue(n1) || !ue(i)) throw Error(`Malformed X-TIMESTAMP-MAP: Local:${e}`);
    return t += 1e3 * r, t += 60 * 1e3 * n1, t += 3600 * 1e3 * i, t;
};
function Bu(s, e, t) {
    return Xn(s.toString()) + Xn(e.toString()) + Xn(t);
}
const $w = function(e, t, r) {
    let n1 = e[t], i = e[n1.prevCC];
    if (!i || !i.new && n1.new) {
        e.ccOffset = e.presentationOffset = n1.start, n1.new = !1;
        return;
    }
    for(; (o = i) != null && o.new;){
        var o;
        e.ccOffset += n1.start - i.start, n1.new = !1, n1 = i, i = e[n1.prevCC];
    }
    e.presentationOffset = r;
};
function Gw(s, e, t, r, n1, i, o) {
    const a = new Fw(), l = Tr(new Uint8Array(s)).trim().replace(Nw, `
`).split(`
`), c = [], u = e ? WT(e.baseTime, e.timescale) : 0;
    let d1 = "00:00.000", h = 0, f = 0, p, y = !0;
    a.oncue = function(E) {
        const b = t[r];
        let L = t.ccOffset;
        const A = (h - u) / 9e4;
        if (b != null && b.new && (f !== void 0 ? L = t.ccOffset = b.start : $w(t, r, A)), A) {
            if (!e) {
                p = new Error("Missing initPTS for VTT MPEGTS");
                return;
            }
            L = A - t.presentationOffset;
        }
        const F = E.endTime - E.startTime, M = Ar((E.startTime + L - f) * 9e4, n1 * 9e4) / 9e4;
        E.startTime = Math.max(M, 0), E.endTime = Math.max(M + F, 0);
        const H = E.text.trim();
        E.text = decodeURIComponent(encodeURIComponent(H)), E.id || (E.id = Bu(E.startTime, E.endTime, H)), E.endTime > 0 && c.push(E);
    }, a.onparsingerror = function(E) {
        p = E;
    }, a.onflush = function() {
        if (p) {
            o(p);
            return;
        }
        i(c);
    }, l.forEach((E)=>{
        if (y) if (Al(E, "X-TIMESTAMP-MAP=")) {
            y = !1, E.slice(16).split(",").forEach((b)=>{
                Al(b, "LOCAL:") ? d1 = b.slice(6) : Al(b, "MPEGTS:") && (h = parseInt(b.slice(7)));
            });
            try {
                f = Uw(d1) / 1e3;
            } catch (b) {
                p = b;
            }
            return;
        } else E === "" && (y = !1);
        a.parse(E + `
`);
    }), a.flush();
}
const Il = "stpp.ttml.im1t", qp = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/, Wp = /^(\d*(?:\.\d*)?)(h|m|s|ms|f|t)$/, Vw = {
    left: "start",
    center: "center",
    right: "end",
    start: "start",
    end: "end"
};
function rf(s, e, t, r) {
    const n1 = Ge(new Uint8Array(s), [
        "mdat"
    ]);
    if (n1.length === 0) {
        r(new Error("Could not parse IMSC1 mdat"));
        return;
    }
    const i = n1.map((a)=>Tr(a)), o = qT(e.baseTime, 1, e.timescale);
    try {
        i.forEach((a)=>t(jw(a, o)));
    } catch (a) {
        r(a);
    }
}
function jw(s, e) {
    const n1 = new DOMParser().parseFromString(s, "text/xml").getElementsByTagName("tt")[0];
    if (!n1) throw new Error("Invalid ttml");
    const i = {
        frameRate: 30,
        subFrameRate: 1,
        frameRateMultiplier: 0,
        tickRate: 0
    }, o = Object.keys(i).reduce((d1, h)=>(d1[h] = n1.getAttribute(`ttp:${h}`) || i[h], d1), {}), a = n1.getAttribute("xml:space") !== "preserve", l = sf(_l(n1, "styling", "style")), c = sf(_l(n1, "layout", "region")), u = _l(n1, "body", "[begin]");
    return [].map.call(u, (d1)=>{
        const h = zp(d1, a);
        if (!h || !d1.hasAttribute("begin")) return null;
        const f = Rl(d1.getAttribute("begin"), o), p = Rl(d1.getAttribute("dur"), o);
        let y = Rl(d1.getAttribute("end"), o);
        if (f === null) throw nf(d1);
        if (y === null) {
            if (p === null) throw nf(d1);
            y = f + p;
        }
        const E = new Ou(f - e, y - e, h);
        E.id = Bu(E.startTime, E.endTime, E.text);
        const b = c[d1.getAttribute("region")], L = l[d1.getAttribute("style")], A = Kw(b, L, l), { textAlign: F } = A;
        if (F) {
            const M = Vw[F];
            M && (E.lineAlign = M), E.align = F;
        }
        return nt(E, A), E;
    }).filter((d1)=>d1 !== null);
}
function _l(s, e, t) {
    const r = s.getElementsByTagName(e)[0];
    return r ? [].slice.call(r.querySelectorAll(t)) : [];
}
function sf(s) {
    return s.reduce((e, t)=>{
        const r = t.getAttribute("xml:id");
        return r && (e[r] = t), e;
    }, {});
}
function zp(s, e) {
    return [].slice.call(s.childNodes).reduce((t, r, n1)=>{
        var i;
        return r.nodeName === "br" && n1 ? t + `
` : (i = r.childNodes) != null && i.length ? zp(r, e) : e ? t + r.textContent.trim().replace(/\s+/g, " ") : t + r.textContent;
    }, "");
}
function Kw(s, e, t) {
    const r = "http://www.w3.org/ns/ttml#styling";
    let n1 = null;
    const i = [
        "displayAlign",
        "textAlign",
        "color",
        "backgroundColor",
        "fontSize",
        "fontFamily"
    ], o = s != null && s.hasAttribute("style") ? s.getAttribute("style") : null;
    return o && t.hasOwnProperty(o) && (n1 = t[o]), i.reduce((a, l)=>{
        const c = Ll(e, r, l) || Ll(s, r, l) || Ll(n1, r, l);
        return c && (a[l] = c), a;
    }, {});
}
function Ll(s, e, t) {
    return s && s.hasAttributeNS(e, t) ? s.getAttributeNS(e, t) : null;
}
function nf(s) {
    return new Error(`Could not parse ttml timestamp ${s}`);
}
function Rl(s, e) {
    if (!s) return null;
    let t = jp(s);
    return t === null && (qp.test(s) ? t = Hw(s, e) : Wp.test(s) && (t = qw(s, e))), t;
}
function Hw(s, e) {
    const t = qp.exec(s), r = (t[4] | 0) + (t[5] | 0) / e.subFrameRate;
    return (t[1] | 0) * 3600 + (t[2] | 0) * 60 + (t[3] | 0) + r / e.frameRate;
}
function qw(s, e) {
    const t = Wp.exec(s), r = Number(t[1]);
    switch(t[2]){
        case "h":
            return r * 3600;
        case "m":
            return r * 60;
        case "ms":
            return r * 1e3;
        case "f":
            return r / e.frameRate;
        case "t":
            return r / e.tickRate;
    }
    return r;
}
class ro {
    constructor(e, t){
        this.timelineController = void 0, this.cueRanges = [], this.trackName = void 0, this.startTime = null, this.endTime = null, this.screen = null, this.timelineController = e, this.trackName = t;
    }
    dispatchCue() {
        this.startTime !== null && (this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen, this.cueRanges), this.startTime = null);
    }
    newCue(e, t, r) {
        (this.startTime === null || this.startTime > e) && (this.startTime = e), this.endTime = t, this.screen = r, this.timelineController.createCaptionsTrack(this.trackName);
    }
    reset() {
        this.cueRanges = [], this.startTime = null;
    }
}
class Ww {
    constructor(e){
        this.hls = void 0, this.media = null, this.config = void 0, this.enabled = !0, this.Cues = void 0, this.textTracks = [], this.tracks = [], this.initPTS = [], this.unparsedVttFrags = [], this.captionsTracks = {}, this.nonNativeCaptionsTracks = {}, this.cea608Parser1 = void 0, this.cea608Parser2 = void 0, this.lastCc = -1, this.lastSn = -1, this.lastPartIndex = -1, this.prevCC = -1, this.vttCCs = af(), this.captionsProperties = void 0, this.hls = e, this.config = e.config, this.Cues = e.config.cueHandler, this.captionsProperties = {
            textTrack1: {
                label: this.config.captionsTextTrack1Label,
                languageCode: this.config.captionsTextTrack1LanguageCode
            },
            textTrack2: {
                label: this.config.captionsTextTrack2Label,
                languageCode: this.config.captionsTextTrack2LanguageCode
            },
            textTrack3: {
                label: this.config.captionsTextTrack3Label,
                languageCode: this.config.captionsTextTrack3LanguageCode
            },
            textTrack4: {
                label: this.config.captionsTextTrack4Label,
                languageCode: this.config.captionsTextTrack4LanguageCode
            }
        }, e.on(I.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(I.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(I.MANIFEST_LOADING, this.onManifestLoading, this), e.on(I.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(I.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.on(I.FRAG_LOADING, this.onFragLoading, this), e.on(I.FRAG_LOADED, this.onFragLoaded, this), e.on(I.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this), e.on(I.FRAG_DECRYPTED, this.onFragDecrypted, this), e.on(I.INIT_PTS_FOUND, this.onInitPtsFound, this), e.on(I.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this), e.on(I.BUFFER_FLUSHING, this.onBufferFlushing, this);
    }
    destroy() {
        const { hls: e } = this;
        e.off(I.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(I.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(I.MANIFEST_LOADING, this.onManifestLoading, this), e.off(I.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(I.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.off(I.FRAG_LOADING, this.onFragLoading, this), e.off(I.FRAG_LOADED, this.onFragLoaded, this), e.off(I.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this), e.off(I.FRAG_DECRYPTED, this.onFragDecrypted, this), e.off(I.INIT_PTS_FOUND, this.onInitPtsFound, this), e.off(I.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this), e.off(I.BUFFER_FLUSHING, this.onBufferFlushing, this), this.hls = this.config = this.media = null, this.cea608Parser1 = this.cea608Parser2 = void 0;
    }
    initCea608Parsers() {
        const e = new ro(this, "textTrack1"), t = new ro(this, "textTrack2"), r = new ro(this, "textTrack3"), n1 = new ro(this, "textTrack4");
        this.cea608Parser1 = new tf(1, e, t), this.cea608Parser2 = new tf(3, r, n1);
    }
    addCues(e, t, r, n1, i) {
        let o = !1;
        for(let a = i.length; a--;){
            const l = i[a], c = zw(l[0], l[1], t, r);
            if (c >= 0 && (l[0] = Math.min(l[0], t), l[1] = Math.max(l[1], r), o = !0, c / (r - t) > 0.5)) return;
        }
        if (o || i.push([
            t,
            r
        ]), this.config.renderTextTracksNatively) {
            const a = this.captionsTracks[e];
            this.Cues.newCue(a, t, r, n1);
        } else {
            const a = this.Cues.newCue(null, t, r, n1);
            this.hls.trigger(I.CUES_PARSED, {
                type: "captions",
                cues: a,
                track: e
            });
        }
    }
    // Triggered when an initial PTS is found; used for synchronisation of WebVTT.
    onInitPtsFound(e, { frag: t, id: r, initPTS: n1, timescale: i, trackId: o }) {
        const { unparsedVttFrags: a } = this;
        r === pe.MAIN && (this.initPTS[t.cc] = {
            baseTime: n1,
            timescale: i,
            trackId: o
        }), a.length && (this.unparsedVttFrags = [], a.forEach((l)=>{
            this.initPTS[l.frag.cc] ? this.onFragLoaded(I.FRAG_LOADED, l) : this.hls.trigger(I.SUBTITLE_FRAG_PROCESSED, {
                success: !1,
                frag: l.frag,
                error: new Error("Subtitle discontinuity domain does not match main")
            });
        }));
    }
    getExistingTrack(e, t) {
        const { media: r } = this;
        if (r) for(let n1 = 0; n1 < r.textTracks.length; n1++){
            const i = r.textTracks[n1];
            if (of(i, {
                name: e,
                lang: t,
                characteristics: "transcribes-spoken-dialog,describes-music-and-sound"
            })) return i;
        }
        return null;
    }
    createCaptionsTrack(e) {
        this.config.renderTextTracksNatively ? this.createNativeTrack(e) : this.createNonNativeTrack(e);
    }
    createNativeTrack(e) {
        if (this.captionsTracks[e]) return;
        const { captionsProperties: t, captionsTracks: r, media: n1 } = this, { label: i, languageCode: o } = t[e], a = this.getExistingTrack(i, o);
        if (a) r[e] = a, En(r[e]), Np(r[e], n1);
        else {
            const l = this.createTextTrack("captions", i, o);
            l && (l[e] = !0, r[e] = l);
        }
    }
    createNonNativeTrack(e) {
        if (this.nonNativeCaptionsTracks[e]) return;
        const t = this.captionsProperties[e];
        if (!t) return;
        const r = t.label, n1 = {
            _id: e,
            label: r,
            kind: "captions",
            default: t.media ? !!t.media.default : !1,
            closedCaptions: t.media
        };
        this.nonNativeCaptionsTracks[e] = n1, this.hls.trigger(I.NON_NATIVE_TEXT_TRACKS_FOUND, {
            tracks: [
                n1
            ]
        });
    }
    createTextTrack(e, t, r) {
        const n1 = this.media;
        if (n1) return n1.addTextTrack(e, t, r);
    }
    onMediaAttaching(e, t) {
        this.media = t.media, t.mediaSource || this._cleanTracks();
    }
    onMediaDetaching(e, t) {
        const r = !!t.transferMedia;
        if (this.media = null, r) return;
        const { captionsTracks: n1 } = this;
        Object.keys(n1).forEach((i)=>{
            En(n1[i]), delete n1[i];
        }), this.nonNativeCaptionsTracks = {};
    }
    onManifestLoading() {
        this.lastCc = -1, this.lastSn = -1, this.lastPartIndex = -1, this.prevCC = -1, this.vttCCs = af(), this._cleanTracks(), this.tracks = [], this.captionsTracks = {}, this.nonNativeCaptionsTracks = {}, this.textTracks = [], this.unparsedVttFrags = [], this.initPTS = [], this.cea608Parser1 && this.cea608Parser2 && (this.cea608Parser1.reset(), this.cea608Parser2.reset());
    }
    _cleanTracks() {
        const { media: e } = this;
        if (!e) return;
        const t = e.textTracks;
        if (t) for(let r = 0; r < t.length; r++)En(t[r]);
    }
    onSubtitleTracksUpdated(e, t) {
        const r = t.subtitleTracks || [], n1 = r.some((i)=>i.textCodec === Il);
        if (this.config.enableWebVTT || n1 && this.config.enableIMSC1) {
            if (Ap(this.tracks, r)) {
                this.tracks = r;
                return;
            }
            if (this.textTracks = [], this.tracks = r, this.config.renderTextTracksNatively) {
                const o = this.media, a = o ? Eo(o.textTracks) : null;
                if (this.tracks.forEach((l, c)=>{
                    let u;
                    if (a) {
                        let d1 = null;
                        for(let h = 0; h < a.length; h++)if (a[h] && of(a[h], l)) {
                            d1 = a[h], a[h] = null;
                            break;
                        }
                        d1 && (u = d1);
                    }
                    if (u) En(u);
                    else {
                        const d1 = Yp(l);
                        u = this.createTextTrack(d1, l.name, l.lang), u && (u.mode = "disabled");
                    }
                    u && this.textTracks.push(u);
                }), a != null && a.length) {
                    const l = a.filter((c)=>c !== null).map((c)=>c.label);
                    l.length && this.hls.logger.warn(`Media element contains unused subtitle tracks: ${l.join(", ")}. Replace media element for each source to clear TextTracks and captions menu.`);
                }
            } else if (this.tracks.length) {
                const o = this.tracks.map((a)=>({
                        label: a.name,
                        kind: a.type.toLowerCase(),
                        default: a.default,
                        subtitleTrack: a
                    }));
                this.hls.trigger(I.NON_NATIVE_TEXT_TRACKS_FOUND, {
                    tracks: o
                });
            }
        }
    }
    onManifestLoaded(e, t) {
        this.config.enableCEA708Captions && t.captions && t.captions.forEach((r)=>{
            const n1 = /(?:CC|SERVICE)([1-4])/.exec(r.instreamId);
            if (!n1) return;
            const i = `textTrack${n1[1]}`, o = this.captionsProperties[i];
            o && (o.label = r.name, r.lang && (o.languageCode = r.lang), o.media = r);
        });
    }
    closedCaptionsForLevel(e) {
        const t = this.hls.levels[e.level];
        return t == null ? void 0 : t.attrs["CLOSED-CAPTIONS"];
    }
    onFragLoading(e, t) {
        if (this.enabled && t.frag.type === pe.MAIN) {
            var r, n1;
            const { cea608Parser1: i, cea608Parser2: o, lastSn: a } = this, { cc: l, sn: c } = t.frag, u = (r = (n1 = t.part) == null ? void 0 : n1.index) != null ? r : -1;
            i && o && (c !== a + 1 || c === a && u !== this.lastPartIndex + 1 || l !== this.lastCc) && (i.reset(), o.reset()), this.lastCc = l, this.lastSn = c, this.lastPartIndex = u;
        }
    }
    onFragLoaded(e, t) {
        const { frag: r, payload: n1 } = t;
        if (r.type === pe.SUBTITLE) if (n1.byteLength) {
            const i = r.decryptdata, o = "stats" in t;
            if (i == null || !i.encrypted || o) {
                const a = this.tracks[r.level], l = this.vttCCs;
                l[r.cc] || (l[r.cc] = {
                    start: r.start,
                    prevCC: this.prevCC,
                    new: !0
                }, this.prevCC = r.cc), a && a.textCodec === Il ? this._parseIMSC1(r, n1) : this._parseVTTs(t);
            }
        } else this.hls.trigger(I.SUBTITLE_FRAG_PROCESSED, {
            success: !1,
            frag: r,
            error: new Error("Empty subtitle payload")
        });
    }
    _parseIMSC1(e, t) {
        const r = this.hls;
        rf(t, this.initPTS[e.cc], (n1)=>{
            this._appendCues(n1, e.level), r.trigger(I.SUBTITLE_FRAG_PROCESSED, {
                success: !0,
                frag: e
            });
        }, (n1)=>{
            r.logger.log(`Failed to parse IMSC1: ${n1}`), r.trigger(I.SUBTITLE_FRAG_PROCESSED, {
                success: !1,
                frag: e,
                error: n1
            });
        });
    }
    _parseVTTs(e) {
        var t;
        const { frag: r, payload: n1 } = e, { initPTS: i, unparsedVttFrags: o } = this, a = i.length - 1;
        if (!i[r.cc] && a === -1) {
            o.push(e);
            return;
        }
        const l = this.hls, c = (t = r.initSegment) != null && t.data ? _r(r.initSegment.data, new Uint8Array(n1)).buffer : n1;
        Gw(c, this.initPTS[r.cc], this.vttCCs, r.cc, r.start, (u)=>{
            this._appendCues(u, r.level), l.trigger(I.SUBTITLE_FRAG_PROCESSED, {
                success: !0,
                frag: r
            });
        }, (u)=>{
            const d1 = u.message === "Missing initPTS for VTT MPEGTS";
            d1 ? o.push(e) : this._fallbackToIMSC1(r, n1), l.logger.log(`Failed to parse VTT cue: ${u}`), !(d1 && a > r.cc) && l.trigger(I.SUBTITLE_FRAG_PROCESSED, {
                success: !1,
                frag: r,
                error: u
            });
        });
    }
    _fallbackToIMSC1(e, t) {
        const r = this.tracks[e.level];
        r.textCodec || rf(t, this.initPTS[e.cc], ()=>{
            r.textCodec = Il, this._parseIMSC1(e, t);
        }, ()=>{
            r.textCodec = "wvtt";
        });
    }
    _appendCues(e, t) {
        const r = this.hls;
        if (this.config.renderTextTracksNatively) {
            const n1 = this.textTracks[t];
            if (!n1 || n1.mode === "disabled") return;
            e.forEach((i)=>Up(n1, i));
        } else {
            const n1 = this.tracks[t];
            if (!n1) return;
            const i = n1.default ? "default" : "subtitles" + t;
            r.trigger(I.CUES_PARSED, {
                type: "subtitles",
                cues: e,
                track: i
            });
        }
    }
    onFragDecrypted(e, t) {
        const { frag: r } = t;
        r.type === pe.SUBTITLE && this.onFragLoaded(I.FRAG_LOADED, t);
    }
    onSubtitleTracksCleared() {
        this.tracks = [], this.captionsTracks = {};
    }
    onFragParsingUserdata(e, t) {
        if (!this.enabled || !this.config.enableCEA708Captions) return;
        const { frag: r, samples: n1 } = t;
        if (!(r.type === pe.MAIN && this.closedCaptionsForLevel(r) === "NONE")) for(let i = 0; i < n1.length; i++){
            const o = n1[i].bytes;
            if (o) {
                this.cea608Parser1 || this.initCea608Parsers();
                const a = this.extractCea608Data(o);
                this.cea608Parser1.addData(n1[i].pts, a[0]), this.cea608Parser2.addData(n1[i].pts, a[1]);
            }
        }
    }
    onBufferFlushing(e, { startOffset: t, endOffset: r, endOffsetSubtitles: n1, type: i }) {
        const { media: o } = this;
        if (!(!o || o.currentTime < r)) {
            if (!i || i === "video") {
                const { captionsTracks: a } = this;
                Object.keys(a).forEach((l)=>Sc(a[l], t, r));
            }
            if (this.config.renderTextTracksNatively && t === 0 && n1 !== void 0) {
                const { textTracks: a } = this;
                Object.keys(a).forEach((l)=>Sc(a[l], t, n1));
            }
        }
    }
    extractCea608Data(e) {
        const t = [
            [],
            []
        ], r = e[0] & 31;
        let n1 = 2;
        for(let i = 0; i < r; i++){
            const o = e[n1++], a = 127 & e[n1++], l = 127 & e[n1++];
            if (a === 0 && l === 0) continue;
            if ((4 & o) !== 0) {
                const u = 3 & o;
                (u === 0 || u === 1) && (t[u].push(a), t[u].push(l));
            }
        }
        return t;
    }
}
function Yp(s) {
    return s.characteristics && /transcribes-spoken-dialog/gi.test(s.characteristics) && /describes-music-and-sound/gi.test(s.characteristics) ? "captions" : "subtitles";
}
function of(s, e) {
    return !!s && s.kind === Yp(e) && yc(e, s);
}
function zw(s, e, t, r) {
    return Math.min(e, r) - Math.max(s, t);
}
function af() {
    return {
        ccOffset: 0,
        presentationOffset: 0,
        0: {
            start: 0,
            prevCC: -1,
            new: !0
        }
    };
}
const Yw = /\s/, Zw = {
    newCue (s, e, t, r) {
        const n1 = [];
        let i, o, a, l, c;
        const u = self.VTTCue || self.TextTrackCue;
        for(let h = 0; h < r.rows.length; h++)if (i = r.rows[h], a = !0, l = 0, c = "", !i.isEmpty()) {
            var d1;
            for(let y = 0; y < i.chars.length; y++)Yw.test(i.chars[y].uchar) && a ? l++ : (c += i.chars[y].uchar, a = !1);
            i.cueStartTime = e, e === t && (t += 1e-4), l >= 16 ? l-- : l++;
            const f = Hp(c.trim()), p = Bu(e, t, f);
            s != null && (d1 = s.cues) != null && d1.getCueById(p) || (o = new u(e, t, f), o.id = p, o.line = h + 1, o.align = "left", o.position = 10 + Math.min(80, Math.floor(l * 8 / 32) * 10), n1.push(o));
        }
        return s && n1.length && (n1.sort((h, f)=>h.line === "auto" || f.line === "auto" ? 0 : h.line > 8 && f.line > 8 ? f.line - h.line : h.line - f.line), n1.forEach((h)=>Up(s, h))), n1;
    }
};
function Xw() {
    if (// @ts-ignore
    self.fetch && self.AbortController && self.ReadableStream && self.Request) try {
        return new self.ReadableStream({}), !0;
    } catch  {}
    return !1;
}
const Jw = /(\d+)-(\d+)\/(\d+)/;
class lf {
    constructor(e){
        this.fetchSetup = void 0, this.requestTimeout = void 0, this.request = null, this.response = null, this.controller = void 0, this.context = null, this.config = null, this.callbacks = null, this.stats = void 0, this.loader = null, this.fetchSetup = e.fetchSetup || rA, this.controller = new self.AbortController(), this.stats = new fu();
    }
    destroy() {
        this.loader = this.callbacks = this.context = this.config = this.request = null, this.abortInternal(), this.response = null, this.fetchSetup = this.controller = this.stats = null;
    }
    abortInternal() {
        this.controller && !this.stats.loading.end && (this.stats.aborted = !0, this.controller.abort());
    }
    abort() {
        var e;
        this.abortInternal(), (e = this.callbacks) != null && e.onAbort && this.callbacks.onAbort(this.stats, this.context, this.response);
    }
    load(e, t, r) {
        const n1 = this.stats;
        if (n1.loading.start) throw new Error("Loader can only be used once.");
        n1.loading.start = self.performance.now();
        const i = Qw(e, this.controller.signal), o = e.responseType === "arraybuffer", a = o ? "byteLength" : "length", { maxTimeToFirstByteMs: l, maxLoadTimeMs: c } = t.loadPolicy;
        this.context = e, this.config = t, this.callbacks = r, this.request = this.fetchSetup(e, i), self.clearTimeout(this.requestTimeout), t.timeout = l && ue(l) ? l : c, this.requestTimeout = self.setTimeout(()=>{
            this.callbacks && (this.abortInternal(), this.callbacks.onTimeout(n1, e, this.response));
        }, t.timeout), (xi(this.request) ? this.request.then(self.fetch) : self.fetch(this.request)).then((d1)=>{
            var h;
            this.response = this.loader = d1;
            const f = Math.max(self.performance.now(), n1.loading.start);
            if (self.clearTimeout(this.requestTimeout), t.timeout = c, this.requestTimeout = self.setTimeout(()=>{
                this.callbacks && (this.abortInternal(), this.callbacks.onTimeout(n1, e, this.response));
            }, c - (f - n1.loading.start)), !d1.ok) {
                const { status: y, statusText: E } = d1;
                throw new sA(E || "fetch, bad network response", y, d1);
            }
            n1.loading.first = f, n1.total = tA(d1.headers) || n1.total;
            const p = (h = this.callbacks) == null ? void 0 : h.onProgress;
            return p && ue(t.highWaterMark) ? this.loadProgressively(d1, n1, e, t.highWaterMark, p) : o ? d1.arrayBuffer() : e.responseType === "json" ? d1.json() : d1.text();
        }).then((d1)=>{
            var h, f;
            const p = this.response;
            if (!p) throw new Error("loader destroyed");
            self.clearTimeout(this.requestTimeout), n1.loading.end = Math.max(self.performance.now(), n1.loading.first);
            const y = d1[a];
            y && (n1.loaded = n1.total = y);
            const E = {
                url: p.url,
                data: d1,
                code: p.status
            }, b = (h = this.callbacks) == null ? void 0 : h.onProgress;
            b && !ue(t.highWaterMark) && b(n1, e, d1, p), (f = this.callbacks) == null || f.onSuccess(E, n1, e, p);
        }).catch((d1)=>{
            var h;
            if (self.clearTimeout(this.requestTimeout), n1.aborted) return;
            const f = d1 && d1.code || 0, p = d1 ? d1.message : null;
            (h = this.callbacks) == null || h.onError({
                code: f,
                text: p
            }, e, d1 ? d1.details : null, n1);
        });
    }
    getCacheAge() {
        let e = null;
        if (this.response) {
            const t = this.response.headers.get("age");
            e = t ? parseFloat(t) : null;
        }
        return e;
    }
    getResponseHeader(e) {
        return this.response ? this.response.headers.get(e) : null;
    }
    loadProgressively(e, t, r, n1 = 0, i) {
        const o = new ip(), a = e.body.getReader(), l = ()=>a.read().then((c)=>{
                if (c.done) return o.dataLength && i(t, r, o.flush().buffer, e), Promise.resolve(new ArrayBuffer(0));
                const u = c.value, d1 = u.length;
                return t.loaded += d1, d1 < n1 || o.dataLength ? (o.push(u), o.dataLength >= n1 && i(t, r, o.flush().buffer, e)) : i(t, r, u.buffer, e), l();
            }).catch(()=>Promise.reject());
        return l();
    }
}
function Qw(s, e) {
    const t = {
        method: "GET",
        mode: "cors",
        credentials: "same-origin",
        signal: e,
        headers: new self.Headers(nt({}, s.headers))
    };
    return s.rangeEnd && t.headers.set("Range", "bytes=" + s.rangeStart + "-" + String(s.rangeEnd - 1)), t;
}
function eA(s) {
    const e = Jw.exec(s);
    if (e) return parseInt(e[2]) - parseInt(e[1]) + 1;
}
function tA(s) {
    const e = s.get("Content-Range");
    if (e) {
        const r = eA(e);
        if (ue(r)) return r;
    }
    const t = s.get("Content-Length");
    if (t) return parseInt(t);
}
function rA(s, e) {
    return new self.Request(s.url, e);
}
class sA extends Error {
    constructor(e, t, r){
        super(e), this.code = void 0, this.details = void 0, this.code = t, this.details = r;
    }
}
const nA = /^age:\s*[\d.]+\s*$/im;
class Zp {
    constructor(e){
        this.xhrSetup = void 0, this.requestTimeout = void 0, this.retryTimeout = void 0, this.retryDelay = void 0, this.config = null, this.callbacks = null, this.context = null, this.loader = null, this.stats = void 0, this.xhrSetup = e && e.xhrSetup || null, this.stats = new fu(), this.retryDelay = 0;
    }
    destroy() {
        this.callbacks = null, this.abortInternal(), this.loader = null, this.config = null, this.context = null, this.xhrSetup = null;
    }
    abortInternal() {
        const e = this.loader;
        self.clearTimeout(this.requestTimeout), self.clearTimeout(this.retryTimeout), e && (e.onreadystatechange = null, e.onprogress = null, e.readyState !== 4 && (this.stats.aborted = !0, e.abort()));
    }
    abort() {
        var e;
        this.abortInternal(), (e = this.callbacks) != null && e.onAbort && this.callbacks.onAbort(this.stats, this.context, this.loader);
    }
    load(e, t, r) {
        if (this.stats.loading.start) throw new Error("Loader can only be used once.");
        this.stats.loading.start = self.performance.now(), this.context = e, this.config = t, this.callbacks = r, this.loadInternal();
    }
    loadInternal() {
        const { config: e, context: t } = this;
        if (!e || !t) return;
        const r = this.loader = new self.XMLHttpRequest(), n1 = this.stats;
        n1.loading.first = 0, n1.loaded = 0, n1.aborted = !1;
        const i = this.xhrSetup;
        i ? Promise.resolve().then(()=>{
            if (!(this.loader !== r || this.stats.aborted)) return i(r, t.url);
        }).catch((o)=>{
            if (!(this.loader !== r || this.stats.aborted)) return r.open("GET", t.url, !0), i(r, t.url);
        }).then(()=>{
            this.loader !== r || this.stats.aborted || this.openAndSendXhr(r, t, e);
        }).catch((o)=>{
            var a;
            (a = this.callbacks) == null || a.onError({
                code: r.status,
                text: o.message
            }, t, r, n1);
        }) : this.openAndSendXhr(r, t, e);
    }
    openAndSendXhr(e, t, r) {
        e.readyState || e.open("GET", t.url, !0);
        const n1 = t.headers, { maxTimeToFirstByteMs: i, maxLoadTimeMs: o } = r.loadPolicy;
        if (n1) for(const a in n1)e.setRequestHeader(a, n1[a]);
        t.rangeEnd && e.setRequestHeader("Range", "bytes=" + t.rangeStart + "-" + (t.rangeEnd - 1)), e.onreadystatechange = this.readystatechange.bind(this), e.onprogress = this.loadprogress.bind(this), e.responseType = t.responseType, self.clearTimeout(this.requestTimeout), r.timeout = i && ue(i) ? i : o, this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), r.timeout), e.send();
    }
    readystatechange() {
        const { context: e, loader: t, stats: r } = this;
        if (!e || !t) return;
        const n1 = t.readyState, i = this.config;
        if (!r.aborted && n1 >= 2 && (r.loading.first === 0 && (r.loading.first = Math.max(self.performance.now(), r.loading.start), i.timeout !== i.loadPolicy.maxLoadTimeMs && (self.clearTimeout(this.requestTimeout), i.timeout = i.loadPolicy.maxLoadTimeMs, this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), i.loadPolicy.maxLoadTimeMs - (r.loading.first - r.loading.start)))), n1 === 4)) {
            self.clearTimeout(this.requestTimeout), t.onreadystatechange = null, t.onprogress = null;
            const c = t.status, u = t.responseType === "text" ? t.responseText : null;
            if (c >= 200 && c < 300) {
                const p = u ?? t.response;
                if (p != null) {
                    var o, a;
                    r.loading.end = Math.max(self.performance.now(), r.loading.first);
                    const y = t.responseType === "arraybuffer" ? p.byteLength : p.length;
                    r.loaded = r.total = y, r.bwEstimate = r.total * 8e3 / (r.loading.end - r.loading.first);
                    const E = (o = this.callbacks) == null ? void 0 : o.onProgress;
                    E && E(r, e, p, t);
                    const b = {
                        url: t.responseURL,
                        data: p,
                        code: c
                    };
                    (a = this.callbacks) == null || a.onSuccess(b, r, e, t);
                    return;
                }
            }
            const d1 = i.loadPolicy.errorRetry, h = r.retry, f = {
                url: e.url,
                data: void 0,
                code: c
            };
            if (ta(d1, h, !1, f)) this.retry(d1);
            else {
                var l;
                rt.error(`${c} while loading ${e.url}`), (l = this.callbacks) == null || l.onError({
                    code: c,
                    text: t.statusText
                }, e, t, r);
            }
        }
    }
    loadtimeout() {
        if (!this.config) return;
        const e = this.config.loadPolicy.timeoutRetry, t = this.stats.retry;
        if (ta(e, t, !0)) this.retry(e);
        else {
            var r;
            rt.warn(`timeout while loading ${(r = this.context) == null ? void 0 : r.url}`);
            const n1 = this.callbacks;
            n1 && (this.abortInternal(), n1.onTimeout(this.stats, this.context, this.loader));
        }
    }
    retry(e) {
        const { context: t, stats: r } = this;
        this.retryDelay = yu(e, r.retry), r.retry++, rt.warn(`${status ? "HTTP Status " + status : "Timeout"} while loading ${t == null ? void 0 : t.url}, retrying ${r.retry}/${e.maxNumRetry} in ${this.retryDelay}ms`), this.abortInternal(), this.loader = null, self.clearTimeout(this.retryTimeout), this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay);
    }
    loadprogress(e) {
        const t = this.stats;
        t.loaded = e.loaded, e.lengthComputable && (t.total = e.total);
    }
    getCacheAge() {
        let e = null;
        if (this.loader && nA.test(this.loader.getAllResponseHeaders())) {
            const t = this.loader.getResponseHeader("age");
            e = t ? parseFloat(t) : null;
        }
        return e;
    }
    getResponseHeader(e) {
        return this.loader && new RegExp(`^${e}:\\s*[\\d.]+\\s*$`, "im").test(this.loader.getAllResponseHeaders()) ? this.loader.getResponseHeader(e) : null;
    }
}
const iA = {
    maxTimeToFirstByteMs: 8e3,
    maxLoadTimeMs: 2e4,
    timeoutRetry: null,
    errorRetry: null
}, oA = tt(tt({
    autoStartLoad: !0,
    // used by stream-controller
    startPosition: -1,
    // used by stream-controller
    defaultAudioCodec: void 0,
    // used by stream-controller
    debug: !1,
    // used by logger
    capLevelOnFPSDrop: !1,
    // used by fps-controller
    capLevelToPlayerSize: !1,
    // used by cap-level-controller
    ignoreDevicePixelRatio: !1,
    // used by cap-level-controller
    maxDevicePixelRatio: Number.POSITIVE_INFINITY,
    // used by cap-level-controller
    preferManagedMediaSource: !0,
    initialLiveManifestSize: 1,
    // used by stream-controller
    maxBufferLength: 30,
    // used by stream-controller
    backBufferLength: 1 / 0,
    // used by buffer-controller
    frontBufferFlushThreshold: 1 / 0,
    startOnSegmentBoundary: !1,
    // used by stream-controller
    maxBufferSize: 60 * 1e3 * 1e3,
    // used by stream-controller
    maxFragLookUpTolerance: 0.25,
    // used by stream-controller
    maxBufferHole: 0.1,
    // used by stream-controller and gap-controller
    detectStallWithCurrentTimeMs: 1250,
    // used by gap-controller
    highBufferWatchdogPeriod: 2,
    // used by gap-controller
    nudgeOffset: 0.1,
    // used by gap-controller
    nudgeMaxRetry: 3,
    // used by gap-controller
    nudgeOnVideoHole: !0,
    // used by gap-controller
    liveSyncMode: "edge",
    // used by stream-controller
    liveSyncDurationCount: 3,
    // used by latency-controller
    liveSyncOnStallIncrease: 1,
    // used by latency-controller
    liveMaxLatencyDurationCount: 1 / 0,
    // used by latency-controller
    liveSyncDuration: void 0,
    // used by latency-controller
    liveMaxLatencyDuration: void 0,
    // used by latency-controller
    maxLiveSyncPlaybackRate: 1,
    // used by latency-controller
    liveDurationInfinity: !1,
    // used by buffer-controller
    /**
   * @deprecated use backBufferLength
   */ liveBackBufferLength: null,
    // used by buffer-controller
    maxMaxBufferLength: 600,
    // used by stream-controller
    enableWorker: !0,
    // used by transmuxer
    workerPath: null,
    // used by transmuxer
    enableSoftwareAES: !0,
    // used by decrypter
    startLevel: void 0,
    // used by level-controller
    startFragPrefetch: !1,
    // used by stream-controller
    fpsDroppedMonitoringPeriod: 5e3,
    // used by fps-controller
    fpsDroppedMonitoringThreshold: 0.2,
    // used by fps-controller
    appendErrorMaxRetry: 3,
    // used by buffer-controller
    ignorePlaylistParsingErrors: !1,
    loader: Zp,
    // loader: FetchLoader,
    fLoader: void 0,
    // used by fragment-loader
    pLoader: void 0,
    // used by playlist-loader
    xhrSetup: void 0,
    // used by xhr-loader
    licenseXhrSetup: void 0,
    // used by eme-controller
    licenseResponseCallback: void 0,
    // used by eme-controller
    abrController: yb,
    bufferController: l2,
    capLevelController: Du,
    errorController: bb,
    fpsController: cw,
    stretchShortVideoTrack: !1,
    // used by mp4-remuxer
    maxAudioFramesDrift: 1,
    // used by mp4-remuxer
    forceKeyFrameOnDiscontinuity: !0,
    // used by ts-demuxer
    abrEwmaFastLive: 3,
    // used by abr-controller
    abrEwmaSlowLive: 9,
    // used by abr-controller
    abrEwmaFastVoD: 3,
    // used by abr-controller
    abrEwmaSlowVoD: 9,
    // used by abr-controller
    abrEwmaDefaultEstimate: 5e5,
    // 500 kbps  // used by abr-controller
    abrEwmaDefaultEstimateMax: 5e6,
    // 5 mbps
    abrBandWidthFactor: 0.95,
    // used by abr-controller
    abrBandWidthUpFactor: 0.7,
    // used by abr-controller
    abrMaxWithRealBitrate: !1,
    // used by abr-controller
    maxStarvationDelay: 4,
    // used by abr-controller
    maxLoadingDelay: 4,
    // used by abr-controller
    minAutoBitrate: 0,
    // used by hls
    emeEnabled: !1,
    // used by eme-controller
    widevineLicenseUrl: void 0,
    // used by eme-controller
    drmSystems: {},
    // used by eme-controller
    drmSystemOptions: {},
    // used by eme-controller
    requestMediaKeySystemAccessFunc: Yg,
    // used by eme-controller
    requireKeySystemAccessOnStart: !1,
    // used by eme-controller
    testBandwidth: !0,
    progressive: !1,
    lowLatencyMode: !0,
    cmcd: void 0,
    enableDateRangeMetadataCues: !0,
    enableEmsgMetadataCues: !0,
    enableEmsgKLVMetadata: !1,
    enableID3MetadataCues: !0,
    enableInterstitialPlayback: !0,
    interstitialAppendInPlace: !0,
    interstitialLiveLookAhead: 10,
    useMediaCapabilities: !0,
    preserveManualLevelOnError: !1,
    certLoadPolicy: {
        default: iA
    },
    keyLoadPolicy: {
        default: {
            maxTimeToFirstByteMs: 8e3,
            maxLoadTimeMs: 2e4,
            timeoutRetry: {
                maxNumRetry: 1,
                retryDelayMs: 1e3,
                maxRetryDelayMs: 2e4,
                backoff: "linear"
            },
            errorRetry: {
                maxNumRetry: 8,
                retryDelayMs: 1e3,
                maxRetryDelayMs: 2e4,
                backoff: "linear"
            }
        }
    },
    manifestLoadPolicy: {
        default: {
            maxTimeToFirstByteMs: 1 / 0,
            maxLoadTimeMs: 2e4,
            timeoutRetry: {
                maxNumRetry: 2,
                retryDelayMs: 0,
                maxRetryDelayMs: 0
            },
            errorRetry: {
                maxNumRetry: 1,
                retryDelayMs: 1e3,
                maxRetryDelayMs: 8e3
            }
        }
    },
    playlistLoadPolicy: {
        default: {
            maxTimeToFirstByteMs: 1e4,
            maxLoadTimeMs: 2e4,
            timeoutRetry: {
                maxNumRetry: 2,
                retryDelayMs: 0,
                maxRetryDelayMs: 0
            },
            errorRetry: {
                maxNumRetry: 2,
                retryDelayMs: 1e3,
                maxRetryDelayMs: 8e3
            }
        }
    },
    fragLoadPolicy: {
        default: {
            maxTimeToFirstByteMs: 1e4,
            maxLoadTimeMs: 12e4,
            timeoutRetry: {
                maxNumRetry: 4,
                retryDelayMs: 0,
                maxRetryDelayMs: 0
            },
            errorRetry: {
                maxNumRetry: 6,
                retryDelayMs: 1e3,
                maxRetryDelayMs: 8e3
            }
        }
    },
    steeringManifestLoadPolicy: {
        default: {
            maxTimeToFirstByteMs: 1e4,
            maxLoadTimeMs: 2e4,
            timeoutRetry: {
                maxNumRetry: 2,
                retryDelayMs: 0,
                maxRetryDelayMs: 0
            },
            errorRetry: {
                maxNumRetry: 1,
                retryDelayMs: 1e3,
                maxRetryDelayMs: 8e3
            }
        }
    },
    interstitialAssetListLoadPolicy: {
        default: {
            maxTimeToFirstByteMs: 1e4,
            maxLoadTimeMs: 3e4,
            timeoutRetry: {
                maxNumRetry: 0,
                retryDelayMs: 0,
                maxRetryDelayMs: 0
            },
            errorRetry: {
                maxNumRetry: 0,
                retryDelayMs: 1e3,
                maxRetryDelayMs: 8e3
            }
        }
    },
    // These default settings are deprecated in favor of the above policies
    // and are maintained for backwards compatibility
    manifestLoadingTimeOut: 1e4,
    manifestLoadingMaxRetry: 1,
    manifestLoadingRetryDelay: 1e3,
    manifestLoadingMaxRetryTimeout: 64e3,
    levelLoadingTimeOut: 1e4,
    levelLoadingMaxRetry: 4,
    levelLoadingRetryDelay: 1e3,
    levelLoadingMaxRetryTimeout: 64e3,
    fragLoadingTimeOut: 2e4,
    fragLoadingMaxRetry: 6,
    fragLoadingRetryDelay: 1e3,
    fragLoadingMaxRetryTimeout: 64e3
}, aA()), {}, {
    subtitleStreamController: Sw,
    subtitleTrackController: hw,
    timelineController: Ww,
    audioStreamController: n2,
    audioTrackController: i2,
    emeController: An,
    cmcdController: iw,
    contentSteeringController: aw,
    interstitialsController: xw
});
function aA() {
    return {
        cueHandler: Zw,
        // used by timeline-controller
        enableWebVTT: !0,
        // used by timeline-controller
        enableIMSC1: !0,
        // used by timeline-controller
        enableCEA708Captions: !0,
        // used by timeline-controller
        captionsTextTrack1Label: "English",
        // used by timeline-controller
        captionsTextTrack1LanguageCode: "en",
        // used by timeline-controller
        captionsTextTrack2Label: "Spanish",
        // used by timeline-controller
        captionsTextTrack2LanguageCode: "es",
        // used by timeline-controller
        captionsTextTrack3Label: "Unknown CC",
        // used by timeline-controller
        captionsTextTrack3LanguageCode: "",
        // used by timeline-controller
        captionsTextTrack4Label: "Unknown CC",
        // used by timeline-controller
        captionsTextTrack4LanguageCode: "",
        // used by timeline-controller
        renderTextTracksNatively: !0
    };
}
function lA(s, e, t) {
    if ((e.liveSyncDurationCount || e.liveMaxLatencyDurationCount) && (e.liveSyncDuration || e.liveMaxLatencyDuration)) throw new Error("Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration");
    if (e.liveMaxLatencyDurationCount !== void 0 && (e.liveSyncDurationCount === void 0 || e.liveMaxLatencyDurationCount <= e.liveSyncDurationCount)) throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be greater than "liveSyncDurationCount"');
    if (e.liveMaxLatencyDuration !== void 0 && (e.liveSyncDuration === void 0 || e.liveMaxLatencyDuration <= e.liveSyncDuration)) throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be greater than "liveSyncDuration"');
    const r = Tc(s), n1 = [
        "manifest",
        "level",
        "frag"
    ], i = [
        "TimeOut",
        "MaxRetry",
        "RetryDelay",
        "MaxRetryTimeout"
    ];
    return n1.forEach((o)=>{
        const a = `${o === "level" ? "playlist" : o}LoadPolicy`, l = e[a] === void 0, c = [];
        i.forEach((u)=>{
            const d1 = `${o}Loading${u}`, h = e[d1];
            if (h !== void 0 && l) {
                c.push(d1);
                const f = r[a].default;
                switch(e[a] = {
                    default: f
                }, u){
                    case "TimeOut":
                        f.maxLoadTimeMs = h, f.maxTimeToFirstByteMs = h;
                        break;
                    case "MaxRetry":
                        f.errorRetry.maxNumRetry = h, f.timeoutRetry.maxNumRetry = h;
                        break;
                    case "RetryDelay":
                        f.errorRetry.retryDelayMs = h, f.timeoutRetry.retryDelayMs = h;
                        break;
                    case "MaxRetryTimeout":
                        f.errorRetry.maxRetryDelayMs = h, f.timeoutRetry.maxRetryDelayMs = h;
                        break;
                }
            }
        }), c.length && t.warn(`hls.js config: "${c.join('", "')}" setting(s) are deprecated, use "${a}": ${at(e[a])}`);
    }), tt(tt({}, r), e);
}
function Tc(s) {
    return s && typeof s == "object" ? Array.isArray(s) ? s.map(Tc) : Object.keys(s).reduce((e, t)=>(e[t] = Tc(s[t]), e), {}) : s;
}
function cA(s, e) {
    const t = s.loader;
    t !== lf && t !== Zp ? (e.log("[config]: Custom loader detected, cannot enable progressive streaming"), s.progressive = !1) : Xw() && (s.loader = lf, s.progressive = !0, s.enableSoftwareAES = !0, e.log("[config]: Progressive streaming enabled, using FetchLoader"));
}
const xo = 2, uA = 0.1, dA = 0.05, hA = 100;
class fA extends Hg {
    constructor(e, t){
        super("gap-controller", e.logger), this.hls = void 0, this.fragmentTracker = void 0, this.media = null, this.mediaSource = void 0, this.nudgeRetry = 0, this.stallReported = !1, this.stalled = null, this.moved = !1, this.seeking = !1, this.buffered = {}, this.lastCurrentTime = 0, this.ended = 0, this.waiting = 0, this.onMediaPlaying = ()=>{
            this.ended = 0, this.waiting = 0;
        }, this.onMediaWaiting = ()=>{
            var r;
            (r = this.media) != null && r.seeking || (this.waiting = self.performance.now(), this.tick());
        }, this.onMediaEnded = ()=>{
            if (this.hls) {
                var r;
                this.ended = ((r = this.media) == null ? void 0 : r.currentTime) || 1, this.hls.trigger(I.MEDIA_ENDED, {
                    stalled: !1
                });
            }
        }, this.hls = e, this.fragmentTracker = t, this.registerListeners();
    }
    registerListeners() {
        const { hls: e } = this;
        e && (e.on(I.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(I.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(I.BUFFER_APPENDED, this.onBufferAppended, this));
    }
    unregisterListeners() {
        const { hls: e } = this;
        e && (e.off(I.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(I.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(I.BUFFER_APPENDED, this.onBufferAppended, this));
    }
    destroy() {
        super.destroy(), this.unregisterListeners(), this.media = this.hls = this.fragmentTracker = null, this.mediaSource = void 0;
    }
    onMediaAttached(e, t) {
        this.setInterval(hA), this.mediaSource = t.mediaSource;
        const r = this.media = t.media;
        cr(r, "playing", this.onMediaPlaying), cr(r, "waiting", this.onMediaWaiting), cr(r, "ended", this.onMediaEnded);
    }
    onMediaDetaching(e, t) {
        this.clearInterval();
        const { media: r } = this;
        r && (pr(r, "playing", this.onMediaPlaying), pr(r, "waiting", this.onMediaWaiting), pr(r, "ended", this.onMediaEnded), this.media = null), this.mediaSource = void 0;
    }
    onBufferAppended(e, t) {
        this.buffered = t.timeRanges;
    }
    get hasBuffered() {
        return Object.keys(this.buffered).length > 0;
    }
    tick() {
        var e;
        if (!((e = this.media) != null && e.readyState) || !this.hasBuffered) return;
        const t = this.media.currentTime;
        this.poll(t, this.lastCurrentTime), this.lastCurrentTime = t;
    }
    /**
   * Checks if the playhead is stuck within a gap, and if so, attempts to free it.
   * A gap is an unbuffered range between two buffered ranges (or the start and the first buffered range).
   *
   * @param lastCurrentTime - Previously read playhead position
   */ poll(e, t) {
        var r, n1;
        const i = (r = this.hls) == null ? void 0 : r.config;
        if (!i) return;
        const o = this.media;
        if (!o) return;
        const { seeking: a } = o, l = this.seeking && !a, c = !this.seeking && a, u = o.paused && !a || o.ended || o.playbackRate === 0;
        if (this.seeking = a, e !== t) {
            t && (this.ended = 0), this.moved = !0, a || (this.nudgeRetry = 0, i.nudgeOnVideoHole && !u && e > t && this.nudgeOnVideoHole(e, t)), this.waiting === 0 && this.stallResolved(e);
            return;
        }
        if (c || l) {
            l && this.stallResolved(e);
            return;
        }
        if (u) {
            this.nudgeRetry = 0, this.stallResolved(e), !this.ended && o.ended && this.hls && (this.ended = e || 1, this.hls.trigger(I.MEDIA_ENDED, {
                stalled: !1
            }));
            return;
        }
        if (!Ce.getBuffered(o).length) {
            this.nudgeRetry = 0;
            return;
        }
        const d1 = Ce.bufferInfo(o, e, 0), h = d1.nextStart || 0, f = this.fragmentTracker;
        if (a && f && this.hls) {
            const H = cf(this.hls.inFlightFragments, e), K = d1.len > xo, j = !h || H || h - e > xo && !f.getPartialFragment(e);
            if (K || j) return;
            this.moved = !1;
        }
        const p = (n1 = this.hls) == null ? void 0 : n1.latestLevelDetails;
        if (!this.moved && this.stalled !== null && f) {
            if (!(d1.len > 0) && !h) return;
            const K = Math.max(h, d1.start || 0) - e, C = !!(p != null && p.live) ? p.targetduration * 2 : xo, k = so(e, f);
            if (K > 0 && (K <= C || k)) {
                o.paused || this._trySkipBufferHole(k);
                return;
            }
        }
        const y = i.detectStallWithCurrentTimeMs, E = self.performance.now(), b = this.waiting;
        let L = this.stalled;
        if (L === null) if (b > 0 && E - b < y) L = this.stalled = b;
        else {
            this.stalled = E;
            return;
        }
        const A = E - L;
        if (!a && (A >= y || b) && this.hls) {
            var F;
            if (((F = this.mediaSource) == null ? void 0 : F.readyState) === "ended" && !(p != null && p.live) && Math.abs(e - ((p == null ? void 0 : p.edge) || 0)) < 1) {
                if (this.ended) return;
                this.ended = e || 1, this.hls.trigger(I.MEDIA_ENDED, {
                    stalled: !0
                });
                return;
            }
            if (this._reportStall(d1), !this.media || !this.hls) return;
        }
        const M = Ce.bufferInfo(o, e, i.maxBufferHole);
        this._tryFixBufferStall(M, A, e);
    }
    stallResolved(e) {
        const t = this.stalled;
        if (t && this.hls && (this.stalled = null, this.stallReported)) {
            const r = self.performance.now() - t;
            this.log(`playback not stuck anymore @${e}, after ${Math.round(r)}ms`), this.stallReported = !1, this.waiting = 0, this.hls.trigger(I.STALL_RESOLVED, {});
        }
    }
    nudgeOnVideoHole(e, t) {
        var r;
        const n1 = this.buffered.video;
        if (this.hls && this.media && this.fragmentTracker && (r = this.buffered.audio) != null && r.length && n1 && n1.length > 1 && e > n1.end(0)) {
            const i = Ce.bufferedInfo(Ce.timeRangesToArray(this.buffered.audio), e, 0);
            if (i.len > 1 && t >= i.start) {
                const o = Ce.timeRangesToArray(n1), a = Ce.bufferedInfo(o, t, 0).bufferedIndex;
                if (a > -1 && a < o.length - 1) {
                    const l = Ce.bufferedInfo(o, e, 0).bufferedIndex, c = o[a].end, u = o[a + 1].start;
                    if ((l === -1 || l > a) && u - c < 1 && // `maxBufferHole` may be too small and setting it to 0 should not disable this feature
                    e - c < 2) {
                        const d1 = new Error(`nudging playhead to flush pipeline after video hole. currentTime: ${e} hole: ${c} -> ${u} buffered index: ${l}`);
                        this.warn(d1.message), this.media.currentTime += 1e-6;
                        let h = so(e, this.fragmentTracker);
                        h && "fragment" in h ? h = h.fragment : h || (h = void 0);
                        const f = Ce.bufferInfo(this.media, e, 0);
                        this.hls.trigger(I.ERROR, {
                            type: ve.MEDIA_ERROR,
                            details: J.BUFFER_SEEK_OVER_HOLE,
                            fatal: !1,
                            error: d1,
                            reason: d1.message,
                            frag: h,
                            buffer: f.len,
                            bufferInfo: f
                        });
                    }
                }
            }
        }
    }
    /**
   * Detects and attempts to fix known buffer stalling issues.
   * @param bufferInfo - The properties of the current buffer.
   * @param stalledDurationMs - The amount of time Hls.js has been stalling for.
   * @private
   */ _tryFixBufferStall(e, t, r) {
        var n1, i;
        const { fragmentTracker: o, media: a } = this, l = (n1 = this.hls) == null ? void 0 : n1.config;
        if (!a || !o || !l) return;
        const c = (i = this.hls) == null ? void 0 : i.latestLevelDetails, u = so(r, o);
        if ((u || c != null && c.live && r < c.fragmentStart) && (this._trySkipBufferHole(u) || !this.media)) return;
        const d1 = e.buffered, h = this.adjacentTraversal(e, r);
        (d1 && d1.length > 1 && e.len > l.maxBufferHole || e.nextStart && (e.nextStart - r < l.maxBufferHole || h)) && (t > l.highBufferWatchdogPeriod * 1e3 || this.waiting) && (this.warn("Trying to nudge playhead over buffer-hole"), this._tryNudgeBuffer(e));
    }
    adjacentTraversal(e, t) {
        const r = this.fragmentTracker, n1 = e.nextStart;
        if (r && n1) {
            const i = r.getFragAtPos(t, pe.MAIN), o = r.getFragAtPos(n1, pe.MAIN);
            if (i && o) return o.sn - i.sn < 2;
        }
        return !1;
    }
    /**
   * Triggers a BUFFER_STALLED_ERROR event, but only once per stall period.
   * @param bufferLen - The playhead distance from the end of the current buffer segment.
   * @private
   */ _reportStall(e) {
        const { hls: t, media: r, stallReported: n1, stalled: i } = this;
        if (!n1 && i !== null && r && t) {
            this.stallReported = !0;
            const o = new Error(`Playback stalling at @${r.currentTime} due to low buffer (${at(e)})`);
            this.warn(o.message), t.trigger(I.ERROR, {
                type: ve.MEDIA_ERROR,
                details: J.BUFFER_STALLED_ERROR,
                fatal: !1,
                error: o,
                buffer: e.len,
                bufferInfo: e,
                stalled: {
                    start: i
                }
            });
        }
    }
    /**
   * Attempts to fix buffer stalls by jumping over known gaps caused by partial fragments
   * @param appended - The fragment or part found at the current time (where playback is stalling).
   * @private
   */ _trySkipBufferHole(e) {
        var t;
        const { fragmentTracker: r, media: n1 } = this, i = (t = this.hls) == null ? void 0 : t.config;
        if (!n1 || !r || !i) return 0;
        const o = n1.currentTime, a = Ce.bufferInfo(n1, o, 0), l = o < a.start ? a.start : a.nextStart;
        if (l && this.hls) {
            const u = a.len <= i.maxBufferHole, d1 = a.len > 0 && a.len < 1 && n1.readyState < 3, h = l - o;
            if (h > 0 && (u || d1)) {
                if (h > i.maxBufferHole) {
                    let p = !1;
                    if (o === 0) {
                        const y = r.getAppendedFrag(0, pe.MAIN);
                        y && l < y.end && (p = !0);
                    }
                    if (!p && e) {
                        var c;
                        if (!((c = this.hls.loadLevelObj) != null && c.details) || cf(this.hls.inFlightFragments, l)) return 0;
                        let E = !1, b = e.end;
                        for(; b < l;){
                            const L = so(b, r);
                            if (L) b += L.duration;
                            else {
                                E = !0;
                                break;
                            }
                        }
                        if (E) return 0;
                    }
                }
                const f = Math.max(l + dA, o + uA);
                if (this.warn(`skipping hole, adjusting currentTime from ${o} to ${f}`), this.moved = !0, n1.currentTime = f, !(e != null && e.gap)) {
                    const p = new Error(`fragment loaded with buffer holes, seeking from ${o} to ${f}`), y = {
                        type: ve.MEDIA_ERROR,
                        details: J.BUFFER_SEEK_OVER_HOLE,
                        fatal: !1,
                        error: p,
                        reason: p.message,
                        buffer: a.len,
                        bufferInfo: a
                    };
                    e && ("fragment" in e ? y.part = e : y.frag = e), this.hls.trigger(I.ERROR, y);
                }
                return f;
            }
        }
        return 0;
    }
    /**
   * Attempts to fix buffer stalls by advancing the mediaElement's current time by a small amount.
   * @private
   */ _tryNudgeBuffer(e) {
        const { hls: t, media: r, nudgeRetry: n1 } = this, i = t == null ? void 0 : t.config;
        if (!r || !i) return 0;
        const o = r.currentTime;
        if (this.nudgeRetry++, n1 < i.nudgeMaxRetry) {
            const a = o + (n1 + 1) * i.nudgeOffset, l = new Error(`Nudging 'currentTime' from ${o} to ${a}`);
            this.warn(l.message), r.currentTime = a, t.trigger(I.ERROR, {
                type: ve.MEDIA_ERROR,
                details: J.BUFFER_NUDGE_ON_STALL,
                error: l,
                fatal: !1,
                buffer: e.len,
                bufferInfo: e
            });
        } else {
            const a = new Error(`Playhead still not moving while enough data buffered @${o} after ${i.nudgeMaxRetry} nudges`);
            this.error(a.message), t.trigger(I.ERROR, {
                type: ve.MEDIA_ERROR,
                details: J.BUFFER_STALLED_ERROR,
                error: a,
                fatal: !0,
                buffer: e.len,
                bufferInfo: e
            });
        }
    }
}
function cf(s, e) {
    const t = uf(s.main);
    if (t && t.start <= e) return t;
    const r = uf(s.audio);
    return r && r.start <= e ? r : null;
}
function uf(s) {
    if (!s) return null;
    switch(s.state){
        case ne.IDLE:
        case ne.STOPPED:
        case ne.ENDED:
        case ne.ERROR:
            return null;
    }
    return s.frag;
}
function so(s, e) {
    return e.getAppendedFrag(s, pe.MAIN) || e.getPartialFragment(s);
}
const gA = 0.25;
function wc() {
    if (!(typeof self > "u")) return self.VTTCue || self.TextTrackCue;
}
function Cl(s, e, t, r, n1) {
    let i = new s(e, t, "");
    try {
        i.value = r, n1 && (i.type = n1);
    } catch  {
        i = new s(e, t, at(n1 ? tt({
            type: n1
        }, r) : r));
    }
    return i;
}
const no = (()=>{
    const s = wc();
    try {
        s && new s(0, Number.POSITIVE_INFINITY, "");
    } catch  {
        return Number.MAX_VALUE;
    }
    return Number.POSITIVE_INFINITY;
})();
class pA {
    constructor(e){
        this.hls = void 0, this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {}, this.removeCues = !0, this.assetCue = void 0, this.onEventCueEnter = ()=>{
            this.hls && this.hls.trigger(I.EVENT_CUE_ENTER, {});
        }, this.hls = e, this._registerListeners();
    }
    destroy() {
        this._unregisterListeners(), this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {}, this.hls = this.onEventCueEnter = null;
    }
    _registerListeners() {
        const { hls: e } = this;
        e && (e.on(I.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(I.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(I.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(I.MANIFEST_LOADING, this.onManifestLoading, this), e.on(I.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), e.on(I.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(I.LEVEL_UPDATED, this.onLevelUpdated, this), e.on(I.LEVEL_PTS_UPDATED, this.onLevelPtsUpdated, this));
    }
    _unregisterListeners() {
        const { hls: e } = this;
        e && (e.off(I.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(I.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(I.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(I.MANIFEST_LOADING, this.onManifestLoading, this), e.off(I.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), e.off(I.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(I.LEVEL_UPDATED, this.onLevelUpdated, this), e.off(I.LEVEL_PTS_UPDATED, this.onLevelPtsUpdated, this));
    }
    // Add ID3 metatadata text track.
    onMediaAttaching(e, t) {
        var r;
        this.media = t.media, ((r = t.overrides) == null ? void 0 : r.cueRemoval) === !1 && (this.removeCues = !1);
    }
    onMediaAttached() {
        var e;
        const t = (e = this.hls) == null ? void 0 : e.latestLevelDetails;
        t && this.updateDateRangeCues(t);
    }
    onMediaDetaching(e, t) {
        this.media = null, !t.transferMedia && (this.id3Track && (this.removeCues && En(this.id3Track, this.onEventCueEnter), this.id3Track = null), this.dateRangeCuesAppended = {});
    }
    onManifestLoading() {
        this.dateRangeCuesAppended = {};
    }
    createTrack(e) {
        const t = this.getID3Track(e.textTracks);
        return t.mode = "hidden", t;
    }
    getID3Track(e) {
        if (this.media) {
            for(let t = 0; t < e.length; t++){
                const r = e[t];
                if (r.kind === "metadata" && r.label === "id3") return Np(r, this.media), r;
            }
            return this.media.addTextTrack("metadata", "id3");
        }
    }
    onFragParsingMetadata(e, t) {
        if (!this.media || !this.hls) return;
        const { enableEmsgMetadataCues: r, enableID3MetadataCues: n1 } = this.hls.config;
        if (!r && !n1) return;
        const { samples: i } = t;
        this.id3Track || (this.id3Track = this.createTrack(this.media));
        const o = wc();
        if (o) for(let a = 0; a < i.length; a++){
            const l = i[a].type;
            if (l === br.emsg && !r || !n1) continue;
            const c = hp(i[a].data), u = i[a].pts;
            let d1 = u + i[a].duration;
            d1 > no && (d1 = no), d1 - u <= 0 && (d1 = u + gA);
            for(let f = 0; f < c.length; f++){
                const p = c[f];
                if (!fp(p)) {
                    this.updateId3CueEnds(u, l);
                    const y = Cl(o, u, d1, p, l);
                    y && this.id3Track.addCue(y);
                }
            }
        }
    }
    updateId3CueEnds(e, t) {
        var r;
        const n1 = (r = this.id3Track) == null ? void 0 : r.cues;
        if (n1) for(let i = n1.length; i--;){
            const o = n1[i];
            o.type === t && o.startTime < e && o.endTime === no && (o.endTime = e);
        }
    }
    onBufferFlushing(e, { startOffset: t, endOffset: r, type: n1 }) {
        const { id3Track: i, hls: o } = this;
        if (!o) return;
        const { config: { enableEmsgMetadataCues: a, enableID3MetadataCues: l } } = o;
        if (i && (a || l)) {
            let c;
            n1 === "audio" ? c = (u)=>u.type === br.audioId3 && l : n1 === "video" ? c = (u)=>u.type === br.emsg && a : c = (u)=>u.type === br.audioId3 && l || u.type === br.emsg && a, Sc(i, t, r, c);
        }
    }
    onLevelUpdated(e, { details: t }) {
        this.updateDateRangeCues(t, !0);
    }
    onLevelPtsUpdated(e, t) {
        Math.abs(t.drift) > 0.01 && this.updateDateRangeCues(t.details);
    }
    updateDateRangeCues(e, t) {
        if (!this.hls || !this.media) return;
        const { assetPlayerId: r, timelineOffset: n1, enableDateRangeMetadataCues: i, interstitialsController: o } = this.hls.config;
        if (!i) return;
        const a = wc();
        if (r && n1 && !o) {
            const { fragmentStart: y, fragmentEnd: E } = e;
            let b = this.assetCue;
            b ? (b.startTime = y, b.endTime = E) : a && (b = this.assetCue = Cl(a, y, E, {
                assetPlayerId: this.hls.config.assetPlayerId
            }, "hlsjs.interstitial.asset"), b && (b.id = r, this.id3Track || (this.id3Track = this.createTrack(this.media)), this.id3Track.addCue(b), b.addEventListener("enter", this.onEventCueEnter)));
        }
        if (!e.hasProgramDateTime) return;
        const { id3Track: l } = this, { dateRanges: c } = e, u = Object.keys(c);
        let d1 = this.dateRangeCuesAppended;
        if (l && t) {
            var h;
            if ((h = l.cues) != null && h.length) {
                const y = Object.keys(d1).filter((E)=>!u.includes(E));
                for(let E = y.length; E--;){
                    var f;
                    const b = y[E], L = (f = d1[b]) == null ? void 0 : f.cues;
                    delete d1[b], L && Object.keys(L).forEach((A)=>{
                        const F = L[A];
                        if (F) {
                            F.removeEventListener("enter", this.onEventCueEnter);
                            try {
                                l.removeCue(F);
                            } catch  {}
                        }
                    });
                }
            } else d1 = this.dateRangeCuesAppended = {};
        }
        const p = e.fragments[e.fragments.length - 1];
        if (!(u.length === 0 || !ue(p == null ? void 0 : p.programDateTime))) {
            this.id3Track || (this.id3Track = this.createTrack(this.media));
            for(let y = 0; y < u.length; y++){
                const E = u[y], b = c[E], L = b.startTime, A = d1[E], F = (A == null ? void 0 : A.cues) || {};
                let M = (A == null ? void 0 : A.durationKnown) || !1, H = no;
                const { duration: K, endDate: j } = b;
                if (j && K !== null) H = L + K, M = !0;
                else if (b.endOnNext && !M) {
                    const k = u.reduce(($, W)=>{
                        if (W !== b.id) {
                            const _ = c[W];
                            if (_.class === b.class && _.startDate > b.startDate && (!$ || b.startDate < $.startDate)) return _;
                        }
                        return $;
                    }, null);
                    k && (H = k.startTime, M = !0);
                }
                const C = Object.keys(b.attr);
                for(let k = 0; k < C.length; k++){
                    const $ = C[k];
                    if (!Ob($)) continue;
                    const W = F[$];
                    if (W) M && !(A != null && A.durationKnown) ? W.endTime = H : Math.abs(W.startTime - L) > 0.01 && (W.startTime = L, W.endTime = H);
                    else if (a) {
                        let _ = b.attr[$];
                        Bb($) && (_ = Ig(_));
                        const x = Cl(a, L, H, {
                            key: $,
                            data: _
                        }, br.dateRange);
                        x && (x.id = E, this.id3Track.addCue(x), F[$] = x, o && ($ === "X-ASSET-LIST" || $ === "X-ASSET-URL") && x.addEventListener("enter", this.onEventCueEnter));
                    }
                }
                d1[E] = {
                    cues: F,
                    dateRange: b,
                    durationKnown: M
                };
            }
        }
    }
}
class mA {
    constructor(e){
        this.hls = void 0, this.config = void 0, this.media = null, this.currentTime = 0, this.stallCount = 0, this._latency = null, this._targetLatencyUpdated = !1, this.onTimeupdate = ()=>{
            const { media: t } = this, r = this.levelDetails;
            if (!t || !r) return;
            this.currentTime = t.currentTime;
            const n1 = this.computeLatency();
            if (n1 === null) return;
            this._latency = n1;
            const { lowLatencyMode: i, maxLiveSyncPlaybackRate: o } = this.config;
            if (!i || o === 1 || !r.live) return;
            const a = this.targetLatency;
            if (a === null) return;
            const l = n1 - a, c = Math.min(this.maxLatency, a + r.targetduration);
            if (l < c && l > 0.05 && this.forwardBufferLength > 1) {
                const d1 = Math.min(2, Math.max(1, o)), h = Math.round(2 / (1 + Math.exp(-0.75 * l - this.edgeStalled)) * 20) / 20, f = Math.min(d1, Math.max(1, h));
                this.changeMediaPlaybackRate(t, f);
            } else t.playbackRate !== 1 && t.playbackRate !== 0 && this.changeMediaPlaybackRate(t, 1);
        }, this.hls = e, this.config = e.config, this.registerListeners();
    }
    get levelDetails() {
        var e;
        return ((e = this.hls) == null ? void 0 : e.latestLevelDetails) || null;
    }
    get latency() {
        return this._latency || 0;
    }
    get maxLatency() {
        const { config: e } = this;
        if (e.liveMaxLatencyDuration !== void 0) return e.liveMaxLatencyDuration;
        const t = this.levelDetails;
        return t ? e.liveMaxLatencyDurationCount * t.targetduration : 0;
    }
    get targetLatency() {
        const e = this.levelDetails;
        if (e === null || this.hls === null) return null;
        const { holdBack: t, partHoldBack: r, targetduration: n1 } = e, { liveSyncDuration: i, liveSyncDurationCount: o, lowLatencyMode: a } = this.config, l = this.hls.userConfig;
        let c = a && r || t;
        (this._targetLatencyUpdated || l.liveSyncDuration || l.liveSyncDurationCount || c === 0) && (c = i !== void 0 ? i : o * n1);
        const u = n1;
        return c + Math.min(this.stallCount * this.config.liveSyncOnStallIncrease, u);
    }
    set targetLatency(e) {
        this.stallCount = 0, this.config.liveSyncDuration = e, this._targetLatencyUpdated = !0;
    }
    get liveSyncPosition() {
        const e = this.estimateLiveEdge(), t = this.targetLatency;
        if (e === null || t === null) return null;
        const r = this.levelDetails;
        if (r === null) return null;
        const n1 = r.edge, i = e - t - this.edgeStalled, o = n1 - r.totalduration, a = n1 - (this.config.lowLatencyMode && r.partTarget || r.targetduration);
        return Math.min(Math.max(o, i), a);
    }
    get drift() {
        const e = this.levelDetails;
        return e === null ? 1 : e.drift;
    }
    get edgeStalled() {
        const e = this.levelDetails;
        if (e === null) return 0;
        const t = (this.config.lowLatencyMode && e.partTarget || e.targetduration) * 3;
        return Math.max(e.age - t, 0);
    }
    get forwardBufferLength() {
        const { media: e } = this, t = this.levelDetails;
        if (!e || !t) return 0;
        const r = e.buffered.length;
        return (r ? e.buffered.end(r - 1) : t.edge) - this.currentTime;
    }
    destroy() {
        this.unregisterListeners(), this.onMediaDetaching(), this.hls = null;
    }
    registerListeners() {
        const { hls: e } = this;
        e && (e.on(I.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(I.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(I.MANIFEST_LOADING, this.onManifestLoading, this), e.on(I.LEVEL_UPDATED, this.onLevelUpdated, this), e.on(I.ERROR, this.onError, this));
    }
    unregisterListeners() {
        const { hls: e } = this;
        e && (e.off(I.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(I.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(I.MANIFEST_LOADING, this.onManifestLoading, this), e.off(I.LEVEL_UPDATED, this.onLevelUpdated, this), e.off(I.ERROR, this.onError, this));
    }
    onMediaAttached(e, t) {
        this.media = t.media, this.media.addEventListener("timeupdate", this.onTimeupdate);
    }
    onMediaDetaching() {
        this.media && (this.media.removeEventListener("timeupdate", this.onTimeupdate), this.media = null);
    }
    onManifestLoading() {
        this._latency = null, this.stallCount = 0;
    }
    onLevelUpdated(e, { details: t }) {
        t.advanced && this.onTimeupdate(), !t.live && this.media && this.media.removeEventListener("timeupdate", this.onTimeupdate);
    }
    onError(e, t) {
        var r;
        t.details === J.BUFFER_STALLED_ERROR && (this.stallCount++, this.hls && (r = this.levelDetails) != null && r.live && this.hls.logger.warn("[latency-controller]: Stall detected, adjusting target latency"));
    }
    changeMediaPlaybackRate(e, t) {
        var r, n1;
        e.playbackRate !== t && ((r = this.hls) == null || r.logger.debug(`[latency-controller]: latency=${this.latency.toFixed(3)}, targetLatency=${(n1 = this.targetLatency) == null ? void 0 : n1.toFixed(3)}, forwardBufferLength=${this.forwardBufferLength.toFixed(3)}: adjusting playback rate from ${e.playbackRate} to ${t}`), e.playbackRate = t);
    }
    estimateLiveEdge() {
        const e = this.levelDetails;
        return e === null ? null : e.edge + e.age;
    }
    computeLatency() {
        const e = this.estimateLiveEdge();
        return e === null ? null : e - this.currentTime;
    }
}
class yA extends ku {
    constructor(e, t){
        super(e, "level-controller"), this._levels = [], this._firstLevel = -1, this._maxAutoLevel = -1, this._startLevel = void 0, this.currentLevel = null, this.currentLevelIndex = -1, this.manualLevelIndex = -1, this.steering = void 0, this.onParsedComplete = void 0, this.steering = t, this._registerListeners();
    }
    _registerListeners() {
        const { hls: e } = this;
        e.on(I.MANIFEST_LOADING, this.onManifestLoading, this), e.on(I.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(I.LEVEL_LOADED, this.onLevelLoaded, this), e.on(I.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(I.FRAG_BUFFERED, this.onFragBuffered, this), e.on(I.ERROR, this.onError, this);
    }
    _unregisterListeners() {
        const { hls: e } = this;
        e.off(I.MANIFEST_LOADING, this.onManifestLoading, this), e.off(I.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(I.LEVEL_LOADED, this.onLevelLoaded, this), e.off(I.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(I.FRAG_BUFFERED, this.onFragBuffered, this), e.off(I.ERROR, this.onError, this);
    }
    destroy() {
        this._unregisterListeners(), this.steering = null, this.resetLevels(), super.destroy();
    }
    stopLoad() {
        this._levels.forEach((t)=>{
            t.loadError = 0, t.fragmentError = 0;
        }), super.stopLoad();
    }
    resetLevels() {
        this._startLevel = void 0, this.manualLevelIndex = -1, this.currentLevelIndex = -1, this.currentLevel = null, this._levels = [], this._maxAutoLevel = -1;
    }
    onManifestLoading(e, t) {
        this.resetLevels();
    }
    onManifestLoaded(e, t) {
        const r = this.hls.config.preferManagedMediaSource, n1 = [], i = {}, o = {};
        let a = !1, l = !1, c = !1;
        t.levels.forEach((u)=>{
            const d1 = u.attrs;
            let { audioCodec: h, videoCodec: f } = u;
            h && (u.audioCodec = h = Xo(h, r) || void 0), f && (f = u.videoCodec = JS(f));
            const { width: p, height: y, unknownCodecs: E } = u, b = (E == null ? void 0 : E.length) || 0;
            if (a || (a = !!(p && y)), l || (l = !!f), c || (c = !!h), b || h && !this.isAudioSupported(h) || f && !this.isVideoSupported(f)) {
                this.log(`Some or all CODECS not supported "${d1.CODECS}"`);
                return;
            }
            const { CODECS: L, "FRAME-RATE": A, "HDCP-LEVEL": F, "PATHWAY-ID": M, RESOLUTION: H, "VIDEO-RANGE": K } = d1, C = `${`${M || "."}-`}${u.bitrate}-${H}-${A}-${L}-${K}-${F}`;
            if (i[C]) if (i[C].uri !== u.url && !u.attrs["PATHWAY-ID"]) {
                const k = o[C] += 1;
                u.attrs["PATHWAY-ID"] = new Array(k + 1).join(".");
                const $ = this.createLevel(u);
                i[C] = $, n1.push($);
            } else i[C].addGroupId("audio", d1.AUDIO), i[C].addGroupId("text", d1.SUBTITLES);
            else {
                const k = this.createLevel(u);
                i[C] = k, o[C] = 1, n1.push(k);
            }
        }), this.filterAndSortMediaOptions(n1, t, a, l, c);
    }
    createLevel(e) {
        const t = new mi(e), r = e.supplemental;
        if (r != null && r.videoCodec && !this.isVideoSupported(r.videoCodec)) {
            const n1 = new Error(`SUPPLEMENTAL-CODECS not supported "${r.videoCodec}"`);
            this.log(n1.message), t.supportedResult = Fg(n1, []);
        }
        return t;
    }
    isAudioSupported(e) {
        return gi(e, "audio", this.hls.config.preferManagedMediaSource);
    }
    isVideoSupported(e) {
        return gi(e, "video", this.hls.config.preferManagedMediaSource);
    }
    filterAndSortMediaOptions(e, t, r, n1, i) {
        var o;
        let a = [], l = [], c = e;
        const u = ((o = t.stats) == null ? void 0 : o.parsing) || {};
        if ((r || n1) && i && (c = c.filter(({ videoCodec: L, videoRange: A, width: F, height: M })=>(!!L || !!(F && M)) && lb(A))), c.length === 0) {
            Promise.resolve().then(()=>{
                if (this.hls) {
                    let L = "no level with compatible codecs found in manifest", A = L;
                    t.levels.length && (A = `one or more CODECS in variant not supported: ${at(t.levels.map((M)=>M.attrs.CODECS).filter((M, H, K)=>K.indexOf(M) === H))}`, this.warn(A), L += ` (${A})`);
                    const F = new Error(L);
                    this.hls.trigger(I.ERROR, {
                        type: ve.MEDIA_ERROR,
                        details: J.MANIFEST_INCOMPATIBLE_CODECS_ERROR,
                        fatal: !0,
                        url: t.url,
                        error: F,
                        reason: A
                    });
                }
            }), u.end = performance.now();
            return;
        }
        t.audioTracks && (a = t.audioTracks.filter((L)=>!L.audioCodec || this.isAudioSupported(L.audioCodec)), df(a)), t.subtitles && (l = t.subtitles, df(l));
        const d1 = c.slice(0);
        c.sort((L, A)=>{
            if (L.attrs["HDCP-LEVEL"] !== A.attrs["HDCP-LEVEL"]) return (L.attrs["HDCP-LEVEL"] || "") > (A.attrs["HDCP-LEVEL"] || "") ? 1 : -1;
            if (r && L.height !== A.height) return L.height - A.height;
            if (L.frameRate !== A.frameRate) return L.frameRate - A.frameRate;
            if (L.videoRange !== A.videoRange) return Jo.indexOf(L.videoRange) - Jo.indexOf(A.videoRange);
            if (L.videoCodec !== A.videoCodec) {
                const F = sh(L.videoCodec), M = sh(A.videoCodec);
                if (F !== M) return M - F;
            }
            if (L.uri === A.uri && L.codecSet !== A.codecSet) {
                const F = Zo(L.codecSet), M = Zo(A.codecSet);
                if (F !== M) return M - F;
            }
            return L.averageBitrate !== A.averageBitrate ? L.averageBitrate - A.averageBitrate : 0;
        });
        let h = d1[0];
        if (this.steering && (c = this.steering.filterParsedLevels(c), c.length !== d1.length)) {
            for(let L = 0; L < d1.length; L++)if (d1[L].pathwayId === c[0].pathwayId) {
                h = d1[L];
                break;
            }
        }
        this._levels = c;
        for(let L = 0; L < c.length; L++)if (c[L] === h) {
            var f;
            this._firstLevel = L;
            const A = h.bitrate, F = this.hls.bandwidthEstimate;
            if (this.log(`manifest loaded, ${c.length} level(s) found, first bitrate: ${A}`), ((f = this.hls.userConfig) == null ? void 0 : f.abrEwmaDefaultEstimate) === void 0) {
                const M = Math.min(A, this.hls.config.abrEwmaDefaultEstimateMax);
                M > F && F === this.hls.abrEwmaDefaultEstimate && (this.hls.bandwidthEstimate = M);
            }
            break;
        }
        const p = i && !n1, y = this.hls.config, E = !!(y.audioStreamController && y.audioTrackController), b = {
            levels: c,
            audioTracks: a,
            subtitleTracks: l,
            sessionData: t.sessionData,
            sessionKeys: t.sessionKeys,
            firstLevel: this._firstLevel,
            stats: t.stats,
            audio: i,
            video: n1,
            altAudio: E && !p && a.some((L)=>!!L.url)
        };
        u.end = performance.now(), this.hls.trigger(I.MANIFEST_PARSED, b);
    }
    get levels() {
        return this._levels.length === 0 ? null : this._levels;
    }
    get loadLevelObj() {
        return this.currentLevel;
    }
    get level() {
        return this.currentLevelIndex;
    }
    set level(e) {
        const t = this._levels;
        if (t.length === 0) return;
        if (e < 0 || e >= t.length) {
            const u = new Error("invalid level idx"), d1 = e < 0;
            if (this.hls.trigger(I.ERROR, {
                type: ve.OTHER_ERROR,
                details: J.LEVEL_SWITCH_ERROR,
                level: e,
                fatal: d1,
                error: u,
                reason: u.message
            }), d1) return;
            e = Math.min(e, t.length - 1);
        }
        const r = this.currentLevelIndex, n1 = this.currentLevel, i = n1 ? n1.attrs["PATHWAY-ID"] : void 0, o = t[e], a = o.attrs["PATHWAY-ID"];
        if (this.currentLevelIndex = e, this.currentLevel = o, r === e && n1 && i === a) return;
        this.log(`Switching to level ${e} (${o.height ? o.height + "p " : ""}${o.videoRange ? o.videoRange + " " : ""}${o.codecSet ? o.codecSet + " " : ""}@${o.bitrate})${a ? " with Pathway " + a : ""} from level ${r}${i ? " with Pathway " + i : ""}`);
        const l = {
            level: e,
            attrs: o.attrs,
            details: o.details,
            bitrate: o.bitrate,
            averageBitrate: o.averageBitrate,
            maxBitrate: o.maxBitrate,
            realBitrate: o.realBitrate,
            width: o.width,
            height: o.height,
            codecSet: o.codecSet,
            audioCodec: o.audioCodec,
            videoCodec: o.videoCodec,
            audioGroups: o.audioGroups,
            subtitleGroups: o.subtitleGroups,
            loaded: o.loaded,
            loadError: o.loadError,
            fragmentError: o.fragmentError,
            name: o.name,
            id: o.id,
            uri: o.uri,
            url: o.url,
            urlId: 0,
            audioGroupIds: o.audioGroupIds,
            textGroupIds: o.textGroupIds
        };
        this.hls.trigger(I.LEVEL_SWITCHING, l);
        const c = o.details;
        if (!c || c.live) {
            const u = this.switchParams(o.uri, n1 == null ? void 0 : n1.details, c);
            this.loadPlaylist(u);
        }
    }
    get manualLevel() {
        return this.manualLevelIndex;
    }
    set manualLevel(e) {
        this.manualLevelIndex = e, this._startLevel === void 0 && (this._startLevel = e), e !== -1 && (this.level = e);
    }
    get firstLevel() {
        return this._firstLevel;
    }
    set firstLevel(e) {
        this._firstLevel = e;
    }
    get startLevel() {
        if (this._startLevel === void 0) {
            const e = this.hls.config.startLevel;
            return e !== void 0 ? e : this.hls.firstAutoLevel;
        }
        return this._startLevel;
    }
    set startLevel(e) {
        this._startLevel = e;
    }
    get pathways() {
        return this.steering ? this.steering.pathways() : [];
    }
    get pathwayPriority() {
        return this.steering ? this.steering.pathwayPriority : null;
    }
    set pathwayPriority(e) {
        if (this.steering) {
            const t = this.steering.pathways(), r = e.filter((n1)=>t.indexOf(n1) !== -1);
            if (e.length < 1) {
                this.warn(`pathwayPriority ${e} should contain at least one pathway from list: ${t}`);
                return;
            }
            this.steering.pathwayPriority = r;
        }
    }
    onError(e, t) {
        t.fatal || !t.context || t.context.type === Ke.LEVEL && t.context.level === this.level && this.checkRetry(t);
    }
    // reset errors on the successful load of a fragment
    onFragBuffered(e, { frag: t }) {
        if (t !== void 0 && t.type === pe.MAIN) {
            const r = t.elementaryStreams;
            if (!Object.keys(r).some((i)=>!!r[i])) return;
            const n1 = this._levels[t.level];
            n1 != null && n1.loadError && (this.log(`Resetting level error count of ${n1.loadError} on frag buffered`), n1.loadError = 0);
        }
    }
    onLevelLoaded(e, t) {
        var r;
        const { level: n1, details: i } = t, o = t.levelInfo;
        if (!o) {
            var a;
            this.warn(`Invalid level index ${n1}`), (a = t.deliveryDirectives) != null && a.skip && (i.deltaUpdateFailed = !0);
            return;
        }
        if (o === this.currentLevel || t.withoutMultiVariant) {
            o.fragmentError === 0 && (o.loadError = 0);
            let l = o.details;
            l === t.details && l.advanced && (l = void 0), this.playlistLoaded(n1, t, l);
        } else (r = t.deliveryDirectives) != null && r.skip && (i.deltaUpdateFailed = !0);
    }
    loadPlaylist(e) {
        super.loadPlaylist(), this.shouldLoadPlaylist(this.currentLevel) && this.scheduleLoading(this.currentLevel, e);
    }
    loadingPlaylist(e, t) {
        super.loadingPlaylist(e, t);
        const r = this.getUrlWithDirectives(e.uri, t), n1 = this.currentLevelIndex, i = e.attrs["PATHWAY-ID"], o = e.details, a = o == null ? void 0 : o.age;
        this.log(`Loading level index ${n1}${(t == null ? void 0 : t.msn) !== void 0 ? " at sn " + t.msn + " part " + t.part : ""}${i ? " Pathway " + i : ""}${a && o.live ? " age " + a.toFixed(1) + (o.type && " " + o.type || "") : ""} ${r}`), this.hls.trigger(I.LEVEL_LOADING, {
            url: r,
            level: n1,
            levelInfo: e,
            pathwayId: e.attrs["PATHWAY-ID"],
            id: 0,
            // Deprecated Level urlId
            deliveryDirectives: t || null
        });
    }
    get nextLoadLevel() {
        return this.manualLevelIndex !== -1 ? this.manualLevelIndex : this.hls.nextAutoLevel;
    }
    set nextLoadLevel(e) {
        this.level = e, this.manualLevelIndex === -1 && (this.hls.nextAutoLevel = e);
    }
    removeLevel(e) {
        var t;
        if (this._levels.length === 1) return;
        const r = this._levels.filter((i, o)=>o !== e ? !0 : (this.steering && this.steering.removeLevel(i), i === this.currentLevel && (this.currentLevel = null, this.currentLevelIndex = -1, i.details && i.details.fragments.forEach((a)=>a.level = -1)), !1));
        rp(r), this._levels = r, this.currentLevelIndex > -1 && (t = this.currentLevel) != null && t.details && (this.currentLevelIndex = this.currentLevel.details.fragments[0].level), this.manualLevelIndex > -1 && (this.manualLevelIndex = this.currentLevelIndex);
        const n1 = r.length - 1;
        this._firstLevel = Math.min(this._firstLevel, n1), this._startLevel && (this._startLevel = Math.min(this._startLevel, n1)), this.hls.trigger(I.LEVELS_UPDATED, {
            levels: r
        });
    }
    onLevelsUpdated(e, { levels: t }) {
        this._levels = t;
    }
    checkMaxAutoUpdated() {
        const { autoLevelCapping: e, maxAutoLevel: t, maxHdcpLevel: r } = this.hls;
        this._maxAutoLevel !== t && (this._maxAutoLevel = t, this.hls.trigger(I.MAX_AUTO_LEVEL_UPDATED, {
            autoLevelCapping: e,
            levels: this.levels,
            maxAutoLevel: t,
            minAutoLevel: this.hls.minAutoLevel,
            maxHdcpLevel: r
        }));
    }
}
function df(s) {
    const e = {};
    s.forEach((t)=>{
        const r = t.groupId || "";
        t.id = e[r] = e[r] || 0, e[r]++;
    });
}
function Xp() {
    return self.SourceBuffer || self.WebKitSourceBuffer;
}
function Jp() {
    if (!Ms()) return !1;
    const e = Xp();
    return !e || e.prototype && typeof e.prototype.appendBuffer == "function" && typeof e.prototype.remove == "function";
}
function vA() {
    if (!Jp()) return !1;
    const s = Ms();
    return typeof (s == null ? void 0 : s.isTypeSupported) == "function" && ([
        "avc1.42E01E,mp4a.40.2",
        "av01.0.01M.08",
        "vp09.00.50.08"
    ].some((e)=>s.isTypeSupported(pi(e, "video"))) || [
        "mp4a.40.2",
        "fLaC"
    ].some((e)=>s.isTypeSupported(pi(e, "audio"))));
}
function EA() {
    var s;
    const e = Xp();
    return typeof (e == null || (s = e.prototype) == null ? void 0 : s.changeType) == "function";
}
const xA = 100;
class SA extends Tu {
    constructor(e, t, r){
        super(e, t, r, "stream-controller", pe.MAIN), this.audioCodecSwap = !1, this.level = -1, this._forceStartLoad = !1, this._hasEnoughToStart = !1, this.altAudio = 0, this.audioOnly = !1, this.fragPlaying = null, this.fragLastKbps = 0, this.couldBacktrack = !1, this.backtrackFragment = null, this.audioCodecSwitch = !1, this.videoBuffer = null, this.onMediaPlaying = ()=>{
            this.tick();
        }, this.onMediaSeeked = ()=>{
            const n1 = this.media, i = n1 ? n1.currentTime : null;
            if (i === null || !ue(i) || (this.log(`Media seeked to ${i.toFixed(3)}`), !this.getBufferedFrag(i))) return;
            const o = this.getFwdBufferInfoAtPos(n1, i, pe.MAIN, 0);
            if (o === null || o.len === 0) {
                this.warn(`Main forward buffer length at ${i} on "seeked" event ${o ? o.len : "empty"})`);
                return;
            }
            this.tick();
        }, this.registerListeners();
    }
    registerListeners() {
        super.registerListeners();
        const { hls: e } = this;
        e.on(I.MANIFEST_PARSED, this.onManifestParsed, this), e.on(I.LEVEL_LOADING, this.onLevelLoading, this), e.on(I.LEVEL_LOADED, this.onLevelLoaded, this), e.on(I.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), e.on(I.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.on(I.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.on(I.BUFFER_CREATED, this.onBufferCreated, this), e.on(I.BUFFER_FLUSHED, this.onBufferFlushed, this), e.on(I.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(I.FRAG_BUFFERED, this.onFragBuffered, this);
    }
    unregisterListeners() {
        super.unregisterListeners();
        const { hls: e } = this;
        e.off(I.MANIFEST_PARSED, this.onManifestParsed, this), e.off(I.LEVEL_LOADED, this.onLevelLoaded, this), e.off(I.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), e.off(I.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.off(I.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.off(I.BUFFER_CREATED, this.onBufferCreated, this), e.off(I.BUFFER_FLUSHED, this.onBufferFlushed, this), e.off(I.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(I.FRAG_BUFFERED, this.onFragBuffered, this);
    }
    onHandlerDestroying() {
        this.onMediaPlaying = this.onMediaSeeked = null, this.unregisterListeners(), super.onHandlerDestroying();
    }
    startLoad(e, t) {
        if (this.levels) {
            const { lastCurrentTime: r, hls: n1 } = this;
            if (this.stopLoad(), this.setInterval(xA), this.level = -1, !this.startFragRequested) {
                let i = n1.startLevel;
                i === -1 && (n1.config.testBandwidth && this.levels.length > 1 ? (i = 0, this.bitrateTest = !0) : i = n1.firstAutoLevel), n1.nextLoadLevel = i, this.level = n1.loadLevel, this._hasEnoughToStart = !!t;
            }
            r > 0 && e === -1 && !t && (this.log(`Override startPosition with lastCurrentTime @${r.toFixed(3)}`), e = r), this.state = ne.IDLE, this.nextLoadPosition = this.lastCurrentTime = e + this.timelineOffset, this.startPosition = t ? -1 : e, this.tick();
        } else this._forceStartLoad = !0, this.state = ne.STOPPED;
    }
    stopLoad() {
        this._forceStartLoad = !1, super.stopLoad();
    }
    doTick() {
        switch(this.state){
            case ne.WAITING_LEVEL:
                {
                    const { levels: e, level: t } = this, r = e == null ? void 0 : e[t], n1 = r == null ? void 0 : r.details;
                    if (n1 && (!n1.live || this.levelLastLoaded === r && !this.waitForLive(r))) {
                        if (this.waitForCdnTuneIn(n1)) break;
                        this.state = ne.IDLE;
                        break;
                    } else if (this.hls.nextLoadLevel !== this.level) {
                        this.state = ne.IDLE;
                        break;
                    }
                    break;
                }
            case ne.FRAG_LOADING_WAITING_RETRY:
                this.checkRetryDate();
                break;
        }
        this.state === ne.IDLE && this.doTickIdle(), this.onTickEnd();
    }
    onTickEnd() {
        var e;
        super.onTickEnd(), (e = this.media) != null && e.readyState && this.media.seeking === !1 && (this.lastCurrentTime = this.media.currentTime), this.checkFragmentChanged();
    }
    doTickIdle() {
        const { hls: e, levelLastLoaded: t, levels: r, media: n1 } = this;
        if (t === null || !n1 && !this.primaryPrefetch && (this.startFragRequested || !e.config.startFragPrefetch) || this.altAudio && this.audioOnly) return;
        const i = this.buffering ? e.nextLoadLevel : e.loadLevel;
        if (!(r != null && r[i])) return;
        const o = r[i], a = this.getMainFwdBufferInfo();
        if (a === null) return;
        const l = this.getLevelDetails();
        if (l && this._streamEnded(a, l)) {
            const y = {};
            this.altAudio === 2 && (y.type = "video"), this.hls.trigger(I.BUFFER_EOS, y), this.state = ne.ENDED;
            return;
        }
        if (!this.buffering) return;
        e.loadLevel !== i && e.manualLevel === -1 && this.log(`Adapting to level ${i} from level ${this.level}`), this.level = e.nextLoadLevel = i;
        const c = o.details;
        if (!c || this.state === ne.WAITING_LEVEL || this.waitForLive(o)) {
            this.level = i, this.state = ne.WAITING_LEVEL, this.startFragRequested = !1;
            return;
        }
        const u = a.len, d1 = this.getMaxBufferLength(o.maxBitrate);
        if (u >= d1) return;
        this.backtrackFragment && this.backtrackFragment.start > a.end && (this.backtrackFragment = null);
        const h = this.backtrackFragment ? this.backtrackFragment.start : a.end;
        let f = this.getNextFragment(h, c);
        if (this.couldBacktrack && !this.fragPrevious && f && Vt(f) && this.fragmentTracker.getState(f) !== Ht.OK) {
            var p;
            const E = ((p = this.backtrackFragment) != null ? p : f).sn - c.startSN, b = c.fragments[E - 1];
            b && f.cc === b.cc && (f = b, this.fragmentTracker.removeFragment(b));
        } else this.backtrackFragment && a.len && (this.backtrackFragment = null);
        if (f && this.isLoopLoading(f, h)) {
            if (!f.gap) {
                const E = this.audioOnly && !this.altAudio ? ot.AUDIO : ot.VIDEO, b = (E === ot.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;
                b && this.afterBufferFlushed(b, E, pe.MAIN);
            }
            f = this.getNextFragmentLoopLoading(f, c, a, pe.MAIN, d1);
        }
        f && (f.initSegment && !f.initSegment.data && !this.bitrateTest && (f = f.initSegment), this.loadFragment(f, o, h));
    }
    loadFragment(e, t, r) {
        const n1 = this.fragmentTracker.getState(e);
        n1 === Ht.NOT_LOADED || n1 === Ht.PARTIAL ? Vt(e) ? this.bitrateTest ? (this.log(`Fragment ${e.sn} of level ${e.level} is being downloaded to test bitrate and will not be buffered`), this._loadBitrateTestFrag(e, t)) : super.loadFragment(e, t, r) : this._loadInitSegment(e, t) : this.clearTrackerIfNeeded(e);
    }
    getBufferedFrag(e) {
        return this.fragmentTracker.getBufferedFrag(e, pe.MAIN);
    }
    followingBufferedFrag(e) {
        return e ? this.getBufferedFrag(e.end + 0.5) : null;
    }
    /*
    on immediate level switch :
     - pause playback if playing
     - cancel any pending load request
     - and trigger a buffer flush
  */ immediateLevelSwitch() {
        this.abortCurrentFrag(), this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
    }
    /**
   * try to switch ASAP without breaking video playback:
   * in order to ensure smooth but quick level switching,
   * we need to find the next flushable buffer range
   * we should take into account new segment fetch time
   */ nextLevelSwitch() {
        const { levels: e, media: t } = this;
        if (t != null && t.readyState) {
            let r;
            const n1 = this.getAppendedFrag(t.currentTime);
            n1 && n1.start > 1 && this.flushMainBuffer(0, n1.start - 1);
            const i = this.getLevelDetails();
            if (i != null && i.live) {
                const a = this.getMainFwdBufferInfo();
                if (!a || a.len < i.targetduration * 2) return;
            }
            if (!t.paused && e) {
                const a = this.hls.nextLoadLevel, l = e[a], c = this.fragLastKbps;
                c && this.fragCurrent ? r = this.fragCurrent.duration * l.maxBitrate / (1e3 * c) + 1 : r = 0;
            } else r = 0;
            const o = this.getBufferedFrag(t.currentTime + r);
            if (o) {
                const a = this.followingBufferedFrag(o);
                if (a) {
                    this.abortCurrentFrag();
                    const l = a.maxStartPTS ? a.maxStartPTS : a.start, c = a.duration, u = Math.max(o.end, l + Math.min(Math.max(c - this.config.maxFragLookUpTolerance, c * (this.couldBacktrack ? 0.5 : 0.125)), c * (this.couldBacktrack ? 0.75 : 0.25)));
                    this.flushMainBuffer(u, Number.POSITIVE_INFINITY);
                }
            }
        }
    }
    abortCurrentFrag() {
        const e = this.fragCurrent;
        switch(this.fragCurrent = null, this.backtrackFragment = null, e && (e.abortRequests(), this.fragmentTracker.removeFragment(e)), this.state){
            case ne.KEY_LOADING:
            case ne.FRAG_LOADING:
            case ne.FRAG_LOADING_WAITING_RETRY:
            case ne.PARSING:
            case ne.PARSED:
                this.state = ne.IDLE;
                break;
        }
        this.nextLoadPosition = this.getLoadPosition();
    }
    flushMainBuffer(e, t) {
        super.flushMainBuffer(e, t, this.altAudio === 2 ? "video" : null);
    }
    onMediaAttached(e, t) {
        super.onMediaAttached(e, t);
        const r = t.media;
        cr(r, "playing", this.onMediaPlaying), cr(r, "seeked", this.onMediaSeeked);
    }
    onMediaDetaching(e, t) {
        const { media: r } = this;
        r && (pr(r, "playing", this.onMediaPlaying), pr(r, "seeked", this.onMediaSeeked)), this.videoBuffer = null, this.fragPlaying = null, super.onMediaDetaching(e, t), !t.transferMedia && (this._hasEnoughToStart = !1);
    }
    onManifestLoading() {
        super.onManifestLoading(), this.log("Trigger BUFFER_RESET"), this.hls.trigger(I.BUFFER_RESET, void 0), this.couldBacktrack = !1, this.fragLastKbps = 0, this.fragPlaying = this.backtrackFragment = null, this.altAudio = 0, this.audioOnly = !1;
    }
    onManifestParsed(e, t) {
        let r = !1, n1 = !1;
        for(let i = 0; i < t.levels.length; i++){
            const o = t.levels[i].audioCodec;
            o && (r = r || o.indexOf("mp4a.40.2") !== -1, n1 = n1 || o.indexOf("mp4a.40.5") !== -1);
        }
        this.audioCodecSwitch = r && n1 && !EA(), this.audioCodecSwitch && this.log("Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC"), this.levels = t.levels, this.startFragRequested = !1;
    }
    onLevelLoading(e, t) {
        const { levels: r } = this;
        if (!r || this.state !== ne.IDLE) return;
        const n1 = t.levelInfo;
        (!n1.details || n1.details.live && (this.levelLastLoaded !== n1 || n1.details.expired) || this.waitForCdnTuneIn(n1.details)) && (this.state = ne.WAITING_LEVEL);
    }
    onLevelLoaded(e, t) {
        var r;
        const { levels: n1, startFragRequested: i } = this, o = t.level, a = t.details, l = a.totalduration;
        if (!n1) {
            this.warn(`Levels were reset while loading level ${o}`);
            return;
        }
        this.log(`Level ${o} loaded [${a.startSN},${a.endSN}]${a.lastPartSn ? `[part-${a.lastPartSn}-${a.lastPartIndex}]` : ""}, cc [${a.startCC}, ${a.endCC}] duration:${l}`);
        const c = t.levelInfo, u = this.fragCurrent;
        u && (this.state === ne.FRAG_LOADING || this.state === ne.FRAG_LOADING_WAITING_RETRY) && u.level !== t.level && u.loader && this.abortCurrentFrag();
        let d1 = 0;
        if (a.live || (r = c.details) != null && r.live) {
            var h;
            if (this.checkLiveUpdate(a), a.deltaUpdateFailed) return;
            d1 = this.alignPlaylists(a, c.details, (h = this.levelLastLoaded) == null ? void 0 : h.details);
        }
        if (c.details = a, this.levelLastLoaded = c, i || this.setStartPosition(a, d1), this.hls.trigger(I.LEVEL_UPDATED, {
            details: a,
            level: o
        }), this.state === ne.WAITING_LEVEL) {
            if (this.waitForCdnTuneIn(a)) return;
            this.state = ne.IDLE;
        }
        i && a.live && this.synchronizeToLiveEdge(a), this.tick();
    }
    synchronizeToLiveEdge(e) {
        const { config: t, media: r } = this;
        if (!r) return;
        const n1 = this.hls.liveSyncPosition, i = this.getLoadPosition(), o = e.fragmentStart, a = e.edge, l = i >= o - t.maxFragLookUpTolerance && i <= a;
        if (n1 !== null && r.duration > n1 && (i < n1 || !l)) {
            const u = t.liveMaxLatencyDuration !== void 0 ? t.liveMaxLatencyDuration : t.liveMaxLatencyDurationCount * e.targetduration;
            if ((!l && r.readyState < 4 || i < a - u) && (this._hasEnoughToStart || (this.nextLoadPosition = n1), r.readyState)) if (this.warn(`Playback: ${i.toFixed(3)} is located too far from the end of live sliding playlist: ${a}, reset currentTime to : ${n1.toFixed(3)}`), this.config.liveSyncMode === "buffered") {
                var c;
                const d1 = Ce.bufferInfo(r, n1, 0);
                if (!((c = d1.buffered) != null && c.length)) {
                    r.currentTime = n1;
                    return;
                }
                if (d1.start <= i) {
                    r.currentTime = n1;
                    return;
                }
                const { nextStart: f } = Ce.bufferedInfo(d1.buffered, i, 0);
                f && (r.currentTime = f);
            } else r.currentTime = n1;
        }
    }
    _handleFragmentLoadProgress(e) {
        var t;
        const r = e.frag, { part: n1, payload: i } = e, { levels: o } = this;
        if (!o) {
            this.warn(`Levels were reset while fragment load was in progress. Fragment ${r.sn} of level ${r.level} will not be buffered`);
            return;
        }
        const a = o[r.level];
        if (!a) {
            this.warn(`Level ${r.level} not found on progress`);
            return;
        }
        const l = a.details;
        if (!l) {
            this.warn(`Dropping fragment ${r.sn} of level ${r.level} after level details were reset`), this.fragmentTracker.removeFragment(r);
            return;
        }
        const c = a.videoCodec, u = l.PTSKnown || !l.live, d1 = (t = r.initSegment) == null ? void 0 : t.data, h = this._getAudioCodec(a), f = this.transmuxer = this.transmuxer || new wp(this.hls, pe.MAIN, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this)), p = n1 ? n1.index : -1, y = p !== -1, E = new Eu(r.level, r.sn, r.stats.chunkCount, i.byteLength, p, y), b = this.initPTS[r.cc];
        f.push(i, d1, h, c, r, n1, l.totalduration, u, E, b);
    }
    onAudioTrackSwitching(e, t) {
        const r = this.hls, n1 = this.altAudio === 2;
        if (Qo(t.url, r)) this.altAudio = 1;
        else {
            if (this.mediaBuffer !== this.media) {
                this.log("Switching on main audio, use media.buffered to schedule main fragment loading"), this.mediaBuffer = this.media;
                const o = this.fragCurrent;
                o && (this.log("Switching to main audio track, cancel main fragment load"), o.abortRequests(), this.fragmentTracker.removeFragment(o)), this.resetTransmuxer(), this.resetLoadingState();
            } else this.audioOnly && this.resetTransmuxer();
            if (n1) {
                this.fragmentTracker.removeAllFragments(), r.once(I.BUFFER_FLUSHED, ()=>{
                    this.hls && this.hls.trigger(I.AUDIO_TRACK_SWITCHED, t);
                }), r.trigger(I.BUFFER_FLUSHING, {
                    startOffset: 0,
                    endOffset: Number.POSITIVE_INFINITY,
                    type: null
                });
                return;
            }
            r.trigger(I.AUDIO_TRACK_SWITCHED, t);
        }
    }
    onAudioTrackSwitched(e, t) {
        const r = Qo(t.url, this.hls);
        if (r) {
            const n1 = this.videoBuffer;
            n1 && this.mediaBuffer !== n1 && (this.log("Switching on alternate audio, use video.buffered to schedule main fragment loading"), this.mediaBuffer = n1);
        }
        this.altAudio = r ? 2 : 0, this.tick();
    }
    onBufferCreated(e, t) {
        const r = t.tracks;
        let n1, i, o = !1;
        for(const a in r){
            const l = r[a];
            if (l.id === "main") {
                if (i = a, n1 = l, a === "video") {
                    const c = r[a];
                    c && (this.videoBuffer = c.buffer);
                }
            } else o = !0;
        }
        o && n1 ? (this.log(`Alternate track found, use ${i}.buffered to schedule main fragment loading`), this.mediaBuffer = n1.buffer) : this.mediaBuffer = this.media;
    }
    onFragBuffered(e, t) {
        const { frag: r, part: n1 } = t, i = r.type === pe.MAIN;
        if (i) {
            if (this.fragContextChanged(r)) {
                this.warn(`Fragment ${r.sn}${n1 ? " p: " + n1.index : ""} of level ${r.level} finished buffering, but was aborted. state: ${this.state}`), this.state === ne.PARSED && (this.state = ne.IDLE);
                return;
            }
            const a = n1 ? n1.stats : r.stats;
            this.fragLastKbps = Math.round(8 * a.total / (a.buffering.end - a.loading.first)), Vt(r) && (this.fragPrevious = r), this.fragBufferedComplete(r, n1);
        }
        const o = this.media;
        o && (!this._hasEnoughToStart && Ce.getBuffered(o).length && (this._hasEnoughToStart = !0, this.seekToStartPos()), i && this.tick());
    }
    get hasEnoughToStart() {
        return this._hasEnoughToStart;
    }
    onError(e, t) {
        var r;
        if (t.fatal) {
            this.state = ne.ERROR;
            return;
        }
        switch(t.details){
            case J.FRAG_GAP:
            case J.FRAG_PARSING_ERROR:
            case J.FRAG_DECRYPT_ERROR:
            case J.FRAG_LOAD_ERROR:
            case J.FRAG_LOAD_TIMEOUT:
            case J.KEY_LOAD_ERROR:
            case J.KEY_LOAD_TIMEOUT:
                this.onFragmentOrKeyLoadError(pe.MAIN, t);
                break;
            case J.LEVEL_LOAD_ERROR:
            case J.LEVEL_LOAD_TIMEOUT:
            case J.LEVEL_PARSING_ERROR:
                !t.levelRetry && this.state === ne.WAITING_LEVEL && ((r = t.context) == null ? void 0 : r.type) === Ke.LEVEL && (this.state = ne.IDLE);
                break;
            case J.BUFFER_ADD_CODEC_ERROR:
            case J.BUFFER_APPEND_ERROR:
                if (t.parent !== "main") return;
                this.reduceLengthAndFlushBuffer(t) && this.resetLoadingState();
                break;
            case J.BUFFER_FULL_ERROR:
                if (t.parent !== "main") return;
                this.reduceLengthAndFlushBuffer(t) && (!this.config.interstitialsController && this.config.assetPlayerId ? this._hasEnoughToStart = !0 : this.flushMainBuffer(0, Number.POSITIVE_INFINITY));
                break;
            case J.INTERNAL_EXCEPTION:
                this.recoverWorkerError(t);
                break;
        }
    }
    onFragLoadEmergencyAborted() {
        this.state = ne.IDLE, this._hasEnoughToStart || (this.startFragRequested = !1, this.nextLoadPosition = this.lastCurrentTime), this.tickImmediate();
    }
    onBufferFlushed(e, { type: t }) {
        if (t !== ot.AUDIO || !this.altAudio) {
            const r = (t === ot.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;
            r && (this.afterBufferFlushed(r, t, pe.MAIN), this.tick());
        }
    }
    onLevelsUpdated(e, t) {
        this.level > -1 && this.fragCurrent && (this.level = this.fragCurrent.level, this.level === -1 && this.resetWhenMissingContext(this.fragCurrent)), this.levels = t.levels;
    }
    swapAudioCodec() {
        this.audioCodecSwap = !this.audioCodecSwap;
    }
    /**
   * Seeks to the set startPosition if not equal to the mediaElement's current time.
   */ seekToStartPos() {
        const { media: e } = this;
        if (!e) return;
        const t = e.currentTime;
        let r = this.startPosition;
        if (r >= 0 && t < r) {
            if (e.seeking) {
                this.log(`could not seek to ${r}, already seeking at ${t}`);
                return;
            }
            const n1 = this.timelineOffset;
            n1 && r && (r += n1);
            const i = this.getLevelDetails(), o = Ce.getBuffered(e), a = o.length ? o.start(0) : 0, l = a - r, c = Math.max(this.config.maxBufferHole, this.config.maxFragLookUpTolerance);
            (this.config.startOnSegmentBoundary || l > 0 && (l < c || this.loadingParts && l < 2 * ((i == null ? void 0 : i.partTarget) || 0))) && (this.log(`adjusting start position by ${l} to match buffer start`), r += l, this.startPosition = r), t < r && (this.log(`seek to target start position ${r} from current time ${t} buffer start ${a}`), e.currentTime = r);
        }
    }
    _getAudioCodec(e) {
        let t = this.config.defaultAudioCodec || e.audioCodec;
        return this.audioCodecSwap && t && (this.log("Swapping audio codec"), t.indexOf("mp4a.40.5") !== -1 ? t = "mp4a.40.2" : t = "mp4a.40.5"), t;
    }
    _loadBitrateTestFrag(e, t) {
        e.bitrateTest = !0, this._doFragLoad(e, t).then((r)=>{
            const { hls: n1 } = this, i = r == null ? void 0 : r.frag;
            if (!i || this.fragContextChanged(i)) return;
            t.fragmentError = 0, this.state = ne.IDLE, this.startFragRequested = !1, this.bitrateTest = !1;
            const o = i.stats;
            o.parsing.start = o.parsing.end = o.buffering.start = o.buffering.end = self.performance.now(), n1.trigger(I.FRAG_LOADED, r), i.bitrateTest = !1;
        }).catch((r)=>{
            this.state === ne.STOPPED || this.state === ne.ERROR || (this.warn(r), this.resetFragmentLoading(e));
        });
    }
    _handleTransmuxComplete(e) {
        const t = this.playlistType, { hls: r } = this, { remuxResult: n1, chunkMeta: i } = e, o = this.getCurrentContext(i);
        if (!o) {
            this.resetWhenMissingContext(i);
            return;
        }
        const { frag: a, part: l, level: c } = o, { video: u, text: d1, id3: h, initSegment: f } = n1, { details: p } = c, y = this.altAudio ? void 0 : n1.audio;
        if (this.fragContextChanged(a)) {
            this.fragmentTracker.removeFragment(a);
            return;
        }
        if (this.state = ne.PARSING, f) {
            const E = f.tracks;
            if (E) {
                const F = a.initSegment || a;
                if (this.unhandledEncryptionError(f, a)) return;
                this._bufferInitSegment(c, E, F, i), r.trigger(I.FRAG_PARSING_INIT_SEGMENT, {
                    frag: F,
                    id: t,
                    tracks: E
                });
            }
            const b = f.initPTS, L = f.timescale, A = this.initPTS[a.cc];
            if (ue(b) && (!A || A.baseTime !== b || A.timescale !== L)) {
                const F = f.trackId;
                this.initPTS[a.cc] = {
                    baseTime: b,
                    timescale: L,
                    trackId: F
                }, r.trigger(I.INIT_PTS_FOUND, {
                    frag: a,
                    id: t,
                    initPTS: b,
                    timescale: L,
                    trackId: F
                });
            }
        }
        if (u && p) {
            y && u.type === "audiovideo" && this.logMuxedErr(a);
            const E = p.fragments[a.sn - 1 - p.startSN], b = a.sn === p.startSN, L = !E || a.cc > E.cc;
            if (n1.independent !== !1) {
                const { startPTS: A, endPTS: F, startDTS: M, endDTS: H } = u;
                if (l) l.elementaryStreams[u.type] = {
                    startPTS: A,
                    endPTS: F,
                    startDTS: M,
                    endDTS: H
                };
                else if (u.firstKeyFrame && u.independent && i.id === 1 && !L && (this.couldBacktrack = !0), u.dropped && u.independent) {
                    const K = this.getMainFwdBufferInfo(), j = (K ? K.end : this.getLoadPosition()) + this.config.maxBufferHole, C = u.firstKeyFramePTS ? u.firstKeyFramePTS : A;
                    if (!b && j < C - this.config.maxBufferHole && !L) {
                        this.backtrack(a);
                        return;
                    } else L && (a.gap = !0);
                    a.setElementaryStreamInfo(u.type, a.start, F, a.start, H, !0);
                } else b && A - (p.appliedTimelineOffset || 0) > xo && (a.gap = !0);
                a.setElementaryStreamInfo(u.type, A, F, M, H), this.backtrackFragment && (this.backtrackFragment = a), this.bufferFragmentData(u, a, l, i, b || L);
            } else if (b || L) a.gap = !0;
            else {
                this.backtrack(a);
                return;
            }
        }
        if (y) {
            const { startPTS: E, endPTS: b, startDTS: L, endDTS: A } = y;
            l && (l.elementaryStreams[ot.AUDIO] = {
                startPTS: E,
                endPTS: b,
                startDTS: L,
                endDTS: A
            }), a.setElementaryStreamInfo(ot.AUDIO, E, b, L, A), this.bufferFragmentData(y, a, l, i);
        }
        if (p && h != null && h.samples.length) {
            const E = {
                id: t,
                frag: a,
                details: p,
                samples: h.samples
            };
            r.trigger(I.FRAG_PARSING_METADATA, E);
        }
        if (p && d1) {
            const E = {
                id: t,
                frag: a,
                details: p,
                samples: d1.samples
            };
            r.trigger(I.FRAG_PARSING_USERDATA, E);
        }
    }
    logMuxedErr(e) {
        this.warn(`${Vt(e) ? "Media" : "Init"} segment with muxed audiovideo where only video expected: ${e.url}`);
    }
    _bufferInitSegment(e, t, r, n1) {
        if (this.state !== ne.PARSING) return;
        this.audioOnly = !!t.audio && !t.video, this.altAudio && !this.audioOnly && (delete t.audio, t.audiovideo && this.logMuxedErr(r));
        const { audio: i, video: o, audiovideo: a } = t;
        if (i) {
            const c = e.audioCodec;
            let u = fo(i.codec, c);
            u === "mp4a" && (u = "mp4a.40.5");
            const d1 = navigator.userAgent.toLowerCase();
            if (this.audioCodecSwitch) {
                u && (u.indexOf("mp4a.40.5") !== -1 ? u = "mp4a.40.2" : u = "mp4a.40.5");
                const h = i.metadata;
                h && "channelCount" in h && (h.channelCount || 1) !== 1 && d1.indexOf("firefox") === -1 && (u = "mp4a.40.5");
            }
            u && u.indexOf("mp4a.40.5") !== -1 && d1.indexOf("android") !== -1 && i.container !== "audio/mpeg" && (u = "mp4a.40.2", this.log(`Android: force audio codec to ${u}`)), c && c !== u && this.log(`Swapping manifest audio codec "${c}" for "${u}"`), i.levelCodec = u, i.id = pe.MAIN, this.log(`Init audio buffer, container:${i.container}, codecs[selected/level/parsed]=[${u || ""}/${c || ""}/${i.codec}]`), delete t.audiovideo;
        }
        if (o) {
            o.levelCodec = e.videoCodec, o.id = pe.MAIN;
            const c = o.codec;
            if ((c == null ? void 0 : c.length) === 4) switch(c){
                case "hvc1":
                case "hev1":
                    o.codec = "hvc1.1.6.L120.90";
                    break;
                case "av01":
                    o.codec = "av01.0.04M.08";
                    break;
                case "avc1":
                    o.codec = "avc1.42e01e";
                    break;
            }
            this.log(`Init video buffer, container:${o.container}, codecs[level/parsed]=[${e.videoCodec || ""}/${c}]${o.codec !== c ? " parsed-corrected=" + o.codec : ""}${o.supplemental ? " supplemental=" + o.supplemental : ""}`), delete t.audiovideo;
        }
        a && (this.log(`Init audiovideo buffer, container:${a.container}, codecs[level/parsed]=[${e.codecs}/${a.codec}]`), delete t.video, delete t.audio);
        const l = Object.keys(t);
        if (l.length) {
            if (this.hls.trigger(I.BUFFER_CODECS, t), !this.hls) return;
            l.forEach((c)=>{
                const d1 = t[c].initSegment;
                d1 != null && d1.byteLength && this.hls.trigger(I.BUFFER_APPENDING, {
                    type: c,
                    data: d1,
                    frag: r,
                    part: null,
                    chunkMeta: n1,
                    parent: r.type
                });
            });
        }
        this.tickImmediate();
    }
    getMainFwdBufferInfo() {
        const e = this.mediaBuffer && this.altAudio === 2 ? this.mediaBuffer : this.media;
        return this.getFwdBufferInfo(e, pe.MAIN);
    }
    get maxBufferLength() {
        const { levels: e, level: t } = this, r = e == null ? void 0 : e[t];
        return r ? this.getMaxBufferLength(r.maxBitrate) : this.config.maxBufferLength;
    }
    backtrack(e) {
        this.couldBacktrack = !0, this.backtrackFragment = e, this.resetTransmuxer(), this.flushBufferGap(e), this.fragmentTracker.removeFragment(e), this.fragPrevious = null, this.nextLoadPosition = e.start, this.state = ne.IDLE;
    }
    checkFragmentChanged() {
        const e = this.media;
        let t = null;
        if (e && e.readyState > 1 && e.seeking === !1) {
            const r = e.currentTime;
            if (Ce.isBuffered(e, r) ? t = this.getAppendedFrag(r) : Ce.isBuffered(e, r + 0.1) && (t = this.getAppendedFrag(r + 0.1)), t) {
                this.backtrackFragment = null;
                const n1 = this.fragPlaying, i = t.level;
                (!n1 || t.sn !== n1.sn || n1.level !== i) && (this.fragPlaying = t, this.hls.trigger(I.FRAG_CHANGED, {
                    frag: t
                }), (!n1 || n1.level !== i) && this.hls.trigger(I.LEVEL_SWITCHED, {
                    level: i
                }));
            }
        }
    }
    get nextLevel() {
        const e = this.nextBufferedFrag;
        return e ? e.level : -1;
    }
    get currentFrag() {
        var e;
        if (this.fragPlaying) return this.fragPlaying;
        const t = ((e = this.media) == null ? void 0 : e.currentTime) || this.lastCurrentTime;
        return ue(t) ? this.getAppendedFrag(t) : null;
    }
    get currentProgramDateTime() {
        var e;
        const t = ((e = this.media) == null ? void 0 : e.currentTime) || this.lastCurrentTime;
        if (ue(t)) {
            const r = this.getLevelDetails(), n1 = this.currentFrag || (r ? Js(null, r.fragments, t) : null);
            if (n1) {
                const i = n1.programDateTime;
                if (i !== null) {
                    const o = i + (t - n1.start) * 1e3;
                    return new Date(o);
                }
            }
        }
        return null;
    }
    get currentLevel() {
        const e = this.currentFrag;
        return e ? e.level : -1;
    }
    get nextBufferedFrag() {
        const e = this.currentFrag;
        return e ? this.followingBufferedFrag(e) : null;
    }
    get forceStartLoad() {
        return this._forceStartLoad;
    }
}
class bA extends Rr {
    constructor(e, t){
        super("key-loader", t), this.config = void 0, this.keyIdToKeyInfo = {}, this.emeController = null, this.config = e;
    }
    abort(e) {
        for(const r in this.keyIdToKeyInfo){
            const n1 = this.keyIdToKeyInfo[r].loader;
            if (n1) {
                var t;
                if (e && e !== ((t = n1.context) == null ? void 0 : t.frag.type)) return;
                n1.abort();
            }
        }
    }
    detach() {
        for(const e in this.keyIdToKeyInfo){
            const t = this.keyIdToKeyInfo[e];
            (t.mediaKeySessionContext || t.decryptdata.isCommonEncryption) && delete this.keyIdToKeyInfo[e];
        }
    }
    destroy() {
        this.detach();
        for(const e in this.keyIdToKeyInfo){
            const t = this.keyIdToKeyInfo[e].loader;
            t && t.destroy();
        }
        this.keyIdToKeyInfo = {};
    }
    createKeyLoadError(e, t = J.KEY_LOAD_ERROR, r, n1, i) {
        return new as({
            type: ve.NETWORK_ERROR,
            details: t,
            fatal: !1,
            frag: e,
            response: i,
            error: r,
            networkDetails: n1
        });
    }
    loadClear(e, t, r) {
        if (this.emeController && this.config.emeEnabled && !this.emeController.getSelectedKeySystemFormats().length) {
            if (t.length) for(let n1 = 0, i = t.length; n1 < i; n1++){
                const o = t[n1];
                if (e.cc <= o.cc && (!Vt(e) || !Vt(o) || e.sn < o.sn) || !r && n1 == i - 1) return this.emeController.selectKeySystemFormat(o).then((a)=>{
                    if (!this.emeController) return;
                    o.setKeyFormat(a);
                    const l = po(a);
                    if (l) return this.emeController.getKeySystemAccess([
                        l
                    ]);
                });
            }
            if (this.config.requireKeySystemAccessOnStart) {
                const n1 = zn(this.config);
                if (n1.length) return this.emeController.getKeySystemAccess(n1);
            }
        }
        return null;
    }
    load(e) {
        return !e.decryptdata && e.encrypted && this.emeController && this.config.emeEnabled ? this.emeController.selectKeySystemFormat(e).then((t)=>this.loadInternal(e, t)) : this.loadInternal(e);
    }
    loadInternal(e, t) {
        var r, n1;
        t && e.setKeyFormat(t);
        const i = e.decryptdata;
        if (!i) {
            const c = new Error(t ? `Expected frag.decryptdata to be defined after setting format ${t}` : `Missing decryption data on fragment in onKeyLoading (emeEnabled with controller: ${this.emeController && this.config.emeEnabled})`);
            return Promise.reject(this.createKeyLoadError(e, J.KEY_LOAD_ERROR, c));
        }
        const o = i.uri;
        if (!o) return Promise.reject(this.createKeyLoadError(e, J.KEY_LOAD_ERROR, new Error(`Invalid key URI: "${o}"`)));
        const a = kl(i);
        let l = this.keyIdToKeyInfo[a];
        if ((r = l) != null && r.decryptdata.key) return i.key = l.decryptdata.key, Promise.resolve({
            frag: e,
            keyInfo: l
        });
        if (this.emeController && (n1 = l) != null && n1.keyLoadPromise) switch(this.emeController.getKeyStatus(l.decryptdata)){
            case "usable":
            case "usable-in-future":
                return l.keyLoadPromise.then((u)=>{
                    const { keyInfo: d1 } = u;
                    return i.key = d1.decryptdata.key, {
                        frag: e,
                        keyInfo: d1
                    };
                });
        }
        switch(this.log(`${this.keyIdToKeyInfo[a] ? "Rel" : "L"}oading${i.keyId ? " keyId: " + fr(i.keyId) : ""} URI: ${i.uri} from ${e.type} ${e.level}`), l = this.keyIdToKeyInfo[a] = {
            decryptdata: i,
            keyLoadPromise: null,
            loader: null,
            mediaKeySessionContext: null
        }, i.method){
            case "SAMPLE-AES":
            case "SAMPLE-AES-CENC":
            case "SAMPLE-AES-CTR":
                return i.keyFormat === "identity" ? this.loadKeyHTTP(l, e) : this.loadKeyEME(l, e);
            case "AES-128":
            case "AES-256":
            case "AES-256-CTR":
                return this.loadKeyHTTP(l, e);
            default:
                return Promise.reject(this.createKeyLoadError(e, J.KEY_LOAD_ERROR, new Error(`Key supplied with unsupported METHOD: "${i.method}"`)));
        }
    }
    loadKeyEME(e, t) {
        const r = {
            frag: t,
            keyInfo: e
        };
        if (this.emeController && this.config.emeEnabled) {
            const n1 = this.emeController.loadKey(r);
            return (e.keyLoadPromise = n1.then((i)=>(e.mediaKeySessionContext = i, r))).catch((i)=>{
                throw e.keyLoadPromise = null, "data" in i && (i.data.frag = t), i;
            });
        }
        return Promise.resolve(r);
    }
    loadKeyHTTP(e, t) {
        const r = this.config, n1 = r.loader, i = new n1(r);
        return t.keyLoader = e.loader = i, e.keyLoadPromise = new Promise((o, a)=>{
            const l = {
                keyInfo: e,
                frag: t,
                responseType: "arraybuffer",
                url: e.decryptdata.uri
            }, c = r.keyLoadPolicy.default, u = {
                loadPolicy: c,
                timeout: c.maxLoadTimeMs,
                maxRetry: 0,
                retryDelay: 0,
                maxRetryDelay: 0
            }, d1 = {
                onSuccess: (h, f, p, y)=>{
                    const { frag: E, keyInfo: b } = p, L = kl(b.decryptdata);
                    if (!E.decryptdata || b !== this.keyIdToKeyInfo[L]) return a(this.createKeyLoadError(E, J.KEY_LOAD_ERROR, new Error("after key load, decryptdata unset or changed"), y));
                    b.decryptdata.key = E.decryptdata.key = new Uint8Array(h.data), E.keyLoader = null, b.loader = null, o({
                        frag: E,
                        keyInfo: b
                    });
                },
                onError: (h, f, p, y)=>{
                    this.resetLoader(f), a(this.createKeyLoadError(t, J.KEY_LOAD_ERROR, new Error(`HTTP Error ${h.code} loading key ${h.text}`), p, tt({
                        url: l.url,
                        data: void 0
                    }, h)));
                },
                onTimeout: (h, f, p)=>{
                    this.resetLoader(f), a(this.createKeyLoadError(t, J.KEY_LOAD_TIMEOUT, new Error("key loading timed out"), p));
                },
                onAbort: (h, f, p)=>{
                    this.resetLoader(f), a(this.createKeyLoadError(t, J.INTERNAL_ABORTED, new Error("key loading aborted"), p));
                }
            };
            i.load(l, u, d1);
        });
    }
    resetLoader(e) {
        const { frag: t, keyInfo: r, url: n1 } = e, i = r.loader;
        t.keyLoader === i && (t.keyLoader = null, r.loader = null);
        const o = kl(r.decryptdata) || n1;
        delete this.keyIdToKeyInfo[o], i && i.destroy();
    }
}
function kl(s) {
    if (s.keyFormat !== lr.FAIRPLAY) {
        const e = s.keyId;
        if (e) return fr(e);
    }
    return s.uri;
}
function hf(s) {
    const { type: e } = s;
    switch(e){
        case Ke.AUDIO_TRACK:
            return pe.AUDIO;
        case Ke.SUBTITLE_TRACK:
            return pe.SUBTITLE;
        default:
            return pe.MAIN;
    }
}
function Dl(s, e) {
    let t = s.url;
    return (t === void 0 || t.indexOf("data:") === 0) && (t = e.url), t;
}
class TA {
    constructor(e){
        this.hls = void 0, this.loaders = /* @__PURE__ */ Object.create(null), this.variableList = null, this.onManifestLoaded = this.checkAutostartLoad, this.hls = e, this.registerListeners();
    }
    startLoad(e) {}
    stopLoad() {
        this.destroyInternalLoaders();
    }
    registerListeners() {
        const { hls: e } = this;
        e.on(I.MANIFEST_LOADING, this.onManifestLoading, this), e.on(I.LEVEL_LOADING, this.onLevelLoading, this), e.on(I.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), e.on(I.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this), e.on(I.LEVELS_UPDATED, this.onLevelsUpdated, this);
    }
    unregisterListeners() {
        const { hls: e } = this;
        e.off(I.MANIFEST_LOADING, this.onManifestLoading, this), e.off(I.LEVEL_LOADING, this.onLevelLoading, this), e.off(I.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), e.off(I.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this), e.off(I.LEVELS_UPDATED, this.onLevelsUpdated, this);
    }
    /**
   * Returns defaults or configured loader-type overloads (pLoader and loader config params)
   */ createInternalLoader(e) {
        const t = this.hls.config, r = t.pLoader, n1 = t.loader, i = r || n1, o = new i(t);
        return this.loaders[e.type] = o, o;
    }
    getInternalLoader(e) {
        return this.loaders[e.type];
    }
    resetInternalLoader(e) {
        this.loaders[e] && delete this.loaders[e];
    }
    /**
   * Call `destroy` on all internal loader instances mapped (one per context type)
   */ destroyInternalLoaders() {
        for(const e in this.loaders){
            const t = this.loaders[e];
            t && t.destroy(), this.resetInternalLoader(e);
        }
    }
    destroy() {
        this.variableList = null, this.unregisterListeners(), this.destroyInternalLoaders();
    }
    onManifestLoading(e, t) {
        const { url: r } = t;
        this.variableList = null, this.load({
            id: null,
            level: 0,
            responseType: "text",
            type: Ke.MANIFEST,
            url: r,
            deliveryDirectives: null,
            levelOrTrack: null
        });
    }
    onLevelLoading(e, t) {
        const { id: r, level: n1, pathwayId: i, url: o, deliveryDirectives: a, levelInfo: l } = t;
        this.load({
            id: r,
            level: n1,
            pathwayId: i,
            responseType: "text",
            type: Ke.LEVEL,
            url: o,
            deliveryDirectives: a,
            levelOrTrack: l
        });
    }
    onAudioTrackLoading(e, t) {
        const { id: r, groupId: n1, url: i, deliveryDirectives: o, track: a } = t;
        this.load({
            id: r,
            groupId: n1,
            level: null,
            responseType: "text",
            type: Ke.AUDIO_TRACK,
            url: i,
            deliveryDirectives: o,
            levelOrTrack: a
        });
    }
    onSubtitleTrackLoading(e, t) {
        const { id: r, groupId: n1, url: i, deliveryDirectives: o, track: a } = t;
        this.load({
            id: r,
            groupId: n1,
            level: null,
            responseType: "text",
            type: Ke.SUBTITLE_TRACK,
            url: i,
            deliveryDirectives: o,
            levelOrTrack: a
        });
    }
    onLevelsUpdated(e, t) {
        const r = this.loaders[Ke.LEVEL];
        if (r) {
            const n1 = r.context;
            n1 && !t.levels.some((i)=>i === n1.levelOrTrack) && (r.abort(), delete this.loaders[Ke.LEVEL]);
        }
    }
    load(e) {
        var t;
        const r = this.hls.config;
        let n1 = this.getInternalLoader(e);
        if (n1) {
            const c = this.hls.logger, u = n1.context;
            if (u && u.levelOrTrack === e.levelOrTrack && (u.url === e.url || u.deliveryDirectives && !e.deliveryDirectives)) {
                u.url === e.url ? c.log(`[playlist-loader]: ignore ${e.url} ongoing request`) : c.log(`[playlist-loader]: ignore ${e.url} in favor of ${u.url}`);
                return;
            }
            c.log(`[playlist-loader]: aborting previous loader for type: ${e.type}`), n1.abort();
        }
        let i;
        if (e.type === Ke.MANIFEST ? i = r.manifestLoadPolicy.default : i = nt({}, r.playlistLoadPolicy.default, {
            timeoutRetry: null,
            errorRetry: null
        }), n1 = this.createInternalLoader(e), ue((t = e.deliveryDirectives) == null ? void 0 : t.part)) {
            let c;
            if (e.type === Ke.LEVEL && e.level !== null ? c = this.hls.levels[e.level].details : e.type === Ke.AUDIO_TRACK && e.id !== null ? c = this.hls.audioTracks[e.id].details : e.type === Ke.SUBTITLE_TRACK && e.id !== null && (c = this.hls.subtitleTracks[e.id].details), c) {
                const u = c.partTarget, d1 = c.targetduration;
                if (u && d1) {
                    const h = Math.max(u * 3, d1 * 0.8) * 1e3;
                    i = nt({}, i, {
                        maxTimeToFirstByteMs: Math.min(h, i.maxTimeToFirstByteMs),
                        maxLoadTimeMs: Math.min(h, i.maxTimeToFirstByteMs)
                    });
                }
            }
        }
        const o = i.errorRetry || i.timeoutRetry || {}, a = {
            loadPolicy: i,
            timeout: i.maxLoadTimeMs,
            maxRetry: o.maxNumRetry || 0,
            retryDelay: o.retryDelayMs || 0,
            maxRetryDelay: o.maxRetryDelayMs || 0
        }, l = {
            onSuccess: (c, u, d1, h)=>{
                const f = this.getInternalLoader(d1);
                this.resetInternalLoader(d1.type);
                const p = c.data;
                u.parsing.start = performance.now(), zr.isMediaPlaylist(p) || d1.type !== Ke.MANIFEST ? this.handleTrackOrLevelPlaylist(c, u, d1, h || null, f) : this.handleMasterPlaylist(c, u, d1, h);
            },
            onError: (c, u, d1, h)=>{
                this.handleNetworkError(u, d1, !1, c, h);
            },
            onTimeout: (c, u, d1)=>{
                this.handleNetworkError(u, d1, !0, void 0, c);
            }
        };
        n1.load(e, a, l);
    }
    checkAutostartLoad() {
        if (!this.hls) return;
        const { config: { autoStartLoad: e, startPosition: t }, forceStartLoad: r } = this.hls;
        (e || r) && (this.hls.logger.log(`${e ? "auto" : "force"} startLoad with configured startPosition ${t}`), this.hls.startLoad(t));
    }
    handleMasterPlaylist(e, t, r, n1) {
        const i = this.hls, o = e.data, a = Dl(e, r), l = zr.parseMasterPlaylist(o, a);
        if (l.playlistParsingError) {
            t.parsing.end = performance.now(), this.handleManifestParsingError(e, r, l.playlistParsingError, n1, t);
            return;
        }
        const { contentSteering: c, levels: u, sessionData: d1, sessionKeys: h, startTimeOffset: f, variableList: p } = l;
        this.variableList = p, u.forEach((L)=>{
            const { unknownCodecs: A } = L;
            if (A) {
                const { preferManagedMediaSource: F } = this.hls.config;
                let { audioCodec: M, videoCodec: H } = L;
                for(let K = A.length; K--;){
                    const j = A[K];
                    gi(j, "audio", F) ? (L.audioCodec = M = M ? `${M},${j}` : j, On.audio[M.substring(0, 4)] = 2, A.splice(K, 1)) : gi(j, "video", F) && (L.videoCodec = H = H ? `${H},${j}` : j, On.video[H.substring(0, 4)] = 2, A.splice(K, 1));
                }
            }
        });
        const { AUDIO: y = [], SUBTITLES: E, "CLOSED-CAPTIONS": b } = zr.parseMasterPlaylistMedia(o, a, l);
        y.length && !y.some((A)=>!A.url) && u[0].audioCodec && !u[0].attrs.AUDIO && (this.hls.logger.log("[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one"), y.unshift({
            type: "main",
            name: "main",
            groupId: "main",
            default: !1,
            autoselect: !1,
            forced: !1,
            id: -1,
            attrs: new ft({}),
            bitrate: 0,
            url: ""
        })), i.trigger(I.MANIFEST_LOADED, {
            levels: u,
            audioTracks: y,
            subtitles: E,
            captions: b,
            contentSteering: c,
            url: a,
            stats: t,
            networkDetails: n1,
            sessionData: d1,
            sessionKeys: h,
            startTimeOffset: f,
            variableList: p
        });
    }
    handleTrackOrLevelPlaylist(e, t, r, n1, i) {
        const o = this.hls, { id: a, level: l, type: c } = r, u = Dl(e, r), d1 = ue(l) ? l : ue(a) ? a : 0, h = hf(r), f = zr.parseLevelPlaylist(e.data, u, d1, h, 0, this.variableList);
        if (c === Ke.MANIFEST) {
            const p = {
                attrs: new ft({}),
                bitrate: 0,
                details: f,
                name: "",
                url: u
            };
            f.requestScheduled = t.loading.start + Qg(f, 0), o.trigger(I.MANIFEST_LOADED, {
                levels: [
                    p
                ],
                audioTracks: [],
                url: u,
                stats: t,
                networkDetails: n1,
                sessionData: null,
                sessionKeys: null,
                contentSteering: null,
                startTimeOffset: null,
                variableList: null
            });
        }
        t.parsing.end = performance.now(), r.levelDetails = f, this.handlePlaylistLoaded(f, e, t, r, n1, i);
    }
    handleManifestParsingError(e, t, r, n1, i) {
        this.hls.trigger(I.ERROR, {
            type: ve.NETWORK_ERROR,
            details: J.MANIFEST_PARSING_ERROR,
            fatal: t.type === Ke.MANIFEST,
            url: e.url,
            err: r,
            error: r,
            reason: r.message,
            response: e,
            context: t,
            networkDetails: n1,
            stats: i
        });
    }
    handleNetworkError(e, t, r = !1, n1, i) {
        let o = `A network ${r ? "timeout" : "error" + (n1 ? " (status " + n1.code + ")" : "")} occurred while loading ${e.type}`;
        e.type === Ke.LEVEL ? o += `: ${e.level} id: ${e.id}` : (e.type === Ke.AUDIO_TRACK || e.type === Ke.SUBTITLE_TRACK) && (o += ` id: ${e.id} group-id: "${e.groupId}"`);
        const a = new Error(o);
        this.hls.logger.warn(`[playlist-loader]: ${o}`);
        let l = J.UNKNOWN, c = !1;
        const u = this.getInternalLoader(e);
        switch(e.type){
            case Ke.MANIFEST:
                l = r ? J.MANIFEST_LOAD_TIMEOUT : J.MANIFEST_LOAD_ERROR, c = !0;
                break;
            case Ke.LEVEL:
                l = r ? J.LEVEL_LOAD_TIMEOUT : J.LEVEL_LOAD_ERROR, c = !1;
                break;
            case Ke.AUDIO_TRACK:
                l = r ? J.AUDIO_TRACK_LOAD_TIMEOUT : J.AUDIO_TRACK_LOAD_ERROR, c = !1;
                break;
            case Ke.SUBTITLE_TRACK:
                l = r ? J.SUBTITLE_TRACK_LOAD_TIMEOUT : J.SUBTITLE_LOAD_ERROR, c = !1;
                break;
        }
        u && this.resetInternalLoader(e.type);
        const d1 = {
            type: ve.NETWORK_ERROR,
            details: l,
            fatal: c,
            url: e.url,
            loader: u,
            context: e,
            error: a,
            networkDetails: t,
            stats: i
        };
        if (n1) {
            const h = (t == null ? void 0 : t.url) || e.url;
            d1.response = tt({
                url: h,
                data: void 0
            }, n1);
        }
        this.hls.trigger(I.ERROR, d1);
    }
    handlePlaylistLoaded(e, t, r, n1, i, o) {
        const a = this.hls, { type: l, level: c, levelOrTrack: u, id: d1, groupId: h, deliveryDirectives: f } = n1, p = Dl(t, n1), y = hf(n1);
        let E = typeof n1.level == "number" && y === pe.MAIN ? c : void 0;
        const b = e.playlistParsingError;
        if (b) {
            if (this.hls.logger.warn(`${b} ${e.url}`), !a.config.ignorePlaylistParsingErrors) {
                a.trigger(I.ERROR, {
                    type: ve.NETWORK_ERROR,
                    details: J.LEVEL_PARSING_ERROR,
                    fatal: !1,
                    url: p,
                    error: b,
                    reason: b.message,
                    response: t,
                    context: n1,
                    level: E,
                    parent: y,
                    networkDetails: i,
                    stats: r
                });
                return;
            }
            e.playlistParsingError = null;
        }
        if (!e.fragments.length) {
            const L = e.playlistParsingError = new Error("No Segments found in Playlist");
            a.trigger(I.ERROR, {
                type: ve.NETWORK_ERROR,
                details: J.LEVEL_EMPTY_ERROR,
                fatal: !1,
                url: p,
                error: L,
                reason: L.message,
                response: t,
                context: n1,
                level: E,
                parent: y,
                networkDetails: i,
                stats: r
            });
            return;
        }
        switch(e.live && o && (o.getCacheAge && (e.ageHeader = o.getCacheAge() || 0), (!o.getCacheAge || isNaN(e.ageHeader)) && (e.ageHeader = 0)), l){
            case Ke.MANIFEST:
            case Ke.LEVEL:
                if (E) {
                    if (!u) E = 0;
                    else if (u !== a.levels[E]) {
                        const L = a.levels.indexOf(u);
                        L > -1 && (E = L);
                    }
                }
                a.trigger(I.LEVEL_LOADED, {
                    details: e,
                    levelInfo: u || a.levels[0],
                    level: E || 0,
                    id: d1 || 0,
                    stats: r,
                    networkDetails: i,
                    deliveryDirectives: f,
                    withoutMultiVariant: l === Ke.MANIFEST
                });
                break;
            case Ke.AUDIO_TRACK:
                a.trigger(I.AUDIO_TRACK_LOADED, {
                    details: e,
                    track: u,
                    id: d1 || 0,
                    groupId: h || "",
                    stats: r,
                    networkDetails: i,
                    deliveryDirectives: f
                });
                break;
            case Ke.SUBTITLE_TRACK:
                a.trigger(I.SUBTITLE_TRACK_LOADED, {
                    details: e,
                    track: u,
                    id: d1 || 0,
                    groupId: h || "",
                    stats: r,
                    networkDetails: i,
                    deliveryDirectives: f
                });
                break;
        }
    }
}
class Hr {
    /**
   * Get the video-dev/hls.js package version.
   */ static get version() {
        return vi;
    }
    /**
   * Check if the required MediaSource Extensions are available.
   */ static isMSESupported() {
        return Jp();
    }
    /**
   * Check if MediaSource Extensions are available and isTypeSupported checks pass for any baseline codecs.
   */ static isSupported() {
        return vA();
    }
    /**
   * Get the MediaSource global used for MSE playback (ManagedMediaSource, MediaSource, or WebKitMediaSource).
   */ static getMediaSource() {
        return Ms();
    }
    static get Events() {
        return I;
    }
    static get MetadataSchema() {
        return br;
    }
    static get ErrorTypes() {
        return ve;
    }
    static get ErrorDetails() {
        return J;
    }
    /**
   * Get the default configuration applied to new instances.
   */ static get DefaultConfig() {
        return Hr.defaultConfig ? Hr.defaultConfig : oA;
    }
    /**
   * Replace the default configuration applied to new instances.
   */ static set DefaultConfig(e) {
        Hr.defaultConfig = e;
    }
    /**
   * Creates an instance of an HLS client that can attach to exactly one `HTMLMediaElement`.
   * @param userConfig - Configuration options applied over `Hls.DefaultConfig`
   */ constructor(e = {}){
        this.config = void 0, this.userConfig = void 0, this.logger = void 0, this.coreComponents = void 0, this.networkControllers = void 0, this._emitter = new wu(), this._autoLevelCapping = -1, this._maxHdcpLevel = null, this.abrController = void 0, this.bufferController = void 0, this.capLevelController = void 0, this.latencyController = void 0, this.levelController = void 0, this.streamController = void 0, this.audioStreamController = void 0, this.subtititleStreamController = void 0, this.audioTrackController = void 0, this.subtitleTrackController = void 0, this.interstitialsController = void 0, this.gapController = void 0, this.emeController = void 0, this.cmcdController = void 0, this._media = null, this._url = null, this._sessionId = void 0, this.triggeringException = void 0, this.started = !1;
        const t = this.logger = RS(e.debug || !1, "Hls instance", e.assetPlayerId), r = this.config = lA(Hr.DefaultConfig, e, t);
        this.userConfig = e, r.progressive && cA(r, t);
        const { abrController: n1, bufferController: i, capLevelController: o, errorController: a, fpsController: l } = r, c = new a(this), u = this.abrController = new n1(this), d1 = new Tb(this), h = r.interstitialsController, f = h ? this.interstitialsController = new h(this, Hr) : null, p = this.bufferController = new i(this, d1), y = this.capLevelController = new o(this), E = new l(this), b = new TA(this), L = r.contentSteeringController, A = L ? new L(this) : null, F = this.levelController = new yA(this, A), M = new pA(this), H = new bA(this.config, this.logger), K = this.streamController = new SA(this, d1, H), j = this.gapController = new fA(this, d1);
        y.setStreamController(K), E.setStreamController(K);
        const C = [
            b,
            F,
            K
        ];
        f && C.splice(1, 0, f), A && C.splice(1, 0, A), this.networkControllers = C;
        const k = [
            u,
            p,
            j,
            y,
            E,
            M,
            d1
        ];
        this.audioTrackController = this.createController(r.audioTrackController, C);
        const $ = r.audioStreamController;
        $ && C.push(this.audioStreamController = new $(this, d1, H)), this.subtitleTrackController = this.createController(r.subtitleTrackController, C);
        const W = r.subtitleStreamController;
        W && C.push(this.subtititleStreamController = new W(this, d1, H)), this.createController(r.timelineController, k), H.emeController = this.emeController = this.createController(r.emeController, k), this.cmcdController = this.createController(r.cmcdController, k), this.latencyController = this.createController(mA, k), this.coreComponents = k, C.push(c);
        const _ = c.onErrorOut;
        typeof _ == "function" && this.on(I.ERROR, _, c), this.on(I.MANIFEST_LOADED, b.onManifestLoaded, b);
    }
    createController(e, t) {
        if (e) {
            const r = new e(this);
            return t && t.push(r), r;
        }
        return null;
    }
    // Delegate the EventEmitter through the public API of Hls.js
    on(e, t, r = this) {
        this._emitter.on(e, t, r);
    }
    once(e, t, r = this) {
        this._emitter.once(e, t, r);
    }
    removeAllListeners(e) {
        this._emitter.removeAllListeners(e);
    }
    off(e, t, r = this, n1) {
        this._emitter.off(e, t, r, n1);
    }
    listeners(e) {
        return this._emitter.listeners(e);
    }
    emit(e, t, r) {
        return this._emitter.emit(e, t, r);
    }
    trigger(e, t) {
        if (this.config.debug) return this.emit(e, e, t);
        try {
            return this.emit(e, e, t);
        } catch (r) {
            if (this.logger.error("An internal error happened while handling event " + e + '. Error message: "' + r.message + '". Here is a stacktrace:', r), !this.triggeringException) {
                this.triggeringException = !0;
                const n1 = e === I.ERROR;
                this.trigger(I.ERROR, {
                    type: ve.OTHER_ERROR,
                    details: J.INTERNAL_EXCEPTION,
                    fatal: n1,
                    event: e,
                    error: r
                }), this.triggeringException = !1;
            }
        }
        return !1;
    }
    listenerCount(e) {
        return this._emitter.listenerCount(e);
    }
    /**
   * Dispose of the instance
   */ destroy() {
        this.logger.log("destroy"), this.trigger(I.DESTROYING, void 0), this.detachMedia(), this.removeAllListeners(), this._autoLevelCapping = -1, this._url = null, this.networkControllers.forEach((t)=>t.destroy()), this.networkControllers.length = 0, this.coreComponents.forEach((t)=>t.destroy()), this.coreComponents.length = 0;
        const e = this.config;
        e.xhrSetup = e.fetchSetup = void 0, this.userConfig = null;
    }
    /**
   * Attaches Hls.js to a media element
   */ attachMedia(e) {
        if (!e || "media" in e && !e.media) {
            const i = new Error(`attachMedia failed: invalid argument (${e})`);
            this.trigger(I.ERROR, {
                type: ve.OTHER_ERROR,
                details: J.ATTACH_MEDIA_ERROR,
                fatal: !0,
                error: i
            });
            return;
        }
        this.logger.log("attachMedia"), this._media && (this.logger.warn("media must be detached before attaching"), this.detachMedia());
        const t = "media" in e, r = t ? e.media : e, n1 = t ? e : {
            media: r
        };
        this._media = r, this.trigger(I.MEDIA_ATTACHING, n1);
    }
    /**
   * Detach Hls.js from the media
   */ detachMedia() {
        this.logger.log("detachMedia"), this.trigger(I.MEDIA_DETACHING, {}), this._media = null;
    }
    /**
   * Detach HTMLMediaElement, MediaSource, and SourceBuffers without reset, for attaching to another instance
   */ transferMedia() {
        this._media = null;
        const e = this.bufferController.transferMedia();
        return this.trigger(I.MEDIA_DETACHING, {
            transferMedia: e
        }), e;
    }
    /**
   * Set the source URL. Can be relative or absolute.
   */ loadSource(e) {
        this.stopLoad();
        const t = this.media, r = this._url, n1 = this._url = hu.buildAbsoluteURL(self.location.href, e, {
            alwaysNormalize: !0
        });
        this._autoLevelCapping = -1, this._maxHdcpLevel = null, this.logger.log(`loadSource:${n1}`), t && r && (r !== n1 || this.bufferController.hasSourceTypes()) && (this.detachMedia(), this.attachMedia(t)), this.trigger(I.MANIFEST_LOADING, {
            url: e
        });
    }
    /**
   * Gets the currently loaded URL
   */ get url() {
        return this._url;
    }
    /**
   * Whether or not enough has been buffered to seek to start position or use `media.currentTime` to determine next load position
   */ get hasEnoughToStart() {
        return this.streamController.hasEnoughToStart;
    }
    /**
   * Get the startPosition set on startLoad(position) or on autostart with config.startPosition
   */ get startPosition() {
        return this.streamController.startPositionValue;
    }
    /**
   * Start loading data from the stream source.
   * Depending on default config, client starts loading automatically when a source is set.
   *
   * @param startPosition - Set the start position to stream from.
   * Defaults to -1 (None: starts from earliest point)
   */ startLoad(e = -1, t) {
        this.logger.log(`startLoad(${e + (t ? ", <skip seek to start>" : "")})`), this.started = !0, this.resumeBuffering();
        for(let r = 0; r < this.networkControllers.length && (this.networkControllers[r].startLoad(e, t), !(!this.started || !this.networkControllers)); r++);
    }
    /**
   * Stop loading of any stream data.
   */ stopLoad() {
        this.logger.log("stopLoad"), this.started = !1;
        for(let e = 0; e < this.networkControllers.length && (this.networkControllers[e].stopLoad(), !(this.started || !this.networkControllers)); e++);
    }
    /**
   * Returns whether loading, toggled with `startLoad()` and `stopLoad()`, is active or not`.
   */ get loadingEnabled() {
        return this.started;
    }
    /**
   * Returns state of fragment loading toggled by calling `pauseBuffering()` and `resumeBuffering()`.
   */ get bufferingEnabled() {
        return this.streamController.bufferingEnabled;
    }
    /**
   * Resumes stream controller segment loading after `pauseBuffering` has been called.
   */ resumeBuffering() {
        this.bufferingEnabled || (this.logger.log("resume buffering"), this.networkControllers.forEach((e)=>{
            e.resumeBuffering && e.resumeBuffering();
        }));
    }
    /**
   * Prevents stream controller from loading new segments until `resumeBuffering` is called.
   * This allows for media buffering to be paused without interupting playlist loading.
   */ pauseBuffering() {
        this.bufferingEnabled && (this.logger.log("pause buffering"), this.networkControllers.forEach((e)=>{
            e.pauseBuffering && e.pauseBuffering();
        }));
    }
    get inFlightFragments() {
        const e = {
            [pe.MAIN]: this.streamController.inFlightFrag
        };
        return this.audioStreamController && (e[pe.AUDIO] = this.audioStreamController.inFlightFrag), this.subtititleStreamController && (e[pe.SUBTITLE] = this.subtititleStreamController.inFlightFrag), e;
    }
    /**
   * Swap through possible audio codecs in the stream (for example to switch from stereo to 5.1)
   */ swapAudioCodec() {
        this.logger.log("swapAudioCodec"), this.streamController.swapAudioCodec();
    }
    /**
   * When the media-element fails, this allows to detach and then re-attach it
   * as one call (convenience method).
   *
   * Automatic recovery of media-errors by this process is configurable.
   */ recoverMediaError() {
        this.logger.log("recoverMediaError");
        const e = this._media, t = e == null ? void 0 : e.currentTime;
        this.detachMedia(), e && (this.attachMedia(e), t && this.startLoad(t));
    }
    removeLevel(e) {
        this.levelController.removeLevel(e);
    }
    /**
   * @returns a UUID for this player instance
   */ get sessionId() {
        let e = this._sessionId;
        return e || (e = this._sessionId = fw()), e;
    }
    /**
   * @returns an array of levels (variants) sorted by HDCP-LEVEL, RESOLUTION (height), FRAME-RATE, CODECS, VIDEO-RANGE, and BANDWIDTH
   */ get levels() {
        const e = this.levelController.levels;
        return e || [];
    }
    /**
   * @returns LevelDetails of last loaded level (variant) or `null` prior to loading a media playlist.
   */ get latestLevelDetails() {
        return this.streamController.getLevelDetails() || null;
    }
    /**
   * @returns Level object of selected level (variant) or `null` prior to selecting a level or once the level is removed.
   */ get loadLevelObj() {
        return this.levelController.loadLevelObj;
    }
    /**
   * Index of quality level (variant) currently played
   */ get currentLevel() {
        return this.streamController.currentLevel;
    }
    /**
   * Set quality level index immediately. This will flush the current buffer to replace the quality asap. That means playback will interrupt at least shortly to re-buffer and re-sync eventually. Set to -1 for automatic level selection.
   */ set currentLevel(e) {
        this.logger.log(`set currentLevel:${e}`), this.levelController.manualLevel = e, this.streamController.immediateLevelSwitch();
    }
    /**
   * Index of next quality level loaded as scheduled by stream controller.
   */ get nextLevel() {
        return this.streamController.nextLevel;
    }
    /**
   * Set quality level index for next loaded data.
   * This will switch the video quality asap, without interrupting playback.
   * May abort current loading of data, and flush parts of buffer (outside currently played fragment region).
   * @param newLevel - Pass -1 for automatic level selection
   */ set nextLevel(e) {
        this.logger.log(`set nextLevel:${e}`), this.levelController.manualLevel = e, this.streamController.nextLevelSwitch();
    }
    /**
   * Return the quality level of the currently or last (of none is loaded currently) segment
   */ get loadLevel() {
        return this.levelController.level;
    }
    /**
   * Set quality level index for next loaded data in a conservative way.
   * This will switch the quality without flushing, but interrupt current loading.
   * Thus the moment when the quality switch will appear in effect will only be after the already existing buffer.
   * @param newLevel - Pass -1 for automatic level selection
   */ set loadLevel(e) {
        this.logger.log(`set loadLevel:${e}`), this.levelController.manualLevel = e;
    }
    /**
   * get next quality level loaded
   */ get nextLoadLevel() {
        return this.levelController.nextLoadLevel;
    }
    /**
   * Set quality level of next loaded segment in a fully "non-destructive" way.
   * Same as `loadLevel` but will wait for next switch (until current loading is done).
   */ set nextLoadLevel(e) {
        this.levelController.nextLoadLevel = e;
    }
    /**
   * Return "first level": like a default level, if not set,
   * falls back to index of first level referenced in manifest
   */ get firstLevel() {
        return Math.max(this.levelController.firstLevel, this.minAutoLevel);
    }
    /**
   * Sets "first-level", see getter.
   */ set firstLevel(e) {
        this.logger.log(`set firstLevel:${e}`), this.levelController.firstLevel = e;
    }
    /**
   * Return the desired start level for the first fragment that will be loaded.
   * The default value of -1 indicates automatic start level selection.
   * Setting hls.nextAutoLevel without setting a startLevel will result in
   * the nextAutoLevel value being used for one fragment load.
   */ get startLevel() {
        const e = this.levelController.startLevel;
        return e === -1 && this.abrController.forcedAutoLevel > -1 ? this.abrController.forcedAutoLevel : e;
    }
    /**
   * set  start level (level of first fragment that will be played back)
   * if not overrided by user, first level appearing in manifest will be used as start level
   * if -1 : automatic start level selection, playback will start from level matching download bandwidth
   * (determined from download of first segment)
   */ set startLevel(e) {
        this.logger.log(`set startLevel:${e}`), e !== -1 && (e = Math.max(e, this.minAutoLevel)), this.levelController.startLevel = e;
    }
    /**
   * Whether level capping is enabled.
   * Default value is set via `config.capLevelToPlayerSize`.
   */ get capLevelToPlayerSize() {
        return this.config.capLevelToPlayerSize;
    }
    /**
   * Enables or disables level capping. If disabled after previously enabled, `nextLevelSwitch` will be immediately called.
   */ set capLevelToPlayerSize(e) {
        const t = !!e;
        t !== this.config.capLevelToPlayerSize && (t ? this.capLevelController.startCapping() : (this.capLevelController.stopCapping(), this.autoLevelCapping = -1, this.streamController.nextLevelSwitch()), this.config.capLevelToPlayerSize = t);
    }
    /**
   * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)
   */ get autoLevelCapping() {
        return this._autoLevelCapping;
    }
    /**
   * Returns the current bandwidth estimate in bits per second, when available. Otherwise, `NaN` is returned.
   */ get bandwidthEstimate() {
        const { bwEstimator: e } = this.abrController;
        return e ? e.getEstimate() : NaN;
    }
    set bandwidthEstimate(e) {
        this.abrController.resetEstimator(e);
    }
    get abrEwmaDefaultEstimate() {
        const { bwEstimator: e } = this.abrController;
        return e ? e.defaultEstimate : NaN;
    }
    /**
   * get time to first byte estimate
   * @type {number}
   */ get ttfbEstimate() {
        const { bwEstimator: e } = this.abrController;
        return e ? e.getEstimateTTFB() : NaN;
    }
    /**
   * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)
   */ set autoLevelCapping(e) {
        this._autoLevelCapping !== e && (this.logger.log(`set autoLevelCapping:${e}`), this._autoLevelCapping = e, this.levelController.checkMaxAutoUpdated());
    }
    get maxHdcpLevel() {
        return this._maxHdcpLevel;
    }
    set maxHdcpLevel(e) {
        ab(e) && this._maxHdcpLevel !== e && (this._maxHdcpLevel = e, this.levelController.checkMaxAutoUpdated());
    }
    /**
   * True when automatic level selection enabled
   */ get autoLevelEnabled() {
        return this.levelController.manualLevel === -1;
    }
    /**
   * Level set manually (if any)
   */ get manualLevel() {
        return this.levelController.manualLevel;
    }
    /**
   * min level selectable in auto mode according to config.minAutoBitrate
   */ get minAutoLevel() {
        const { levels: e, config: { minAutoBitrate: t } } = this;
        if (!e) return 0;
        const r = e.length;
        for(let n1 = 0; n1 < r; n1++)if (e[n1].maxBitrate >= t) return n1;
        return 0;
    }
    /**
   * max level selectable in auto mode according to autoLevelCapping
   */ get maxAutoLevel() {
        const { levels: e, autoLevelCapping: t, maxHdcpLevel: r } = this;
        let n1;
        if (t === -1 && e != null && e.length ? n1 = e.length - 1 : n1 = t, r) for(let i = n1; i--;){
            const o = e[i].attrs["HDCP-LEVEL"];
            if (o && o <= r) return i;
        }
        return n1;
    }
    get firstAutoLevel() {
        return this.abrController.firstAutoLevel;
    }
    /**
   * next automatically selected quality level
   */ get nextAutoLevel() {
        return this.abrController.nextAutoLevel;
    }
    /**
   * this setter is used to force next auto level.
   * this is useful to force a switch down in auto mode:
   * in case of load error on level N, hls.js can set nextAutoLevel to N-1 for example)
   * forced value is valid for one fragment. upon successful frag loading at forced level,
   * this value will be resetted to -1 by ABR controller.
   */ set nextAutoLevel(e) {
        this.abrController.nextAutoLevel = e;
    }
    /**
   * get the datetime value relative to media.currentTime for the active level Program Date Time if present
   */ get playingDate() {
        return this.streamController.currentProgramDateTime;
    }
    get mainForwardBufferInfo() {
        return this.streamController.getMainFwdBufferInfo();
    }
    get maxBufferLength() {
        return this.streamController.maxBufferLength;
    }
    /**
   * Find and select the best matching audio track, making a level switch when a Group change is necessary.
   * Updates `hls.config.audioPreference`. Returns the selected track, or null when no matching track is found.
   */ setAudioOption(e) {
        var t;
        return ((t = this.audioTrackController) == null ? void 0 : t.setAudioOption(e)) || null;
    }
    /**
   * Find and select the best matching subtitle track, making a level switch when a Group change is necessary.
   * Updates `hls.config.subtitlePreference`. Returns the selected track, or null when no matching track is found.
   */ setSubtitleOption(e) {
        var t;
        return ((t = this.subtitleTrackController) == null ? void 0 : t.setSubtitleOption(e)) || null;
    }
    /**
   * Get the complete list of audio tracks across all media groups
   */ get allAudioTracks() {
        const e = this.audioTrackController;
        return e ? e.allAudioTracks : [];
    }
    /**
   * Get the list of selectable audio tracks
   */ get audioTracks() {
        const e = this.audioTrackController;
        return e ? e.audioTracks : [];
    }
    /**
   * index of the selected audio track (index in audio track lists)
   */ get audioTrack() {
        const e = this.audioTrackController;
        return e ? e.audioTrack : -1;
    }
    /**
   * selects an audio track, based on its index in audio track lists
   */ set audioTrack(e) {
        const t = this.audioTrackController;
        t && (t.audioTrack = e);
    }
    /**
   * get the complete list of subtitle tracks across all media groups
   */ get allSubtitleTracks() {
        const e = this.subtitleTrackController;
        return e ? e.allSubtitleTracks : [];
    }
    /**
   * get alternate subtitle tracks list from playlist
   */ get subtitleTracks() {
        const e = this.subtitleTrackController;
        return e ? e.subtitleTracks : [];
    }
    /**
   * index of the selected subtitle track (index in subtitle track lists)
   */ get subtitleTrack() {
        const e = this.subtitleTrackController;
        return e ? e.subtitleTrack : -1;
    }
    get media() {
        return this._media;
    }
    /**
   * select an subtitle track, based on its index in subtitle track lists
   */ set subtitleTrack(e) {
        const t = this.subtitleTrackController;
        t && (t.subtitleTrack = e);
    }
    /**
   * Whether subtitle display is enabled or not
   */ get subtitleDisplay() {
        const e = this.subtitleTrackController;
        return e ? e.subtitleDisplay : !1;
    }
    /**
   * Enable/disable subtitle display rendering
   */ set subtitleDisplay(e) {
        const t = this.subtitleTrackController;
        t && (t.subtitleDisplay = e);
    }
    /**
   * get mode for Low-Latency HLS loading
   */ get lowLatencyMode() {
        return this.config.lowLatencyMode;
    }
    /**
   * Enable/disable Low-Latency HLS part playlist and segment loading, and start live streams at playlist PART-HOLD-BACK rather than HOLD-BACK.
   */ set lowLatencyMode(e) {
        this.config.lowLatencyMode = e;
    }
    /**
   * Position (in seconds) of live sync point (ie edge of live position minus safety delay defined by ```hls.config.liveSyncDuration```)
   * @returns null prior to loading live Playlist
   */ get liveSyncPosition() {
        return this.latencyController.liveSyncPosition;
    }
    /**
   * Estimated position (in seconds) of live edge (ie edge of live playlist plus time sync playlist advanced)
   * @returns 0 before first playlist is loaded
   */ get latency() {
        return this.latencyController.latency;
    }
    /**
   * maximum distance from the edge before the player seeks forward to ```hls.liveSyncPosition```
   * configured using ```liveMaxLatencyDurationCount``` (multiple of target duration) or ```liveMaxLatencyDuration```
   * @returns 0 before first playlist is loaded
   */ get maxLatency() {
        return this.latencyController.maxLatency;
    }
    /**
   * target distance from the edge as calculated by the latency controller
   */ get targetLatency() {
        return this.latencyController.targetLatency;
    }
    set targetLatency(e) {
        this.latencyController.targetLatency = e;
    }
    /**
   * the rate at which the edge of the current live playlist is advancing or 1 if there is none
   */ get drift() {
        return this.latencyController.drift;
    }
    /**
   * set to true when startLoad is called before MANIFEST_PARSED event
   */ get forceStartLoad() {
        return this.streamController.forceStartLoad;
    }
    /**
   * ContentSteering pathways getter
   */ get pathways() {
        return this.levelController.pathways;
    }
    /**
   * ContentSteering pathwayPriority getter/setter
   */ get pathwayPriority() {
        return this.levelController.pathwayPriority;
    }
    set pathwayPriority(e) {
        this.levelController.pathwayPriority = e;
    }
    /**
   * returns true when all SourceBuffers are buffered to the end
   */ get bufferedToEnd() {
        var e;
        return !!((e = this.bufferController) != null && e.bufferedToEnd);
    }
    /**
   * returns Interstitials Program Manager
   */ get interstitialsManager() {
        var e;
        return ((e = this.interstitialsController) == null ? void 0 : e.interstitialsManager) || null;
    }
    /**
   * returns mediaCapabilities.decodingInfo for a variant/rendition
   */ getMediaDecodingInfo(e, t = this.allAudioTracks) {
        const r = $g(t);
        return Ng(e, r, navigator.mediaCapabilities);
    }
}
Hr.defaultConfig = void 0;
const Vn = "https://sdk-api.neynar.com", wA = "https://api.allorigins.win/get", bi = "https://i.imgur.com/gxH8azy.png";
var AA = {
    SDK_VERSION: '"1.2.22"'
};
const IA = AA.SDK_VERSION, jn = async (s, e = {})=>(e.headers = {
        ...e.headers,
        "x-sdk": "react",
        "x-sdk-version": IA
    }, fetch(s, e));
async function _A({ type: s, identifier: e, viewerFid: t, client_id: r }) {
    try {
        let n1 = `${Vn}/v2/farcaster/cast?type=${s}&identifier=${e}${t ? `&viewer_fid=${t}` : ""}&client_id=${r}`;
        const o = await (await jn(n1)).json();
        return (o == null ? void 0 : o.cast) || null;
    } catch (n1) {
        return console.error("Error fetching cast by identifier", n1), null;
    }
}
const LA = ({ type: s, identifier: e, viewerFid: t, allowReactions: r = !1, renderEmbeds: n1 = !0, renderFrames: i = !1, onLikeBtnPress: o, onRecastBtnPress: a, onCommentBtnPress: l, onFrameBtnPress: c, containerStyles: u, textStyles: d1 })=>{
    var F;
    const { client_id: h } = ts(), [f, p] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].useState(null), [y, E] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].useState(!0), [b, L] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].useState(null), A = (f == null ? void 0 : f.author.fid) === t;
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].useEffect(()=>{
        s && e && (E(!0), L(null), _A({
            type: s,
            identifier: e,
            viewerFid: t,
            client_id: h
        }).then((M)=>{
            p(M);
        }).catch((M)=>{
            L(M);
        }).finally(()=>{
            E(!1);
        }));
    }, [
        s,
        e,
        t,
        h
    ]), y ? /* @__PURE__ */ q.jsx("div", {
        style: {
            padding: "20px"
        },
        children: "Loading..."
    }) : !f || b ? /* @__PURE__ */ q.jsx("div", {
        children: "Error: could not fetch cast data"
    }) : i && !c ? /* @__PURE__ */ q.jsx("div", {
        children: "Error: onFrameBtnPress must be provided when renderEmbeds is true."
    }) : /* @__PURE__ */ q.jsx(oa, {
        username: f.author.username,
        displayName: f.author.display_name,
        avatarImgUrl: f.author.pfp_url,
        text: f.text,
        hash: f.hash,
        reactions: f.reactions,
        replies: f.replies.count,
        embeds: f.embeds ?? [],
        frames: f.frames ?? [],
        renderEmbeds: n1,
        renderFrames: i,
        channel: f.channel ? {
            id: f.channel.id,
            name: f.channel.name,
            url: f.parent_url
        } : void 0,
        viewerFid: t,
        allowReactions: r,
        hasPowerBadge: f.author.power_badge,
        appAvatarImgUrl: ((F = f.app) == null ? void 0 : F.pfp_url) || null,
        isOwnProfile: A,
        containerStyles: u,
        textStyles: d1,
        onLikeBtnPress: o,
        onRecastBtnPress: a,
        onCommentBtnPress: l,
        onFrameBtnPress: c,
        timestamp: f.timestamp
    });
}, RA = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("a")({
    classes: [
        "s1uo4lx4"
    ]
}), Pl = /* @__PURE__ */ new Map(), io = /* @__PURE__ */ new Map(), ff = /* @__PURE__ */ new Map(), gf = (s)=>new Promise((e)=>setTimeout(e, s)), Qp = async (s, e = 0)=>{
    const t = new URL(s).hostname;
    if (ff.get(t)) return {
        ogImage: "",
        ogTitle: "",
        ogDescription: ""
    };
    if (Pl.has(s)) return Pl.get(s);
    if (io.has(s)) return io.get(s);
    const r = (async ()=>{
        try {
            await gf(100);
            const n1 = await fetch(`${wA}?url=${encodeURIComponent(s)}`, {
                method: "GET"
            });
            if (!n1.ok) {
                if (n1.status === 429 && e < 5) {
                    const E = Math.pow(2, e) * 1e3;
                    return await gf(E), Qp(s, e + 1);
                }
                throw ff.set(t, !0), new Error(`Failed to fetch Open Graph data: ${n1.statusText}`);
            }
            const i = await n1.json(), a = new DOMParser().parseFromString(i.contents, "text/html"), l = a.querySelector('meta[property="og:image"]'), c = a.querySelector('meta[property="og:title"]'), u = a.querySelector('meta[property="og:description"]'), d1 = a.querySelector("title"), h = l && l.getAttribute("content") || "", f = c ? c.getAttribute("content") || "" : d1 ? d1.innerText : "", p = u && u.getAttribute("content") || "", y = {
                ogImage: h,
                ogTitle: f,
                ogDescription: p
            };
            return Pl.set(s, y), y;
        } catch (n1) {
            return console.error("Error fetching Open Graph data", n1), {
                ogImage: "",
                ogTitle: "",
                ogDescription: ""
            };
        } finally{
            io.delete(s);
        }
    })();
    return io.set(s, r), r;
}, Ac = [];
let Ml = 0;
const CA = 5, kA = (s)=>{
    Ac.push(s), em();
}, em = async ()=>{
    if (Ml >= CA || Ac.length === 0) return;
    Ml++;
    const s = Ac.shift();
    s && await s(), Ml--, em();
}, DA = ({ src: s, alt: e, style: t })=>/* @__PURE__ */ q.jsx("img", {
        src: s,
        alt: e,
        style: {
            display: "block",
            height: "auto",
            maxHeight: "150px",
            width: "auto",
            maxWidth: "100%",
            objectFit: "cover",
            border: "1px solid grey",
            borderRadius: "10px",
            margin: "4px 0",
            ...t
        }
    }), PA = ({ url: s })=>{
    const e = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].useRef(null);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].useEffect(()=>{
        if (e.current) if (Hr.isSupported() && s.endsWith(".m3u8")) {
            const t = new Hr();
            t.loadSource(s), t.attachMedia(e.current), t.on(Hr.Events.MANIFEST_PARSED, ()=>{
                e.current.play();
            });
        } else e.current.src = s, e.current.addEventListener("loadedmetadata", ()=>{
            e.current.play();
        });
    }, [
        s
    ]), /* @__PURE__ */ q.jsx("video", {
        ref: e,
        controls: !0,
        muted: !0,
        style: {
            width: "auto",
            maxWidth: "100%",
            maxHeight: "400px",
            borderRadius: "10px",
            margin: "10px 0",
            objectFit: "contain"
        }
    });
}, MA = (s)=>/\.(jpeg|jpg|gif|png|webp|bmp|svg)$/.test(s) || s.startsWith("https://imagedelivery.net"), OA = (s, e, t)=>{
    const [r, n1] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].useState([]), i = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].useCallback(async (o)=>(await Promise.all(o.map(async (l)=>{
            if (l.url) {
                const c = l.url;
                return MA(c) ? /* @__PURE__ */ q.jsx(DA, {
                    src: c,
                    alt: "Embedded image"
                }, c) : c.endsWith(".m3u8") || c.endsWith(".mp4") ? /* @__PURE__ */ q.jsx(PA, {
                    url: c
                }, c) : new Promise((u)=>{
                    kA(async ()=>{
                        const { ogImage: d1, ogTitle: h } = await Qp(c), f = new URL(c).hostname.replace("www.", "");
                        u(/* @__PURE__ */ q.jsxs(RA, {
                            href: c,
                            target: "_blank",
                            rel: "noreferrer",
                            children: [
                                d1 && /* @__PURE__ */ q.jsx("img", {
                                    src: d1,
                                    alt: h,
                                    style: {
                                        width: "50px",
                                        height: "50px",
                                        objectFit: "cover",
                                        borderRadius: "5px"
                                    }
                                }),
                                /* @__PURE__ */ q.jsxs("div", {
                                    style: {
                                        display: "flex",
                                        flexDirection: "column"
                                    },
                                    children: [
                                        /* @__PURE__ */ q.jsx("p", {
                                            style: {
                                                margin: 0
                                            },
                                            children: h || c
                                        }),
                                        /* @__PURE__ */ q.jsx("p", {
                                            style: {
                                                margin: 0,
                                                color: "grey",
                                                fontSize: "12px"
                                            },
                                            children: f
                                        })
                                    ]
                                })
                            ]
                        }, c));
                    });
                });
            } else if (l.cast_id) return /* @__PURE__ */ q.jsx("div", {
                style: {
                    maxWidth: "85%"
                },
                children: /* @__PURE__ */ q.jsx(LA, {
                    type: "hash",
                    identifier: l.cast_id.hash,
                    viewerFid: t,
                    allowReactions: e,
                    renderEmbeds: !1
                }, l.cast_id.fid)
            }, `cast-${l.cast_id.hash}`);
            return null;
        }))).filter((l)=>l !== null), [
        e,
        t
    ]);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].useEffect(()=>{
        i(s).then(n1);
    }, [
        s,
        i
    ]), r;
}, tm = ({ onClick: s })=>/* @__PURE__ */ q.jsx("svg", {
        width: "18",
        height: "17",
        viewBox: "0 0 18 17",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        onClick: (e)=>s ? s(e) : void 0,
        style: {
            cursor: "pointer"
        },
        children: /* @__PURE__ */ q.jsx("path", {
            d: "M6.22857 12.6828H7.01285C7.01285 12.2496 6.66172 11.8985 6.22857 11.8985V12.6828ZM6.22857 15.8199H5.4443C5.4443 16.1137 5.60848 16.3828 5.8697 16.5172C6.13092 16.6517 6.44537 16.6288 6.68443 16.4581L6.22857 15.8199ZM10.6205 12.6828V11.8985C10.4571 11.8985 10.2977 11.9496 10.1647 12.0446L10.6205 12.6828ZM1.78428 3.27146C1.78428 2.54955 2.3695 1.96433 3.09141 1.96433V0.395777C1.50321 0.395777 0.215723 1.68327 0.215723 3.27146H1.78428ZM1.78428 10.5914V3.27146H0.215723V10.5914H1.78428ZM3.0914 11.8985C2.3695 11.8985 1.78428 11.3133 1.78428 10.5914H0.215723C0.215723 12.1796 1.50321 13.4671 3.0914 13.4671V11.8985ZM6.22857 11.8985H3.0914V13.4671H6.22857V11.8985ZM7.01285 15.8199V12.6828H5.4443V15.8199H7.01285ZM10.1647 12.0446L5.77272 15.1817L6.68443 16.4581L11.0764 13.321L10.1647 12.0446ZM14.5941 11.8985H10.6205V13.4671H14.5941V11.8985ZM15.9013 10.5914C15.9013 11.3133 15.316 11.8985 14.5941 11.8985V13.4671C16.1823 13.4671 17.4698 12.1796 17.4698 10.5914H15.9013ZM15.9013 3.27146V10.5914H17.4698V3.27146H15.9013ZM14.5941 1.96433C15.316 1.96433 15.9013 2.54955 15.9013 3.27146H17.4698C17.4698 1.68326 16.1823 0.395777 14.5941 0.395777V1.96433ZM3.09141 1.96433H14.5941V0.395777H3.09141V1.96433Z",
            fill: "#A0A3AD"
        })
    }), BA = ({ fill: s, onClick: e })=>/* @__PURE__ */ q.jsxs("svg", {
        width: "16",
        height: "15",
        viewBox: "0 0 16 15",
        fill: s || "none",
        xmlns: "http://www.w3.org/2000/svg",
        onClick: (t)=>e ? e(t) : void 0,
        style: {
            cursor: "pointer"
        },
        children: [
            /* @__PURE__ */ q.jsx("path", {
                d: "M14.9245 14.2506C14.7258 14.2506 14.5352 14.1716 14.3946 14.0311C14.2541 13.8905 14.1751 13.6999 14.1751 13.5011V10.5034H11.1774C10.9787 10.5034 10.7881 10.4245 10.6475 10.2839C10.507 10.1434 10.428 9.95279 10.428 9.75403C10.428 9.55527 10.507 9.36465 10.6475 9.22411C10.7881 9.08357 10.9787 9.00461 11.1774 9.00461H14.9245C15.1233 9.00461 15.3139 9.08357 15.4545 9.22411C15.595 9.36465 15.674 9.55527 15.674 9.75403V13.5011C15.674 13.6999 15.595 13.8905 15.4545 14.0311C15.3139 14.1716 15.1233 14.2506 14.9245 14.2506ZM5.18207 6.00693H1.43497C1.23621 6.00693 1.04559 5.92797 0.905047 5.78743C0.764503 5.64688 0.685547 5.45627 0.685547 5.25751V1.51041C0.685547 1.31165 0.764503 1.12103 0.905047 0.980486C1.04559 0.839943 1.23621 0.760986 1.43497 0.760986C1.63373 0.760986 1.82434 0.839943 1.96489 0.980486C2.10543 1.12103 2.18439 1.31165 2.18439 1.51041V4.50809H5.18207C5.38083 4.50809 5.57145 4.58704 5.71199 4.72759C5.85253 4.86813 5.93149 5.05875 5.93149 5.25751C5.93149 5.45627 5.85253 5.64688 5.71199 5.78743C5.57145 5.92797 5.38083 6.00693 5.18207 6.00693Z",
                fill: s || "#A0A3AD"
            }),
            /* @__PURE__ */ q.jsx("path", {
                d: "M8.17934 15C6.33556 15.0003 4.55637 14.3209 3.18205 13.0918C1.80774 11.8627 0.934766 10.17 0.730106 8.33765C0.719281 8.23923 0.727945 8.13965 0.755606 8.04458C0.783266 7.94951 0.82938 7.86083 0.891315 7.78358C1.0164 7.62758 1.19833 7.52765 1.39709 7.50579C1.59585 7.48393 1.79515 7.54191 1.95116 7.667C2.10716 7.79208 2.20708 7.97401 2.22895 8.17277C2.37708 9.52376 2.97983 10.7843 3.93838 11.7478C4.89692 12.7113 6.15438 13.3205 7.50459 13.4755C8.85479 13.6306 10.2176 13.3223 11.3696 12.6012C12.5216 11.8801 13.3944 10.789 13.845 9.50674C13.8731 9.40817 13.9211 9.31642 13.986 9.23714C14.051 9.15787 14.1316 9.09277 14.2227 9.04586C14.3138 8.99895 14.4136 8.97123 14.5159 8.96442C14.6181 8.95761 14.7207 8.97185 14.8173 9.00625C14.9138 9.04066 15.0023 9.09451 15.0772 9.16446C15.1521 9.23442 15.2118 9.31899 15.2528 9.41296C15.2937 9.50693 15.3149 9.6083 15.3151 9.71079C15.3153 9.81329 15.2944 9.91473 15.2539 10.0089C14.7359 11.4705 13.7774 12.7355 12.5103 13.6294C11.2432 14.5233 9.73002 15.0022 8.17934 15ZM14.8792 7.50579C14.6939 7.50691 14.5148 7.43937 14.3764 7.3162C14.238 7.19302 14.1501 7.02295 14.1297 6.8388C13.975 5.49429 13.3699 4.24169 12.4128 3.28476C11.4558 2.32782 10.2031 1.72285 8.85858 1.56824C7.51405 1.41364 6.15676 1.7185 5.0075 2.43324C3.85823 3.14798 2.9846 4.23054 2.52872 5.50484C2.50062 5.6034 2.4526 5.69516 2.38763 5.77443C2.32266 5.85371 2.24212 5.91881 2.15099 5.96572C2.05987 6.01263 1.96008 6.04035 1.85781 6.04716C1.75555 6.05397 1.65297 6.03973 1.55642 6.00532C1.45988 5.97092 1.37141 5.91707 1.29651 5.84712C1.2216 5.77716 1.16183 5.69258 1.12091 5.59861C1.07999 5.50464 1.05878 5.40328 1.05859 5.30078C1.0584 5.19829 1.07923 5.09685 1.1198 5.00273C1.68406 3.40202 2.77497 2.04025 4.21397 1.14029C5.65297 0.240337 7.35485 -0.144505 9.04106 0.0487522C10.7273 0.242009 12.2979 1.00192 13.496 2.20411C14.6941 3.4063 15.4486 4.97958 15.6361 6.66644C15.6571 6.86306 15.5997 7.06004 15.4761 7.21445C15.3526 7.36887 15.173 7.4682 14.9766 7.4908L14.8792 7.50579Z",
                fill: s || "#A0A3AD"
            })
        ]
    }), rm = ({ fill: s, onClick: e })=>/* @__PURE__ */ q.jsxs("svg", {
        width: "17",
        height: "15",
        viewBox: "0 0 17 15",
        fill: s ? "red" : "none",
        xmlns: "http://www.w3.org/2000/svg",
        onClick: (t)=>e ? e(t) : void 0,
        style: {
            cursor: "pointer"
        },
        children: [
            /* @__PURE__ */ q.jsx("path", {
                d: "M13.8719 2.25042L14.2947 1.58984L13.8719 2.25042C15.2467 3.13022 15.7676 5.22206 14.8856 7.61317C14.0436 9.89583 11.9555 12.2374 8.51573 13.3648C5.07606 12.2374 2.98799 9.89584 2.14596 7.61316C1.26392 5.22203 1.7848 3.13022 3.15951 2.25042L3.15951 2.25042C4.58542 1.33783 5.64997 1.52983 6.39945 1.92503C7.21272 2.35388 7.73108 3.07114 7.86143 3.26838L8.51573 4.25838L9.17002 3.26838C9.30038 3.07113 9.81873 2.35388 10.632 1.92503C11.3815 1.52983 12.446 1.33783 13.8719 2.25042Z",
                stroke: s || "#A0A3AD",
                strokeWidth: "1.56855"
            }),
            /* @__PURE__ */ q.jsx("mask", {
                id: "path-2-inside-1_187_1051",
                fill: "white",
                children: /* @__PURE__ */ q.jsx("path", {
                    d: "M8.58444 13.9397C7.76139 13.6864 7.05334 13.3937 6.29976 12.9825C5.95633 12.7951 5.62285 12.5895 5.3003 12.3681C5.14416 12.2609 4.99108 12.1493 4.84063 12.0343C4.78132 11.9889 4.88038 12.0652 4.82156 12.0195C4.80388 12.0058 4.7863 11.9919 4.76869 11.9781C4.73364 11.9505 4.69884 11.9225 4.66413 11.8945C4.58948 11.8342 4.51582 11.7727 4.4428 11.7105C3.90499 11.252 3.41381 10.7389 2.98016 10.1809C3.01856 10.2303 2.97651 10.176 2.97064 10.1683C2.9583 10.1522 2.94604 10.1359 2.9338 10.1197C2.90939 10.0874 2.88527 10.0548 2.86126 10.0221C2.80961 9.95189 2.75908 9.8808 2.70932 9.8092C2.61492 9.67345 2.52441 9.535 2.4371 9.39457C2.2673 9.12145 2.11213 8.83926 1.97147 8.55006C1.93849 8.48228 1.90657 8.41396 1.87531 8.34537C1.85978 8.3113 1.84459 8.27709 1.82948 8.24284C1.82195 8.22575 1.81456 8.20864 1.80714 8.19152C1.80167 8.17889 1.76856 8.10061 1.79664 8.16736C1.73728 8.0262 1.68205 7.88329 1.63029 7.73916C1.52982 7.45942 1.44498 7.17407 1.37575 6.88502C1.34218 6.74492 1.31301 6.60379 1.28746 6.46202C1.2754 6.39502 1.2645 6.32782 1.2543 6.26052C1.24925 6.22713 1.24453 6.19369 1.23994 6.16023C1.25136 6.24358 1.23495 6.11772 1.23231 6.09532C1.20042 5.82444 1.18535 5.55158 1.18721 5.27885C1.18811 5.14691 1.19374 5.01501 1.20334 4.88343C1.20788 4.82128 1.21368 4.75922 1.22023 4.69726C1.2235 4.66651 1.22713 4.6358 1.23089 4.60511C1.23278 4.58982 1.23477 4.57457 1.23678 4.5593C1.22562 4.64425 1.23563 4.56956 1.23823 4.55163C1.27428 4.30419 1.32861 4.05943 1.40097 3.82006C1.43614 3.70375 1.47635 3.58899 1.52072 3.47587C1.53125 3.449 1.54219 3.42229 1.55326 3.39564C1.51941 3.47716 1.55889 3.38334 1.56717 3.36464C1.59226 3.30803 1.61886 3.25209 1.64643 3.19664C1.75101 2.98624 1.87476 2.78549 2.01534 2.59724C2.02371 2.58603 2.03221 2.57492 2.04071 2.5638C1.99275 2.62656 2.02446 2.58496 2.03493 2.57169C2.05223 2.54974 2.06993 2.52808 2.08773 2.50653C2.12631 2.45984 2.16629 2.41434 2.20713 2.36962C2.28587 2.28341 2.36926 2.20151 2.456 2.12339C2.49787 2.08568 2.54084 2.0492 2.58443 2.01352C2.60631 1.99561 2.62852 1.97808 2.65084 1.9607C2.58164 2.01466 2.67191 1.94557 2.68962 1.93265C2.83338 1.8277 2.98587 1.7348 3.14013 1.6463C3.54393 1.41459 3.92437 1.25567 4.3831 1.15072C4.47716 1.12921 4.57219 1.11204 4.6676 1.09771C4.74483 1.08611 4.61527 1.10399 4.69217 1.09444C4.71513 1.0916 4.73817 1.08917 4.76119 1.08677C4.81403 1.08124 4.86704 1.07739 4.92007 1.07423C5.10084 1.06348 5.28237 1.06851 5.46252 1.0864C5.48336 1.08846 5.50417 1.09092 5.52495 1.09338C5.59508 1.10167 5.46943 1.08526 5.53899 1.09521C5.57965 1.10103 5.62016 1.10795 5.66059 1.11524C5.74647 1.13073 5.83159 1.1503 5.91604 1.17227C6.0728 1.21311 6.22621 1.26621 6.37595 1.32786C6.31111 1.30115 6.41877 1.34702 6.43584 1.35477C6.46987 1.3702 6.50356 1.38639 6.53714 1.4028C6.60865 1.43779 6.67886 1.47543 6.74817 1.51462C6.87662 1.58723 7.00062 1.66753 7.12092 1.7529C7.14882 1.77271 7.17637 1.79297 7.20383 1.81338C7.21739 1.82348 7.23087 1.8337 7.24432 1.84396C7.29158 1.87992 7.1988 1.80839 7.24529 1.84482C7.30109 1.88853 7.35568 1.93375 7.40949 1.97982C7.50652 2.06288 7.59994 2.15008 7.69053 2.24011C7.84008 2.38879 7.98044 2.54677 8.11149 2.71194C8.12572 2.72987 8.17533 2.79414 8.11485 2.7157C8.12636 2.73065 8.13776 2.74568 8.1491 2.76075C8.1694 2.78769 8.18934 2.81491 8.20905 2.8423C8.23825 2.88286 8.2667 2.92398 8.29429 2.96566C8.40374 3.131 8.6286 3.131 8.73805 2.96566C8.76707 2.92181 8.79712 2.87866 8.82785 2.83598C8.84783 2.80823 8.86819 2.78075 8.88875 2.75344C8.90242 2.73529 8.94928 2.67474 8.88935 2.75214C8.90409 2.73312 8.919 2.71424 8.93399 2.69542C9.0671 2.52834 9.21071 2.36968 9.36261 2.21954C9.45411 2.12907 9.5493 2.04234 9.64732 1.95897C9.69737 1.91641 9.74847 1.87507 9.80017 1.83456C9.7388 1.88263 9.82694 1.81457 9.84213 1.80327C9.87427 1.77937 9.90683 1.75606 9.9396 1.73301C10.0608 1.64773 10.1866 1.56915 10.3159 1.49682C10.3802 1.46084 10.4457 1.42703 10.5119 1.39467C10.5455 1.37823 10.5795 1.36251 10.6136 1.34704C10.6308 1.33926 10.6481 1.33171 10.6654 1.32417C10.6915 1.31296 10.6885 1.3142 10.6564 1.3279C10.6681 1.32303 10.6798 1.31822 10.6916 1.31349C10.8423 1.25235 10.9973 1.20246 11.1548 1.16239C11.2332 1.14248 11.3123 1.12599 11.3918 1.11166C11.4323 1.10435 11.473 1.09815 11.5138 1.09231C11.4471 1.10186 11.5171 1.09226 11.5281 1.09095C11.5559 1.08767 11.5838 1.08499 11.6117 1.0824C11.793 1.06553 11.9757 1.06513 12.1573 1.0771C12.203 1.08011 12.2485 1.08444 12.294 1.08921C12.3172 1.09163 12.3402 1.0945 12.3633 1.09734C12.3036 1.08994 12.3813 1.10022 12.3881 1.10123C12.4921 1.11685 12.5952 1.13785 12.6975 1.16193C13.1586 1.27048 13.5378 1.44037 13.9464 1.67761C14.0904 1.76129 14.2314 1.8507 14.3656 1.9495C14.377 1.95791 14.3884 1.96648 14.3997 1.97503C14.4419 2.00688 14.351 1.93696 14.3926 1.96945C14.4149 1.98683 14.4369 2.00462 14.4588 2.02252C14.5059 2.06115 14.5519 2.1013 14.5971 2.14228C14.6835 2.22073 14.7656 2.30388 14.8439 2.39035C14.8815 2.43176 14.9178 2.47427 14.9534 2.51736C14.9712 2.53891 14.9887 2.56077 15.006 2.58274C15.0384 2.62388 14.9682 2.53335 15 2.575C15.0114 2.58983 15.0225 2.60479 15.0336 2.61978C15.1736 2.80871 15.2946 3.01142 15.3985 3.22224C15.4238 3.27356 15.4477 3.32553 15.4709 3.37782C15.4767 3.39096 15.4824 3.40414 15.4881 3.41734C15.5093 3.46656 15.464 3.35945 15.4845 3.40902C15.4975 3.44013 15.5099 3.47148 15.5221 3.50289C15.5661 3.61632 15.6049 3.73175 15.6398 3.84833C15.7115 4.08832 15.763 4.33416 15.7984 4.58204C15.8064 4.63806 15.7901 4.51842 15.7975 4.57463C15.7995 4.58992 15.8014 4.60521 15.8033 4.6205C15.807 4.6512 15.8104 4.68197 15.8137 4.71273C15.8208 4.77994 15.8264 4.84732 15.8312 4.91474C15.8404 5.04658 15.8447 5.17876 15.8453 5.31093C15.8464 5.58418 15.8287 5.85737 15.7961 6.12862C15.7941 6.14529 15.7919 6.16192 15.7898 6.17856C15.7822 6.23827 15.7983 6.11722 15.7901 6.17697C15.7855 6.21044 15.7806 6.24389 15.7755 6.27731C15.7644 6.35031 15.752 6.4231 15.7388 6.49573C15.7129 6.63769 15.6823 6.7788 15.6484 6.91905C15.5784 7.20843 15.4909 7.49348 15.3897 7.77343C15.3648 7.84232 15.3388 7.9108 15.3121 7.97902C15.2987 8.01338 15.2849 8.0476 15.2711 8.08179C15.2641 8.09896 15.257 8.11604 15.25 8.13315C15.2452 8.14458 15.2405 8.15598 15.2357 8.16738C15.2496 8.13453 15.251 8.13117 15.2399 8.15734C15.1786 8.30137 15.1131 8.44355 15.0443 8.58416C14.9028 8.87351 14.7451 9.15483 14.5745 9.42799C14.4868 9.56844 14.395 9.70634 14.3002 9.84213C14.254 9.90821 14.2069 9.97355 14.1592 10.0385C14.1351 10.0711 14.1108 10.1036 14.0864 10.136C14.0741 10.1522 14.0617 10.1684 14.0494 10.1845C14.0319 10.2073 14.0329 10.2061 14.0522 10.181C14.0439 10.1918 14.0355 10.2025 14.0271 10.2132C13.8135 10.4869 13.5849 10.7488 13.3445 10.9992C13.0948 11.2594 12.8309 11.5058 12.556 11.7391C12.4884 11.7965 12.4199 11.8528 12.3509 11.9086C12.3162 11.9366 12.2812 11.9643 12.2461 11.992C12.2285 12.0058 12.2108 12.0196 12.1931 12.0333C12.2377 11.9987 12.1636 12.0558 12.156 12.0616C12.005 12.1765 11.8508 12.2871 11.6942 12.3941C11.3706 12.6153 11.0348 12.8185 10.6904 13.0055C10.5122 13.1023 10.3313 13.1939 10.1484 13.2815C10.059 13.3243 9.96904 13.3658 9.87868 13.4064C9.8331 13.4269 9.78733 13.4469 9.74151 13.4669C9.7185 13.4769 9.69541 13.4868 9.67233 13.4966C9.6442 13.5086 9.64146 13.5098 9.66417 13.5002C9.64864 13.5067 9.63313 13.5132 9.61758 13.5196C9.2349 13.6788 8.84398 13.8179 8.44786 13.9398C8.31409 13.9809 8.2304 14.1178 8.26839 14.2559C8.3047 14.3878 8.45064 14.4765 8.5845 14.4353C10.1534 13.9525 11.626 13.1871 12.8857 12.131C13.9425 11.245 14.8349 10.1456 15.4543 8.91165C15.9942 7.83608 16.3357 6.64744 16.3583 5.43967C16.3774 4.41628 16.149 3.35704 15.5742 2.49789C15.2929 2.07732 14.9371 1.71816 14.5205 1.43134C13.7956 0.932295 12.9294 0.592822 12.045 0.557214C10.7717 0.505949 9.60126 1.17157 8.7697 2.09685C8.59779 2.28813 8.43634 2.49172 8.29431 2.70629C8.44223 2.70629 8.59015 2.70629 8.73807 2.70629C8.22434 1.93023 7.48255 1.25338 6.6264 0.880424C5.9305 0.577258 5.18555 0.490164 4.43721 0.617179C3.98766 0.69348 3.55546 0.856508 3.14849 1.05915C2.81945 1.22296 2.50653 1.41842 2.22115 1.65017C1.44904 2.27713 0.973026 3.20995 0.783732 4.17519C0.56509 5.29004 0.68737 6.45381 1.02051 7.53339C1.41084 8.79827 2.09407 9.95916 2.95641 10.9589C3.94757 12.1081 5.19614 13.0306 6.5582 13.6933C7.16712 13.9896 7.8008 14.2362 8.44788 14.4353C8.58174 14.4765 8.72768 14.3878 8.76399 14.2559C8.80189 14.1177 8.71821 13.9809 8.58444 13.9397Z"
                })
            }),
            /* @__PURE__ */ q.jsx("path", {
                d: "M8.58444 13.9397C7.76139 13.6864 7.05334 13.3937 6.29976 12.9825C5.95633 12.7951 5.62285 12.5895 5.3003 12.3681C5.14416 12.2609 4.99108 12.1493 4.84063 12.0343C4.78132 11.9889 4.88038 12.0652 4.82156 12.0195C4.80388 12.0058 4.7863 11.9919 4.76869 11.9781C4.73364 11.9505 4.69884 11.9225 4.66413 11.8945C4.58948 11.8342 4.51582 11.7727 4.4428 11.7105C3.90499 11.252 3.41381 10.7389 2.98016 10.1809C3.01856 10.2303 2.97651 10.176 2.97064 10.1683C2.9583 10.1522 2.94604 10.1359 2.9338 10.1197C2.90939 10.0874 2.88527 10.0548 2.86126 10.0221C2.80961 9.95189 2.75908 9.8808 2.70932 9.8092C2.61492 9.67345 2.52441 9.535 2.4371 9.39457C2.2673 9.12145 2.11213 8.83926 1.97147 8.55006C1.93849 8.48228 1.90657 8.41396 1.87531 8.34537C1.85978 8.3113 1.84459 8.27709 1.82948 8.24284C1.82195 8.22575 1.81456 8.20864 1.80714 8.19152C1.80167 8.17889 1.76856 8.10061 1.79664 8.16736C1.73728 8.0262 1.68205 7.88329 1.63029 7.73916C1.52982 7.45942 1.44498 7.17407 1.37575 6.88502C1.34218 6.74492 1.31301 6.60379 1.28746 6.46202C1.2754 6.39502 1.2645 6.32782 1.2543 6.26052C1.24925 6.22713 1.24453 6.19369 1.23994 6.16023C1.25136 6.24358 1.23495 6.11772 1.23231 6.09532C1.20042 5.82444 1.18535 5.55158 1.18721 5.27885C1.18811 5.14691 1.19374 5.01501 1.20334 4.88343C1.20788 4.82128 1.21368 4.75922 1.22023 4.69726C1.2235 4.66651 1.22713 4.6358 1.23089 4.60511C1.23278 4.58982 1.23477 4.57457 1.23678 4.5593C1.22562 4.64425 1.23563 4.56956 1.23823 4.55163C1.27428 4.30419 1.32861 4.05943 1.40097 3.82006C1.43614 3.70375 1.47635 3.58899 1.52072 3.47587C1.53125 3.449 1.54219 3.42229 1.55326 3.39564C1.51941 3.47716 1.55889 3.38334 1.56717 3.36464C1.59226 3.30803 1.61886 3.25209 1.64643 3.19664C1.75101 2.98624 1.87476 2.78549 2.01534 2.59724C2.02371 2.58603 2.03221 2.57492 2.04071 2.5638C1.99275 2.62656 2.02446 2.58496 2.03493 2.57169C2.05223 2.54974 2.06993 2.52808 2.08773 2.50653C2.12631 2.45984 2.16629 2.41434 2.20713 2.36962C2.28587 2.28341 2.36926 2.20151 2.456 2.12339C2.49787 2.08568 2.54084 2.0492 2.58443 2.01352C2.60631 1.99561 2.62852 1.97808 2.65084 1.9607C2.58164 2.01466 2.67191 1.94557 2.68962 1.93265C2.83338 1.8277 2.98587 1.7348 3.14013 1.6463C3.54393 1.41459 3.92437 1.25567 4.3831 1.15072C4.47716 1.12921 4.57219 1.11204 4.6676 1.09771C4.74483 1.08611 4.61527 1.10399 4.69217 1.09444C4.71513 1.0916 4.73817 1.08917 4.76119 1.08677C4.81403 1.08124 4.86704 1.07739 4.92007 1.07423C5.10084 1.06348 5.28237 1.06851 5.46252 1.0864C5.48336 1.08846 5.50417 1.09092 5.52495 1.09338C5.59508 1.10167 5.46943 1.08526 5.53899 1.09521C5.57965 1.10103 5.62016 1.10795 5.66059 1.11524C5.74647 1.13073 5.83159 1.1503 5.91604 1.17227C6.0728 1.21311 6.22621 1.26621 6.37595 1.32786C6.31111 1.30115 6.41877 1.34702 6.43584 1.35477C6.46987 1.3702 6.50356 1.38639 6.53714 1.4028C6.60865 1.43779 6.67886 1.47543 6.74817 1.51462C6.87662 1.58723 7.00062 1.66753 7.12092 1.7529C7.14882 1.77271 7.17637 1.79297 7.20383 1.81338C7.21739 1.82348 7.23087 1.8337 7.24432 1.84396C7.29158 1.87992 7.1988 1.80839 7.24529 1.84482C7.30109 1.88853 7.35568 1.93375 7.40949 1.97982C7.50652 2.06288 7.59994 2.15008 7.69053 2.24011C7.84008 2.38879 7.98044 2.54677 8.11149 2.71194C8.12572 2.72987 8.17533 2.79414 8.11485 2.7157C8.12636 2.73065 8.13776 2.74568 8.1491 2.76075C8.1694 2.78769 8.18934 2.81491 8.20905 2.8423C8.23825 2.88286 8.2667 2.92398 8.29429 2.96566C8.40374 3.131 8.6286 3.131 8.73805 2.96566C8.76707 2.92181 8.79712 2.87866 8.82785 2.83598C8.84783 2.80823 8.86819 2.78075 8.88875 2.75344C8.90242 2.73529 8.94928 2.67474 8.88935 2.75214C8.90409 2.73312 8.919 2.71424 8.93399 2.69542C9.0671 2.52834 9.21071 2.36968 9.36261 2.21954C9.45411 2.12907 9.5493 2.04234 9.64732 1.95897C9.69737 1.91641 9.74847 1.87507 9.80017 1.83456C9.7388 1.88263 9.82694 1.81457 9.84213 1.80327C9.87427 1.77937 9.90683 1.75606 9.9396 1.73301C10.0608 1.64773 10.1866 1.56915 10.3159 1.49682C10.3802 1.46084 10.4457 1.42703 10.5119 1.39467C10.5455 1.37823 10.5795 1.36251 10.6136 1.34704C10.6308 1.33926 10.6481 1.33171 10.6654 1.32417C10.6915 1.31296 10.6885 1.3142 10.6564 1.3279C10.6681 1.32303 10.6798 1.31822 10.6916 1.31349C10.8423 1.25235 10.9973 1.20246 11.1548 1.16239C11.2332 1.14248 11.3123 1.12599 11.3918 1.11166C11.4323 1.10435 11.473 1.09815 11.5138 1.09231C11.4471 1.10186 11.5171 1.09226 11.5281 1.09095C11.5559 1.08767 11.5838 1.08499 11.6117 1.0824C11.793 1.06553 11.9757 1.06513 12.1573 1.0771C12.203 1.08011 12.2485 1.08444 12.294 1.08921C12.3172 1.09163 12.3402 1.0945 12.3633 1.09734C12.3036 1.08994 12.3813 1.10022 12.3881 1.10123C12.4921 1.11685 12.5952 1.13785 12.6975 1.16193C13.1586 1.27048 13.5378 1.44037 13.9464 1.67761C14.0904 1.76129 14.2314 1.8507 14.3656 1.9495C14.377 1.95791 14.3884 1.96648 14.3997 1.97503C14.4419 2.00688 14.351 1.93696 14.3926 1.96945C14.4149 1.98683 14.4369 2.00462 14.4588 2.02252C14.5059 2.06115 14.5519 2.1013 14.5971 2.14228C14.6835 2.22073 14.7656 2.30388 14.8439 2.39035C14.8815 2.43176 14.9178 2.47427 14.9534 2.51736C14.9712 2.53891 14.9887 2.56077 15.006 2.58274C15.0384 2.62388 14.9682 2.53335 15 2.575C15.0114 2.58983 15.0225 2.60479 15.0336 2.61978C15.1736 2.80871 15.2946 3.01142 15.3985 3.22224C15.4238 3.27356 15.4477 3.32553 15.4709 3.37782C15.4767 3.39096 15.4824 3.40414 15.4881 3.41734C15.5093 3.46656 15.464 3.35945 15.4845 3.40902C15.4975 3.44013 15.5099 3.47148 15.5221 3.50289C15.5661 3.61632 15.6049 3.73175 15.6398 3.84833C15.7115 4.08832 15.763 4.33416 15.7984 4.58204C15.8064 4.63806 15.7901 4.51842 15.7975 4.57463C15.7995 4.58992 15.8014 4.60521 15.8033 4.6205C15.807 4.6512 15.8104 4.68197 15.8137 4.71273C15.8208 4.77994 15.8264 4.84732 15.8312 4.91474C15.8404 5.04658 15.8447 5.17876 15.8453 5.31093C15.8464 5.58418 15.8287 5.85737 15.7961 6.12862C15.7941 6.14529 15.7919 6.16192 15.7898 6.17856C15.7822 6.23827 15.7983 6.11722 15.7901 6.17697C15.7855 6.21044 15.7806 6.24389 15.7755 6.27731C15.7644 6.35031 15.752 6.4231 15.7388 6.49573C15.7129 6.63769 15.6823 6.7788 15.6484 6.91905C15.5784 7.20843 15.4909 7.49348 15.3897 7.77343C15.3648 7.84232 15.3388 7.9108 15.3121 7.97902C15.2987 8.01338 15.2849 8.0476 15.2711 8.08179C15.2641 8.09896 15.257 8.11604 15.25 8.13315C15.2452 8.14458 15.2405 8.15598 15.2357 8.16738C15.2496 8.13453 15.251 8.13117 15.2399 8.15734C15.1786 8.30137 15.1131 8.44355 15.0443 8.58416C14.9028 8.87351 14.7451 9.15483 14.5745 9.42799C14.4868 9.56844 14.395 9.70634 14.3002 9.84213C14.254 9.90821 14.2069 9.97355 14.1592 10.0385C14.1351 10.0711 14.1108 10.1036 14.0864 10.136C14.0741 10.1522 14.0617 10.1684 14.0494 10.1845C14.0319 10.2073 14.0329 10.2061 14.0522 10.181C14.0439 10.1918 14.0355 10.2025 14.0271 10.2132C13.8135 10.4869 13.5849 10.7488 13.3445 10.9992C13.0948 11.2594 12.8309 11.5058 12.556 11.7391C12.4884 11.7965 12.4199 11.8528 12.3509 11.9086C12.3162 11.9366 12.2812 11.9643 12.2461 11.992C12.2285 12.0058 12.2108 12.0196 12.1931 12.0333C12.2377 11.9987 12.1636 12.0558 12.156 12.0616C12.005 12.1765 11.8508 12.2871 11.6942 12.3941C11.3706 12.6153 11.0348 12.8185 10.6904 13.0055C10.5122 13.1023 10.3313 13.1939 10.1484 13.2815C10.059 13.3243 9.96904 13.3658 9.87868 13.4064C9.8331 13.4269 9.78733 13.4469 9.74151 13.4669C9.7185 13.4769 9.69541 13.4868 9.67233 13.4966C9.6442 13.5086 9.64146 13.5098 9.66417 13.5002C9.64864 13.5067 9.63313 13.5132 9.61758 13.5196C9.2349 13.6788 8.84398 13.8179 8.44786 13.9398C8.31409 13.9809 8.2304 14.1178 8.26839 14.2559C8.3047 14.3878 8.45064 14.4765 8.5845 14.4353C10.1534 13.9525 11.626 13.1871 12.8857 12.131C13.9425 11.245 14.8349 10.1456 15.4543 8.91165C15.9942 7.83608 16.3357 6.64744 16.3583 5.43967C16.3774 4.41628 16.149 3.35704 15.5742 2.49789C15.2929 2.07732 14.9371 1.71816 14.5205 1.43134C13.7956 0.932295 12.9294 0.592822 12.045 0.557214C10.7717 0.505949 9.60126 1.17157 8.7697 2.09685C8.59779 2.28813 8.43634 2.49172 8.29431 2.70629C8.44223 2.70629 8.59015 2.70629 8.73807 2.70629C8.22434 1.93023 7.48255 1.25338 6.6264 0.880424C5.9305 0.577258 5.18555 0.490164 4.43721 0.617179C3.98766 0.69348 3.55546 0.856508 3.14849 1.05915C2.81945 1.22296 2.50653 1.41842 2.22115 1.65017C1.44904 2.27713 0.973026 3.20995 0.783732 4.17519C0.56509 5.29004 0.68737 6.45381 1.02051 7.53339C1.41084 8.79827 2.09407 9.95916 2.95641 10.9589C3.94757 12.1081 5.19614 13.0306 6.5582 13.6933C7.16712 13.9896 7.8008 14.2362 8.44788 14.4353C8.58174 14.4765 8.72768 14.3878 8.76399 14.2559C8.80189 14.1177 8.71821 13.9809 8.58444 13.9397Z",
                stroke: s || "#A0A3AD",
                strokeWidth: "3.13711",
                mask: "url(#path-2-inside-1_187_1051)"
            })
        ]
    });
function sm({ onClick: s, size: e = 24 }) {
    return /* @__PURE__ */ q.jsx("svg", {
        "aria-hidden": "true",
        focusable: "false",
        role: "img",
        viewBox: "0 0 16 16",
        width: e,
        height: e,
        fill: "#4A4A4A",
        style: {
            display: "inline-block",
            userSelect: "none",
            verticalAlign: "text-bottom",
            overflow: "visible",
            cursor: "pointer",
            padding: "4px"
        },
        onClick: s,
        children: /* @__PURE__ */ q.jsx("path", {
            d: "M3.72 3.72a.75.75 0 0 1 1.06 0L8 6.94l3.22-3.22a.749.749 0 0 1 1.275.326.749.749 0 0 1-.215.734L9.06 8l3.22 3.22a.749.749 0 0 1-.326 1.275.749.749 0 0 1-.734-.215L8 9.06l-3.22 3.22a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042L6.94 8 3.72 4.78a.75.75 0 0 1 0-1.06Z"
        })
    });
}
const FA = ()=>Ir, NA = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])(FA())({
    classes: [
        "rect7e5"
    ]
}), UA = ()=>Ir, $A = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])(UA())({
    classes: [
        "p13mqntt"
    ]
}), GA = ()=>Ir, VA = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])(GA())({
    classes: [
        "p1r47dz2"
    ]
}), jA = ()=>Ir, KA = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])(jA())({
    classes: [
        "cnojpqv"
    ]
}), HA = ({ hash: s, reactions: e, onComment: t, onRecast: r, onLike: n1, isLiked: i })=>{
    const { client_id: o, user: a, isAuthenticated: l } = ts(), [c, u] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].useState(!1), [d1, h] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].useState({
        top: 0,
        left: 0
    }), [f, p] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].useState(null), [y, E] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].useState(i), [b, L] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].useState(!1), A = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].useRef(null), F = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].useRef({
        comment: null,
        recast: null,
        like: null
    });
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        E(e.likes.some((H)=>H.fid === (a == null ? void 0 : a.fid))), L(e.recasts.some((H)=>H.fid === (a == null ? void 0 : a.fid)));
    }, [
        e,
        a
    ]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        const H = localStorage.getItem(Gn.NEYNAR_AUTHENTICATED_USER);
        if (H) try {
            p(JSON.parse(H).signer_uuid);
        } catch (K) {
            console.error("Error parsing JSON from local storage:", K), p(null);
        }
        else console.warn("No NEYNAR_AUTHENTICATED_USER found in local storage.");
    }, [
        l
    ]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        (f || l) && c && u(!1);
    }, [
        f,
        l,
        c
    ]);
    const M = async (H, K)=>{
        if (f) switch(K){
            case "comment":
                if (t) t();
                else throw new Error("No comment handler function provided");
                break;
            case "recast":
                if (r) L(r());
                else throw new Error("No recast handler function provided");
                break;
            case "like":
                if (n1) E(n1());
                else throw new Error("No like handler function provided");
                break;
        }
        const j = F.current[K];
        if (j) {
            const C = j.getBoundingClientRect(), k = A.current;
            if (k) {
                const $ = k.getBoundingClientRect();
                h({
                    top: C.top - $.height - 10,
                    left: C.left + C.width / 2 - $.width / 2
                });
            }
        }
    };
    return /* @__PURE__ */ q.jsxs(NA, {
        children: [
            c && /* @__PURE__ */ q.jsxs($A, {
                ref: A,
                style: {
                    top: d1.top,
                    left: d1.left
                },
                children: [
                    /* @__PURE__ */ q.jsx(VA, {
                        children: /* @__PURE__ */ q.jsx(pS, {
                            variant: gs.NEYNAR
                        })
                    }),
                    /* @__PURE__ */ q.jsx(KA, {
                        children: /* @__PURE__ */ q.jsx(sm, {
                            onClick: ()=>u(!1),
                            size: 16
                        })
                    })
                ]
            }),
            /* @__PURE__ */ q.jsx(Ir, {
                style: {
                    display: "flex",
                    justifyContent: "space-between",
                    alignItems: "center"
                },
                children: /* @__PURE__ */ q.jsxs(Ir, {
                    spacingVertical: "15px",
                    style: {
                        display: "flex",
                        gap: "42px"
                    },
                    children: [
                        /* @__PURE__ */ q.jsx("div", {
                            ref: (H)=>F.current.comment = H,
                            children: /* @__PURE__ */ q.jsx(tm, {
                                onClick: (H)=>M(H, "comment")
                            })
                        }),
                        /* @__PURE__ */ q.jsx("div", {
                            ref: (H)=>F.current.recast = H,
                            children: /* @__PURE__ */ q.jsx(BA, {
                                fill: b ? "green" : void 0,
                                onClick: (H)=>M(H, "recast")
                            })
                        }),
                        /* @__PURE__ */ q.jsx("div", {
                            ref: (H)=>F.current.like = H,
                            children: /* @__PURE__ */ q.jsx(rm, {
                                fill: y ? "red" : void 0,
                                onClick: (H)=>M(H, "like")
                            })
                        })
                    ]
                })
            })
        ]
    });
};
function qA({ onClick: s }) {
    return /* @__PURE__ */ q.jsx("svg", {
        style: {
            cursor: "pointer"
        },
        width: "16",
        height: "15",
        viewBox: "0 0 16 15",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        onClick: (e)=>s ? s(e) : void 0,
        children: /* @__PURE__ */ q.jsx("path", {
            d: "M15.2003 7.49063C14.7504 7.49063 14.4504 7.79057 14.4504 8.24048V12.7396C14.4504 13.1895 14.1505 13.4894 13.7006 13.4894H3.20268C2.75277 13.4894 2.45283 13.1895 2.45283 12.7396V8.24048C2.45283 7.79057 2.15289 7.49063 1.70298 7.49063C1.25307 7.49063 0.953125 7.79057 0.953125 8.24048V12.7396C0.953125 14.0143 1.92793 14.9891 3.20268 14.9891H13.7006C14.9753 14.9891 15.9501 14.0143 15.9501 12.7396V8.24048C15.9501 7.79057 15.6502 7.49063 15.2003 7.49063ZM5.97713 4.26627L7.70178 2.54161V9.74018C7.70178 10.1901 8.00172 10.49 8.45163 10.49C8.90155 10.49 9.20149 10.1901 9.20149 9.74018V2.54161L10.9261 4.26627C11.2261 4.56621 11.676 4.56621 11.9759 4.26627C12.2759 3.96633 12.2759 3.51642 11.9759 3.21648L8.97653 0.217073C8.90155 0.142088 8.82656 0.0671031 8.75157 0.0671031C8.6016 -0.00788202 8.37665 -0.00788202 8.15169 0.0671031C8.07671 0.0671031 8.00172 0.142088 7.92674 0.217073L4.92734 3.21648C4.62739 3.51642 4.62739 3.96633 4.92734 4.26627C5.22728 4.56621 5.67719 4.56621 5.97713 4.26627Z",
            fill: "#A0A3AD"
        })
    });
}
const Ic = ({ url: s })=>{
    const [e, t] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].useState(!1), r = async (n1)=>{
        try {
            await navigator.clipboard.writeText(s), t(!0), setTimeout(()=>{
                t(!1);
            }, 2e3);
        } catch (i) {
            console.error("Failed to copy the text to clipboard:", i);
        }
    };
    return /* @__PURE__ */ q.jsx("div", {
        children: e ? /* @__PURE__ */ q.jsx("svg", {
            style: {
                cursor: "pointer",
                fill: "green"
            },
            width: "16",
            height: "15",
            viewBox: "0 0 16 15",
            xmlns: "http://www.w3.org/2000/svg",
            children: /* @__PURE__ */ q.jsx("path", {
                d: "M5.99967 12.8136L1.71967 8.53364L0.559673 9.69364L5.99967 15.1336L16.4397 4.69364L15.2797 3.53364L5.99967 12.8136Z"
            })
        }) : /* @__PURE__ */ q.jsx(qA, {
            onClick: r
        })
    });
}, WA = ()=>/* @__PURE__ */ q.jsxs("svg", {
        width: "10",
        height: "10",
        viewBox: "0 0 10 10",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
            /* @__PURE__ */ q.jsx("path", {
                d: "M5.85855 0.555664H8.31281M8.31281 0.555664V2.73754M8.31281 0.555664L4.31445 4.11122",
                stroke: "#FFFFFF",
                "stroke-linecap": "round",
                "stroke-linejoin": "round"
            }),
            /* @__PURE__ */ q.jsx("path", {
                "fill-rule": "evenodd",
                "clip-rule": "evenodd",
                d: "M3.31445 1H1.31445C0.762168 1 0.314453 1.44772 0.314453 2V8C0.314453 8.55228 0.762168 9 1.31445 9H7.31445C7.86674 9 8.31445 8.55228 8.31445 8V6H7.31445V8H1.31445V2H3.31445V1Z",
                fill: "#FFFFFF"
            })
        ]
    }), zA = ()=>/* @__PURE__ */ q.jsx("svg", {
        width: "10",
        height: "14",
        viewBox: "0 0 10 14",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: /* @__PURE__ */ q.jsx("path", {
            d: "M5.01451 12.5187L4.96833 12.5174L4.93914 12.522C4.93113 12.516 4.92402 12.5087 4.91808 12.5005L4.51231 12.7926L4.91808 12.5005C4.9049 12.4822 4.89824 12.46 4.89913 12.4375L4.89953 12.4275V12.4176V8.81194V8.31194H4.39953H1.8876H1.88753C1.76188 8.31196 1.63853 8.27825 1.53036 8.21433C1.42218 8.1504 1.33315 8.05862 1.27256 7.94854C1.21196 7.83847 1.18203 7.71415 1.18588 7.58856C1.18973 7.46301 1.2272 7.34079 1.29438 7.23466C1.2944 7.23463 1.29442 7.23459 1.29444 7.23456L4.90001 1.54377L4.90567 1.53483L4.91095 1.52567C4.92227 1.50601 4.93988 1.49074 4.96094 1.48232C4.982 1.47389 5.00528 1.47281 5.02703 1.47924L5.02912 1.47985C5.05077 1.48614 5.06969 1.4995 5.08286 1.5178C5.09603 1.53609 5.1027 1.55827 5.1018 1.58079L5.10141 1.59073V1.60067V5.20631V5.70631H5.60141H8.11333H8.1134C8.23905 5.70629 8.3624 5.74 8.47058 5.80392C8.57875 5.86784 8.66778 5.95963 8.72838 6.06971C8.78897 6.17978 8.81891 6.3041 8.81506 6.42969C8.81121 6.55528 8.77371 6.67753 8.70649 6.78369L5.10232 12.4723C5.10219 12.4725 5.10205 12.4727 5.10191 12.4729C5.09255 12.4873 5.07969 12.499 5.06452 12.507C5.04914 12.5152 5.03191 12.5192 5.01451 12.5187Z",
            stroke: "#FFFFFF"
        })
    }), YA = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("button")({
    classes: [
        "f1hmcrrf"
    ]
}), ZA = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("div")({
    classes: [
        "f1ki4il6"
    ]
}), XA = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("div")({
    classes: [
        "bgnz0ud"
    ]
}), JA = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("img")({
    classes: [
        "f1gbget9"
    ]
}), QA = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("div")({
    classes: [
        "f4rwe4i"
    ]
}), eI = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("div")({
    classes: [
        "f1qellgw"
    ]
}), tI = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("input")({
    classes: [
        "i1hgxwhi"
    ]
}), rI = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("div")({
    classes: [
        "s1ahcfax"
    ]
}), sI = ()=>{
    const s = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useRef"])(null);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        if (s.current) {
            let e = 0;
            const t = ()=>{
                e += 6, s.current && (s.current.style.transform = `rotate(${e}deg)`), requestAnimationFrame(t);
            };
            requestAnimationFrame(t);
        }
    }, []), /* @__PURE__ */ q.jsx("svg", {
        ref: s,
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: "1.5",
        stroke: "currentColor",
        className: "size-6 text-white",
        style: {
            width: "24px",
            height: "24px"
        },
        children: /* @__PURE__ */ q.jsx("path", {
            strokeLinecap: "round",
            strokeLinejoin: "round",
            d: "M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0 3.181 3.183a8.25 8.25 0 0 0 13.803-3.7M4.031 9.865a8.25 8.25 0 0 1 13.803-3.7l3.181 3.182m0-4.991v4.99"
        })
    });
};
function nI({ number: s, text: e, actionType: t, target: r, frameUrl: n1, handleOnClick: i }) {
    return /* @__PURE__ */ q.jsxs(YA, {
        onClick: ()=>i(s),
        children: [
            e,
            (t === "link" || t === "post_redirect" || t === "mint") && /* @__PURE__ */ q.jsx(WA, {}),
            t === "tx" && /* @__PURE__ */ q.jsx(zA, {})
        ]
    });
}
function iI({ frame: s, onFrameBtnPress: e }) {
    var h;
    const [t, r] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useState"])(s), [n1, i] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useState"])(""), [o, a] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useState"])(!1), l = ()=>{
        const f = t.buttons.map((p)=>/* @__PURE__ */ q.jsx(nI, {
                number: p.index,
                text: p.title,
                actionType: p.action_type,
                target: p.target,
                frameUrl: s.frames_url,
                handleOnClick: (y)=>{
                    a(!0), e(y, t, r, n1).finally(()=>a(!1));
                }
            }, p.index));
        return /* @__PURE__ */ q.jsx(XA, {
            children: f
        });
    }, c = (f)=>{
        i(f);
    }, u = (f)=>{
        try {
            return new URL(f).hostname.replace("www.", "");
        } catch  {
            return "";
        }
    }, d1 = ()=>{
        switch(t.image_aspect_ratio){
            case "1:1":
                return {
                    aspectRatio: "1 / 1"
                };
            case "1.91:1":
                return {
                    aspectRatio: "1.91 / 1"
                };
            default:
                return {
                    aspectRatio: "1.91 / 1"
                };
        }
    };
    return /* @__PURE__ */ q.jsxs(q.Fragment, {
        children: [
            /* @__PURE__ */ q.jsxs(ZA, {
                children: [
                    o && /* @__PURE__ */ q.jsx(rI, {
                        children: /* @__PURE__ */ q.jsx(sI, {})
                    }),
                    t.frames_url && /* @__PURE__ */ q.jsxs(q.Fragment, {
                        children: [
                            /* @__PURE__ */ q.jsx("a", {
                                href: t.frames_url,
                                target: "_blank",
                                rel: "noopener noreferrer",
                                style: {
                                    width: "100%"
                                },
                                children: /* @__PURE__ */ q.jsx(JA, {
                                    src: t.image,
                                    alt: `Frame image for ${t.frames_url}`,
                                    style: d1()
                                })
                            }),
                            ((h = t.input) == null ? void 0 : h.text) && /* @__PURE__ */ q.jsx(tI, {
                                type: "text",
                                placeholder: t.input.text,
                                value: n1,
                                onChange: (f)=>c(f.target.value)
                            }),
                            l()
                        ]
                    })
                ]
            }),
            t.frames_url && /* @__PURE__ */ q.jsx(QA, {
                children: u(t.frames_url)
            })
        ]
    });
}
const oI = ({ frame: s, onFrameBtnPress: e })=>/* @__PURE__ */ q.jsx(eI, {
        children: s ? /* @__PURE__ */ q.jsx(iI, {
            frame: s,
            onFrameBtnPress: e
        }) : /* @__PURE__ */ q.jsx(q.Fragment, {})
    }), aI = ({ url: s, onFrameBtnPress: e, initialFrame: t })=>{
    const { showToast: r } = ts(), [n1] = du(Gn.NEYNAR_AUTHENTICATED_USER, null), [i, o] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useState"])(null), [a, l] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useState"])(t);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        n1 ? o(n1.signer_uuid) : console.warn("No NEYNAR_AUTHENTICATED_USER found in local storage.");
    }, [
        n1
    ]);
    const c = (d1)=>{
        if (typeof d1 != "object" || d1 === null) return !1;
        const h = [
            "version",
            "image",
            "buttons",
            "frames_url"
        ];
        for (const f of h)if (!(f in d1)) return !1;
        return !(!Array.isArray(d1.buttons) || d1.buttons.some((f)=>typeof f.index != "number"));
    }, u = async (d1, h, f, p)=>{
        try {
            const y = await e(d1, h, f, p);
            if (!c(y)) throw new Error("Invalid frame data received");
            f(y);
        } catch (y) {
            r(xg.Error, `An error occurred while processing the button press: ${y}`);
        }
    };
    return /* @__PURE__ */ q.jsx(oI, {
        frame: a,
        onFrameBtnPress: u
    });
};
function pf(s) {
    const e = Math.min(s, 1e9);
    return e >= 1e9 ? Math.floor(e / 1e8) / 10 + "B" : e >= 1e6 ? Math.floor(e / 1e5) / 10 + "M" : e >= 1e3 ? Math.floor(e / 100) / 10 + "K" : e.toString();
}
function lI(s) {
    if (!s) return console.error("Error: Timestamp is undefined or empty."), "Invalid timestamp";
    const e = new Date(s);
    if (isNaN(e.getTime())) return console.error("Error: Invalid timestamp provided:", s), "Invalid timestamp";
    const t = /* @__PURE__ */ new Date(), n1 = new Intl.DateTimeFormat(void 0, {
        hour: "numeric",
        minute: "2-digit",
        hour12: !0
    }).format(e).replace(" ", ""), i = t.toDateString() === e.toDateString(), o = new Date(t.setDate(t.getDate() - 1)).toDateString() === e.toDateString();
    if (i) return `${n1}, today`;
    if (o) return `${n1}, yesterday`;
    const a = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
    ], l = e.getDate(), c = a[e.getMonth()], u = e.getFullYear(), h = `${c} ${((f)=>{
        if (f > 3 && f < 21) return `${f}th`;
        const p = [
            "st",
            "nd",
            "rd"
        ], y = f % 10;
        return `${f}${p[y - 1] || "th"}`;
    })(l)} ${u}`;
    return `${n1}, ${h}`;
}
const cI = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("div")({
    classes: [
        "sxqvxvq"
    ]
}), uI = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("a")({
    classes: [
        "s3kamov"
    ]
}), dI = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("div")({
    classes: [
        "m1wrvvhk"
    ]
}), hI = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("div")({
    classes: [
        "t1lcaq27"
    ]
}), fI = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("div")({
    classes: [
        "ugtp1wh"
    ]
}), gI = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("div")({
    classes: [
        "l1dqpn4e"
    ]
}), pI = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("div")({
    classes: [
        "l1bjnv2t"
    ]
}), mf = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("div")({
    classes: [
        "e15yf123"
    ]
}), mI = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("div")({
    classes: [
        "rxra94g"
    ]
}), yf = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("div")({
    classes: [
        "s1whgqrs"
    ]
}), yI = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("p")({
    classes: [
        "dz8marf"
    ]
}), oa = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].memo(({ username: s, displayName: e, avatarImgUrl: t, text: r = "", hash: n1, reactions: i, replies: o, embeds: a = [], frames: l = [], channel: c, viewerFid: u, hasPowerBadge: d1, isEmbed: h = !0, allowReactions: f, renderEmbeds: p, renderFrames: y, onLikeBtnPress: E, onRecastBtnPress: b, onCommentBtnPress: L, onFrameBtnPress: A, direct_replies: F, containerStyles: M, textStyles: H, timestamp: K, appAvatarImgUrl: j })=>{
    const [C, k] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useState"])(i.likes_count), [$, W] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useState"])(i.likes.some((V)=>V.fid === u)), _ = /* @__PURE__ */ q.jsx(pI, {
        children: ES(r, a)
    }), g = (a == null ? void 0 : a.length) === 1, x = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useMemo"])(()=>l.map((V)=>V.frames_url), [
        l
    ]), w = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useMemo"])(()=>a.filter((V)=>!x.includes(V.url)), [
        a,
        x
    ]), D = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useCallback"])((V)=>{
        V.currentTarget.src = bi;
    }, []);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        W(i.likes.some((V)=>V.fid === u));
    }, [
        i.likes,
        u
    ]);
    const O = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useCallback"])(()=>E && E() ? (k((R)=>R + 1), W(!$), !0) : !1, [
        E
    ]), U = OA(w, f, u);
    return /* @__PURE__ */ q.jsx(cI, {
        style: {
            ...M,
            borderWidth: h ? "1px" : "0"
        },
        children: /* @__PURE__ */ q.jsxs(Pr, {
            children: [
                /* @__PURE__ */ q.jsx(Ir, {
                    spacingRight: "10px",
                    children: /* @__PURE__ */ q.jsx(Yo, {
                        src: t && t.length > 0 ? t : bi,
                        width: "20px",
                        height: "20px",
                        onError: D,
                        loading: "lazy",
                        alt: `${e ?? "Skeleton"} Avatar`
                    })
                }),
                /* @__PURE__ */ q.jsxs(dI, {
                    children: [
                        /* @__PURE__ */ q.jsxs(Pr, {
                            flexGrow: 1,
                            alignItems: "center",
                            children: [
                                /* @__PURE__ */ q.jsxs(Pr, {
                                    children: [
                                        /* @__PURE__ */ q.jsx(yI, {
                                            children: e
                                        }),
                                        " ",
                                        j && /* @__PURE__ */ q.jsx(Ir, {
                                            spacingLeft: "5px",
                                            children: /* @__PURE__ */ q.jsx("img", {
                                                style: {
                                                    padding: "2px",
                                                    borderWidth: "0.5px"
                                                },
                                                className: "border-white rounded-full",
                                                src: j,
                                                width: "18",
                                                height: "18",
                                                onError: (V)=>{
                                                    V.currentTarget.style.display = "none";
                                                }
                                            })
                                        })
                                    ]
                                }),
                                /* @__PURE__ */ q.jsxs(Pr, {
                                    alignItems: "center",
                                    children: [
                                        /* @__PURE__ */ q.jsxs(fI, {
                                            children: [
                                                "@",
                                                s,
                                                " "
                                            ]
                                        }),
                                        " ",
                                        /* @__PURE__ */ q.jsx(hI, {
                                            style: {
                                                color: "#999999",
                                                fontSize: "14px",
                                                fontFamily: "Work Sans"
                                            },
                                            children: lI(K)
                                        })
                                    ]
                                })
                            ]
                        }),
                        /* @__PURE__ */ q.jsx(Ir, {
                            style: {
                                marginTop: "10px"
                            },
                            children: /* @__PURE__ */ q.jsx(gI, {
                                style: H,
                                children: _
                            })
                        }),
                        p && w && w.length > 0 ? /* @__PURE__ */ q.jsx(mf, {
                            style: {
                                margin: g ? "4px 0" : "0"
                            },
                            children: U.map((V, R)=>/* @__PURE__ */ q.jsx("div", {
                                    style: {
                                        width: "100%"
                                    },
                                    children: V
                                }, R))
                        }) : /* @__PURE__ */ q.jsx(q.Fragment, {}),
                        y && l && l.length > 0 ? /* @__PURE__ */ q.jsx(mf, {
                            children: l.map((V)=>/* @__PURE__ */ q.jsx(aI, {
                                    url: V.frames_url,
                                    initialFrame: V,
                                    onFrameBtnPress: A
                                }, V.frames_url))
                        }) : null,
                        /* @__PURE__ */ q.jsxs(mI, {
                            style: {
                                justifyContent: f ? "space-between" : "flex-end"
                            },
                            children: [
                                f && /* @__PURE__ */ q.jsx(HA, {
                                    hash: n1,
                                    reactions: i,
                                    onComment: L,
                                    onRecast: b,
                                    onLike: O,
                                    isLiked: $
                                }),
                                f && s && n1 && /* @__PURE__ */ q.jsx(Ic, {
                                    url: `https://farcaster.xyz/${s}/${n1.slice(0, 10)}`
                                })
                            ]
                        }),
                        /* @__PURE__ */ q.jsxs(yf, {
                            style: {
                                justifyContent: f ? "" : "space-between",
                                marginTop: "10px"
                            },
                            children: [
                                /* @__PURE__ */ q.jsxs(yf, {
                                    style: {
                                        justifyContent: f ? "" : "space-between",
                                        gap: 6
                                    },
                                    children: [
                                        /* @__PURE__ */ q.jsxs("div", {
                                            style: {
                                                display: "flex",
                                                alignItems: "center",
                                                gap: "4px",
                                                color: "#999999"
                                            },
                                            children: [
                                                /* @__PURE__ */ q.jsx(tm, {}),
                                                o
                                            ]
                                        }),
                                        /* @__PURE__ */ q.jsx("div", {
                                            style: {
                                                padding: "0px 10px"
                                            }
                                        }),
                                        /* @__PURE__ */ q.jsxs("div", {
                                            style: {
                                                display: "flex",
                                                alignItems: "center",
                                                gap: "4px",
                                                color: "#999999"
                                            },
                                            children: [
                                                /* @__PURE__ */ q.jsx(rm, {}),
                                                " ",
                                                C
                                            ]
                                        }),
                                        c && /* @__PURE__ */ q.jsxs(q.Fragment, {
                                            children: [
                                                /* @__PURE__ */ q.jsx("div", {}),
                                                /* @__PURE__ */ q.jsxs(uI, {
                                                    href: `https://farcaster.xyz/~/channel/${c.id}`,
                                                    target: "_blank",
                                                    children: [
                                                        "/",
                                                        c.id
                                                    ]
                                                })
                                            ]
                                        })
                                    ]
                                }),
                                !f && s && n1 && /* @__PURE__ */ q.jsx(Ic, {
                                    url: `https://farcaster.xyz/${s}/${n1.slice(0, 10)}`
                                })
                            ]
                        })
                    ]
                })
            ]
        })
    });
}), vI = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("div")({
    classes: [
        "s1m6ob1a"
    ]
}), vf = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("div")({
    classes: [
        "r1esevc7"
    ]
}), Ef = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("div")({
    classes: [
        "vxb1f00"
    ]
}), EI = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("div")({
    classes: [
        "htv0qz7"
    ]
}), xf = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("div")({
    classes: [
        "rzksy2"
    ]
});
function xI(s) {
    return /* @__PURE__ */ q.jsx(vI, {
        children: s.casts.map((e, t)=>/* @__PURE__ */ q.jsxs(vf, {
                children: [
                    t !== 0 && /* @__PURE__ */ q.jsx(Ef, {
                        style: {
                            left: "42px"
                        }
                    }),
                    /* @__PURE__ */ q.jsxs(xf, {
                        children: [
                            /* @__PURE__ */ q.jsx(oa, {
                                isEmbed: !1,
                                ...e
                            }),
                            t === 0 && /* @__PURE__ */ q.jsx(EI, {}),
                            e.direct_replies && e.direct_replies.length > 0 && e.direct_replies.map((r, n1)=>/* @__PURE__ */ q.jsxs(vf, {
                                    children: [
                                        /* @__PURE__ */ q.jsx(Ef, {
                                            style: {
                                                left: "42px"
                                            }
                                        }),
                                        /* @__PURE__ */ q.jsx(xf, {
                                            children: /* @__PURE__ */ q.jsx(oa, {
                                                isEmbed: !1,
                                                ...r
                                            })
                                        })
                                    ]
                                }, n1))
                        ]
                    })
                ]
            }, t))
    });
}
async function SI({ type: s, identifier: e, replyDepth: t = 2, includeChronologicalParentCasts: r = !1, limit: n1 = 20, viewerFid: i, clientId: o }) {
    try {
        let a = `${Vn}/v2/farcaster/cast/conversation?identifier=${encodeURIComponent(e)}&type=${s}&reply_depth=${t}&include_chronological_parent_casts=${r}&limit=${n1}&client_id=${o}`;
        return i && (a += `&viewer_fid=${i}`), await (await jn(a, {
            method: "GET",
            headers: {
                accept: "application/json"
            }
        })).json() || null;
    } catch (a) {
        return console.error("Error fetching conversation", a), null;
    }
}
function nm(s) {
    return {
        username: s.author.username,
        displayName: s.author.display_name,
        avatarImgUrl: s.author.pfp_url,
        text: s.text,
        hash: s.hash,
        reactions: s.reactions,
        replies: s.replies.count,
        embeds: s.embeds,
        frames: s.frames,
        renderEmbeds: s.renderEmbeds,
        channel: s.channel,
        viewerFid: 2,
        hasPowerBadge: s.author.power_badge,
        appAvatarImgUrl: s.app.pfp_url,
        isOwnProfile: !1,
        allowReactions: !0,
        renderFrames: !1,
        direct_replies: s.direct_replies ? s.direct_replies.map(nm) : [],
        timestamp: s.timestamp
    };
}
function bI(s) {
    const e = [];
    return s.cast && e.push(nm(s.cast)), e;
}
const pL = ({ type: s, identifier: e, replyDepth: t = 2, includeChronologicalParentCasts: r = !1, limit: n1 = 20, viewerFid: i })=>{
    const { client_id: o } = ts(), [a, l] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].useState(null), [c, u] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].useState(!0), [d1, h] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].useState(null);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].useEffect(()=>{
        u(!0), h(null), SI({
            type: s,
            identifier: e,
            replyDepth: t,
            includeChronologicalParentCasts: r,
            limit: n1,
            viewerFid: i,
            clientId: o
        }).then((f)=>{
            l(f);
        }).catch((f)=>{
            h(f);
        }).finally(()=>{
            u(!1);
        });
    }, [
        s,
        e,
        t,
        r,
        n1,
        i,
        o
    ]), c ? /* @__PURE__ */ q.jsx(q.Fragment, {
        children: " "
    }) : d1 ? /* @__PURE__ */ q.jsx(q.Fragment, {
        children: " "
    }) : /* @__PURE__ */ q.jsx(xI, {
        casts: bI(a.conversation)
    });
};
var Ol = {
    exports: {}
}, Bl = {};
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Sf;
function TI() {
    if (Sf) return Bl;
    Sf = 1;
    var s = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"];
    function e(d1, h) {
        return d1 === h && (d1 !== 0 || 1 / d1 === 1 / h) || d1 !== d1 && h !== h;
    }
    var t = typeof Object.is == "function" ? Object.is : e, r = s.useState, n1 = s.useEffect, i = s.useLayoutEffect, o = s.useDebugValue;
    function a(d1, h) {
        var f = h(), p = r({
            inst: {
                value: f,
                getSnapshot: h
            }
        }), y = p[0].inst, E = p[1];
        return i(function() {
            y.value = f, y.getSnapshot = h, l(y) && E({
                inst: y
            });
        }, [
            d1,
            f,
            h
        ]), n1(function() {
            return l(y) && E({
                inst: y
            }), d1(function() {
                l(y) && E({
                    inst: y
                });
            });
        }, [
            d1
        ]), o(f), f;
    }
    function l(d1) {
        var h = d1.getSnapshot;
        d1 = d1.value;
        try {
            var f = h();
            return !t(d1, f);
        } catch  {
            return !0;
        }
    }
    function c(d1, h) {
        return h();
    }
    var u = ("TURBOPACK compile-time value", "undefined") > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? c : a;
    return Bl.useSyncExternalStore = s.useSyncExternalStore !== void 0 ? s.useSyncExternalStore : u, Bl;
}
var bf;
function wI() {
    return bf || (bf = 1, Ol.exports = TI()), Ol.exports;
}
var im = wI();
const om = 0, am = 1, lm = 2, Tf = 3;
var wf = Object.prototype.hasOwnProperty;
function _c(s, e) {
    var t, r;
    if (s === e) return !0;
    if (s && e && (t = s.constructor) === e.constructor) {
        if (t === Date) return s.getTime() === e.getTime();
        if (t === RegExp) return s.toString() === e.toString();
        if (t === Array) {
            if ((r = s.length) === e.length) for(; r-- && _c(s[r], e[r]););
            return r === -1;
        }
        if (!t || typeof s == "object") {
            r = 0;
            for(t in s)if (wf.call(s, t) && ++r && !wf.call(e, t) || !(t in e) || !_c(s[t], e[t])) return !1;
            return Object.keys(e).length === r;
        }
    }
    return s !== s && e !== e;
}
const qr = /* @__PURE__ */ new WeakMap(), Cs = ()=>{}, qt = /*#__NOINLINE__*/ Cs(), Lc = Object, $e = (s)=>s === qt, Mr = (s)=>typeof s == "function", Bs = (s, e)=>({
        ...s,
        ...e
    }), cm = (s)=>Mr(s.then), Fl = {}, oo = {}, Fu = "undefined", Pi = ("TURBOPACK compile-time value", "undefined") != Fu, Rc = typeof document != Fu, AI = Pi && "Deno" in window, II = ()=>Pi && typeof window.requestAnimationFrame != Fu, _s = (s, e)=>{
    const t = qr.get(s);
    return [
        // Getter
        ()=>!$e(e) && s.get(e) || Fl,
        // Setter
        (r)=>{
            if (!$e(e)) {
                const n1 = s.get(e);
                e in oo || (oo[e] = n1), t[5](e, Bs(n1, r), n1 || Fl);
            }
        },
        // Subscriber
        t[6],
        // Get server cache snapshot
        ()=>!$e(e) && e in oo ? oo[e] : !$e(e) && s.get(e) || Fl
    ];
};
let Cc = !0;
const _I = ()=>Cc, [kc, Dc] = ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : [
    Cs,
    Cs
], LI = ()=>{
    const s = Rc && document.visibilityState;
    return $e(s) || s !== "hidden";
}, RI = (s)=>(Rc && document.addEventListener("visibilitychange", s), kc("focus", s), ()=>{
        Rc && document.removeEventListener("visibilitychange", s), Dc("focus", s);
    }), CI = (s)=>{
    const e = ()=>{
        Cc = !0, s();
    }, t = ()=>{
        Cc = !1;
    };
    return kc("online", e), kc("offline", t), ()=>{
        Dc("online", e), Dc("offline", t);
    };
}, kI = {
    isOnline: _I,
    isVisible: LI
}, DI = {
    initFocus: RI,
    initReconnect: CI
}, Af = !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].useId, Ti = !Pi || AI, PI = (s)=>II() ? "TURBOPACK unreachable" : setTimeout(s, 1), So = ("TURBOPACK compile-time truthy", 1) ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useEffect"] : "TURBOPACK unreachable", Nl = typeof navigator < "u" && navigator.connection, If = !Ti && Nl && ([
    "slow-2g",
    "2g"
].includes(Nl.effectiveType) || Nl.saveData), ao = /* @__PURE__ */ new WeakMap(), MI = (s)=>Lc.prototype.toString.call(s), Ul = (s, e)=>s === `[object ${e}]`;
let OI = 0;
const Pc = (s)=>{
    const e = typeof s, t = MI(s), r = Ul(t, "Date"), n1 = Ul(t, "RegExp"), i = Ul(t, "Object");
    let o, a;
    if (Lc(s) === s && !r && !n1) {
        if (o = ao.get(s), o) return o;
        if (o = ++OI + "~", ao.set(s, o), Array.isArray(s)) {
            for(o = "@", a = 0; a < s.length; a++)o += Pc(s[a]) + ",";
            ao.set(s, o);
        }
        if (i) {
            o = "#";
            const l = Lc.keys(s).sort();
            for(; !$e(a = l.pop());)$e(s[a]) || (o += a + ":" + Pc(s[a]) + ",");
            ao.set(s, o);
        }
    } else o = r ? s.toJSON() : e == "symbol" ? s.toString() : e == "string" ? JSON.stringify(s) : "" + s;
    return o;
}, wi = (s)=>{
    if (Mr(s)) try {
        s = s();
    } catch  {
        s = "";
    }
    const e = s;
    return s = typeof s == "string" ? s : (Array.isArray(s) ? s.length : s) ? Pc(s) : "", [
        s,
        e
    ];
};
let BI = 0;
const Mc = ()=>++BI;
async function um(...s) {
    const [e, t, r, n1] = s, i = Bs({
        populateCache: !0,
        throwOnError: !0
    }, typeof n1 == "boolean" ? {
        revalidate: n1
    } : n1 || {});
    let o = i.populateCache;
    const a = i.rollbackOnError;
    let l = i.optimisticData;
    const c = (h)=>typeof a == "function" ? a(h) : a !== !1, u = i.throwOnError;
    if (Mr(t)) {
        const h = t, f = [], p = e.keys();
        for (const y of p)// Skip the special useSWRInfinite and useSWRSubscription keys.
        !/^\$(inf|sub)\$/.test(y) && h(e.get(y)._k) && f.push(y);
        return Promise.all(f.map(d1));
    }
    return d1(t);
    //TURBOPACK unreachable
    ;
    async function d1(h) {
        const [f] = wi(h);
        if (!f) return;
        const [p, y] = _s(e, f), [E, b, L, A] = qr.get(e), F = ()=>{
            const g = E[f];
            return (Mr(i.revalidate) ? i.revalidate(p().data, h) : i.revalidate !== !1) && (delete L[f], delete A[f], g && g[0]) ? g[0](lm).then(()=>p().data) : p().data;
        };
        if (s.length < 3) return F();
        let M = r, H, K = !1;
        const j = Mc();
        b[f] = [
            j,
            0
        ];
        const C = !$e(l), k = p(), $ = k.data, W = k._c, _ = $e(W) ? $ : W;
        if (C && (l = Mr(l) ? l(_, $) : l, y({
            data: l,
            _c: _
        })), Mr(M)) try {
            M = M(_);
        } catch (g) {
            H = g, K = !0;
        }
        if (M && cm(M)) if (M = await M.catch((g)=>{
            H = g, K = !0;
        }), j !== b[f][0]) {
            if (K) throw H;
            return M;
        } else K && C && c(H) && (o = !0, y({
            data: _,
            _c: qt
        }));
        if (o && !K) if (Mr(o)) {
            const g = o(M, _);
            y({
                data: g,
                error: qt,
                _c: qt
            });
        } else y({
            data: M,
            error: qt,
            _c: qt
        });
        if (b[f][1] = Mc(), Promise.resolve(F()).then(()=>{
            y({
                _c: qt
            });
        }), K) {
            if (u) throw H;
            return;
        }
        return M;
    }
}
const _f = (s, e)=>{
    for(const t in s)s[t][0] && s[t][0](e);
}, FI = (s, e)=>{
    if (!qr.has(s)) {
        const t = Bs(DI, e), r = /* @__PURE__ */ Object.create(null), n1 = um.bind(qt, s);
        let i = Cs;
        const o = /* @__PURE__ */ Object.create(null), a = (u, d1)=>{
            const h = o[u] || [];
            return o[u] = h, h.push(d1), ()=>h.splice(h.indexOf(d1), 1);
        }, l = (u, d1, h)=>{
            s.set(u, d1);
            const f = o[u];
            if (f) for (const p of f)p(d1, h);
        }, c = ()=>{
            if (!qr.has(s) && (qr.set(s, [
                r,
                /* @__PURE__ */ Object.create(null),
                /* @__PURE__ */ Object.create(null),
                /* @__PURE__ */ Object.create(null),
                n1,
                l,
                a
            ]), !Ti)) {
                const u = t.initFocus(setTimeout.bind(qt, _f.bind(qt, r, om))), d1 = t.initReconnect(setTimeout.bind(qt, _f.bind(qt, r, am)));
                i = ()=>{
                    u && u(), d1 && d1(), qr.delete(s);
                };
            }
        };
        return c(), [
            s,
            n1,
            c,
            i
        ];
    }
    return [
        s,
        qr.get(s)[4]
    ];
}, NI = (s, e, t, r, n1)=>{
    const i = t.errorRetryCount, o = n1.retryCount, a = ~~((Math.random() + 0.5) * (1 << (o < 8 ? o : 8))) * t.errorRetryInterval;
    !$e(i) && o > i || setTimeout(r, a, n1);
}, UI = _c, [Nu, $I] = FI(/* @__PURE__ */ new Map()), GI = Bs({
    // events
    onLoadingSlow: Cs,
    onSuccess: Cs,
    onError: Cs,
    onErrorRetry: NI,
    onDiscarded: Cs,
    // switches
    revalidateOnFocus: !0,
    revalidateOnReconnect: !0,
    revalidateIfStale: !0,
    shouldRetryOnError: !0,
    // timeouts
    errorRetryInterval: ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : 5e3,
    focusThrottleInterval: 5 * 1e3,
    dedupingInterval: 2 * 1e3,
    loadingTimeout: ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : 3e3,
    // providers
    compare: UI,
    isPaused: ()=>!1,
    cache: Nu,
    mutate: $I,
    fallback: {}
}, // use web preset by default
kI), VI = (s, e)=>{
    const t = Bs(s, e);
    if (e) {
        const { use: r, fallback: n1 } = s, { use: i, fallback: o } = e;
        r && i && (t.use = r.concat(i)), n1 && o && (t.fallback = Bs(n1, o));
    }
    return t;
}, jI = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createContext"])({}), dm = "$inf$", hm = Pi && window.__SWR_DEVTOOLS_USE__, KI = ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : [], HI = ()=>{
    hm && (window.__SWR_DEVTOOLS_REACT__ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"]);
}, fm = (s)=>Mr(s[1]) ? [
        s[0],
        s[1],
        s[2] || {}
    ] : [
        s[0],
        null,
        (s[1] === null ? s[2] : s[1]) || {}
    ], qI = ()=>{
    const s = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useContext"])(jI);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useMemo"])(()=>Bs(GI, s), [
        s
    ]);
}, WI = (s)=>(e, t, r)=>s(e, t && ((...i)=>{
            const [o] = wi(e), [, , , a] = qr.get(Nu);
            if (o.startsWith(dm)) return t(...i);
            const l = a[o];
            return $e(l) ? t(...i) : (delete a[o], l);
        }), r), zI = KI.concat(WI), YI = (s)=>function(...t) {
        const r = qI(), [n1, i, o] = fm(t), a = VI(r, o);
        let l = s;
        const { use: c } = a, u = (c || []).concat(zI);
        for(let d1 = u.length; d1--;)l = u[d1](l);
        return l(n1, i || a.fetcher || null, a);
    }, ZI = (s, e, t)=>{
    const r = e[s] || (e[s] = []);
    return r.push(t), ()=>{
        const n1 = r.indexOf(t);
        n1 >= 0 && (r[n1] = r[r.length - 1], r.pop());
    };
}, XI = (s, e)=>(...t)=>{
        const [r, n1, i] = fm(t), o = (i.use || []).concat(e);
        return s(r, n1, {
            ...i,
            use: o
        });
    };
HI();
const $l = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].use || // This extra generic is to avoid TypeScript mixing up the generic and JSX sytax
// and emitting an error.
// We assume that this is only for the `use(thenable)` case, not `use(context)`.
// https://github.com/facebook/react/blob/aed00dacfb79d17c53218404c52b1c7aa59c4a89/packages/react-server/src/ReactFizzThenable.js#L45
((s)=>{
    switch(s.status){
        case "pending":
            throw s;
        case "fulfilled":
            return s.value;
        case "rejected":
            throw s.reason;
        default:
            throw s.status = "pending", s.then((e)=>{
                s.status = "fulfilled", s.value = e;
            }, (e)=>{
                s.status = "rejected", s.reason = e;
            }), s;
    }
}), Gl = {
    dedupe: !0
}, Lf = Promise.resolve(qt), JI = (s, e, t)=>{
    const { cache: r, compare: n1, suspense: i, fallbackData: o, revalidateOnMount: a, revalidateIfStale: l, refreshInterval: c, refreshWhenHidden: u, refreshWhenOffline: d1, keepPreviousData: h } = t, [f, p, y, E] = qr.get(r), [b, L] = wi(s), A = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useRef"])(!1), F = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useRef"])(!1), M = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useRef"])(b), H = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useRef"])(e), K = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useRef"])(t), j = ()=>K.current, C = ()=>j().isVisible() && j().isOnline(), [k, $, W, _] = _s(r, b), g = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useRef"])({}).current, x = $e(o) ? $e(t.fallback) ? qt : t.fallback[b] : o, w = (_e, xe)=>{
        for(const Be in g){
            const ye = Be;
            if (ye === "data") {
                if (!n1(_e[ye], xe[ye]) && (!$e(_e[ye]) || !n1(N, xe[ye]))) return !1;
            } else if (xe[ye] !== _e[ye]) return !1;
        }
        return !0;
    }, D = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useMemo"])(()=>{
        const _e = !b || !e ? !1 : $e(a) ? j().isPaused() || i ? !1 : l !== !1 : a, xe = (we)=>{
            const Ne = Bs(we);
            return delete Ne._k, _e ? {
                isValidating: !0,
                isLoading: !0,
                ...Ne
            } : Ne;
        }, Be = k(), ye = _(), be = xe(Be), Fe = Be === ye ? be : xe(ye);
        let Xe = be;
        return [
            ()=>{
                const we = xe(k());
                return w(we, Xe) ? (Xe.data = we.data, Xe.isLoading = we.isLoading, Xe.isValidating = we.isValidating, Xe.error = we.error, Xe) : (Xe = we, we);
            },
            ()=>Fe
        ];
    }, [
        r,
        b
    ]), O = im.useSyncExternalStore((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useCallback"])((_e)=>W(b, (xe, Be)=>{
            w(Be, xe) || _e();
        }), // eslint-disable-next-line react-hooks/exhaustive-deps
    [
        r,
        b
    ]), D[0], D[1]), U = !A.current, V = f[b] && f[b].length > 0, R = O.data, m = $e(R) ? x && cm(x) ? $l(x) : x : R, v = O.error, P = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useRef"])(m), N = h ? $e(R) ? $e(P.current) ? m : P.current : R : m, Y = V && !$e(v) ? !1 : U && !$e(a) ? a : j().isPaused() ? !1 : i ? $e(m) ? !1 : l : $e(m) || l, ee = !!(b && e && U && Y), ie = $e(O.isValidating) ? ee : O.isValidating, le = $e(O.isLoading) ? ee : O.isLoading, Te = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useCallback"])(async (_e)=>{
        const xe = H.current;
        if (!b || !xe || F.current || j().isPaused()) return !1;
        let Be, ye, be = !0;
        const Fe = _e || {}, Xe = !y[b] || !Fe.dedupe, we = ()=>Af ? !F.current && b === M.current && A.current : b === M.current, Ne = {
            isValidating: !1,
            isLoading: !1
        }, dt = ()=>{
            $(Ne);
        }, Je = ()=>{
            const it = y[b];
            it && it[1] === ye && delete y[b];
        }, Qe = {
            isValidating: !0
        };
        $e(k().data) && (Qe.isLoading = !0);
        try {
            if (Xe && ($(Qe), t.loadingTimeout && $e(k().data) && setTimeout(()=>{
                be && we() && j().onLoadingSlow(b, t);
            }, t.loadingTimeout), y[b] = [
                xe(L),
                Mc()
            ]), [Be, ye] = y[b], Be = await Be, Xe && setTimeout(Je, t.dedupingInterval), !y[b] || y[b][1] !== ye) return Xe && we() && j().onDiscarded(b), !1;
            Ne.error = qt;
            const it = p[b];
            if (!$e(it) && // case 1
            (ye <= it[0] || // case 2
            ye <= it[1] || // case 3
            it[1] === 0)) return dt(), Xe && we() && j().onDiscarded(b), !1;
            const je = k().data;
            Ne.data = n1(je, Be) ? je : Be, Xe && we() && j().onSuccess(Be, b, t);
        } catch (it) {
            Je();
            const je = j(), { shouldRetryOnError: B } = je;
            je.isPaused() || (Ne.error = it, Xe && we() && (je.onError(it, b, je), (B === !0 || Mr(B) && B(it)) && (!j().revalidateOnFocus || !j().revalidateOnReconnect || C()) && je.onErrorRetry(it, b, je, (S)=>{
                const T = f[b];
                T && T[0] && T[0](Tf, S);
            }, {
                retryCount: (Fe.retryCount || 0) + 1,
                dedupe: !0
            })));
        }
        return be = !1, dt(), !0;
    }, // `setState` is immutable, and `eventsCallback`, `fnArg`, and
    // `keyValidating` are depending on `key`, so we can exclude them from
    // the deps array.
    //
    // FIXME:
    // `fn` and `config` might be changed during the lifecycle,
    // but they might be changed every render like this.
    // `useSWR('key', () => fetch('/api/'), { suspense: true })`
    // So we omit the values from the deps array
    // even though it might cause unexpected behaviors.
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
        b,
        r
    ]), De = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useCallback"])(// Use callback to make sure `keyRef.current` returns latest result every time
    (..._e)=>um(r, M.current, ..._e), // eslint-disable-next-line react-hooks/exhaustive-deps
    []);
    if (So(()=>{
        H.current = e, K.current = t, $e(R) || (P.current = R);
    }), So(()=>{
        if (!b) return;
        const _e = Te.bind(qt, Gl);
        let xe = 0;
        j().revalidateOnFocus && (xe = Date.now() + j().focusThrottleInterval);
        const ye = ZI(b, f, (be, Fe = {})=>{
            if (be == om) {
                const Xe = Date.now();
                j().revalidateOnFocus && Xe > xe && C() && (xe = Xe + j().focusThrottleInterval, _e());
            } else if (be == am) j().revalidateOnReconnect && C() && _e();
            else {
                if (be == lm) return Te();
                if (be == Tf) return Te(Fe);
            }
        });
        return F.current = !1, M.current = b, A.current = !0, $({
            _k: L
        }), Y && (y[b] || ($e(m) || Ti ? _e() : "TURBOPACK unreachable")), ()=>{
            F.current = !0, ye();
        };
    }, [
        b
    ]), So(()=>{
        let _e;
        function xe() {
            const ye = Mr(c) ? c(k().data) : c;
            ye && _e !== -1 && (_e = setTimeout(Be, ye));
        }
        function Be() {
            !k().error && (u || j().isVisible()) && (d1 || j().isOnline()) ? Te(Gl).then(xe) : xe();
        }
        return xe(), ()=>{
            _e && (clearTimeout(_e), _e = -1);
        };
    }, [
        c,
        u,
        d1,
        b
    ]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useDebugValue"])(N), i) {
        const _e = b && $e(m);
        if (!Af && Ti && _e) throw new Error("Fallback data is required when using Suspense in SSR.");
        _e && (H.current = e, K.current = t, F.current = !1);
        const xe = E[b], Be = !$e(xe) && _e ? De(xe) : Lf;
        if ($l(Be), !$e(v) && _e) throw v;
        const ye = _e ? Te(Gl) : Lf;
        !$e(N) && _e && (ye.status = "fulfilled", ye.value = !0), $l(ye);
    }
    return {
        mutate: De,
        get data () {
            return g.data = !0, N;
        },
        get error () {
            return g.error = !0, v;
        },
        get isValidating () {
            return g.isValidating = !0, ie;
        },
        get isLoading () {
            return g.isLoading = !0, le;
        }
    };
}, QI = YI(JI), e_ = ()=>{}, t_ = /*#__NOINLINE__*/ e_(), Oc = Object, Rf = (s)=>s === t_, r_ = (s)=>typeof s == "function", lo = /* @__PURE__ */ new WeakMap(), s_ = (s)=>Oc.prototype.toString.call(s), Vl = (s, e)=>s === `[object ${e}]`;
let n_ = 0;
const Bc = (s)=>{
    const e = typeof s, t = s_(s), r = Vl(t, "Date"), n1 = Vl(t, "RegExp"), i = Vl(t, "Object");
    let o, a;
    if (Oc(s) === s && !r && !n1) {
        if (o = lo.get(s), o) return o;
        if (o = ++n_ + "~", lo.set(s, o), Array.isArray(s)) {
            for(o = "@", a = 0; a < s.length; a++)o += Bc(s[a]) + ",";
            lo.set(s, o);
        }
        if (i) {
            o = "#";
            const l = Oc.keys(s).sort();
            for(; !Rf(a = l.pop());)Rf(s[a]) || (o += a + ":" + Bc(s[a]) + ",");
            lo.set(s, o);
        }
    } else o = r ? s.toJSON() : e == "symbol" ? s.toString() : e == "string" ? JSON.stringify(s) : "" + s;
    return o;
}, i_ = (s)=>{
    if (r_(s)) try {
        s = s();
    } catch  {
        s = "";
    }
    const e = s;
    return s = typeof s == "string" ? s : (Array.isArray(s) ? s.length : s) ? Bc(s) : "", [
        s,
        e
    ];
}, o_ = (s)=>i_(s ? s(0, null) : null)[0], jl = Promise.resolve(), a_ = (s)=>(e, t, r)=>{
        const n1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useRef"])(!1), { cache: i, initialSize: o = 1, revalidateAll: a = !1, persistSize: l = !1, revalidateFirstPage: c = !0, revalidateOnMount: u = !1, parallel: d1 = !1 } = r, [, , , h] = qr.get(Nu);
        let f;
        try {
            f = o_(e), f && (f = dm + f);
        } catch  {}
        const [p, y, E] = _s(i, f), b = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useCallback"])(()=>$e(p()._l) ? o : p()._l, [
            i,
            f,
            o
        ]);
        im.useSyncExternalStore((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useCallback"])((j)=>f ? E(f, ()=>{
                j();
            }) : ()=>{}, // eslint-disable-next-line react-hooks/exhaustive-deps
        [
            i,
            f
        ]), b, b);
        const L = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useCallback"])(()=>{
            const j = p()._l;
            return $e(j) ? o : j;
        }, [
            f,
            o
        ]), A = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useRef"])(L());
        So(()=>{
            if (!n1.current) {
                n1.current = !0;
                return;
            }
            f && y({
                _l: l ? A.current : L()
            });
        }, [
            f,
            i
        ]);
        const F = u && !n1.current, M = s(f, async (j)=>{
            const C = p()._i, k = p()._r;
            y({
                _r: qt
            });
            const $ = [], W = L(), [_] = _s(i, j), g = _().data, x = [];
            let w = null;
            for(let D = 0; D < W; ++D){
                const [O, U] = wi(e(D, d1 ? null : w));
                if (!O) break;
                const [V, R] = _s(i, O);
                let m = V().data;
                const v = a || C || $e(m) || c && !D && !$e(g) || F || g && !$e(g[D]) && !r.compare(g[D], m);
                if (t && (typeof k == "function" ? k(m, U) : v)) {
                    const P = async ()=>{
                        if (!(O in h)) m = await t(U);
                        else {
                            const Y = h[O];
                            delete h[O], m = await Y;
                        }
                        R({
                            data: m,
                            _k: U
                        }), $[D] = m;
                    };
                    d1 ? x.push(P) : await P();
                } else $[D] = m;
                d1 || (w = m);
            }
            return d1 && await Promise.all(x.map((D)=>D())), y({
                _i: qt
            }), $;
        }, r), H = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useCallback"])(// eslint-disable-next-line func-names
        function(j, C) {
            const k = typeof C == "boolean" ? {
                revalidate: C
            } : C || {}, $ = k.revalidate !== !1;
            return f ? ($ && ($e(j) ? y({
                _i: !0,
                _r: k.revalidate
            }) : y({
                _i: !1,
                _r: k.revalidate
            })), arguments.length ? M.mutate(j, {
                ...k,
                revalidate: $
            }) : M.mutate()) : jl;
        }, // swr.mutate is always the same reference
        // eslint-disable-next-line react-hooks/exhaustive-deps
        [
            f,
            i
        ]), K = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useCallback"])((j)=>{
            if (!f) return jl;
            const [, C] = _s(i, f);
            let k;
            if (Mr(j) ? k = j(L()) : typeof j == "number" && (k = j), typeof k != "number") return jl;
            C({
                _l: k
            }), A.current = k;
            const $ = [], [W] = _s(i, f);
            let _ = null;
            for(let g = 0; g < k; ++g){
                const [x] = wi(e(g, _)), [w] = _s(i, x), D = x ? w().data : qt;
                if ($e(D)) return H(W().data);
                $.push(D), _ = D;
            }
            return H($);
        }, // exclude getKey from the dependencies, which isn't allowed to change during the lifecycle
        // eslint-disable-next-line react-hooks/exhaustive-deps
        [
            f,
            i,
            H,
            L
        ]);
        return {
            size: L(),
            setSize: K,
            mutate: H,
            get data () {
                return M.data;
            },
            get error () {
                return M.error;
            },
            get isValidating () {
                return M.isValidating;
            },
            get isLoading () {
                return M.isLoading;
            }
        };
    }, l_ = XI(QI, a_), c_ = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("div")({
    classes: [
        "sfmkqcr"
    ]
}), u_ = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("div")({
    classes: [
        "hrldtio"
    ]
}), d_ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["memo"])(({ casts: s, cursor: e })=>/* @__PURE__ */ q.jsx(c_, {
        children: s.map((t, r)=>/* @__PURE__ */ q.jsxs(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].Fragment, {
                children: [
                    /* @__PURE__ */ q.jsx(oa, {
                        isEmbed: !1,
                        ...t
                    }),
                    r < s.length - 1 && /* @__PURE__ */ q.jsx(u_, {})
                ]
            }, t.hash))
    }));
function h_(s) {
    return s ? s.map((e)=>{
        var r, n1, i, o, a;
        const t = e != null && e.replies && typeof e.replies == "object" ? Number(e.replies.count) || 0 : Number(e == null ? void 0 : e.replies) || 0;
        return {
            username: ((r = e == null ? void 0 : e.author) == null ? void 0 : r.username) ?? "",
            displayName: ((n1 = e == null ? void 0 : e.author) == null ? void 0 : n1.display_name) ?? "",
            avatarImgUrl: ((i = e == null ? void 0 : e.author) == null ? void 0 : i.pfp_url) ?? "",
            text: (e == null ? void 0 : e.text) ?? "",
            hash: (e == null ? void 0 : e.hash) ?? "",
            reactions: (e == null ? void 0 : e.reactions) ?? [],
            replies: t,
            embeds: (e == null ? void 0 : e.embeds) ?? [],
            frames: (e == null ? void 0 : e.frames) ?? [],
            renderEmbeds: (e == null ? void 0 : e.renderEmbeds) ?? !0,
            channel: (e == null ? void 0 : e.channel) ?? "",
            viewerFid: 2,
            hasPowerBadge: ((o = e == null ? void 0 : e.author) == null ? void 0 : o.power_badge) ?? !1,
            appAvatarImgUrl: ((a = e == null ? void 0 : e.app) == null ? void 0 : a.pfp_url) ?? "",
            isOwnProfile: !1,
            allowReactions: !0,
            renderFrames: !1,
            timestamp: e.timestamp ?? ""
        };
    }) : [];
}
const f_ = (s)=>jn(s).then(async (e)=>await e.json()), g_ = (s, e, t, r, n1)=>{
    if (e && (!e.casts || !e.casts.length)) return null;
    let i = `${Vn}/v2/farcaster/feed${t ? "" : "?"}`;
    const o = new URLSearchParams();
    t && (i += `${t}?`), n1 && (i += `client_id=${n1}`), e && (i += `&cursor=${e.next.cursor}`);
    const a = (l, c)=>{
        c != null && !i.includes(`${l}=`) && o.append(l, String(c));
    };
    if (r) {
        Object.entries(r).forEach(([c, u])=>{
            const d1 = c.replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
            a(d1, u);
        });
        const l = o.toString();
        l && (i += i.includes("?") ? `&${l}` : `?${l}`);
    }
    if (Object.keys(r).length > 1) return i;
}, mL = ({ path: s, ...e })=>{
    var f;
    const { client_id: t } = ts(), r = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useRef"])(null), [n1, i] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useState"])(!1), o = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useRef"])(null), { data: a, error: l, size: c, setSize: u, isValidating: d1 } = l_((p, y)=>g_(p, y, s, e, t), f_), h = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useMemo"])(()=>{
        if (!a) return [];
        const p = a.flatMap((E)=>(E == null ? void 0 : E.casts) ?? []), y = Array.from(new Set(p.map((E)=>E.hash))).map((E)=>p.find((b)=>b.hash === E));
        return h_(y);
    }, [
        a
    ]);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useEffect"])(()=>(o.current && o.current.disconnect(), o.current = new IntersectionObserver((p)=>{
            var E, b;
            const [y] = p;
            y.isIntersecting && !n1 && !d1 && a && (b = (E = a[a.length - 1]) == null ? void 0 : E.next) != null && b.cursor && (i(!0), u(c + 1).then(()=>i(!1)));
        }, {
            rootMargin: "100px"
        }), r.current && o.current.observe(r.current), ()=>{
            o.current && o.current.disconnect();
        }), [
        r.current,
        n1,
        d1,
        a,
        c
    ]), l ? /* @__PURE__ */ q.jsx("div", {
        children: "Error fetching feed data"
    }) : /* @__PURE__ */ q.jsxs("div", {
        children: [
            h.length !== 0 ? /* @__PURE__ */ q.jsx(d_, {
                casts: h,
                cursor: ""
            }) : /* @__PURE__ */ q.jsx("div", {
                children: (f = a == null ? void 0 : a[0]) == null ? void 0 : f.message
            }),
            d1 && /* @__PURE__ */ q.jsxs("div", {
                style: {
                    display: "flex",
                    justifyContent: "center",
                    padding: "10px"
                },
                children: [
                    /* @__PURE__ */ q.jsxs("span", {
                        style: {
                            animation: "blink 1.5s infinite"
                        },
                        children: [
                            "Loading",
                            /* @__PURE__ */ q.jsx("span", {
                                className: "dots",
                                children: "..."
                            })
                        ]
                    }),
                    /* @__PURE__ */ q.jsx("style", {
                        children: `
                        @keyframes blink {
                            0% { opacity: 1; }
                            50% { opacity: 0; }
                            100% { opacity: 1; }
                        }
                    `
                    })
                ]
            }),
            /* @__PURE__ */ q.jsx("div", {
                ref: r
            })
        ]
    });
}, p_ = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("button")({
    classes: [
        "b1bqug8r"
    ]
}), m_ = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("button")({
    classes: [
        "b1mra45w"
    ]
}), Cf = "https://farcaster.xyz", gm = /(^|\s)\/\w+/g, pm = /@\w+/g, mm = /((https?:\/\/)?([a-zA-Z0-9.-]+\.[a-zA-Z]{2,})(\/[^\s]*)?)/g, kf = new RegExp(`(${gm.source})|(${pm.source})|(${mm.source})`, "g"), y_ = (s)=>gm.test(s) ? `${Cf}/~/channel${s.trim()}` : pm.test(s) ? `${Cf}/${s.substring(1)}` : mm.test(s) ? s.startsWith("http") ? s : `http://${s}` : "", v_ = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("a")({
    classes: [
        "sby9wa2"
    ]
}), E_ = (s)=>{
    if (!s) return [];
    const e = [];
    let t = 0, r;
    for(; (r = kf.exec(s)) !== null;){
        const n1 = r.index;
        t < n1 && e.push(s.slice(t, n1));
        const i = y_(r[0]), o = r[0].trim().startsWith("/");
        e.push(/* @__PURE__ */ q.jsx("span", {
            children: /* @__PURE__ */ q.jsx(v_, {
                href: i,
                target: "_blank",
                style: o ? {
                    marginLeft: 3.5
                } : {},
                children: r[0]
            }, n1)
        })), t = kf.lastIndex;
    }
    return t < s.length && e.push(s.slice(t)), e;
}, x_ = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("div")({
    classes: [
        "sdahm58"
    ]
}), S_ = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("div")({
    classes: [
        "mziqyxp"
    ]
}), b_ = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("div")({
    classes: [
        "uz7tpmf"
    ]
}), T_ = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("div")({
    classes: [
        "d1rxlwac"
    ]
}), w_ = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("div")({
    classes: [
        "ugc6yqp"
    ]
}), Df = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("div")({
    classes: [
        "porjf9a"
    ]
}), A_ = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("div")({
    classes: [
        "ttt7x9x"
    ]
}), Pf = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("div")({
    classes: [
        "b1wbe9o6"
    ]
}), I_ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["memo"])(({ fid: s, username: e, displayName: t, avatarImgUrl: r, bio: n1, followers: i, following: o, hasPowerBadge: a, isFollowing: l, isOwnProfile: c, onCast: u, containerStyles: d1 })=>{
    const h = E_(n1), f = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useMemo"])(()=>pf(o), [
        o
    ]), p = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useMemo"])(()=>pf(i), [
        i
    ]), y = ()=>{
        window.open("https://farcaster.xyz/~/settings", "_blank");
    }, E = {
        color: d1 == null ? void 0 : d1.color
    };
    return /* @__PURE__ */ q.jsxs(x_, {
        style: d1,
        children: [
            c && u && /* @__PURE__ */ q.jsxs(Pr, {
                alignItems: "center",
                justifyContent: "space-between",
                spacingBottom: "20px",
                children: [
                    /* @__PURE__ */ q.jsxs(w_, {
                        children: [
                            "@",
                            e
                        ]
                    }),
                    /* @__PURE__ */ q.jsx(p_, {
                        onClick: u,
                        children: "Cast"
                    })
                ]
            }),
            /* @__PURE__ */ q.jsx(Pr, {
                children: /* @__PURE__ */ q.jsxs(S_, {
                    children: [
                        /* @__PURE__ */ q.jsxs(Pr, {
                            alignItems: "center",
                            flexGrow: 1,
                            style: {
                                gap: "10px"
                            },
                            children: [
                                /* @__PURE__ */ q.jsx(Ir, {
                                    children: /* @__PURE__ */ q.jsx(Yo, {
                                        width: "20px",
                                        height: "20px",
                                        src: r ?? bi,
                                        loading: "lazy",
                                        alt: `${t ?? "Skeleton"} Avatar`
                                    })
                                }),
                                /* @__PURE__ */ q.jsx(Pr, {
                                    children: /* @__PURE__ */ q.jsx(T_, {
                                        children: t || `!${s}`
                                    })
                                }),
                                /* @__PURE__ */ q.jsxs(Pr, {
                                    alignItems: "center",
                                    children: [
                                        /* @__PURE__ */ q.jsxs(b_, {
                                            children: [
                                                "@",
                                                e
                                            ]
                                        }),
                                        l && /* @__PURE__ */ q.jsx(A_, {
                                            children: "Follows you"
                                        })
                                    ]
                                }),
                                /* @__PURE__ */ q.jsx(Pr, {
                                    children: c && /* @__PURE__ */ q.jsx(m_, {
                                        onClick: y,
                                        children: "Edit Profile"
                                    })
                                })
                            ]
                        }),
                        (h == null ? void 0 : h.length) !== 0 ? /* @__PURE__ */ q.jsx(Pf, {
                            children: h
                        }) : /* @__PURE__ */ q.jsx(Pf, {
                            style: {
                                padding: "26px 0px"
                            }
                        }),
                        /* @__PURE__ */ q.jsxs(Pr, {
                            style: {
                                justifyContent: "space-between",
                                display: "flex",
                                alignItems: "center"
                            },
                            children: [
                                /* @__PURE__ */ q.jsxs(Df, {
                                    children: [
                                        /* @__PURE__ */ q.jsx("strong", {
                                            style: E,
                                            children: f
                                        }),
                                        " ",
                                        "Following"
                                    ]
                                }),
                                /* @__PURE__ */ q.jsxs(Df, {
                                    children: [
                                        /* @__PURE__ */ q.jsx("strong", {
                                            style: E,
                                            children: p
                                        }),
                                        " ",
                                        "Followers"
                                    ]
                                }),
                                e && /* @__PURE__ */ q.jsx(Ir, {
                                    style: {
                                        marginLeft: "auto"
                                    },
                                    children: /* @__PURE__ */ q.jsx(Ic, {
                                        url: `https://farcaster.xyz/${e}`
                                    })
                                })
                            ]
                        })
                    ]
                })
            })
        ]
    });
});
async function __({ fid: s, viewerFid: e, clientId: t, experimental: r = !1 }) {
    var n1;
    try {
        let i = `${Vn}/v2/farcaster/user/bulk?client_id=${t}&fids=${s}`;
        e && (i += `&viewer_fid=${e}`);
        const o = {};
        r && (o["x-neynar-experimental"] = "true");
        const l = await (await jn(i, {
            headers: o
        })).json();
        return ((n1 = l == null ? void 0 : l.users) == null ? void 0 : n1[0]) ?? null;
    } catch (i) {
        return console.error("Error fetching user by fid", i), null;
    }
}
const yL = ({ fid: s, viewerFid: e, containerStyles: t })=>{
    var f;
    const { client_id: r } = ts(), [n1, i] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useState"])(null), [o, a] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useState"])(!0), [l, c] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useState"])(null), u = ("TURBOPACK compile-time value", "undefined") < "u" ? new URLSearchParams(window.location.search).get("experimental") === "true" : !1, d1 = (n1 == null ? void 0 : n1.fid) === e;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        s && (a(!0), c(null), __({
            fid: s,
            viewerFid: e,
            clientId: r,
            experimental: u
        }).then((p)=>{
            i(p);
        }).catch((p)=>{
            c(p);
        }).finally(()=>{
            a(!1);
        }));
    }, [
        s,
        e,
        u
    ]);
    const h = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useCallback"])(()=>{}, []);
    return o ? /* @__PURE__ */ q.jsx("div", {
        style: {
            padding: "20px"
        },
        children: "Loading..."
    }) : !n1 || l ? /* @__PURE__ */ q.jsx("div", {
        children: "Error fetching user data"
    }) : /* @__PURE__ */ q.jsx(I_, {
        fid: s,
        username: n1.username,
        displayName: n1.display_name,
        avatarImgUrl: n1.pfp_url,
        bio: n1.profile.bio.text,
        followers: n1.follower_count,
        following: n1.following_count,
        hasPowerBadge: n1.power_badge,
        isOwnProfile: d1,
        isFollowing: (f = n1.viewer_context) == null ? void 0 : f.followed_by,
        onCast: h,
        containerStyles: t
    });
}, L_ = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("ul")({
    classes: [
        "d12rx4om"
    ]
}), R_ = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("li")({
    classes: [
        "lrpm6lp"
    ]
}), C_ = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("img")({
    classes: [
        "a1e9hg3b"
    ]
}), k_ = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("div")({
    classes: [
        "u1aqay1i"
    ]
}), D_ = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("div")({
    classes: [
        "d1m0njq"
    ]
}), P_ = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("div")({
    classes: [
        "u1lvlbuo"
    ]
}), M_ = ({ users: s, onSelect: e, customStyles: t = {} })=>/* @__PURE__ */ q.jsx(L_, {
        style: {
            ...t == null ? void 0 : t.dropdown
        },
        children: s.map((r)=>/* @__PURE__ */ q.jsxs(R_, {
                style: {
                    ...t == null ? void 0 : t.listItem
                },
                onClick: ()=>e(r),
                children: [
                    /* @__PURE__ */ q.jsx(C_, {
                        style: {
                            ...t == null ? void 0 : t.avatar
                        },
                        src: r.pfp_url,
                        alt: r.username
                    }),
                    /* @__PURE__ */ q.jsxs(k_, {
                        style: {
                            ...t.userInfo
                        },
                        children: [
                            /* @__PURE__ */ q.jsx(D_, {
                                children: r.display_name
                            }),
                            /* @__PURE__ */ q.jsxs(P_, {
                                children: [
                                    "@",
                                    r.username
                                ]
                            })
                        ]
                    })
                ]
            }, r.fid))
    }), O_ = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("div")({
    classes: [
        "c9hm20t"
    ]
}), B_ = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("input")({
    classes: [
        "i80sd8h"
    ]
});
async function F_({ q: s, viewerFid: e, client_id: t }) {
    var r;
    try {
        let n1 = `${Vn}/v2/farcaster/user/search?q=${s}&limit=5${e ? `&viewer_fid=${e}` : ""}&client_id=${t}`;
        const o = await (await jn(n1)).json();
        return ((r = o == null ? void 0 : o.result) == null ? void 0 : r.users) || [];
    } catch  {
        return null;
    }
}
const vL = ({ value: s, onChange: e, style: t = {}, placeholder: r = "Enter username", disabled: n1 = !1, viewerFid: i, customStyles: o = {}, limit: a = null })=>{
    const { client_id: l } = ts(), [c, u] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useState"])(""), [d1, h] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useState"])(!1), [f, p] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useState"])([]), y = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useRef"])(null);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        const M = (s == null ? void 0 : s.split(",")) || [];
        if (!M[M.length - 1]) {
            u("");
            return;
        }
        u(M[M.length - 1].trim());
    }, [
        s
    ]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        c !== "" && !/^\d+$/.test(c) ? E(c) : h(!1);
    }, [
        c
    ]);
    const E = async (M)=>{
        const H = await F_({
            q: M,
            viewerFid: i,
            client_id: l
        });
        H && (p(H), h(!0));
    }, b = (M)=>{
        const H = M.target.value;
        e(H);
    }, L = (M)=>{
        let H = s.split(",");
        a !== null && H.length >= a ? H[H.length - 1] = M.fid.toString() : H.push(M.fid.toString());
        const K = H.join(",");
        e(K), u(""), h(!1);
    }, A = ()=>{
        c && isNaN(Number(c)) && h(!0);
    }, F = ()=>{
        setTimeout(()=>h(!1), 200);
    };
    return /* @__PURE__ */ q.jsxs(O_, {
        style: t,
        children: [
            /* @__PURE__ */ q.jsx(B_, {
                ref: y,
                type: "text",
                value: s,
                onChange: b,
                onFocus: A,
                onBlur: F,
                placeholder: r,
                disabled: n1
            }),
            d1 && /* @__PURE__ */ q.jsx(M_, {
                users: f,
                onSelect: L,
                customStyles: o
            })
        ]
    });
}, N_ = ({ color: s = "#855DCD" })=>/* @__PURE__ */ q.jsxs("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        width: "24",
        height: "24",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: s,
        "stroke-width": "2",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        className: "lucide lucide-search",
        children: [
            /* @__PURE__ */ q.jsx("circle", {
                cx: "11",
                cy: "11",
                r: "8"
            }),
            /* @__PURE__ */ q.jsx("path", {
                d: "m21 21-4.3-4.3"
            })
        ]
    }), U_ = ({ color: s = "#855DCD" })=>/* @__PURE__ */ q.jsx("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        width: "24",
        height: "24",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: s,
        "stroke-width": "2",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        className: "lucide lucide-loader-circle",
        children: /* @__PURE__ */ q.jsx("path", {
            d: "M21 12a9 9 0 1 1-6.219-8.56"
        })
    }), $_ = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("div")({
    classes: [
        "ig7kcuc"
    ]
}), G_ = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("input")({
    classes: [
        "sh7z7k6"
    ]
}), V_ = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("div")({
    classes: [
        "s14ai203"
    ]
}), j_ = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("div")({
    classes: [
        "if18nd6"
    ]
}), K_ = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("div")({
    classes: [
        "sd833lb"
    ]
}), H_ = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("div")({
    classes: [
        "ugo586m"
    ]
}), q_ = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("div")({
    classes: [
        "ukwty1d"
    ]
}), W_ = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("div")({
    classes: [
        "u77olmy"
    ]
}), z_ = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("div")({
    classes: [
        "s1xvkxww"
    ]
}), Y_ = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("div")({
    classes: [
        "s1f6b1ja"
    ]
}), Z_ = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("div")({
    classes: [
        "udiufd8"
    ]
}), X_ = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("div")({
    classes: [
        "f1b8a2h0"
    ]
}), J_ = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("div")({
    classes: [
        "l1yq26j0"
    ]
}), Q_ = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$pigment$2d$css$2b$react$40$0$2e$0$2e$30_$40$types$2b$react$40$19$2e$2$2e$6_react$40$19$2e$2$2e$0_typescript$40$5$2e$9$2e$3$2f$node_modules$2f40$pigment$2d$css$2f$react$2f$build$2f$chunk$2d$AFZBAV6Q$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["styled"])("li")({
    classes: [
        "s18mk47k"
    ]
}), EL = ({ width: s, height: e, selectedUsers: t, onSelectUsers: r, ...n1 })=>{
    const { client_id: i } = ts(), { user: o, isAuthenticated: a } = Eg(), [l, c] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useState"])(""), [u, d1] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useState"])([]), [h, f] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useState"])(!1), p = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useRef"])(null);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        function M(H) {
            p.current && !p.current.contains(H.target) && (d1([]), c(""));
        }
        return document.addEventListener("mousedown", M), ()=>{
            document.removeEventListener("mousedown", M);
        };
    }, []);
    const b = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$3_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useCallback"])(((M, H)=>{
        let K;
        return (...j)=>{
            clearTimeout(K), K = setTimeout(()=>M(...j), H);
        };
    })(async (M, H)=>{
        var K;
        if (!M) {
            d1([]);
            return;
        }
        f(!0);
        try {
            const C = await (await jn(H)).json();
            d1(((K = C == null ? void 0 : C.result) == null ? void 0 : K.users) || []);
        } catch (j) {
            console.error("Error fetching data:", j);
        } finally{
            f(!1);
        }
    }, 500), []), L = (M)=>{
        const H = `${Vn}/v2/farcaster/user/search?q=${M.target.value}&client_id=${i}${a ? `&viewer_fid=${o == null ? void 0 : o.fid}` : ""})`;
        c(M.target.value), b(M.target.value, H);
    }, A = (M)=>{
        t.some((H)=>H.username === M.username) || (r([
            ...t,
            M
        ]), c(""), d1([]));
    }, F = (M)=>{
        r(t.filter((H)=>H.username !== M));
    };
    return /* @__PURE__ */ q.jsxs($_, {
        ref: p,
        style: {
            width: s
        },
        children: [
            /* @__PURE__ */ q.jsxs(j_, {
                children: [
                    t.map((M)=>/* @__PURE__ */ q.jsxs(K_, {
                            children: [
                                /* @__PURE__ */ q.jsx(Yo, {
                                    src: M.pfp_url ?? bi,
                                    alt: `${M.username} Avatar`,
                                    style: {
                                        width: "24px",
                                        height: "24px",
                                        borderRadius: "50%"
                                    }
                                }),
                                /* @__PURE__ */ q.jsx("span", {
                                    style: {
                                        marginLeft: "8px"
                                    },
                                    children: M.display_name
                                }),
                                /* @__PURE__ */ q.jsx(sm, {
                                    size: 20,
                                    onClick: ()=>F(M.username)
                                })
                            ]
                        }, M.username)),
                    /* @__PURE__ */ q.jsxs(z_, {
                        children: [
                            /* @__PURE__ */ q.jsx(Y_, {
                                children: /* @__PURE__ */ q.jsx(N_, {
                                    color: "#855DCD"
                                })
                            }),
                            /* @__PURE__ */ q.jsx(G_, {
                                ...n1,
                                value: l,
                                onChange: L,
                                placeholder: "Type to search users",
                                style: {
                                    width: s || "100%",
                                    height: e || "40px"
                                }
                            })
                        ]
                    })
                ]
            }),
            h ? /* @__PURE__ */ q.jsx(J_, {
                children: /* @__PURE__ */ q.jsx(U_, {
                    color: "#855DCD"
                })
            }) : u.length !== 0 && /* @__PURE__ */ q.jsx(V_, {
                children: u.map((M)=>/* @__PURE__ */ q.jsxs(Q_, {
                        onClick: ()=>A(M),
                        children: [
                            /* @__PURE__ */ q.jsx(Yo, {
                                src: M.pfp_url ?? bi,
                                alt: `${M.username} Avatar`,
                                style: {
                                    width: "40px",
                                    height: "40px",
                                    borderRadius: "50%"
                                }
                            }),
                            /* @__PURE__ */ q.jsxs(H_, {
                                children: [
                                    /* @__PURE__ */ q.jsx(q_, {
                                        children: M.display_name
                                    }),
                                    /* @__PURE__ */ q.jsxs(Z_, {
                                        children: [
                                            /* @__PURE__ */ q.jsxs(W_, {
                                                children: [
                                                    "@",
                                                    M.username
                                                ]
                                            }),
                                            M.viewer_context && (M.viewer_context.following || M.viewer_context.followed_by) && /* @__PURE__ */ q.jsx(X_, {
                                                children: M.viewer_context.following && M.viewer_context.followed_by ? "Following each other" : M.viewer_context.following ? "Following" : M.viewer_context.followed_by ? "Follows you" : null
                                            })
                                        ]
                                    })
                                ]
                            })
                        ]
                    }, M.username))
            })
        ]
    });
};
;
}),
];

//# sourceMappingURL=583f9_%40neynar_react_dist_bundle_es_db1c18ba.js.map